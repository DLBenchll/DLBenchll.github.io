[
    {
        "sql_id": 1,
        "database_name": "movie_platform",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT movie_title, movie_release_year FROM movies ORDER BY LENGTH(movie_popularity) DESC LIMIT 1",
        "target_query": "SELECT \"movie_title\", \"movie_release_year\" FROM \"movies\" ORDER BY length(\"movie_popularity\") DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 60,
                "end_index": 83,
                "dilatect_content": "LENGTH(movie_popularity)",
                "feature": "length(X)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 72,
                "end_index": 99,
                "dilatect_content": "length(\"movie_popularity\")",
                "feature": "length(X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "length(X)",
                "explanation": "MonetDB supports the length() function for both string and BLOB values. For a string value X, the function returns the number of characters (code points) in the string. For a BLOB value, it returns the byte-length of the BLOB.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies`\nColumns:\n(`movie_id`, integer, primary key)\n(`movie_title`, text)\n(`movie_release_year`, integer)\n(`movie_url`, text)\n(`movie_title_language`, text)\n(`movie_popularity`, integer)\n(`movie_image_url`, text)\n(`director_id`, text)\n(`director_name`, text)\n(`director_url`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"movies\"\nColumns:\n(\"movie_id\", BIGINT, primary key)\n(\"movie_title\", STRING)\n(\"movie_release_year\", BIGINT)\n(\"movie_url\", STRING)\n(\"movie_title_language\", STRING)\n(\"movie_popularity\", BIGINT)\n(\"movie_image_url\", STRING)\n(\"director_id\", STRING)\n(\"director_name\", STRING)\n(\"director_url\", STRING)\n"
        ]
    },
    {
        "sql_id": 2,
        "database_name": "movie_platform",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.movie_title FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE CAST(SUBSTR(T1.rating_timestamp_utc, 1, 4) AS INTEGER) = 2020 AND CAST(SUBSTR(T1.rating_timestamp_utc, 6, 2) AS INTEGER) > 4",
        "target_query": "SELECT \"T2\".\"movie_title\" FROM \"ratings\" AS \"T1\" INNER JOIN \"movies\" AS \"T2\" ON \"T1\".\"movie_id\" = \"T2\".\"movie_id\" WHERE CAST(substring(\"T1\".\"rating_timestamp_utc\" from 1 for 4) AS INTEGER) = 2020 AND CAST(substring(\"T1\".\"rating_timestamp_utc\" from 6 for 2) AS INTEGER) > 4;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 105,
                "end_index": 141,
                "dilatect_content": "SUBSTR(T1.rating_timestamp_utc, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 171,
                "end_index": 207,
                "dilatect_content": "SUBSTR(T1.rating_timestamp_utc, 6, 2)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 145,
                "end_index": 199,
                "dilatect_content": "substring(\"T1\".\"rating_timestamp_utc\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 229,
                "end_index": 283,
                "dilatect_content": "substring(\"T1\".\"rating_timestamp_utc\" from 6 for 2)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `ratings`\nColumns:\n(`movie_id`, integer)\n(`rating_id`, integer)\n(`rating_url`, text)\n(`rating_score`, integer)\n(`rating_timestamp_utc`, text)\n(`critic`, text)\n(`critic_likes`, integer)\n(`critic_comments`, integer)\n(`user_id`, integer)\n(`user_trialist`, integer)\n(`user_subscriber`, integer)\n(`user_eligible_for_trial`, integer)\n(`user_has_payment_method`, integer)\n(`rowid`, integer, primary key)\n",
            "Table: `movies`\nColumns:\n(`movie_id`, integer, primary key)\n(`movie_title`, text)\n(`movie_release_year`, integer)\n(`movie_url`, text)\n(`movie_title_language`, text)\n(`movie_popularity`, integer)\n(`movie_image_url`, text)\n(`director_id`, text)\n(`director_name`, text)\n(`director_url`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"ratings\"\nColumns:\n(\"movie_id\", BIGINT)\n(\"rating_id\", BIGINT)\n(\"rating_url\", STRING)\n(\"rating_score\", BIGINT)\n(\"rating_timestamp_utc\", STRING)\n(\"critic\", STRING)\n(\"critic_likes\", BIGINT)\n(\"critic_comments\", BIGINT)\n(\"user_id\", BIGINT)\n(\"user_trialist\", BIGINT)\n(\"user_subscriber\", BIGINT)\n(\"user_eligible_for_trial\", BIGINT)\n(\"user_has_payment_method\", BIGINT)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"movies\"\nColumns:\n(\"movie_id\", BIGINT, primary key)\n(\"movie_title\", STRING)\n(\"movie_release_year\", BIGINT)\n(\"movie_url\", STRING)\n(\"movie_title_language\", STRING)\n(\"movie_popularity\", BIGINT)\n(\"movie_image_url\", STRING)\n(\"director_id\", STRING)\n(\"director_name\", STRING)\n(\"director_url\", STRING)\n"
        ]
    },
    {
        "sql_id": 3,
        "database_name": "movie_platform",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT user_id FROM lists_users WHERE user_subscriber = 1 GROUP BY user_id HAVING MAX(SUBSTR(list_creation_date_utc, 1, 4)) - MIN(SUBSTR(list_creation_date_utc, 1, 4)) >= 10",
        "target_query": "SELECT \"user_id\" FROM \"lists_users\" WHERE \"user_subscriber\" = 1 GROUP BY \"user_id\" HAVING MAX(CAST(substring(\"list_creation_date_utc\" from 1 for 4) AS INTEGER)) - MIN(CAST(substring(\"list_creation_date_utc\" from 1 for 4) AS INTEGER)) >= 10;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 86,
                "end_index": 121,
                "dilatect_content": "SUBSTR(list_creation_date_utc, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 130,
                "end_index": 165,
                "dilatect_content": "SUBSTR(list_creation_date_utc, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 107,
                "end_index": 156,
                "dilatect_content": "substring(\"list_creation_date_utc\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 182,
                "end_index": 231,
                "dilatect_content": "substring(\"list_creation_date_utc\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `lists_users`\nColumns:\n(`user_id`, integer, primary key)\n(`list_id`, integer, primary key)\n(`list_update_date_utc`, text)\n(`list_creation_date_utc`, text)\n(`user_trialist`, integer)\n(`user_subscriber`, integer)\n(`user_avatar_image_url`, text)\n(`user_cover_image_url`, text)\n(`user_eligible_for_trial`, text)\n(`user_has_payment_method`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"lists_users\"\nColumns:\n(\"user_id\", BIGINT, primary key)\n(\"list_id\", BIGINT, primary key)\n(\"list_update_date_utc\", STRING)\n(\"list_creation_date_utc\", STRING)\n(\"user_trialist\", BIGINT)\n(\"user_subscriber\", BIGINT)\n(\"user_avatar_image_url\", STRING)\n(\"user_cover_image_url\", STRING)\n(\"user_eligible_for_trial\", STRING)\n(\"user_has_payment_method\", STRING)\n"
        ]
    },
    {
        "sql_id": 4,
        "database_name": "movie_platform",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(*) FROM lists WHERE SUBSTR(list_update_timestamp_utc, 1, 4) - SUBSTR(list_creation_timestamp_utc, 1, 4) > 10",
        "target_query": "SELECT COUNT(*) FROM \"lists\" WHERE CAST(substring(\"list_update_timestamp_utc\" from 1 for 4) AS INTEGER) - CAST(substring(\"list_creation_timestamp_utc\" from 1 for 4) AS INTEGER) > 10;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 33,
                "end_index": 71,
                "dilatect_content": "SUBSTR(list_update_timestamp_utc, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 75,
                "end_index": 115,
                "dilatect_content": "SUBSTR(list_creation_timestamp_utc, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 42,
                "end_index": 94,
                "dilatect_content": "substring(\"list_update_timestamp_utc\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 115,
                "end_index": 169,
                "dilatect_content": "substring(\"list_creation_timestamp_utc\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `lists`\nColumns:\n(`user_id`, integer)\n(`list_id`, integer, primary key)\n(`list_title`, text)\n(`list_movie_number`, integer)\n(`list_update_timestamp_utc`, text)\n(`list_creation_timestamp_utc`, text)\n(`list_followers`, integer)\n(`list_url`, text)\n(`list_comments`, integer)\n(`list_description`, text)\n(`list_cover_image_url`, text)\n(`list_first_image_url`, text)\n(`list_second_image_url`, text)\n(`list_third_image_url`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"lists\"\nColumns:\n(\"user_id\", BIGINT)\n(\"list_id\", BIGINT, primary key)\n(\"list_title\", STRING)\n(\"list_movie_number\", BIGINT)\n(\"list_update_timestamp_utc\", STRING)\n(\"list_creation_timestamp_utc\", STRING)\n(\"list_followers\", BIGINT)\n(\"list_url\", STRING)\n(\"list_comments\", BIGINT)\n(\"list_description\", STRING)\n(\"list_cover_image_url\", STRING)\n(\"list_first_image_url\", STRING)\n(\"list_second_image_url\", STRING)\n(\"list_third_image_url\", STRING)\n"
        ]
    },
    {
        "sql_id": 5,
        "database_name": "movie_platform",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT list_title FROM lists WHERE strftime('%Y', list_update_timestamp_utc) = '2016' ORDER BY list_update_timestamp_utc DESC LIMIT 1",
        "target_query": "SELECT \"list_title\" FROM \"lists\" WHERE sys.timestamp_to_str(\"list_update_timestamp_utc\", '%Y') = '2016' ORDER BY \"list_update_timestamp_utc\" DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 35,
                "end_index": 75,
                "dilatect_content": "strftime('%Y', list_update_timestamp_utc)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 43,
                "end_index": 99,
                "dilatect_content": "sys.timestamp_to_str(\"list_update_timestamp_utc\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `lists`\nColumns:\n(`user_id`, integer)\n(`list_id`, integer, primary key)\n(`list_title`, text)\n(`list_movie_number`, integer)\n(`list_update_timestamp_utc`, text)\n(`list_creation_timestamp_utc`, text)\n(`list_followers`, integer)\n(`list_url`, text)\n(`list_comments`, integer)\n(`list_description`, text)\n(`list_cover_image_url`, text)\n(`list_first_image_url`, text)\n(`list_second_image_url`, text)\n(`list_third_image_url`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"lists\"\nColumns:\n(\"user_id\", BIGINT)\n(\"list_id\", BIGINT, primary key)\n(\"list_title\", STRING)\n(\"list_movie_number\", BIGINT)\n(\"list_update_timestamp_utc\", STRING)\n(\"list_creation_timestamp_utc\", STRING)\n(\"list_followers\", BIGINT)\n(\"list_url\", STRING)\n(\"list_comments\", BIGINT)\n(\"list_description\", STRING)\n(\"list_cover_image_url\", STRING)\n(\"list_first_image_url\", STRING)\n(\"list_second_image_url\", STRING)\n(\"list_third_image_url\", STRING)\n"
        ]
    },
    {
        "sql_id": 9,
        "database_name": "book_publishing_company",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.title FROM sales AS T1 INNER JOIN titles AS T2 ON T1.title_id = T2.title_id WHERE STRFTIME('%Y', T1.ord_date) = '1992' ORDER BY T1.qty DESC LIMIT 1",
        "target_query": "SELECT \"T2\".\"title\" FROM \"sales\" AS \"T1\" INNER JOIN \"titles\" AS \"T2\" ON \"T1\".\"title_id\" = \"T2\".\"title_id\" WHERE sys.timestamp_to_str(\"T1\".\"ord_date\", '%Y') = '1992' ORDER BY \"T1\".\"qty\" DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 92,
                "end_index": 118,
                "dilatect_content": "STRFTIME('%Y', T1.ord_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 132,
                "end_index": 178,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"ord_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `sales`\nColumns:\n(`stor_id`, text, primary key)\n(`ord_num`, text, primary key)\n(`ord_date`, datetime)\n(`qty`, integer)\n(`payterms`, text)\n(`title_id`, text, primary key)\n",
            "Table: `titles`\nColumns:\n(`title_id`, text, primary key)\n(`title`, text)\n(`type`, text)\n(`pub_id`, text)\n(`price`, real)\n(`advance`, real)\n(`royalty`, integer)\n(`ytd_sales`, integer)\n(`notes`, text)\n(`pubdate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"sales\"\nColumns:\n(\"stor_id\", STRING, primary key)\n(\"ord_num\", STRING, primary key)\n(\"ord_date\", TIMESTAMP)\n(\"qty\", BIGINT)\n(\"payterms\", STRING)\n(\"title_id\", STRING, primary key)\n",
            "Table: \"titles\"\nColumns:\n(\"title_id\", STRING, primary key)\n(\"title\", STRING)\n(\"type\", STRING)\n(\"pub_id\", STRING)\n(\"price\", DOUBLE PRECISION)\n(\"advance\", DOUBLE PRECISION)\n(\"royalty\", BIGINT)\n(\"ytd_sales\", BIGINT)\n(\"notes\", STRING)\n(\"pubdate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 10,
        "database_name": "book_publishing_company",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.title, T1.notes, T2.pub_name FROM titles AS T1 INNER JOIN publishers AS T2 ON T1.pub_id = T2.pub_id WHERE STRFTIME('%Y', T1.pubdate) = '1991'",
        "target_query": "SELECT \"T1\".\"title\", \"T1\".\"notes\", \"T2\".\"pub_name\" FROM \"titles\" AS \"T1\" INNER JOIN \"publishers\" AS \"T2\" ON \"T1\".\"pub_id\" = \"T2\".\"pub_id\" WHERE sys.timestamp_to_str(\"T1\".\"pubdate\", '%Y') = '1991';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 116,
                "end_index": 141,
                "dilatect_content": "STRFTIME('%Y', T1.pubdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 172,
                "end_index": 217,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"pubdate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `titles`\nColumns:\n(`title_id`, text, primary key)\n(`title`, text)\n(`type`, text)\n(`pub_id`, text)\n(`price`, real)\n(`advance`, real)\n(`royalty`, integer)\n(`ytd_sales`, integer)\n(`notes`, text)\n(`pubdate`, datetime)\n",
            "Table: `publishers`\nColumns:\n(`pub_id`, text, primary key)\n(`pub_name`, text)\n(`city`, text)\n(`state`, text)\n(`country`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"titles\"\nColumns:\n(\"title_id\", STRING, primary key)\n(\"title\", STRING)\n(\"type\", STRING)\n(\"pub_id\", STRING)\n(\"price\", DOUBLE PRECISION)\n(\"advance\", DOUBLE PRECISION)\n(\"royalty\", BIGINT)\n(\"ytd_sales\", BIGINT)\n(\"notes\", STRING)\n(\"pubdate\", TIMESTAMP)\n",
            "Table: \"publishers\"\nColumns:\n(\"pub_id\", STRING, primary key)\n(\"pub_name\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"country\", STRING)\n"
        ]
    },
    {
        "sql_id": 11,
        "database_name": "book_publishing_company",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT fname, lname FROM employee WHERE STRFTIME('%Y', hire_date) < '1990'",
        "target_query": "SELECT \"fname\", \"lname\" FROM \"employee\" WHERE sys.timestamp_to_str(\"hire_date\", '%Y') < '1990';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 40,
                "end_index": 64,
                "dilatect_content": "STRFTIME('%Y', hire_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 52,
                "end_index": 92,
                "dilatect_content": "sys.timestamp_to_str(\"hire_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`emp_id`, text, primary key)\n(`fname`, text)\n(`minit`, text)\n(`lname`, text)\n(`job_id`, integer)\n(`job_lvl`, integer)\n(`pub_id`, text)\n(`hire_date`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"employee\"\nColumns:\n(\"emp_id\", STRING, primary key)\n(\"fname\", STRING)\n(\"minit\", STRING)\n(\"lname\", STRING)\n(\"job_id\", BIGINT)\n(\"job_lvl\", BIGINT)\n(\"pub_id\", STRING)\n(\"hire_date\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 12,
        "database_name": "book_publishing_company",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT STRFTIME('%Y', hire_date) FROM employee GROUP BY STRFTIME('%Y', hire_date) ORDER BY COUNT(emp_id) DESC LIMIT 1",
        "target_query": "SELECT sys.timestamp_to_str(\"hire_date\", '%Y') FROM \"employee\" GROUP BY sys.timestamp_to_str(\"hire_date\", '%Y') ORDER BY COUNT(\"emp_id\") DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 31,
                "dilatect_content": "STRFTIME('%Y', hire_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 56,
                "end_index": 80,
                "dilatect_content": "STRFTIME('%Y', hire_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 47,
                "dilatect_content": "sys.timestamp_to_str(\"hire_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 76,
                "end_index": 116,
                "dilatect_content": "sys.timestamp_to_str(\"hire_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`emp_id`, text, primary key)\n(`fname`, text)\n(`minit`, text)\n(`lname`, text)\n(`job_id`, integer)\n(`job_lvl`, integer)\n(`pub_id`, text)\n(`hire_date`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"employee\"\nColumns:\n(\"emp_id\", STRING, primary key)\n(\"fname\", STRING)\n(\"minit\", STRING)\n(\"lname\", STRING)\n(\"job_id\", BIGINT)\n(\"job_lvl\", BIGINT)\n(\"pub_id\", STRING)\n(\"hire_date\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 13,
        "database_name": "book_publishing_company",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.pub_name FROM titles AS T1 INNER JOIN publishers AS T2 ON T1.pub_id = T2.pub_id WHERE STRFTIME('%Y', T1.pubdate) = '1991' GROUP BY T1.pub_id, T2.pub_name ORDER BY COUNT(T1.title_id) DESC LIMIT 1",
        "target_query": "SELECT \"T2\".\"pub_name\" FROM \"titles\" AS \"T1\" INNER JOIN \"publishers\" AS \"T2\" ON \"T1\".\"pub_id\" = \"T2\".\"pub_id\" WHERE sys.timestamp_to_str(\"T1\".\"pubdate\", '%Y') = '1991' GROUP BY \"T1\".\"pub_id\", \"T2\".\"pub_name\" ORDER BY COUNT(\"T1\".\"title_id\") DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 96,
                "end_index": 121,
                "dilatect_content": "STRFTIME('%Y', T1.pubdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 136,
                "end_index": 181,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"pubdate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `titles`\nColumns:\n(`title_id`, text, primary key)\n(`title`, text)\n(`type`, text)\n(`pub_id`, text)\n(`price`, real)\n(`advance`, real)\n(`royalty`, integer)\n(`ytd_sales`, integer)\n(`notes`, text)\n(`pubdate`, datetime)\n",
            "Table: `publishers`\nColumns:\n(`pub_id`, text, primary key)\n(`pub_name`, text)\n(`city`, text)\n(`state`, text)\n(`country`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"titles\"\nColumns:\n(\"title_id\", STRING, primary key)\n(\"title\", STRING)\n(\"type\", STRING)\n(\"pub_id\", STRING)\n(\"price\", DOUBLE PRECISION)\n(\"advance\", DOUBLE PRECISION)\n(\"royalty\", BIGINT)\n(\"ytd_sales\", BIGINT)\n(\"notes\", STRING)\n(\"pubdate\", TIMESTAMP)\n",
            "Table: \"publishers\"\nColumns:\n(\"pub_id\", STRING, primary key)\n(\"pub_name\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"country\", STRING)\n"
        ]
    },
    {
        "sql_id": 14,
        "database_name": "book_publishing_company",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.notes FROM titles AS T1 INNER JOIN sales AS T2 ON T1.title_id = T2.title_id WHERE STRFTIME('%Y-%m-%d', T2.ord_date) = '1994-09-14'",
        "target_query": "SELECT \"T1\".\"notes\" FROM \"titles\" AS \"T1\" INNER JOIN \"sales\" AS \"T2\" ON \"T1\".\"title_id\" = \"T2\".\"title_id\" WHERE sys.timestamp_to_str(\"T2\".\"ord_date\", '%Y-%m-%d') = '1994-09-14';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 92,
                "end_index": 124,
                "dilatect_content": "STRFTIME('%Y-%m-%d', T2.ord_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 132,
                "end_index": 184,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"ord_date\", '%Y-%m-%d')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `titles`\nColumns:\n(`title_id`, text, primary key)\n(`title`, text)\n(`type`, text)\n(`pub_id`, text)\n(`price`, real)\n(`advance`, real)\n(`royalty`, integer)\n(`ytd_sales`, integer)\n(`notes`, text)\n(`pubdate`, datetime)\n",
            "Table: `sales`\nColumns:\n(`stor_id`, text, primary key)\n(`ord_num`, text, primary key)\n(`ord_date`, datetime)\n(`qty`, integer)\n(`payterms`, text)\n(`title_id`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"titles\"\nColumns:\n(\"title_id\", STRING, primary key)\n(\"title\", STRING)\n(\"type\", STRING)\n(\"pub_id\", STRING)\n(\"price\", DOUBLE PRECISION)\n(\"advance\", DOUBLE PRECISION)\n(\"royalty\", BIGINT)\n(\"ytd_sales\", BIGINT)\n(\"notes\", STRING)\n(\"pubdate\", TIMESTAMP)\n",
            "Table: \"sales\"\nColumns:\n(\"stor_id\", STRING, primary key)\n(\"ord_num\", STRING, primary key)\n(\"ord_date\", TIMESTAMP)\n(\"qty\", BIGINT)\n(\"payterms\", STRING)\n(\"title_id\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 15,
        "database_name": "book_publishing_company",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT T1.type FROM titles AS T1 INNER JOIN sales AS T2 ON T1.title_id = T2.title_id WHERE STRFTIME('%Y-%m-%d', T2.ord_date) = '1993-05-29'",
        "target_query": "SELECT DISTINCT \"T1\".\"type\" FROM \"titles\" AS \"T1\" INNER JOIN \"sales\" AS \"T2\" ON \"T1\".\"title_id\" = \"T2\".\"title_id\" WHERE sys.timestamp_to_str(\"T2\".\"ord_date\", '%Y-%m-%d') = '1993-05-29';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 100,
                "end_index": 132,
                "dilatect_content": "STRFTIME('%Y-%m-%d', T2.ord_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 140,
                "end_index": 192,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"ord_date\", '%Y-%m-%d')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `titles`\nColumns:\n(`title_id`, text, primary key)\n(`title`, text)\n(`type`, text)\n(`pub_id`, text)\n(`price`, real)\n(`advance`, real)\n(`royalty`, integer)\n(`ytd_sales`, integer)\n(`notes`, text)\n(`pubdate`, datetime)\n",
            "Table: `sales`\nColumns:\n(`stor_id`, text, primary key)\n(`ord_num`, text, primary key)\n(`ord_date`, datetime)\n(`qty`, integer)\n(`payterms`, text)\n(`title_id`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"titles\"\nColumns:\n(\"title_id\", STRING, primary key)\n(\"title\", STRING)\n(\"type\", STRING)\n(\"pub_id\", STRING)\n(\"price\", DOUBLE PRECISION)\n(\"advance\", DOUBLE PRECISION)\n(\"royalty\", BIGINT)\n(\"ytd_sales\", BIGINT)\n(\"notes\", STRING)\n(\"pubdate\", TIMESTAMP)\n",
            "Table: \"sales\"\nColumns:\n(\"stor_id\", STRING, primary key)\n(\"ord_num\", STRING, primary key)\n(\"ord_date\", TIMESTAMP)\n(\"qty\", BIGINT)\n(\"payterms\", STRING)\n(\"title_id\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 16,
        "database_name": "book_publishing_company",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(CASE WHEN T2.city = 'Fremont' THEN qty END) - SUM(CASE WHEN T2.city = 'Portland' THEN qty END) AS REAL) * 100 / SUM(CASE WHEN T2.city = 'Fremont' THEN qty END) FROM sales AS T1 INNER JOIN stores AS T2 ON T1.stor_id = T2.stor_id WHERE STRFTIME('%Y', T1.ord_date) = '1993'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"city\" = 'Fremont' THEN \"qty\" END) - SUM(CASE WHEN \"T2\".\"city\" = 'Portland' THEN \"qty\" END) AS REAL) * 100 / SUM(CASE WHEN \"T2\".\"city\" = 'Fremont' THEN \"qty\" END) FROM \"sales\" AS \"T1\" INNER JOIN \"stores\" AS \"T2\" ON \"T1\".\"stor_id\" = \"T2\".\"stor_id\" WHERE sys.timestamp_to_str(\"T1\".\"ord_date\", '%Y') = '1993';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 250,
                "end_index": 276,
                "dilatect_content": "STRFTIME('%Y', T1.ord_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 318,
                "end_index": 364,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"ord_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `sales`\nColumns:\n(`stor_id`, text, primary key)\n(`ord_num`, text, primary key)\n(`ord_date`, datetime)\n(`qty`, integer)\n(`payterms`, text)\n(`title_id`, text, primary key)\n",
            "Table: `stores`\nColumns:\n(`stor_id`, text, primary key)\n(`stor_name`, text)\n(`stor_address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"sales\"\nColumns:\n(\"stor_id\", STRING, primary key)\n(\"ord_num\", STRING, primary key)\n(\"ord_date\", TIMESTAMP)\n(\"qty\", BIGINT)\n(\"payterms\", STRING)\n(\"title_id\", STRING, primary key)\n",
            "Table: \"stores\"\nColumns:\n(\"stor_id\", STRING, primary key)\n(\"stor_name\", STRING)\n(\"stor_address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", STRING)\n"
        ]
    },
    {
        "sql_id": 17,
        "database_name": "book_publishing_company",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT fname, minit, lname FROM employee WHERE STRFTIME('%Y', hire_date) BETWEEN '1990' AND '1995' ORDER BY job_lvl DESC",
        "target_query": "SELECT \"fname\", \"minit\", \"lname\" FROM \"employee\" WHERE sys.timestamp_to_str(\"hire_date\", '%Y') BETWEEN '1990' AND '1995' ORDER BY \"job_lvl\" DESC;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 47,
                "end_index": 71,
                "dilatect_content": "STRFTIME('%Y', hire_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 63,
                "end_index": 103,
                "dilatect_content": "sys.timestamp_to_str(\"hire_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`emp_id`, text, primary key)\n(`fname`, text)\n(`minit`, text)\n(`lname`, text)\n(`job_id`, integer)\n(`job_lvl`, integer)\n(`pub_id`, text)\n(`hire_date`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"employee\"\nColumns:\n(\"emp_id\", STRING, primary key)\n(\"fname\", STRING)\n(\"minit\", STRING)\n(\"lname\", STRING)\n(\"job_id\", BIGINT)\n(\"job_lvl\", BIGINT)\n(\"pub_id\", STRING)\n(\"hire_date\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 18,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT 365 * (strftime('%Y', T2.`Date sent to company`) - strftime('%Y', T2.`Date received`)) + 30 * (strftime('%M', T2.`Date sent to company`) - strftime('%M', T2.`Date received`)) + (strftime('%d', T2.`Date sent to company`) - strftime('%d', T2.`Date received`)) FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T1.first = 'Matthew' AND T1.last = 'Pierce' AND T2.`Date received` = '2016-10-28'",
        "target_query": "SELECT 365 * (CAST(sys.timestamp_to_str(T2.\"Date_sent_to_company\", '%Y') AS INTEGER) - CAST(sys.timestamp_to_str(T2.\"Date_received\", '%Y') AS INTEGER)) + 30 * (CAST(sys.timestamp_to_str(T2.\"Date_sent_to_company\", '%m') AS INTEGER) - CAST(sys.timestamp_to_str(T2.\"Date_received\", '%m') AS INTEGER)) + (CAST(sys.timestamp_to_str(T2.\"Date_sent_to_company\", '%d') AS INTEGER) - CAST(sys.timestamp_to_str(T2.\"Date_received\", '%d') AS INTEGER)) FROM \"client\" AS T1 INNER JOIN \"events\" AS T2 ON T1.\"client_id\" = T2.\"Client_ID\" WHERE T1.\"_first\" = 'Matthew' AND T1.\"_last\" = 'Pierce' AND T2.\"Date_received\" = '2016-10-28';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 14,
                "end_index": 54,
                "dilatect_content": "strftime('%Y', T2.`Date sent to company`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 58,
                "end_index": 81,
                "dilatect_content": "strftime('%Y', T2.`Date received`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 102,
                "end_index": 142,
                "dilatect_content": "strftime('%M', T2.`Date sent to company`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 146,
                "end_index": 179,
                "dilatect_content": "strftime('%M', T2.`Date received`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 185,
                "end_index": 225,
                "dilatect_content": "strftime('%d', T2.`Date sent to company`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 229,
                "end_index": 262,
                "dilatect_content": "strftime('%d', T2.`Date received`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 19,
                "end_index": 54,
                "dilatect_content": "sys.timestamp_to_str(T2.\"Date_sent_to_company\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 94,
                "end_index": 141,
                "dilatect_content": "sys.timestamp_to_str(T2.\"Date_received\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 169,
                "end_index": 223,
                "dilatect_content": "sys.timestamp_to_str(T2.\"Date_sent_to_company\", '%m')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 244,
                "end_index": 291,
                "dilatect_content": "sys.timestamp_to_str(T2.\"Date_received\", '%m')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 314,
                "end_index": 368,
                "dilatect_content": "sys.timestamp_to_str(T2.\"Date_sent_to_company\", '%d')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 389,
                "end_index": 436,
                "dilatect_content": "sys.timestamp_to_str(T2.\"Date_received\", '%d')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `client`\nColumns:\n(`client_id`, text, primary key)\n(`sex`, text)\n(`day`, integer)\n(`month`, integer)\n(`year`, integer)\n(`age`, integer)\n(`social`, text)\n(`first`, text)\n(`middle`, text)\n(`last`, text)\n(`phone`, text)\n(`email`, text)\n(`address_1`, text)\n(`address_2`, text)\n(`city`, text)\n(`state`, text)\n(`zipcode`, integer)\n(`district_id`, integer)\n",
            "Table: `events`\nColumns:\n(`Date received`, date)\n(`Product`, text)\n(`Sub-product`, text)\n(`Issue`, text)\n(`Sub-issue`, text)\n(`Consumer complaint narrative`, text)\n(`Tags`, text)\n(`Consumer consent provided?`, text)\n(`Submitted via`, text)\n(`Date sent to company`, text)\n(`Company response to consumer`, text)\n(`Timely response?`, text)\n(`Consumer disputed?`, text)\n(`Complaint ID`, text, primary key)\n(`Client_ID`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"client\"\nColumns:\n(\"client_id\", STRING, primary key)\n(\"sex\", STRING)\n(\"_day\", BIGINT)\n(\"_month\", BIGINT)\n(\"_year\", BIGINT)\n(\"age\", BIGINT)\n(\"social\", STRING)\n(\"_first\", STRING)\n(\"middle\", STRING)\n(\"_last\", STRING)\n(\"phone\", STRING)\n(\"email\", STRING)\n(\"address_1\", STRING)\n(\"address_2\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zipcode\", BIGINT)\n(\"district_id\", BIGINT)\n",
            "Table: \"events\"\nColumns:\n(\"Date_received\", DATE)\n(\"Product\", STRING)\n(\"Sub_product\", STRING)\n(\"Issue\", STRING)\n(\"Sub_issue\", STRING)\n(\"Consumer_complaint_narrative\", STRING)\n(\"Tags\", STRING)\n(\"Consumer_consent_provided_\", STRING)\n(\"Submitted_via\", STRING)\n(\"Date_sent_to_company\", STRING)\n(\"Company_response_to_consumer\", STRING)\n(\"Timely_response_\", STRING)\n(\"Consumer_disputed_\", STRING)\n(\"Complaint_ID\", STRING, primary key)\n(\"Client_ID\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 19,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T1.sex) FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE strftime('%Y', T2.`Date received`) = '2016' AND T1.sex = 'Male' AND T2.Product = 'Credit card'",
        "target_query": "SELECT COUNT(\"T1\".\"sex\") FROM \"client\" AS \"T1\" INNER JOIN \"events\" AS \"T2\" ON \"T1\".\"client_id\" = \"T2\".\"Client_ID\" WHERE sys.timestamp_to_str(\"T2\".\"Date_received\", '%Y') = '2016' AND \"T1\".\"sex\" = 'Male' AND \"T2\".\"Product\" = 'Credit card';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 100,
                "end_index": 133,
                "dilatect_content": "strftime('%Y', T2.`Date received`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 140,
                "end_index": 191,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"Date_received\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `client`\nColumns:\n(`client_id`, text, primary key)\n(`sex`, text)\n(`day`, integer)\n(`month`, integer)\n(`year`, integer)\n(`age`, integer)\n(`social`, text)\n(`first`, text)\n(`middle`, text)\n(`last`, text)\n(`phone`, text)\n(`email`, text)\n(`address_1`, text)\n(`address_2`, text)\n(`city`, text)\n(`state`, text)\n(`zipcode`, integer)\n(`district_id`, integer)\n",
            "Table: `events`\nColumns:\n(`Date received`, date)\n(`Product`, text)\n(`Sub-product`, text)\n(`Issue`, text)\n(`Sub-issue`, text)\n(`Consumer complaint narrative`, text)\n(`Tags`, text)\n(`Consumer consent provided?`, text)\n(`Submitted via`, text)\n(`Date sent to company`, text)\n(`Company response to consumer`, text)\n(`Timely response?`, text)\n(`Consumer disputed?`, text)\n(`Complaint ID`, text, primary key)\n(`Client_ID`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"client\"\nColumns:\n(\"client_id\", STRING, primary key)\n(\"sex\", STRING)\n(\"_day\", BIGINT)\n(\"_month\", BIGINT)\n(\"_year\", BIGINT)\n(\"age\", BIGINT)\n(\"social\", STRING)\n(\"_first\", STRING)\n(\"middle\", STRING)\n(\"_last\", STRING)\n(\"phone\", STRING)\n(\"email\", STRING)\n(\"address_1\", STRING)\n(\"address_2\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zipcode\", BIGINT)\n(\"district_id\", BIGINT)\n",
            "Table: \"events\"\nColumns:\n(\"Date_received\", DATE)\n(\"Product\", STRING)\n(\"Sub_product\", STRING)\n(\"Issue\", STRING)\n(\"Sub_issue\", STRING)\n(\"Consumer_complaint_narrative\", STRING)\n(\"Tags\", STRING)\n(\"Consumer_consent_provided_\", STRING)\n(\"Submitted_via\", STRING)\n(\"Date_sent_to_company\", STRING)\n(\"Company_response_to_consumer\", STRING)\n(\"Timely_response_\", STRING)\n(\"Consumer_disputed_\", STRING)\n(\"Complaint_ID\", STRING, primary key)\n(\"Client_ID\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 20,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(COUNT(T2.`Complaint ID`) AS REAL) / 3 AS average FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE strftime('%Y', T2.`Date received`) BETWEEN '2015' AND '2017' AND T1.city = 'New York City' AND T2.Product = 'Credit card'",
        "target_query": "SELECT CAST(COUNT(T2.\"Complaint_ID\") AS REAL) / 3 AS average FROM \"client\" AS T1 INNER JOIN \"events\" AS T2 ON T1.\"client_id\" = T2.\"Client_ID\" WHERE sys.timestamp_to_str(T2.\"Date_received\", '%Y') BETWEEN '2015' AND '2017' AND T1.\"city\" = 'New York City' AND T2.\"Product\" = 'Credit card';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 140,
                "end_index": 173,
                "dilatect_content": "strftime('%Y', T2.`Date received`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 158,
                "end_index": 205,
                "dilatect_content": "sys.timestamp_to_str(T2.\"Date_received\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `client`\nColumns:\n(`client_id`, text, primary key)\n(`sex`, text)\n(`day`, integer)\n(`month`, integer)\n(`year`, integer)\n(`age`, integer)\n(`social`, text)\n(`first`, text)\n(`middle`, text)\n(`last`, text)\n(`phone`, text)\n(`email`, text)\n(`address_1`, text)\n(`address_2`, text)\n(`city`, text)\n(`state`, text)\n(`zipcode`, integer)\n(`district_id`, integer)\n",
            "Table: `events`\nColumns:\n(`Date received`, date)\n(`Product`, text)\n(`Sub-product`, text)\n(`Issue`, text)\n(`Sub-issue`, text)\n(`Consumer complaint narrative`, text)\n(`Tags`, text)\n(`Consumer consent provided?`, text)\n(`Submitted via`, text)\n(`Date sent to company`, text)\n(`Company response to consumer`, text)\n(`Timely response?`, text)\n(`Consumer disputed?`, text)\n(`Complaint ID`, text, primary key)\n(`Client_ID`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"client\"\nColumns:\n(\"client_id\", STRING, primary key)\n(\"sex\", STRING)\n(\"_day\", BIGINT)\n(\"_month\", BIGINT)\n(\"_year\", BIGINT)\n(\"age\", BIGINT)\n(\"social\", STRING)\n(\"_first\", STRING)\n(\"middle\", STRING)\n(\"_last\", STRING)\n(\"phone\", STRING)\n(\"email\", STRING)\n(\"address_1\", STRING)\n(\"address_2\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zipcode\", BIGINT)\n(\"district_id\", BIGINT)\n",
            "Table: \"events\"\nColumns:\n(\"Date_received\", DATE)\n(\"Product\", STRING)\n(\"Sub_product\", STRING)\n(\"Issue\", STRING)\n(\"Sub_issue\", STRING)\n(\"Consumer_complaint_narrative\", STRING)\n(\"Tags\", STRING)\n(\"Consumer_consent_provided_\", STRING)\n(\"Submitted_via\", STRING)\n(\"Date_sent_to_company\", STRING)\n(\"Company_response_to_consumer\", STRING)\n(\"Timely_response_\", STRING)\n(\"Consumer_disputed_\", STRING)\n(\"Complaint_ID\", STRING, primary key)\n(\"Client_ID\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 21,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT 100.0 * (SUM(CASE WHEN strftime('%Y', T2.`Date received`) = '2017' THEN 1 ELSE 0 END) - SUM(CASE WHEN strftime('%Y', T2.`Date received`) = '2016' THEN 1 ELSE 0 END)) / SUM(CASE WHEN strftime('%Y', T2.`Date received`) = '2016' THEN 1 ELSE 0 END) FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T1.city = 'New York City'",
        "target_query": "SELECT 100.0 * (SUM(CASE WHEN sys.timestamp_to_str(\"Date_received\", '%Y') = '2017' THEN 1 ELSE 0 END) - SUM(CASE WHEN sys.timestamp_to_str(\"Date_received\", '%Y') = '2016' THEN 1 ELSE 0 END)) / CAST(NULLIF(SUM(CASE WHEN sys.timestamp_to_str(\"Date_received\", '%Y') = '2016' THEN 1 ELSE 0 END), 0) AS FLOAT) FROM \"client\" AS T1 INNER JOIN \"events\" AS T2 ON T1.\"client_id\" = T2.\"Client_ID\" WHERE T1.\"city\" = 'New York City';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 30,
                "end_index": 63,
                "dilatect_content": "strftime('%Y', T2.`Date received`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 109,
                "end_index": 142,
                "dilatect_content": "strftime('%Y', T2.`Date received`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 189,
                "end_index": 222,
                "dilatect_content": "strftime('%Y', T2.`Date received`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 30,
                "end_index": 74,
                "dilatect_content": "sys.timestamp_to_str(\"Date_received\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 120,
                "end_index": 164,
                "dilatect_content": "sys.timestamp_to_str(\"Date_received\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 223,
                "end_index": 267,
                "dilatect_content": "sys.timestamp_to_str(\"Date_received\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `client`\nColumns:\n(`client_id`, text, primary key)\n(`sex`, text)\n(`day`, integer)\n(`month`, integer)\n(`year`, integer)\n(`age`, integer)\n(`social`, text)\n(`first`, text)\n(`middle`, text)\n(`last`, text)\n(`phone`, text)\n(`email`, text)\n(`address_1`, text)\n(`address_2`, text)\n(`city`, text)\n(`state`, text)\n(`zipcode`, integer)\n(`district_id`, integer)\n",
            "Table: `events`\nColumns:\n(`Date received`, date)\n(`Product`, text)\n(`Sub-product`, text)\n(`Issue`, text)\n(`Sub-issue`, text)\n(`Consumer complaint narrative`, text)\n(`Tags`, text)\n(`Consumer consent provided?`, text)\n(`Submitted via`, text)\n(`Date sent to company`, text)\n(`Company response to consumer`, text)\n(`Timely response?`, text)\n(`Consumer disputed?`, text)\n(`Complaint ID`, text, primary key)\n(`Client_ID`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"client\"\nColumns:\n(\"client_id\", STRING, primary key)\n(\"sex\", STRING)\n(\"_day\", BIGINT)\n(\"_month\", BIGINT)\n(\"_year\", BIGINT)\n(\"age\", BIGINT)\n(\"social\", STRING)\n(\"_first\", STRING)\n(\"middle\", STRING)\n(\"_last\", STRING)\n(\"phone\", STRING)\n(\"email\", STRING)\n(\"address_1\", STRING)\n(\"address_2\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zipcode\", BIGINT)\n(\"district_id\", BIGINT)\n",
            "Table: \"events\"\nColumns:\n(\"Date_received\", DATE)\n(\"Product\", STRING)\n(\"Sub_product\", STRING)\n(\"Issue\", STRING)\n(\"Sub_issue\", STRING)\n(\"Consumer_complaint_narrative\", STRING)\n(\"Tags\", STRING)\n(\"Consumer_consent_provided_\", STRING)\n(\"Submitted_via\", STRING)\n(\"Date_sent_to_company\", STRING)\n(\"Company_response_to_consumer\", STRING)\n(\"Timely_response_\", STRING)\n(\"Consumer_disputed_\", STRING)\n(\"Complaint_ID\", STRING, primary key)\n(\"Client_ID\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 22,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT 365 * (strftime('%Y', T2.`Date sent to company`) - strftime('%Y', T2.`Date received`)) + 30 * (strftime('%M', T2.`Date sent to company`) - strftime('%M', T2.`Date received`)) + (strftime('%d', T2.`Date sent to company`) - strftime('%d', T2.`Date received`)) AS days FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T2.`Date received` = '2012-05-18' AND T1.sex = 'Male' AND T1.first = 'Brantley' AND T1.middle = 'Julian' AND T1.last = 'Stanley'",
        "target_query": "SELECT 365 * (CAST(sys.timestamp_to_str(T2.\"Date_sent_to_company\", '%Y') AS INTEGER) - CAST(sys.timestamp_to_str(T2.\"Date_received\", '%Y') AS INTEGER)) + 30 * (CAST(sys.timestamp_to_str(T2.\"Date_sent_to_company\", '%m') AS INTEGER) - CAST(sys.timestamp_to_str(T2.\"Date_received\", '%m') AS INTEGER)) + (CAST(sys.timestamp_to_str(T2.\"Date_sent_to_company\", '%d') AS INTEGER) - CAST(sys.timestamp_to_str(T2.\"Date_received\", '%d') AS INTEGER)) AS days FROM \"client\" AS T1 INNER JOIN \"events\" AS T2 ON T1.\"client_id\" = T2.\"Client_ID\" WHERE T2.\"Date_received\" = '2012-05-18' AND T1.\"sex\" = 'Male' AND T1.\"_first\" = 'Brantley' AND T1.\"middle\" = 'Julian' AND T1.\"_last\" = 'Stanley';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 14,
                "end_index": 54,
                "dilatect_content": "strftime('%Y', T2.`Date sent to company`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 58,
                "end_index": 91,
                "dilatect_content": "strftime('%Y', T2.`Date received`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 102,
                "end_index": 142,
                "dilatect_content": "strftime('%M', T2.`Date sent to company`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 146,
                "end_index": 179,
                "dilatect_content": "strftime('%M', T2.`Date received`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 185,
                "end_index": 225,
                "dilatect_content": "strftime('%d', T2.`Date sent to company`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 229,
                "end_index": 262,
                "dilatect_content": "strftime('%d', T2.`Date received`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 19,
                "end_index": 73,
                "dilatect_content": "sys.timestamp_to_str(T2.\"Date_sent_to_company\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 94,
                "end_index": 141,
                "dilatect_content": "sys.timestamp_to_str(T2.\"Date_received\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 169,
                "end_index": 223,
                "dilatect_content": "sys.timestamp_to_str(T2.\"Date_sent_to_company\", '%m')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 244,
                "end_index": 291,
                "dilatect_content": "sys.timestamp_to_str(T2.\"Date_received\", '%m')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 314,
                "end_index": 368,
                "dilatect_content": "sys.timestamp_to_str(T2.\"Date_sent_to_company\", '%d')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 389,
                "end_index": 436,
                "dilatect_content": "sys.timestamp_to_str(T2.\"Date_received\", '%d')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `client`\nColumns:\n(`client_id`, text, primary key)\n(`sex`, text)\n(`day`, integer)\n(`month`, integer)\n(`year`, integer)\n(`age`, integer)\n(`social`, text)\n(`first`, text)\n(`middle`, text)\n(`last`, text)\n(`phone`, text)\n(`email`, text)\n(`address_1`, text)\n(`address_2`, text)\n(`city`, text)\n(`state`, text)\n(`zipcode`, integer)\n(`district_id`, integer)\n",
            "Table: `events`\nColumns:\n(`Date received`, date)\n(`Product`, text)\n(`Sub-product`, text)\n(`Issue`, text)\n(`Sub-issue`, text)\n(`Consumer complaint narrative`, text)\n(`Tags`, text)\n(`Consumer consent provided?`, text)\n(`Submitted via`, text)\n(`Date sent to company`, text)\n(`Company response to consumer`, text)\n(`Timely response?`, text)\n(`Consumer disputed?`, text)\n(`Complaint ID`, text, primary key)\n(`Client_ID`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"client\"\nColumns:\n(\"client_id\", STRING, primary key)\n(\"sex\", STRING)\n(\"_day\", BIGINT)\n(\"_month\", BIGINT)\n(\"_year\", BIGINT)\n(\"age\", BIGINT)\n(\"social\", STRING)\n(\"_first\", STRING)\n(\"middle\", STRING)\n(\"_last\", STRING)\n(\"phone\", STRING)\n(\"email\", STRING)\n(\"address_1\", STRING)\n(\"address_2\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zipcode\", BIGINT)\n(\"district_id\", BIGINT)\n",
            "Table: \"events\"\nColumns:\n(\"Date_received\", DATE)\n(\"Product\", STRING)\n(\"Sub_product\", STRING)\n(\"Issue\", STRING)\n(\"Sub_issue\", STRING)\n(\"Consumer_complaint_narrative\", STRING)\n(\"Tags\", STRING)\n(\"Consumer_consent_provided_\", STRING)\n(\"Submitted_via\", STRING)\n(\"Date_sent_to_company\", STRING)\n(\"Company_response_to_consumer\", STRING)\n(\"Timely_response_\", STRING)\n(\"Consumer_disputed_\", STRING)\n(\"Complaint_ID\", STRING, primary key)\n(\"Client_ID\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 24,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT `Complaint ID` FROM events WHERE strftime('%J', `Date sent to company`) - strftime('%J', `Date received`) = ( SELECT MAX(strftime('%J', `Date sent to company`) - strftime('%J', `Date received`)) FROM events WHERE `Date sent to company` = '2014-09-25' ) AND `Date sent to company` = '2014-09-25'",
        "target_query": "SELECT \"Complaint_ID\" FROM \"events\" WHERE (sys.timestamp_to_str(\"Date_sent_to_company\", '%J') - sys.timestamp_to_str(\"Date_received\", '%J')) = ( SELECT MAX(sys.timestamp_to_str(\"Date_sent_to_company\", '%J') - sys.timestamp_to_str(\"Date_received\", '%J')) FROM \"events\" WHERE \"Date_sent_to_company\" = '2014-09-25' ) AND \"Date_sent_to_company\" = '2014-09-25';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 40,
                "end_index": 77,
                "dilatect_content": "strftime('%J', `Date sent to company`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 81,
                "end_index": 111,
                "dilatect_content": "strftime('%J', `Date received`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 128,
                "end_index": 165,
                "dilatect_content": "strftime('%J', `Date sent to company`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 169,
                "end_index": 199,
                "dilatect_content": "strftime('%J', `Date received`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 47,
                "end_index": 98,
                "dilatect_content": "sys.timestamp_to_str(\"Date_sent_to_company\", '%J')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 102,
                "end_index": 146,
                "dilatect_content": "sys.timestamp_to_str(\"Date_received\", '%J')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 164,
                "end_index": 215,
                "dilatect_content": "sys.timestamp_to_str(\"Date_sent_to_company\", '%J')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 219,
                "end_index": 263,
                "dilatect_content": "sys.timestamp_to_str(\"Date_received\", '%J')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `events`\nColumns:\n(`Date received`, date)\n(`Product`, text)\n(`Sub-product`, text)\n(`Issue`, text)\n(`Sub-issue`, text)\n(`Consumer complaint narrative`, text)\n(`Tags`, text)\n(`Consumer consent provided?`, text)\n(`Submitted via`, text)\n(`Date sent to company`, text)\n(`Company response to consumer`, text)\n(`Timely response?`, text)\n(`Consumer disputed?`, text)\n(`Complaint ID`, text, primary key)\n(`Client_ID`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"events\"\nColumns:\n(\"Date_received\", DATE)\n(\"Product\", STRING)\n(\"Sub_product\", STRING)\n(\"Issue\", STRING)\n(\"Sub_issue\", STRING)\n(\"Consumer_complaint_narrative\", STRING)\n(\"Tags\", STRING)\n(\"Consumer_consent_provided_\", STRING)\n(\"Submitted_via\", STRING)\n(\"Date_sent_to_company\", STRING)\n(\"Company_response_to_consumer\", STRING)\n(\"Timely_response_\", STRING)\n(\"Consumer_disputed_\", STRING)\n(\"Complaint_ID\", STRING, primary key)\n(\"Client_ID\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 25,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(ser_time) FROM callcenterlogs WHERE strftime('%M', ser_time) > '15'",
        "target_query": "SELECT COUNT(\"ser_time\") FROM \"callcenterlogs\" WHERE EXTRACT(MINUTE FROM CAST(\"ser_time\" AS TIME)) > 15;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 49,
                "end_index": 72,
                "dilatect_content": "strftime('%M', ser_time)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 65,
                "end_index": 102,
                "dilatect_content": "MINUTE FROM CAST(\"ser_time\" AS TIME)",
                "feature": ""
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `callcenterlogs`\nColumns:\n(`Date received`, date)\n(`Complaint ID`, text, primary key)\n(`rand client`, text)\n(`phonefinal`, text)\n(`vru+line`, text)\n(`call_id`, integer)\n(`priority`, integer)\n(`type`, text)\n(`outcome`, text)\n(`server`, text)\n(`ser_start`, text)\n(`ser_exit`, text)\n(`ser_time`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"callcenterlogs\"\nColumns:\n(\"Date_received\", DATE)\n(\"Complaint_ID\", STRING, primary key)\n(\"rand_client\", STRING)\n(\"phonefinal\", STRING)\n(\"vru_line\", STRING)\n(\"call_id\", BIGINT)\n(\"priority\", BIGINT)\n(\"type\", STRING)\n(\"outcome\", STRING)\n(\"server\", STRING)\n(\"ser_start\", STRING)\n(\"ser_exit\", STRING)\n(\"ser_time\", STRING)\n"
        ]
    },
    {
        "sql_id": 26,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(CASE WHEN T1.age > 13 AND T1.age <= 19 THEN 60 * strftime('%H', ser_time) + strftime('%M', ser_time) + strftime('%S', ser_time) / 60 ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.age > 13 AND T1.age <= 19 THEN 1 ELSE 0 END) AS teenagerAverageMins, CAST(SUM(CASE WHEN T1.age > 19 AND T1.age <= 65 THEN 60 * strftime('%H', ser_time) + strftime('%M', ser_time) + strftime('%S', ser_time) / 60 ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.age > 19 AND T1.age <= 65 THEN 1 ELSE 0 END) AS adultAverageMins , CAST(SUM(CASE WHEN T1.age > 65 THEN 60 * strftime('%H', ser_time) + strftime('%M', ser_time) + strftime('%S', ser_time) / 60 ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.age > 65 THEN 1 ELSE 0 END) AS elderAverageMins FROM client AS T1 INNER JOIN callcenterlogs AS T2 ON T1.client_id = T2.`rand client`",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T1\".\"age\" > 13 AND \"T1\".\"age\" <= 19 THEN 60 * CAST(SUBSTRING(\"T2\".\"ser_time\" FROM 1 FOR 2) AS BIGINT) + CAST(SUBSTRING(\"T2\".\"ser_time\" FROM 4 FOR 2) AS BIGINT) + CAST(SUBSTRING(\"T2\".\"ser_time\" FROM 7 FOR 2) AS BIGINT) / 60 ELSE 0 END) AS REAL) / SUM(CASE WHEN \"T1\".\"age\" > 13 AND \"T1\".\"age\" <= 19 THEN 1 ELSE 0 END) AS \"teenagerAverageMins\", CAST(SUM(CASE WHEN \"T1\".\"age\" > 19 AND \"T1\".\"age\" <= 65 THEN 60 * CAST(SUBSTRING(\"T2\".\"ser_time\" FROM 1 FOR 2) AS BIGINT) + CAST(SUBSTRING(\"T2\".\"ser_time\" FROM 4 FOR 2) AS BIGINT) + CAST(SUBSTRING(\"T2\".\"ser_time\" FROM 7 FOR 2) AS BIGINT) / 60 ELSE 0 END) AS REAL) / SUM(CASE WHEN \"T1\".\"age\" > 19 AND \"T1\".\"age\" <= 65 THEN 1 ELSE 0 END) AS \"adultAverageMins\", CAST(SUM(CASE WHEN \"T1\".\"age\" > 65 THEN 60 * CAST(SUBSTRING(\"T2\".\"ser_time\" FROM 1 FOR 2) AS BIGINT) + CAST(SUBSTRING(\"T2\".\"ser_time\" FROM 4 FOR 2) AS BIGINT) + CAST(SUBSTRING(\"T2\".\"ser_time\" FROM 7 FOR 2) AS BIGINT) / 60 ELSE 0 END) AS REAL) / SUM(CASE WHEN \"T1\".\"age\" > 65 THEN 1 ELSE 0 END) AS \"elderAverageMins\" FROM \"client\" AS \"T1\" INNER JOIN \"callcenterlogs\" AS \"T2\" ON \"T1\".\"client_id\" = \"T2\".\"rand_client\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 65,
                "end_index": 88,
                "dilatect_content": "strftime('%H', ser_time)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 92,
                "end_index": 115,
                "dilatect_content": "strftime('%M', ser_time)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 119,
                "end_index": 142,
                "dilatect_content": "strftime('%S', ser_time)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 316,
                "end_index": 339,
                "dilatect_content": "strftime('%H', ser_time)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 343,
                "end_index": 366,
                "dilatect_content": "strftime('%M', ser_time)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 370,
                "end_index": 393,
                "dilatect_content": "strftime('%S', ser_time)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 548,
                "end_index": 571,
                "dilatect_content": "strftime('%H', ser_time)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 575,
                "end_index": 598,
                "dilatect_content": "strftime('%M', ser_time)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 602,
                "end_index": 625,
                "dilatect_content": "strftime('%S', ser_time)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `client`\nColumns:\n(`client_id`, text, primary key)\n(`sex`, text)\n(`day`, integer)\n(`month`, integer)\n(`year`, integer)\n(`age`, integer)\n(`social`, text)\n(`first`, text)\n(`middle`, text)\n(`last`, text)\n(`phone`, text)\n(`email`, text)\n(`address_1`, text)\n(`address_2`, text)\n(`city`, text)\n(`state`, text)\n(`zipcode`, integer)\n(`district_id`, integer)\n",
            "Table: `callcenterlogs`\nColumns:\n(`Date received`, date)\n(`Complaint ID`, text, primary key)\n(`rand client`, text)\n(`phonefinal`, text)\n(`vru+line`, text)\n(`call_id`, integer)\n(`priority`, integer)\n(`type`, text)\n(`outcome`, text)\n(`server`, text)\n(`ser_start`, text)\n(`ser_exit`, text)\n(`ser_time`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"client\"\nColumns:\n(\"client_id\", STRING, primary key)\n(\"sex\", STRING)\n(\"_day\", BIGINT)\n(\"_month\", BIGINT)\n(\"_year\", BIGINT)\n(\"age\", BIGINT)\n(\"social\", STRING)\n(\"_first\", STRING)\n(\"middle\", STRING)\n(\"_last\", STRING)\n(\"phone\", STRING)\n(\"email\", STRING)\n(\"address_1\", STRING)\n(\"address_2\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zipcode\", BIGINT)\n(\"district_id\", BIGINT)\n",
            "Table: \"callcenterlogs\"\nColumns:\n(\"Date_received\", DATE)\n(\"Complaint_ID\", STRING, primary key)\n(\"rand_client\", STRING)\n(\"phonefinal\", STRING)\n(\"vru_line\", STRING)\n(\"call_id\", BIGINT)\n(\"priority\", BIGINT)\n(\"type\", STRING)\n(\"outcome\", STRING)\n(\"server\", STRING)\n(\"ser_start\", STRING)\n(\"ser_exit\", STRING)\n(\"ser_time\", STRING)\n"
        ]
    },
    {
        "sql_id": 28,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.Issue FROM callcenterlogs AS T1 INNER JOIN events AS T2 ON T1.`Complaint ID` = T2.`Complaint ID` WHERE strftime('%M', T1.ser_time) < '10'",
        "target_query": "SELECT \"T2\".\"Issue\" FROM \"callcenterlogs\" AS \"T1\" INNER JOIN \"events\" AS \"T2\" ON \"T1\".\"Complaint_ID\" = \"T2\".\"Complaint_ID\" WHERE SUBSTRING(\"T1\".\"ser_time\", 4, 2) < '10';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 113,
                "end_index": 139,
                "dilatect_content": "strftime('%M', T1.ser_time)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `callcenterlogs`\nColumns:\n(`Date received`, date)\n(`Complaint ID`, text, primary key)\n(`rand client`, text)\n(`phonefinal`, text)\n(`vru+line`, text)\n(`call_id`, integer)\n(`priority`, integer)\n(`type`, text)\n(`outcome`, text)\n(`server`, text)\n(`ser_start`, text)\n(`ser_exit`, text)\n(`ser_time`, text)\n",
            "Table: `events`\nColumns:\n(`Date received`, date)\n(`Product`, text)\n(`Sub-product`, text)\n(`Issue`, text)\n(`Sub-issue`, text)\n(`Consumer complaint narrative`, text)\n(`Tags`, text)\n(`Consumer consent provided?`, text)\n(`Submitted via`, text)\n(`Date sent to company`, text)\n(`Company response to consumer`, text)\n(`Timely response?`, text)\n(`Consumer disputed?`, text)\n(`Complaint ID`, text, primary key)\n(`Client_ID`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"callcenterlogs\"\nColumns:\n(\"Date_received\", DATE)\n(\"Complaint_ID\", STRING, primary key)\n(\"rand_client\", STRING)\n(\"phonefinal\", STRING)\n(\"vru_line\", STRING)\n(\"call_id\", BIGINT)\n(\"priority\", BIGINT)\n(\"type\", STRING)\n(\"outcome\", STRING)\n(\"server\", STRING)\n(\"ser_start\", STRING)\n(\"ser_exit\", STRING)\n(\"ser_time\", STRING)\n",
            "Table: \"events\"\nColumns:\n(\"Date_received\", DATE)\n(\"Product\", STRING)\n(\"Sub_product\", STRING)\n(\"Issue\", STRING)\n(\"Sub_issue\", STRING)\n(\"Consumer_complaint_narrative\", STRING)\n(\"Tags\", STRING)\n(\"Consumer_consent_provided_\", STRING)\n(\"Submitted_via\", STRING)\n(\"Date_sent_to_company\", STRING)\n(\"Company_response_to_consumer\", STRING)\n(\"Timely_response_\", STRING)\n(\"Consumer_disputed_\", STRING)\n(\"Complaint_ID\", STRING, primary key)\n(\"Client_ID\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 29,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT `Complaint ID`, call_id, phonefinal FROM callcenterlogs WHERE strftime('%Y', `Date received`) = '2014' AND server = 'AVIDAN'",
        "target_query": "SELECT \"Complaint_ID\", call_id, phonefinal FROM \"callcenterlogs\" WHERE sys.timestamp_to_str(\"Date_received\", '%Y') = '2014' AND server = 'AVIDAN';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 69,
                "end_index": 99,
                "dilatect_content": "strftime('%Y', `Date received`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 75,
                "end_index": 119,
                "dilatect_content": "sys.timestamp_to_str(\"Date_received\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `callcenterlogs`\nColumns:\n(`Date received`, date)\n(`Complaint ID`, text, primary key)\n(`rand client`, text)\n(`phonefinal`, text)\n(`vru+line`, text)\n(`call_id`, integer)\n(`priority`, integer)\n(`type`, text)\n(`outcome`, text)\n(`server`, text)\n(`ser_start`, text)\n(`ser_exit`, text)\n(`ser_time`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"callcenterlogs\"\nColumns:\n(\"Date_received\", DATE)\n(\"Complaint_ID\", STRING, primary key)\n(\"rand_client\", STRING)\n(\"phonefinal\", STRING)\n(\"vru_line\", STRING)\n(\"call_id\", BIGINT)\n(\"priority\", BIGINT)\n(\"type\", STRING)\n(\"outcome\", STRING)\n(\"server\", STRING)\n(\"ser_start\", STRING)\n(\"ser_exit\", STRING)\n(\"ser_time\", STRING)\n"
        ]
    },
    {
        "sql_id": 30,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT AVG(CAST(SUBSTR(ser_time, 4, 2) AS REAL)) FROM callcenterlogs WHERE `Date received` BETWEEN '2017-01-01' AND '2017-04-01'",
        "target_query": "SELECT AVG(CAST(substring(\"ser_time\" from 4 for 2) AS REAL)) FROM \"callcenterlogs\" WHERE \"Date_received\" BETWEEN '2017-01-01' AND '2017-04-01';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 37,
                "dilatect_content": "SUBSTR(ser_time, 4, 2)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 51,
                "dilatect_content": "substring(\"ser_time\" from 4 for 2)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `callcenterlogs`\nColumns:\n(`Date received`, date)\n(`Complaint ID`, text, primary key)\n(`rand client`, text)\n(`phonefinal`, text)\n(`vru+line`, text)\n(`call_id`, integer)\n(`priority`, integer)\n(`type`, text)\n(`outcome`, text)\n(`server`, text)\n(`ser_start`, text)\n(`ser_exit`, text)\n(`ser_time`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"callcenterlogs\"\nColumns:\n(\"Date_received\", DATE)\n(\"Complaint_ID\", STRING, primary key)\n(\"rand_client\", STRING)\n(\"phonefinal\", STRING)\n(\"vru_line\", STRING)\n(\"call_id\", BIGINT)\n(\"priority\", BIGINT)\n(\"type\", STRING)\n(\"outcome\", STRING)\n(\"server\", STRING)\n(\"ser_start\", STRING)\n(\"ser_exit\", STRING)\n(\"ser_time\", STRING)\n"
        ]
    },
    {
        "sql_id": 31,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT strftime('%Y', `Date received`), COUNT(`Date received`) FROM events WHERE product = 'Credit card' AND issue = 'Overlimit fee' GROUP BY strftime('%Y', `Date received`) HAVING COUNT(`Date received`)",
        "target_query": "SELECT sys.timestamp_to_str(\"Date_received\", '%Y'), COUNT(\"Date_received\") FROM \"events\" WHERE \"Product\" = 'Credit card' AND \"Issue\" = 'Overlimit fee' GROUP BY sys.timestamp_to_str(\"Date_received\", '%Y') HAVING COUNT(\"Date_received\");",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 37,
                "dilatect_content": "strftime('%Y', `Date received`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 142,
                "end_index": 172,
                "dilatect_content": "strftime('%Y', `Date received`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 51,
                "dilatect_content": "sys.timestamp_to_str(\"Date_received\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 170,
                "end_index": 214,
                "dilatect_content": "sys.timestamp_to_str(\"Date_received\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `events`\nColumns:\n(`Date received`, date)\n(`Product`, text)\n(`Sub-product`, text)\n(`Issue`, text)\n(`Sub-issue`, text)\n(`Consumer complaint narrative`, text)\n(`Tags`, text)\n(`Consumer consent provided?`, text)\n(`Submitted via`, text)\n(`Date sent to company`, text)\n(`Company response to consumer`, text)\n(`Timely response?`, text)\n(`Consumer disputed?`, text)\n(`Complaint ID`, text, primary key)\n(`Client_ID`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"events\"\nColumns:\n(\"Date_received\", DATE)\n(\"Product\", STRING)\n(\"Sub_product\", STRING)\n(\"Issue\", STRING)\n(\"Sub_issue\", STRING)\n(\"Consumer_complaint_narrative\", STRING)\n(\"Tags\", STRING)\n(\"Consumer_consent_provided_\", STRING)\n(\"Submitted_via\", STRING)\n(\"Date_sent_to_company\", STRING)\n(\"Company_response_to_consumer\", STRING)\n(\"Timely_response_\", STRING)\n(\"Consumer_disputed_\", STRING)\n(\"Complaint_ID\", STRING, primary key)\n(\"Client_ID\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 33,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(CASE WHEN T1.priority = 2 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.`Complaint ID`) FROM callcenterlogs AS T1 INNER JOIN events AS T2 ON T1.`Complaint ID` = T2.`Complaint ID` WHERE strftime('%Y', T1.`Date received`) = '2017'",
        "target_query": "SELECT CAST(SUM(CASE WHEN T1.\"priority\" = 2 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.\"Complaint_ID\") FROM \"callcenterlogs\" AS T1 INNER JOIN \"events\" AS T2 ON T1.\"Complaint_ID\" = T2.\"Complaint_ID\" WHERE sys.timestamp_to_str(T1.\"Date_received\", '%Y') = '2017';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 200,
                "end_index": 233,
                "dilatect_content": "strftime('%Y', T1.`Date received`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 218,
                "end_index": 265,
                "dilatect_content": "sys.timestamp_to_str(T1.\"Date_received\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `callcenterlogs`\nColumns:\n(`Date received`, date)\n(`Complaint ID`, text, primary key)\n(`rand client`, text)\n(`phonefinal`, text)\n(`vru+line`, text)\n(`call_id`, integer)\n(`priority`, integer)\n(`type`, text)\n(`outcome`, text)\n(`server`, text)\n(`ser_start`, text)\n(`ser_exit`, text)\n(`ser_time`, text)\n",
            "Table: `events`\nColumns:\n(`Date received`, date)\n(`Product`, text)\n(`Sub-product`, text)\n(`Issue`, text)\n(`Sub-issue`, text)\n(`Consumer complaint narrative`, text)\n(`Tags`, text)\n(`Consumer consent provided?`, text)\n(`Submitted via`, text)\n(`Date sent to company`, text)\n(`Company response to consumer`, text)\n(`Timely response?`, text)\n(`Consumer disputed?`, text)\n(`Complaint ID`, text, primary key)\n(`Client_ID`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"callcenterlogs\"\nColumns:\n(\"Date_received\", DATE)\n(\"Complaint_ID\", STRING, primary key)\n(\"rand_client\", STRING)\n(\"phonefinal\", STRING)\n(\"vru_line\", STRING)\n(\"call_id\", BIGINT)\n(\"priority\", BIGINT)\n(\"type\", STRING)\n(\"outcome\", STRING)\n(\"server\", STRING)\n(\"ser_start\", STRING)\n(\"ser_exit\", STRING)\n(\"ser_time\", STRING)\n",
            "Table: \"events\"\nColumns:\n(\"Date_received\", DATE)\n(\"Product\", STRING)\n(\"Sub_product\", STRING)\n(\"Issue\", STRING)\n(\"Sub_issue\", STRING)\n(\"Consumer_complaint_narrative\", STRING)\n(\"Tags\", STRING)\n(\"Consumer_consent_provided_\", STRING)\n(\"Submitted_via\", STRING)\n(\"Date_sent_to_company\", STRING)\n(\"Company_response_to_consumer\", STRING)\n(\"Timely_response_\", STRING)\n(\"Consumer_disputed_\", STRING)\n(\"Complaint_ID\", STRING, primary key)\n(\"Client_ID\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 34,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T1.city = 'Omaha' AND strftime('%Y', T2.`Date received`) = '2012' AND T2.Product = 'Credit card'",
        "target_query": "SELECT COUNT(\"T1\".\"client_id\") FROM \"client\" AS \"T1\" INNER JOIN \"events\" AS \"T2\" ON \"T1\".\"client_id\" = \"T2\".\"Client_ID\" WHERE \"T1\".\"city\" = 'Omaha' AND sys.timestamp_to_str(\"T2\".\"Date_received\", '%Y') = '2012' AND \"T2\".\"Product\" = 'Credit card';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 128,
                "end_index": 161,
                "dilatect_content": "strftime('%Y', T2.`Date received`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 176,
                "end_index": 237,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"Date_received\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `client`\nColumns:\n(`client_id`, text, primary key)\n(`sex`, text)\n(`day`, integer)\n(`month`, integer)\n(`year`, integer)\n(`age`, integer)\n(`social`, text)\n(`first`, text)\n(`middle`, text)\n(`last`, text)\n(`phone`, text)\n(`email`, text)\n(`address_1`, text)\n(`address_2`, text)\n(`city`, text)\n(`state`, text)\n(`zipcode`, integer)\n(`district_id`, integer)\n",
            "Table: `events`\nColumns:\n(`Date received`, date)\n(`Product`, text)\n(`Sub-product`, text)\n(`Issue`, text)\n(`Sub-issue`, text)\n(`Consumer complaint narrative`, text)\n(`Tags`, text)\n(`Consumer consent provided?`, text)\n(`Submitted via`, text)\n(`Date sent to company`, text)\n(`Company response to consumer`, text)\n(`Timely response?`, text)\n(`Consumer disputed?`, text)\n(`Complaint ID`, text, primary key)\n(`Client_ID`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"client\"\nColumns:\n(\"client_id\", STRING, primary key)\n(\"sex\", STRING)\n(\"_day\", BIGINT)\n(\"_month\", BIGINT)\n(\"_year\", BIGINT)\n(\"age\", BIGINT)\n(\"social\", STRING)\n(\"_first\", STRING)\n(\"middle\", STRING)\n(\"_last\", STRING)\n(\"phone\", STRING)\n(\"email\", STRING)\n(\"address_1\", STRING)\n(\"address_2\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zipcode\", BIGINT)\n(\"district_id\", BIGINT)\n",
            "Table: \"events\"\nColumns:\n(\"Date_received\", DATE)\n(\"Product\", STRING)\n(\"Sub_product\", STRING)\n(\"Issue\", STRING)\n(\"Sub_issue\", STRING)\n(\"Consumer_complaint_narrative\", STRING)\n(\"Tags\", STRING)\n(\"Consumer_consent_provided_\", STRING)\n(\"Submitted_via\", STRING)\n(\"Date_sent_to_company\", STRING)\n(\"Company_response_to_consumer\", STRING)\n(\"Timely_response_\", STRING)\n(\"Consumer_disputed_\", STRING)\n(\"Complaint_ID\", STRING, primary key)\n(\"Client_ID\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 35,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE strftime('%Y', T2.`Date received`) BETWEEN '2012' AND '2015' AND T2.`Submitted via` = 'Email' AND T1.sex = 'Male'",
        "target_query": "SELECT COUNT(\"T1\".\"client_id\") FROM \"client\" AS \"T1\" INNER JOIN \"events\" AS \"T2\" ON \"T1\".\"client_id\" = \"T2\".\"Client_ID\" WHERE sys.timestamp_to_str(\"T2\".\"Date_received\", '%Y') BETWEEN '2012' AND '2015' AND \"T2\".\"Submitted_via\" = 'Email' AND \"T1\".\"sex\" = 'Male';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 106,
                "end_index": 139,
                "dilatect_content": "strftime('%Y', T2.`Date received`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 146,
                "end_index": 197,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"Date_received\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `client`\nColumns:\n(`client_id`, text, primary key)\n(`sex`, text)\n(`day`, integer)\n(`month`, integer)\n(`year`, integer)\n(`age`, integer)\n(`social`, text)\n(`first`, text)\n(`middle`, text)\n(`last`, text)\n(`phone`, text)\n(`email`, text)\n(`address_1`, text)\n(`address_2`, text)\n(`city`, text)\n(`state`, text)\n(`zipcode`, integer)\n(`district_id`, integer)\n",
            "Table: `events`\nColumns:\n(`Date received`, date)\n(`Product`, text)\n(`Sub-product`, text)\n(`Issue`, text)\n(`Sub-issue`, text)\n(`Consumer complaint narrative`, text)\n(`Tags`, text)\n(`Consumer consent provided?`, text)\n(`Submitted via`, text)\n(`Date sent to company`, text)\n(`Company response to consumer`, text)\n(`Timely response?`, text)\n(`Consumer disputed?`, text)\n(`Complaint ID`, text, primary key)\n(`Client_ID`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"client\"\nColumns:\n(\"client_id\", STRING, primary key)\n(\"sex\", STRING)\n(\"_day\", BIGINT)\n(\"_month\", BIGINT)\n(\"_year\", BIGINT)\n(\"age\", BIGINT)\n(\"social\", STRING)\n(\"_first\", STRING)\n(\"middle\", STRING)\n(\"_last\", STRING)\n(\"phone\", STRING)\n(\"email\", STRING)\n(\"address_1\", STRING)\n(\"address_2\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zipcode\", BIGINT)\n(\"district_id\", BIGINT)\n",
            "Table: \"events\"\nColumns:\n(\"Date_received\", DATE)\n(\"Product\", STRING)\n(\"Sub_product\", STRING)\n(\"Issue\", STRING)\n(\"Sub_issue\", STRING)\n(\"Consumer_complaint_narrative\", STRING)\n(\"Tags\", STRING)\n(\"Consumer_consent_provided_\", STRING)\n(\"Submitted_via\", STRING)\n(\"Date_sent_to_company\", STRING)\n(\"Company_response_to_consumer\", STRING)\n(\"Timely_response_\", STRING)\n(\"Consumer_disputed_\", STRING)\n(\"Complaint_ID\", STRING, primary key)\n(\"Client_ID\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 36,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST((SUM(CASE WHEN strftime('%J', T2.`Date sent to company`) - strftime('%J', T2.`Date received`) > 5 THEN 1 ELSE 0 END)) AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T1.city = 'Houston' AND strftime('%Y', T2.`Date received`) = '2014'",
        "target_query": "SELECT CAST((SUM(CASE WHEN CAST(sys.timestamp_to_str(T2.\"Date_sent_to_company\", '%j') AS INTEGER) - CAST(sys.timestamp_to_str(T2.\"Date_received\", '%j') AS INTEGER) > 5 THEN 1 ELSE 0 END)) AS REAL) * 100 / COUNT(T1.\"client_id\") FROM \"client\" AS T1 INNER JOIN \"events\" AS T2 ON T1.\"client_id\" = T2.\"Client_ID\" WHERE T1.\"city\" = 'Houston' AND sys.timestamp_to_str(T2.\"Date_received\", '%Y') = '2014';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 27,
                "end_index": 67,
                "dilatect_content": "strftime('%J', T2.`Date sent to company`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 71,
                "end_index": 104,
                "dilatect_content": "strftime('%J', T2.`Date received`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 270,
                "end_index": 303,
                "dilatect_content": "strftime('%Y', T2.`Date received`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 32,
                "end_index": 86,
                "dilatect_content": "sys.timestamp_to_str(T2.\"Date_sent_to_company\", '%j')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 107,
                "end_index": 154,
                "dilatect_content": "sys.timestamp_to_str(T2.\"Date_received\", '%j')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 356,
                "end_index": 403,
                "dilatect_content": "sys.timestamp_to_str(T2.\"Date_received\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `client`\nColumns:\n(`client_id`, text, primary key)\n(`sex`, text)\n(`day`, integer)\n(`month`, integer)\n(`year`, integer)\n(`age`, integer)\n(`social`, text)\n(`first`, text)\n(`middle`, text)\n(`last`, text)\n(`phone`, text)\n(`email`, text)\n(`address_1`, text)\n(`address_2`, text)\n(`city`, text)\n(`state`, text)\n(`zipcode`, integer)\n(`district_id`, integer)\n",
            "Table: `events`\nColumns:\n(`Date received`, date)\n(`Product`, text)\n(`Sub-product`, text)\n(`Issue`, text)\n(`Sub-issue`, text)\n(`Consumer complaint narrative`, text)\n(`Tags`, text)\n(`Consumer consent provided?`, text)\n(`Submitted via`, text)\n(`Date sent to company`, text)\n(`Company response to consumer`, text)\n(`Timely response?`, text)\n(`Consumer disputed?`, text)\n(`Complaint ID`, text, primary key)\n(`Client_ID`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"client\"\nColumns:\n(\"client_id\", STRING, primary key)\n(\"sex\", STRING)\n(\"_day\", BIGINT)\n(\"_month\", BIGINT)\n(\"_year\", BIGINT)\n(\"age\", BIGINT)\n(\"social\", STRING)\n(\"_first\", STRING)\n(\"middle\", STRING)\n(\"_last\", STRING)\n(\"phone\", STRING)\n(\"email\", STRING)\n(\"address_1\", STRING)\n(\"address_2\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zipcode\", BIGINT)\n(\"district_id\", BIGINT)\n",
            "Table: \"events\"\nColumns:\n(\"Date_received\", DATE)\n(\"Product\", STRING)\n(\"Sub_product\", STRING)\n(\"Issue\", STRING)\n(\"Sub_issue\", STRING)\n(\"Consumer_complaint_narrative\", STRING)\n(\"Tags\", STRING)\n(\"Consumer_consent_provided_\", STRING)\n(\"Submitted_via\", STRING)\n(\"Date_sent_to_company\", STRING)\n(\"Company_response_to_consumer\", STRING)\n(\"Timely_response_\", STRING)\n(\"Consumer_disputed_\", STRING)\n(\"Complaint_ID\", STRING, primary key)\n(\"Client_ID\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 37,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(`Submitted via`) FROM events WHERE strftime('%Y', `Date received`) = '2012' AND `Submitted via` = 'Email'",
        "target_query": "SELECT COUNT(\"Submitted_via\") FROM \"events\" WHERE sys.timestamp_to_str(\"Date_received\", '%Y') = '2012' AND \"Submitted_via\" = 'Email';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 48,
                "end_index": 78,
                "dilatect_content": "strftime('%Y', `Date received`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 54,
                "end_index": 98,
                "dilatect_content": "sys.timestamp_to_str(\"Date_received\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `events`\nColumns:\n(`Date received`, date)\n(`Product`, text)\n(`Sub-product`, text)\n(`Issue`, text)\n(`Sub-issue`, text)\n(`Consumer complaint narrative`, text)\n(`Tags`, text)\n(`Consumer consent provided?`, text)\n(`Submitted via`, text)\n(`Date sent to company`, text)\n(`Company response to consumer`, text)\n(`Timely response?`, text)\n(`Consumer disputed?`, text)\n(`Complaint ID`, text, primary key)\n(`Client_ID`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"events\"\nColumns:\n(\"Date_received\", DATE)\n(\"Product\", STRING)\n(\"Sub_product\", STRING)\n(\"Issue\", STRING)\n(\"Sub_issue\", STRING)\n(\"Consumer_complaint_narrative\", STRING)\n(\"Tags\", STRING)\n(\"Consumer_consent_provided_\", STRING)\n(\"Submitted_via\", STRING)\n(\"Date_sent_to_company\", STRING)\n(\"Company_response_to_consumer\", STRING)\n(\"Timely_response_\", STRING)\n(\"Consumer_disputed_\", STRING)\n(\"Complaint_ID\", STRING, primary key)\n(\"Client_ID\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 38,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T1.`Complaint ID`) FROM callcenterlogs AS T1 INNER JOIN events AS T2 ON T1.`Complaint ID` = T2.`Complaint ID` WHERE strftime('%Y', T1.`Date received`) = '2015' AND T2.`Timely response?` = 'Yes' AND T2.`Company response to consumer` = 'Closed with explanation'",
        "target_query": "SELECT COUNT(T1.\"Complaint_ID\") FROM \"callcenterlogs\" AS T1 INNER JOIN \"events\" AS T2 ON T1.\"Complaint_ID\" = T2.\"Complaint_ID\" WHERE sys.timestamp_to_str(T1.\"Date_received\", '%Y') = '2015' AND T2.\"Timely_response_\" = 'Yes' AND T2.\"Company_response_to_consumer\" = 'Closed with explanation';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 129,
                "end_index": 162,
                "dilatect_content": "strftime('%Y', T1.`Date received`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 143,
                "end_index": 190,
                "dilatect_content": "sys.timestamp_to_str(T1.\"Date_received\", '%Y')",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `callcenterlogs`\nColumns:\n(`Date received`, date)\n(`Complaint ID`, text, primary key)\n(`rand client`, text)\n(`phonefinal`, text)\n(`vru+line`, text)\n(`call_id`, integer)\n(`priority`, integer)\n(`type`, text)\n(`outcome`, text)\n(`server`, text)\n(`ser_start`, text)\n(`ser_exit`, text)\n(`ser_time`, text)\n",
            "Table: `events`\nColumns:\n(`Date received`, date)\n(`Product`, text)\n(`Sub-product`, text)\n(`Issue`, text)\n(`Sub-issue`, text)\n(`Consumer complaint narrative`, text)\n(`Tags`, text)\n(`Consumer consent provided?`, text)\n(`Submitted via`, text)\n(`Date sent to company`, text)\n(`Company response to consumer`, text)\n(`Timely response?`, text)\n(`Consumer disputed?`, text)\n(`Complaint ID`, text, primary key)\n(`Client_ID`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"callcenterlogs\"\nColumns:\n(\"Date_received\", DATE)\n(\"Complaint_ID\", STRING, primary key)\n(\"rand_client\", STRING)\n(\"phonefinal\", STRING)\n(\"vru_line\", STRING)\n(\"call_id\", BIGINT)\n(\"priority\", BIGINT)\n(\"type\", STRING)\n(\"outcome\", STRING)\n(\"server\", STRING)\n(\"ser_start\", STRING)\n(\"ser_exit\", STRING)\n(\"ser_time\", STRING)\n",
            "Table: \"events\"\nColumns:\n(\"Date_received\", DATE)\n(\"Product\", STRING)\n(\"Sub_product\", STRING)\n(\"Issue\", STRING)\n(\"Sub_issue\", STRING)\n(\"Consumer_complaint_narrative\", STRING)\n(\"Tags\", STRING)\n(\"Consumer_consent_provided_\", STRING)\n(\"Submitted_via\", STRING)\n(\"Date_sent_to_company\", STRING)\n(\"Company_response_to_consumer\", STRING)\n(\"Timely_response_\", STRING)\n(\"Consumer_disputed_\", STRING)\n(\"Complaint_ID\", STRING, primary key)\n(\"Client_ID\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 39,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T2.`Complaint ID`) FROM callcenterlogs AS T1 INNER JOIN events AS T2 ON T1.`Complaint ID` = T2.`Complaint ID` WHERE T2.`Submitted via` = 'Phone' AND strftime('%Y', T1.`Date received`) = '2014'",
        "target_query": "SELECT COUNT(T2.\"Complaint_ID\") FROM \"callcenterlogs\" AS T1 INNER JOIN \"events\" AS T2 ON T1.\"Complaint_ID\" = T2.\"Complaint_ID\" WHERE T2.\"Submitted_via\" = 'Phone' AND sys.timestamp_to_str(T1.\"Date_received\", '%Y') = '2014';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 162,
                "end_index": 196,
                "dilatect_content": "strftime('%Y', T1.`Date received`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 178,
                "end_index": 225,
                "dilatect_content": "sys.timestamp_to_str(T1.\"Date_received\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `callcenterlogs`\nColumns:\n(`Date received`, date)\n(`Complaint ID`, text, primary key)\n(`rand client`, text)\n(`phonefinal`, text)\n(`vru+line`, text)\n(`call_id`, integer)\n(`priority`, integer)\n(`type`, text)\n(`outcome`, text)\n(`server`, text)\n(`ser_start`, text)\n(`ser_exit`, text)\n(`ser_time`, text)\n",
            "Table: `events`\nColumns:\n(`Date received`, date)\n(`Product`, text)\n(`Sub-product`, text)\n(`Issue`, text)\n(`Sub-issue`, text)\n(`Consumer complaint narrative`, text)\n(`Tags`, text)\n(`Consumer consent provided?`, text)\n(`Submitted via`, text)\n(`Date sent to company`, text)\n(`Company response to consumer`, text)\n(`Timely response?`, text)\n(`Consumer disputed?`, text)\n(`Complaint ID`, text, primary key)\n(`Client_ID`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"callcenterlogs\"\nColumns:\n(\"Date_received\", DATE)\n(\"Complaint_ID\", STRING, primary key)\n(\"rand_client\", STRING)\n(\"phonefinal\", STRING)\n(\"vru_line\", STRING)\n(\"call_id\", BIGINT)\n(\"priority\", BIGINT)\n(\"type\", STRING)\n(\"outcome\", STRING)\n(\"server\", STRING)\n(\"ser_start\", STRING)\n(\"ser_exit\", STRING)\n(\"ser_time\", STRING)\n",
            "Table: \"events\"\nColumns:\n(\"Date_received\", DATE)\n(\"Product\", STRING)\n(\"Sub_product\", STRING)\n(\"Issue\", STRING)\n(\"Sub_issue\", STRING)\n(\"Consumer_complaint_narrative\", STRING)\n(\"Tags\", STRING)\n(\"Consumer_consent_provided_\", STRING)\n(\"Submitted_via\", STRING)\n(\"Date_sent_to_company\", STRING)\n(\"Company_response_to_consumer\", STRING)\n(\"Timely_response_\", STRING)\n(\"Consumer_disputed_\", STRING)\n(\"Complaint_ID\", STRING, primary key)\n(\"Client_ID\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 40,
        "database_name": "movies_4",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T1.movie_id) FROM movie AS T1 INNER JOIN movie_cast AS T2 ON T1.movie_id = T2.movie_id INNER JOIN person AS T3 ON T2.person_id = T3.person_id WHERE T3.person_name = 'Quentin Tarantino' AND CAST(STRFTIME('%Y', T1.release_date) AS INT) = 1995",
        "target_query": "SELECT COUNT(\"T1\".\"movie_id\") FROM \"movie\" AS \"T1\" INNER JOIN \"movie_cast\" AS \"T2\" ON \"T1\".\"movie_id\" = \"T2\".\"movie_id\" INNER JOIN \"person\" AS \"T3\" ON \"T2\".\"person_id\" = \"T3\".\"person_id\" WHERE \"T3\".\"person_name\" = 'Quentin Tarantino' AND sys.timestamp_to_str(\"T1\".\"release_date\", '%Y') = '1995';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 207,
                "end_index": 237,
                "dilatect_content": "STRFTIME('%Y', T1.release_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 274,
                "end_index": 324,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"release_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movie`\nColumns:\n(`movie_id`, integer, primary key)\n(`title`, text)\n(`budget`, integer)\n(`homepage`, text)\n(`overview`, text)\n(`popularity`, real)\n(`release_date`, date)\n(`revenue`, integer)\n(`runtime`, integer)\n(`movie_status`, text)\n(`tagline`, text)\n(`vote_average`, real)\n(`vote_count`, integer)\n",
            "Table: `movie_cast`\nColumns:\n(`movie_id`, integer)\n(`person_id`, integer)\n(`character_name`, text)\n(`gender_id`, integer)\n(`cast_order`, integer)\n(`rowid`, integer, primary key)\n",
            "Table: `person`\nColumns:\n(`person_id`, integer, primary key)\n(`person_name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"movie\"\nColumns:\n(\"movie_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"budget\", BIGINT)\n(\"homepage\", STRING)\n(\"overview\", STRING)\n(\"popularity\", DOUBLE PRECISION)\n(\"release_date\", DATE)\n(\"revenue\", BIGINT)\n(\"runtime\", BIGINT)\n(\"movie_status\", STRING)\n(\"tagline\", STRING)\n(\"vote_average\", DOUBLE PRECISION)\n(\"vote_count\", BIGINT)\n",
            "Table: \"movie_cast\"\nColumns:\n(\"movie_id\", BIGINT)\n(\"person_id\", BIGINT)\n(\"character_name\", STRING)\n(\"gender_id\", BIGINT)\n(\"cast_order\", BIGINT)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"person\"\nColumns:\n(\"person_id\", BIGINT, primary key)\n(\"person_name\", STRING)\n"
        ]
    },
    {
        "sql_id": 41,
        "database_name": "movies_4",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT AVG(T1.revenue) FROM movie AS T1 INNER JOIN production_country AS T2 ON T1.movie_id = T2.movie_id INNER JOIN country AS T3 ON T2.country_id = T3.country_id WHERE T3.COUNTry_name = 'United States of America' AND CAST(STRFTIME('%Y', T1.release_date) AS INT) = 2006",
        "target_query": "SELECT AVG(\"T1\".\"revenue\") FROM \"movie\" AS \"T1\" INNER JOIN \"production_country\" AS \"T2\" ON \"T1\".\"movie_id\" = \"T2\".\"movie_id\" INNER JOIN \"country\" AS \"T3\" ON \"T2\".\"country_id\" = \"T3\".\"country_id\" WHERE \"T3\".\"country_name\" = 'United States of America' AND EXTRACT(YEAR FROM \"T1\".\"release_date\") = 2006;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 223,
                "end_index": 253,
                "dilatect_content": "STRFTIME('%Y', T1.release_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 298,
                "end_index": 330,
                "dilatect_content": "YEAR FROM \"T1\".\"release_date\"",
                "feature": ""
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movie`\nColumns:\n(`movie_id`, integer, primary key)\n(`title`, text)\n(`budget`, integer)\n(`homepage`, text)\n(`overview`, text)\n(`popularity`, real)\n(`release_date`, date)\n(`revenue`, integer)\n(`runtime`, integer)\n(`movie_status`, text)\n(`tagline`, text)\n(`vote_average`, real)\n(`vote_count`, integer)\n",
            "Table: `production_country`\nColumns:\n(`movie_id`, integer)\n(`country_id`, integer)\n(`rowid`, integer, primary key)\n",
            "Table: `country`\nColumns:\n(`country_id`, integer, primary key)\n(`country_iso_code`, text)\n(`country_name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"movie\"\nColumns:\n(\"movie_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"budget\", BIGINT)\n(\"homepage\", STRING)\n(\"overview\", STRING)\n(\"popularity\", DOUBLE PRECISION)\n(\"release_date\", DATE)\n(\"revenue\", BIGINT)\n(\"runtime\", BIGINT)\n(\"movie_status\", STRING)\n(\"tagline\", STRING)\n(\"vote_average\", DOUBLE PRECISION)\n(\"vote_count\", BIGINT)\n",
            "Table: \"production_country\"\nColumns:\n(\"movie_id\", BIGINT)\n(\"country_id\", BIGINT)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"country\"\nColumns:\n(\"country_id\", BIGINT, primary key)\n(\"country_iso_code\", STRING)\n(\"country_name\", STRING)\n"
        ]
    },
    {
        "sql_id": 42,
        "database_name": "movies_4",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT AVG(CASE WHEN T3.COUNTry_name = 'United States of America' THEN T1.revenue END) - AVG(CASE WHEN T3.COUNTry_name = 'India' THEN T1.revenue END) AS CALCULATE FROM movie AS T1 INNER JOIN production_country AS T2 ON T1.movie_id = T2.movie_id INNER JOIN country AS T3 ON T2.country_id = T3.country_id WHERE CAST(STRFTIME('%Y', T1.release_date) AS INT) = 2016",
        "target_query": "SELECT AVG(CASE WHEN \"country\".\"country_name\" = 'United States of America' THEN \"movie\".\"revenue\" END) - AVG(CASE WHEN \"country\".\"country_name\" = 'India' THEN \"movie\".\"revenue\" END) AS \"CALCULATE\" FROM \"movie\" INNER JOIN \"production_country\" ON \"movie\".\"movie_id\" = \"production_country\".\"movie_id\" INNER JOIN \"country\" ON \"production_country\".\"country_id\" = \"country\".\"country_id\" WHERE sys.timestamp_to_str(\"movie\".\"release_date\", '%Y') = '2016';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 314,
                "end_index": 344,
                "dilatect_content": "STRFTIME('%Y', T1.release_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 427,
                "end_index": 480,
                "dilatect_content": "sys.timestamp_to_str(\"movie\".\"release_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movie`\nColumns:\n(`movie_id`, integer, primary key)\n(`title`, text)\n(`budget`, integer)\n(`homepage`, text)\n(`overview`, text)\n(`popularity`, real)\n(`release_date`, date)\n(`revenue`, integer)\n(`runtime`, integer)\n(`movie_status`, text)\n(`tagline`, text)\n(`vote_average`, real)\n(`vote_count`, integer)\n",
            "Table: `production_country`\nColumns:\n(`movie_id`, integer)\n(`country_id`, integer)\n(`rowid`, integer, primary key)\n",
            "Table: `country`\nColumns:\n(`country_id`, integer, primary key)\n(`country_iso_code`, text)\n(`country_name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"movie\"\nColumns:\n(\"movie_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"budget\", BIGINT)\n(\"homepage\", STRING)\n(\"overview\", STRING)\n(\"popularity\", DOUBLE PRECISION)\n(\"release_date\", DATE)\n(\"revenue\", BIGINT)\n(\"runtime\", BIGINT)\n(\"movie_status\", STRING)\n(\"tagline\", STRING)\n(\"vote_average\", DOUBLE PRECISION)\n(\"vote_count\", BIGINT)\n",
            "Table: \"production_country\"\nColumns:\n(\"movie_id\", BIGINT)\n(\"country_id\", BIGINT)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"country\"\nColumns:\n(\"country_id\", BIGINT, primary key)\n(\"country_iso_code\", STRING)\n(\"country_name\", STRING)\n"
        ]
    },
    {
        "sql_id": 43,
        "database_name": "movies_4",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT title FROM movie WHERE CAST(STRFTIME('%Y', release_date) AS INT) < 2000 LIMIT 5",
        "target_query": "SELECT \"title\" FROM \"movie\" WHERE sys.timestamp_to_str(\"release_date\", '%Y') < '2000' LIMIT 5;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 35,
                "end_index": 62,
                "dilatect_content": "STRFTIME('%Y', release_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 38,
                "end_index": 81,
                "dilatect_content": "sys.timestamp_to_str(\"release_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movie`\nColumns:\n(`movie_id`, integer, primary key)\n(`title`, text)\n(`budget`, integer)\n(`homepage`, text)\n(`overview`, text)\n(`popularity`, real)\n(`release_date`, date)\n(`revenue`, integer)\n(`runtime`, integer)\n(`movie_status`, text)\n(`tagline`, text)\n(`vote_average`, real)\n(`vote_count`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"movie\"\nColumns:\n(\"movie_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"budget\", BIGINT)\n(\"homepage\", STRING)\n(\"overview\", STRING)\n(\"popularity\", DOUBLE PRECISION)\n(\"release_date\", DATE)\n(\"revenue\", BIGINT)\n(\"runtime\", BIGINT)\n(\"movie_status\", STRING)\n(\"tagline\", STRING)\n(\"vote_average\", DOUBLE PRECISION)\n(\"vote_count\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 44,
        "database_name": "movies_4",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.company_id FROM movie AS T1 INNER JOIN movie_company AS T2 ON T1.movie_id = T2.movie_id WHERE CAST(STRFTIME('%Y', T1.release_date) AS INT) = 1916",
        "target_query": "SELECT \"T2\".\"company_id\" FROM \"movie\" AS \"T1\" INNER JOIN \"movie_company\" AS \"T2\" ON \"T1\".\"movie_id\" = \"T2\".\"movie_id\" WHERE sys.timestamp_to_str(\"T1\".\"release_date\", '%Y') = '1916';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 109,
                "end_index": 139,
                "dilatect_content": "STRFTIME('%Y', T1.release_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 144,
                "end_index": 194,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"release_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movie`\nColumns:\n(`movie_id`, integer, primary key)\n(`title`, text)\n(`budget`, integer)\n(`homepage`, text)\n(`overview`, text)\n(`popularity`, real)\n(`release_date`, date)\n(`revenue`, integer)\n(`runtime`, integer)\n(`movie_status`, text)\n(`tagline`, text)\n(`vote_average`, real)\n(`vote_count`, integer)\n",
            "Table: `movie_company`\nColumns:\n(`movie_id`, integer)\n(`company_id`, integer)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"movie\"\nColumns:\n(\"movie_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"budget\", BIGINT)\n(\"homepage\", STRING)\n(\"overview\", STRING)\n(\"popularity\", DOUBLE PRECISION)\n(\"release_date\", DATE)\n(\"revenue\", BIGINT)\n(\"runtime\", BIGINT)\n(\"movie_status\", STRING)\n(\"tagline\", STRING)\n(\"vote_average\", DOUBLE PRECISION)\n(\"vote_count\", BIGINT)\n",
            "Table: \"movie_company\"\nColumns:\n(\"movie_id\", BIGINT)\n(\"company_id\", BIGINT)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 45,
        "database_name": "movies_4",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT title FROM movie WHERE CAST(STRFTIME('%Y', release_date) AS INT) = 1945",
        "target_query": "SELECT \"title\" FROM \"movie\" WHERE sys.timestamp_to_str(\"release_date\", '%Y') = '1945';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 35,
                "end_index": 62,
                "dilatect_content": "STRFTIME('%Y', release_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 38,
                "end_index": 81,
                "dilatect_content": "sys.timestamp_to_str(\"release_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movie`\nColumns:\n(`movie_id`, integer, primary key)\n(`title`, text)\n(`budget`, integer)\n(`homepage`, text)\n(`overview`, text)\n(`popularity`, real)\n(`release_date`, date)\n(`revenue`, integer)\n(`runtime`, integer)\n(`movie_status`, text)\n(`tagline`, text)\n(`vote_average`, real)\n(`vote_count`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"movie\"\nColumns:\n(\"movie_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"budget\", BIGINT)\n(\"homepage\", STRING)\n(\"overview\", STRING)\n(\"popularity\", DOUBLE PRECISION)\n(\"release_date\", DATE)\n(\"revenue\", BIGINT)\n(\"runtime\", BIGINT)\n(\"movie_status\", STRING)\n(\"tagline\", STRING)\n(\"vote_average\", DOUBLE PRECISION)\n(\"vote_count\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 46,
        "database_name": "movies_4",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T1.movie_id) FROM movie AS T1 INNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id INNER JOIN genre AS T3 ON T2.genre_id = T3.genre_id WHERE T3.genre_name = 'Adventure' AND CAST(STRFTIME('%Y', T1.release_date) AS INT) = 2000",
        "target_query": "SELECT COUNT(\"T1\".\"movie_id\") FROM \"movie\" AS \"T1\" INNER JOIN \"movie_genres\" AS \"T2\" ON \"T1\".\"movie_id\" = \"T2\".\"movie_id\" INNER JOIN \"genre\" AS \"T3\" ON \"T2\".\"genre_id\" = \"T3\".\"genre_id\" WHERE \"T3\".\"genre_name\" = 'Adventure' AND sys.timestamp_to_str(\"T1\".\"release_date\", '%Y') = '2000';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 197,
                "end_index": 227,
                "dilatect_content": "STRFTIME('%Y', T1.release_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 264,
                "end_index": 314,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"release_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movie`\nColumns:\n(`movie_id`, integer, primary key)\n(`title`, text)\n(`budget`, integer)\n(`homepage`, text)\n(`overview`, text)\n(`popularity`, real)\n(`release_date`, date)\n(`revenue`, integer)\n(`runtime`, integer)\n(`movie_status`, text)\n(`tagline`, text)\n(`vote_average`, real)\n(`vote_count`, integer)\n",
            "Table: `movie_genres`\nColumns:\n(`movie_id`, integer)\n(`genre_id`, integer)\n(`rowid`, integer, primary key)\n",
            "Table: `genre`\nColumns:\n(`genre_id`, integer, primary key)\n(`genre_name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"movie\"\nColumns:\n(\"movie_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"budget\", BIGINT)\n(\"homepage\", STRING)\n(\"overview\", STRING)\n(\"popularity\", DOUBLE PRECISION)\n(\"release_date\", DATE)\n(\"revenue\", BIGINT)\n(\"runtime\", BIGINT)\n(\"movie_status\", STRING)\n(\"tagline\", STRING)\n(\"vote_average\", DOUBLE PRECISION)\n(\"vote_count\", BIGINT)\n",
            "Table: \"movie_genres\"\nColumns:\n(\"movie_id\", BIGINT)\n(\"genre_id\", BIGINT)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"genre\"\nColumns:\n(\"genre_id\", BIGINT, primary key)\n(\"genre_name\", STRING)\n"
        ]
    },
    {
        "sql_id": 47,
        "database_name": "movies_4",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T3.title FROM production_company AS T1 INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id INNER JOIN movie AS T3 ON T2.movie_id = T3.movie_id WHERE T1.company_name = 'Paramount Pictures' AND CAST(STRFTIME('%Y', T3.release_date) AS INT) = 2000",
        "target_query": "SELECT \"T3\".\"title\" FROM \"production_company\" AS \"T1\" INNER JOIN \"movie_company\" AS \"T2\" ON \"T1\".\"company_id\" = \"T2\".\"company_id\" INNER JOIN \"movie\" AS \"T3\" ON \"T2\".\"movie_id\" = \"T3\".\"movie_id\" WHERE \"T1\".\"company_name\" = 'Paramount Pictures' AND CAST(sys.timestamp_to_str(\"T3\".\"release_date\", '%Y') AS INT) = 2000;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 216,
                "end_index": 246,
                "dilatect_content": "STRFTIME('%Y', T3.release_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 288,
                "end_index": 338,
                "dilatect_content": "sys.timestamp_to_str(\"T3\".\"release_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `production_company`\nColumns:\n(`company_id`, integer, primary key)\n(`company_name`, text)\n",
            "Table: `movie_company`\nColumns:\n(`movie_id`, integer)\n(`company_id`, integer)\n(`rowid`, integer, primary key)\n",
            "Table: `movie`\nColumns:\n(`movie_id`, integer, primary key)\n(`title`, text)\n(`budget`, integer)\n(`homepage`, text)\n(`overview`, text)\n(`popularity`, real)\n(`release_date`, date)\n(`revenue`, integer)\n(`runtime`, integer)\n(`movie_status`, text)\n(`tagline`, text)\n(`vote_average`, real)\n(`vote_count`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"production_company\"\nColumns:\n(\"company_id\", BIGINT, primary key)\n(\"company_name\", STRING)\n",
            "Table: \"movie_company\"\nColumns:\n(\"movie_id\", BIGINT)\n(\"company_id\", BIGINT)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"movie\"\nColumns:\n(\"movie_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"budget\", BIGINT)\n(\"homepage\", STRING)\n(\"overview\", STRING)\n(\"popularity\", DOUBLE PRECISION)\n(\"release_date\", DATE)\n(\"revenue\", BIGINT)\n(\"runtime\", BIGINT)\n(\"movie_status\", STRING)\n(\"tagline\", STRING)\n(\"vote_average\", DOUBLE PRECISION)\n(\"vote_count\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 48,
        "database_name": "codebase_comments",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUBSTR(SUBSTR(Name, INSTR(Name, '.') + 1), 1, INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.') - 1) task FROM Method WHERE NameTokenized = 'online median filter test median window filling'",
        "target_query": "SELECT substring(\"Name\" from POSITION('.' IN \"Name\") + 1 for POSITION('.' IN substring(\"Name\" from POSITION('.' IN \"Name\") + 1)) - 1) AS \"task\" FROM \"Method\" WHERE \"NameTokenized\" = 'online median filter test median window filling';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 103,
                "dilatect_content": "SUBSTR(SUBSTR(Name, INSTR(Name, '.') + 1), 1, INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.') - 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 14,
                "end_index": 47,
                "dilatect_content": "SUBSTR(Name, INSTR(Name, '.') + 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 27,
                "end_index": 42,
                "dilatect_content": "INSTR(Name, '.')",
                "feature": "instr(X,Y)"
            },
            {
                "start_index": 53,
                "end_index": 98,
                "dilatect_content": "INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.')",
                "feature": "instr(X,Y)"
            },
            {
                "start_index": 59,
                "end_index": 92,
                "dilatect_content": "SUBSTR(Name, INSTR(Name, '.') + 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 72,
                "end_index": 87,
                "dilatect_content": "INSTR(Name, '.')",
                "feature": "instr(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 140,
                "dilatect_content": "substring(\"Name\" from POSITION('.' IN \"Name\") + 1 for POSITION('.' IN substring(\"Name\" from POSITION('.' IN \"Name\") + 1)) - 1)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 31,
                "end_index": 55,
                "dilatect_content": "POSITION('.' IN \"Name\")",
                "feature": "POSITION(Y IN X)"
            },
            {
                "start_index": 65,
                "end_index": 135,
                "dilatect_content": "POSITION('.' IN substring(\"Name\" from POSITION('.' IN \"Name\") + 1))",
                "feature": "POSITION(Y IN X)"
            },
            {
                "start_index": 81,
                "end_index": 134,
                "dilatect_content": "substring(\"Name\" from POSITION('.' IN \"Name\") + 1)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 105,
                "end_index": 129,
                "dilatect_content": "POSITION('.' IN \"Name\")",
                "feature": "POSITION(Y IN X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "instr(X,Y)",
                "explanation": "The instr(X,Y) function finds the first occurrence of string Y within \n  string X and returns the number of prior characters plus 1, or 0 if\n  Y is nowhere found within X.\n  Or, if X and Y are both BLOBs, then instr(X,Y) returns one\n  more than the number bytes prior to the first occurrence of Y, or 0 if\n  Y does not occur anywhere within X.\n  If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs\n  then both are interpreted as strings.\n  If either X or Y are NULL in instr(X,Y) then the result is NULL.\n",
                "examples": [
                    "SELECT instr('Hello World', 'World'); -- Returns 7",
                    "SELECT instr('abcdefg', 'x'); -- Returns 0 (not found)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            },
            {
                "feature": "POSITION(Y IN X)",
                "explanation": "In MonetDB, the POSITION function is used to find the first occurrence of string Y within string X and returns the number of characters from the beginning of X to the start of Y. If Y is not found within X, it returns 0.",
                "examples": [
                    "SELECT POSITION('World' IN 'Hello World'); -- Returns 7",
                    "SELECT POSITION('x' IN 'abcdefg'); -- Returns 0 (not found)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Method`\nColumns:\n(`Id`, integer, primary key)\n(`Name`, text)\n(`FullComment`, text)\n(`Summary`, text)\n(`ApiCalls`, text)\n(`CommentIsXml`, integer)\n(`SampledAt`, integer)\n(`SolutionId`, integer)\n(`Lang`, text)\n(`NameTokenized`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Method\"\nColumns:\n(\"Id\", BIGINT, primary key)\n(\"Name\", STRING)\n(\"FullComment\", STRING)\n(\"Summary\", STRING)\n(\"ApiCalls\", STRING)\n(\"CommentIsXml\", BIGINT)\n(\"SampledAt\", BIGINT)\n(\"SolutionId\", BIGINT)\n(\"Lang\", STRING)\n(\"NameTokenized\", STRING)\n"
        ]
    },
    {
        "sql_id": 49,
        "database_name": "codebase_comments",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUBSTR(SUBSTR(Name, INSTR(Name, '.') + 1), 1, INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.') - 1) task FROM Method WHERE NameTokenized = 'html parser feed'",
        "target_query": "SELECT substring(\"Name\" from POSITION('.' IN \"Name\") + 1 for POSITION('.' IN substring(\"Name\" from POSITION('.' IN \"Name\") + 1)) - 1) AS \"task\" FROM \"Method\" WHERE \"NameTokenized\" = 'html parser feed';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 103,
                "dilatect_content": "SUBSTR(SUBSTR(Name, INSTR(Name, '.') + 1), 1, INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.') - 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 14,
                "end_index": 47,
                "dilatect_content": "SUBSTR(Name, INSTR(Name, '.') + 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 27,
                "end_index": 42,
                "dilatect_content": "INSTR(Name, '.')",
                "feature": "instr(X,Y)"
            },
            {
                "start_index": 53,
                "end_index": 98,
                "dilatect_content": "INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.')",
                "feature": "instr(X,Y)"
            },
            {
                "start_index": 59,
                "end_index": 92,
                "dilatect_content": "SUBSTR(Name, INSTR(Name, '.') + 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 72,
                "end_index": 87,
                "dilatect_content": "INSTR(Name, '.')",
                "feature": "instr(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 140,
                "dilatect_content": "substring(\"Name\" from POSITION('.' IN \"Name\") + 1 for POSITION('.' IN substring(\"Name\" from POSITION('.' IN \"Name\") + 1)) - 1)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 31,
                "end_index": 55,
                "dilatect_content": "POSITION('.' IN \"Name\")",
                "feature": "POSITION(Y IN X)"
            },
            {
                "start_index": 65,
                "end_index": 135,
                "dilatect_content": "POSITION('.' IN substring(\"Name\" from POSITION('.' IN \"Name\") + 1))",
                "feature": "POSITION(Y IN X)"
            },
            {
                "start_index": 81,
                "end_index": 134,
                "dilatect_content": "substring(\"Name\" from POSITION('.' IN \"Name\") + 1)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 105,
                "end_index": 129,
                "dilatect_content": "POSITION('.' IN \"Name\")",
                "feature": "POSITION(Y IN X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "instr(X,Y)",
                "explanation": "The instr(X,Y) function finds the first occurrence of string Y within \n  string X and returns the number of prior characters plus 1, or 0 if\n  Y is nowhere found within X.\n  Or, if X and Y are both BLOBs, then instr(X,Y) returns one\n  more than the number bytes prior to the first occurrence of Y, or 0 if\n  Y does not occur anywhere within X.\n  If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs\n  then both are interpreted as strings.\n  If either X or Y are NULL in instr(X,Y) then the result is NULL.\n",
                "examples": [
                    "SELECT instr('Hello World', 'World'); -- Returns 7",
                    "SELECT instr('abcdefg', 'x'); -- Returns 0 (not found)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            },
            {
                "feature": "POSITION(Y IN X)",
                "explanation": "In MonetDB, the POSITION function is used to find the first occurrence of string Y within string X and returns the number of characters from the beginning of X to the start of Y. If Y is not found within X, it returns 0.",
                "examples": [
                    "SELECT POSITION('World' IN 'Hello World'); -- Returns 7",
                    "SELECT POSITION('x' IN 'abcdefg'); -- Returns 0 (not found)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Method`\nColumns:\n(`Id`, integer, primary key)\n(`Name`, text)\n(`FullComment`, text)\n(`Summary`, text)\n(`ApiCalls`, text)\n(`CommentIsXml`, integer)\n(`SampledAt`, integer)\n(`SolutionId`, integer)\n(`Lang`, text)\n(`NameTokenized`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Method\"\nColumns:\n(\"Id\", BIGINT, primary key)\n(\"Name\", STRING)\n(\"FullComment\", STRING)\n(\"Summary\", STRING)\n(\"ApiCalls\", STRING)\n(\"CommentIsXml\", BIGINT)\n(\"SampledAt\", BIGINT)\n(\"SolutionId\", BIGINT)\n(\"Lang\", STRING)\n(\"NameTokenized\", STRING)\n"
        ]
    },
    {
        "sql_id": 50,
        "database_name": "codebase_comments",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUBSTR(SUBSTR(Name, INSTR(Name, '.') + 1), 1, INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.') - 1) task FROM Method WHERE Id = 2",
        "target_query": "SELECT substring(\"Name\" from POSITION('.' IN \"Name\") + 1 for POSITION('.' IN substring(\"Name\" from POSITION('.' IN \"Name\") + 1)) - 1) AS task FROM \"Method\" WHERE \"Id\" = 2;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 103,
                "dilatect_content": "SUBSTR(SUBSTR(Name, INSTR(Name, '.') + 1), 1, INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.') - 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 14,
                "end_index": 47,
                "dilatect_content": "SUBSTR(Name, INSTR(Name, '.') + 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 27,
                "end_index": 42,
                "dilatect_content": "INSTR(Name, '.')",
                "feature": "instr(X,Y)"
            },
            {
                "start_index": 53,
                "end_index": 98,
                "dilatect_content": "INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.')",
                "feature": "instr(X,Y)"
            },
            {
                "start_index": 59,
                "end_index": 92,
                "dilatect_content": "SUBSTR(Name, INSTR(Name, '.') + 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 72,
                "end_index": 87,
                "dilatect_content": "INSTR(Name, '.')",
                "feature": "instr(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 140,
                "dilatect_content": "substring(\"Name\" from POSITION('.' IN \"Name\") + 1 for POSITION('.' IN substring(\"Name\" from POSITION('.' IN \"Name\") + 1)) - 1)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 31,
                "end_index": 55,
                "dilatect_content": "POSITION('.' IN \"Name\")",
                "feature": "POSITION(Y IN X)"
            },
            {
                "start_index": 65,
                "end_index": 135,
                "dilatect_content": "POSITION('.' IN substring(\"Name\" from POSITION('.' IN \"Name\") + 1))",
                "feature": "POSITION(Y IN X)"
            },
            {
                "start_index": 81,
                "end_index": 134,
                "dilatect_content": "substring(\"Name\" from POSITION('.' IN \"Name\") + 1)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 105,
                "end_index": 129,
                "dilatect_content": "POSITION('.' IN \"Name\")",
                "feature": "POSITION(Y IN X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "instr(X,Y)",
                "explanation": "The instr(X,Y) function finds the first occurrence of string Y within \n  string X and returns the number of prior characters plus 1, or 0 if\n  Y is nowhere found within X.\n  Or, if X and Y are both BLOBs, then instr(X,Y) returns one\n  more than the number bytes prior to the first occurrence of Y, or 0 if\n  Y does not occur anywhere within X.\n  If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs\n  then both are interpreted as strings.\n  If either X or Y are NULL in instr(X,Y) then the result is NULL.\n",
                "examples": [
                    "SELECT instr('Hello World', 'World'); -- Returns 7",
                    "SELECT instr('abcdefg', 'x'); -- Returns 0 (not found)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            },
            {
                "feature": "POSITION(Y IN X)",
                "explanation": "In MonetDB, the POSITION function is used to find the first occurrence of string Y within string X and returns the number of characters from the beginning of X to the start of Y. If Y is not found within X, it returns 0.",
                "examples": [
                    "SELECT POSITION('World' IN 'Hello World'); -- Returns 7",
                    "SELECT POSITION('x' IN 'abcdefg'); -- Returns 0 (not found)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Method`\nColumns:\n(`Id`, integer, primary key)\n(`Name`, text)\n(`FullComment`, text)\n(`Summary`, text)\n(`ApiCalls`, text)\n(`CommentIsXml`, integer)\n(`SampledAt`, integer)\n(`SolutionId`, integer)\n(`Lang`, text)\n(`NameTokenized`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Method\"\nColumns:\n(\"Id\", BIGINT, primary key)\n(\"Name\", STRING)\n(\"FullComment\", STRING)\n(\"Summary\", STRING)\n(\"ApiCalls\", STRING)\n(\"CommentIsXml\", BIGINT)\n(\"SampledAt\", BIGINT)\n(\"SolutionId\", BIGINT)\n(\"Lang\", STRING)\n(\"NameTokenized\", STRING)\n"
        ]
    },
    {
        "sql_id": 51,
        "database_name": "codebase_comments",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT SUBSTR(SUBSTR(Name, INSTR(Name, '.') + 1), 1, INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.') - 1) task FROM Method WHERE Lang = 'cs'",
        "target_query": "SELECT DISTINCT substring(substring(\"Name\" from POSITION('.' IN \"Name\") + 1) from 1 for POSITION('.' IN substring(\"Name\" from POSITION('.' IN \"Name\") + 1)) - 1) AS \"task\" FROM \"Method\" WHERE \"Lang\" = 'cs';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": -1,
                "dilatect_content": "",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 23,
                "end_index": -1,
                "dilatect_content": "",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 36,
                "end_index": -1,
                "dilatect_content": "",
                "feature": "instr(X,Y)"
            },
            {
                "start_index": 62,
                "end_index": -1,
                "dilatect_content": "",
                "feature": "instr(X,Y)"
            },
            {
                "start_index": 68,
                "end_index": -1,
                "dilatect_content": "",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 81,
                "end_index": -1,
                "dilatect_content": "",
                "feature": "instr(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 167,
                "dilatect_content": "substring(substring(\"Name\" from POSITION('.' IN \"Name\") + 1) from 1 for POSITION('.' IN substring(\"Name\" from POSITION('.' IN \"Name\") + 1)) - 1)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 26,
                "end_index": 79,
                "dilatect_content": "substring(\"Name\" from POSITION('.' IN \"Name\") + 1)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 50,
                "end_index": 74,
                "dilatect_content": "POSITION('.' IN \"Name\")",
                "feature": "POSITION(Y IN X)"
            },
            {
                "start_index": 92,
                "end_index": 160,
                "dilatect_content": "POSITION('.' IN substring(\"Name\" from POSITION('.' IN \"Name\") + 1))",
                "feature": "POSITION(Y IN X)"
            },
            {
                "start_index": 108,
                "end_index": 161,
                "dilatect_content": "substring(\"Name\" from POSITION('.' IN \"Name\") + 1)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 132,
                "end_index": 156,
                "dilatect_content": "POSITION('.' IN \"Name\")",
                "feature": "POSITION(Y IN X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "instr(X,Y)",
                "explanation": "The instr(X,Y) function finds the first occurrence of string Y within \n  string X and returns the number of prior characters plus 1, or 0 if\n  Y is nowhere found within X.\n  Or, if X and Y are both BLOBs, then instr(X,Y) returns one\n  more than the number bytes prior to the first occurrence of Y, or 0 if\n  Y does not occur anywhere within X.\n  If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs\n  then both are interpreted as strings.\n  If either X or Y are NULL in instr(X,Y) then the result is NULL.\n",
                "examples": [
                    "SELECT instr('Hello World', 'World'); -- Returns 7",
                    "SELECT instr('abcdefg', 'x'); -- Returns 0 (not found)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            },
            {
                "feature": "POSITION(Y IN X)",
                "explanation": "In MonetDB, the POSITION function is used to find the first occurrence of string Y within string X and returns the number of characters from the beginning of X to the start of Y. If Y is not found within X, it returns 0.",
                "examples": [
                    "SELECT POSITION('World' IN 'Hello World'); -- Returns 7",
                    "SELECT POSITION('x' IN 'abcdefg'); -- Returns 0 (not found)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Method`\nColumns:\n(`Id`, integer, primary key)\n(`Name`, text)\n(`FullComment`, text)\n(`Summary`, text)\n(`ApiCalls`, text)\n(`CommentIsXml`, integer)\n(`SampledAt`, integer)\n(`SolutionId`, integer)\n(`Lang`, text)\n(`NameTokenized`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Method\"\nColumns:\n(\"Id\", BIGINT, primary key)\n(\"Name\", STRING)\n(\"FullComment\", STRING)\n(\"Summary\", STRING)\n(\"ApiCalls\", STRING)\n(\"CommentIsXml\", BIGINT)\n(\"SampledAt\", BIGINT)\n(\"SolutionId\", BIGINT)\n(\"Lang\", STRING)\n(\"NameTokenized\", STRING)\n"
        ]
    },
    {
        "sql_id": 52,
        "database_name": "codebase_comments",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT SUBSTR(SUBSTR(Name, INSTR(Name, '.') + 1), 1, INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.') - 1) task FROM Method WHERE NameTokenized = 'string extensions to pascal case'",
        "target_query": "SELECT DISTINCT substring(substring(\"Name\" from POSITION('.' IN \"Name\") + 1 for char_length(\"Name\") - POSITION('.' IN \"Name\")) from 1 for POSITION('.' IN substring(\"Name\" from POSITION('.' IN \"Name\") + 1)) - 1) AS task FROM \"Method\" WHERE \"NameTokenized\" = 'string extensions to pascal case';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 112,
                "dilatect_content": "SUBSTR(SUBSTR(Name, INSTR(Name, '.') + 1), 1, INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.') - 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 23,
                "end_index": 56,
                "dilatect_content": "SUBSTR(Name, INSTR(Name, '.') + 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 36,
                "end_index": 51,
                "dilatect_content": "INSTR(Name, '.')",
                "feature": "instr(X,Y)"
            },
            {
                "start_index": 62,
                "end_index": 107,
                "dilatect_content": "INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.')",
                "feature": "instr(X,Y)"
            },
            {
                "start_index": 68,
                "end_index": 101,
                "dilatect_content": "SUBSTR(Name, INSTR(Name, '.') + 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 81,
                "end_index": 96,
                "dilatect_content": "INSTR(Name, '.')",
                "feature": "instr(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 221,
                "dilatect_content": "substring(substring(\"Name\" from POSITION('.' IN \"Name\") + 1 for char_length(\"Name\") - POSITION('.' IN \"Name\")) from 1 for POSITION('.' IN substring(\"Name\" from POSITION('.' IN \"Name\") + 1)) - 1)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 26,
                "end_index": 133,
                "dilatect_content": "substring(\"Name\" from POSITION('.' IN \"Name\") + 1 for char_length(\"Name\") - POSITION('.' IN \"Name\"))",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 50,
                "end_index": 74,
                "dilatect_content": "POSITION('.' IN \"Name\")",
                "feature": "POSITION(Y IN X)"
            },
            {
                "start_index": 108,
                "end_index": 132,
                "dilatect_content": "POSITION('.' IN \"Name\")",
                "feature": "POSITION(Y IN X)"
            },
            {
                "start_index": 146,
                "end_index": 216,
                "dilatect_content": "POSITION('.' IN substring(\"Name\" from POSITION('.' IN \"Name\") + 1))",
                "feature": "POSITION(Y IN X)"
            },
            {
                "start_index": 162,
                "end_index": 215,
                "dilatect_content": "substring(\"Name\" from POSITION('.' IN \"Name\") + 1)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 186,
                "end_index": 210,
                "dilatect_content": "POSITION('.' IN \"Name\")",
                "feature": "POSITION(Y IN X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "instr(X,Y)",
                "explanation": "The instr(X,Y) function finds the first occurrence of string Y within \n  string X and returns the number of prior characters plus 1, or 0 if\n  Y is nowhere found within X.\n  Or, if X and Y are both BLOBs, then instr(X,Y) returns one\n  more than the number bytes prior to the first occurrence of Y, or 0 if\n  Y does not occur anywhere within X.\n  If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs\n  then both are interpreted as strings.\n  If either X or Y are NULL in instr(X,Y) then the result is NULL.\n",
                "examples": [
                    "SELECT instr('Hello World', 'World'); -- Returns 7",
                    "SELECT instr('abcdefg', 'x'); -- Returns 0 (not found)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            },
            {
                "feature": "POSITION(Y IN X)",
                "explanation": "In MonetDB, the POSITION function is used to find the first occurrence of string Y within string X and returns the number of characters from the beginning of X to the start of Y. If Y is not found within X, it returns 0.",
                "examples": [
                    "SELECT POSITION('World' IN 'Hello World'); -- Returns 7",
                    "SELECT POSITION('x' IN 'abcdefg'); -- Returns 0 (not found)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Method`\nColumns:\n(`Id`, integer, primary key)\n(`Name`, text)\n(`FullComment`, text)\n(`Summary`, text)\n(`ApiCalls`, text)\n(`CommentIsXml`, integer)\n(`SampledAt`, integer)\n(`SolutionId`, integer)\n(`Lang`, text)\n(`NameTokenized`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Method\"\nColumns:\n(\"Id\", BIGINT, primary key)\n(\"Name\", STRING)\n(\"FullComment\", STRING)\n(\"Summary\", STRING)\n(\"ApiCalls\", STRING)\n(\"CommentIsXml\", BIGINT)\n(\"SampledAt\", BIGINT)\n(\"SolutionId\", BIGINT)\n(\"Lang\", STRING)\n(\"NameTokenized\", STRING)\n"
        ]
    },
    {
        "sql_id": 53,
        "database_name": "movie",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT (MAX(CAST(SUBSTR(T2.screentime, 3, 2) AS REAL)) - MIN(CAST(SUBSTR(T2.screentime, 3, 2) AS REAL))) * 100 / MIN(CAST(SUBSTR(T2.screentime, 3, 2) AS REAL)) FROM movie AS T1 INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID WHERE T1.Title = 'Batman'",
        "target_query": "SELECT (MAX(CAST(substring(\"T2\".\"screentime\" from 3 for 2) AS REAL)) - MIN(CAST(substring(\"T2\".\"screentime\" from 3 for 2) AS REAL))) * 100 / MIN(CAST(substring(\"T2\".\"screentime\" from 3 for 2) AS REAL)) FROM \"movie\" AS \"T1\" INNER JOIN \"characters\" AS \"T2\" ON \"T1\".\"MovieID\" = \"T2\".\"MovieID\" WHERE \"T1\".\"Title\" = 'Batman';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 17,
                "end_index": 43,
                "dilatect_content": "SUBSTR(T2.screentime, 3, 2)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 66,
                "end_index": 92,
                "dilatect_content": "SUBSTR(T2.screentime, 3, 2)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 122,
                "end_index": 148,
                "dilatect_content": "SUBSTR(T2.screentime, 3, 2)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 17,
                "end_index": 61,
                "dilatect_content": "substring(\"T2\".\"screentime\" from 3 for 2)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 84,
                "end_index": 128,
                "dilatect_content": "substring(\"T2\".\"screentime\" from 3 for 2)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 158,
                "end_index": 202,
                "dilatect_content": "substring(\"T2\".\"screentime\" from 3 for 2)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movie`\nColumns:\n(`MovieID`, integer, primary key)\n(`Title`, text)\n(`MPAA Rating`, text)\n(`Budget`, integer)\n(`Gross`, integer)\n(`Release Date`, text)\n(`Genre`, text)\n(`Runtime`, integer)\n(`Rating`, real)\n(`Rating Count`, integer)\n(`Summary`, text)\n",
            "Table: `characters`\nColumns:\n(`MovieID`, integer, primary key)\n(`ActorID`, integer, primary key)\n(`Character Name`, text)\n(`creditOrder`, integer)\n(`pay`, text)\n(`screentime`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"movie\"\nColumns:\n(\"MovieID\", BIGINT, primary key)\n(\"Title\", STRING)\n(\"MPAA_Rating\", STRING)\n(\"Budget\", BIGINT)\n(\"Gross\", BIGINT)\n(\"Release_Date\", STRING)\n(\"Genre\", STRING)\n(\"Runtime\", BIGINT)\n(\"Rating\", DOUBLE PRECISION)\n(\"Rating_Count\", BIGINT)\n(\"Summary\", STRING)\n",
            "Table: \"characters\"\nColumns:\n(\"MovieID\", BIGINT, primary key)\n(\"ActorID\", BIGINT, primary key)\n(\"Character_Name\", STRING)\n(\"creditOrder\", BIGINT)\n(\"pay\", STRING)\n(\"screentime\", STRING)\n"
        ]
    },
    {
        "sql_id": 54,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T3.age FROM app_events AS T1 INNER JOIN events_relevant AS T2 ON T1.event_id = T2.event_id INNER JOIN gender_age AS T3 ON T2.device_id = T3.device_id WHERE T1.is_active = 1 AND T2.longitude = 121 AND T2.latitude = 31 AND SUBSTR(T2.timestamp, 1, 10) = '2016-05-06' ORDER BY T3.age DESC LIMIT 1",
        "target_query": "SELECT \"T3\".\"age\" FROM \"app_events\" AS \"T1\" INNER JOIN \"events_relevant\" AS \"T2\" ON \"T1\".\"event_id\" = \"T2\".\"event_id\" INNER JOIN \"gender_age\" AS \"T3\" ON \"T2\".\"device_id\" = \"T3\".\"device_id\" WHERE \"T1\".\"is_active\" = 1 AND \"T2\".\"longitude\" = 121 AND \"T2\".\"latitude\" = 31 AND substring(\"T2\"._timestamp from 1 for 10) = '2016-05-06' ORDER BY \"T3\".\"age\" DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 228,
                "end_index": 254,
                "dilatect_content": "SUBSTR(T2.timestamp, 1, 10)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 316,
                "end_index": 357,
                "dilatect_content": "substring(\"T2\"._timestamp from 1 for 10)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `app_events`\nColumns:\n(`event_id`, integer, primary key)\n(`app_id`, integer, primary key)\n(`is_installed`, integer)\n(`is_active`, integer)\n",
            "Table: `events_relevant`\nColumns:\n(`event_id`, integer, primary key)\n(`device_id`, integer)\n(`timestamp`, datetime)\n(`longitude`, real)\n(`latitude`, real)\n",
            "Table: `gender_age`\nColumns:\n(`device_id`, integer, primary key)\n(`gender`, text)\n(`age`, integer)\n(`group`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"app_events\"\nColumns:\n(\"event_id\", BIGINT, primary key)\n(\"app_id\", BIGINT, primary key)\n(\"is_installed\", BIGINT)\n(\"is_active\", BIGINT)\n",
            "Table: \"events_relevant\"\nColumns:\n(\"event_id\", BIGINT, primary key)\n(\"device_id\", BIGINT)\n(\"_timestamp\", TIMESTAMP)\n(\"longitude\", DOUBLE PRECISION)\n(\"latitude\", DOUBLE PRECISION)\n",
            "Table: \"gender_age\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"gender\", STRING)\n(\"age\", BIGINT)\n(\"group\", STRING)\n"
        ]
    },
    {
        "sql_id": 55,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(T2.gender = 'F', 1, 0)) * 100 / COUNT(T2.device_id) AS perFemale , SUM(IIF(T2.gender = 'M', 1, 0)) * 100 / COUNT(T2.device_id) AS perMale FROM phone_brand_device_model2 AS T1 INNER JOIN gender_age AS T2 ON T2.device_id = T1.device_id WHERE T1.phone_brand = 'OPPO'",
        "target_query": "SELECT SUM(CASE WHEN \"T2\".\"gender\" = 'F' THEN 1 ELSE 0 END) * 100 / COUNT(\"T2\".\"device_id\") AS \"perFemale\", SUM(CASE WHEN \"T2\".\"gender\" = 'M' THEN 1 ELSE 0 END) * 100 / COUNT(\"T2\".\"device_id\") AS \"perMale\" FROM \"phone_brand_device_model2\" AS \"T1\" INNER JOIN \"gender_age\" AS \"T2\" ON \"T2\".\"device_id\" = \"T1\".\"device_id\" WHERE \"T1\".\"phone_brand\" = 'OPPO';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 36,
                "dilatect_content": "IIF(T2.gender = 'F', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 86,
                "end_index": 111,
                "dilatect_content": "IIF(T2.gender = 'M', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 61,
                "dilatect_content": "CASE WHEN \"T2\".\"gender\" = 'F' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 122,
                "end_index": 172,
                "dilatect_content": "CASE WHEN \"T2\".\"gender\" = 'M' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, integer, primary key)\n(`phone_brand`, text, primary key)\n(`device_model`, text, primary key)\n",
            "Table: `gender_age`\nColumns:\n(`device_id`, integer, primary key)\n(`gender`, text)\n(`age`, integer)\n(`group`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"phone_brand_device_model2\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"phone_brand\", STRING, primary key)\n(\"device_model\", STRING, primary key)\n",
            "Table: \"gender_age\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"gender\", STRING)\n(\"age\", BIGINT)\n(\"group\", STRING)\n"
        ]
    },
    {
        "sql_id": 56,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT longitude, latitude FROM `events` WHERE SUBSTR(`timestamp`, 1, 10) = '2016-05-08'",
        "target_query": "SELECT \"longitude\", \"latitude\" FROM \"events\" WHERE substring(\"_timestamp\" from 1 for 10) = '2016-05-08';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 47,
                "end_index": 72,
                "dilatect_content": "SUBSTR(`timestamp`, 1, 10)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 57,
                "end_index": 95,
                "dilatect_content": "substring(\"_timestamp\" from 1 for 10)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `events`\nColumns:\n(`event_id`, integer, primary key)\n(`device_id`, integer)\n(`timestamp`, datetime)\n(`longitude`, real)\n(`latitude`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"events\"\nColumns:\n(\"event_id\", BIGINT, primary key)\n(\"device_id\", BIGINT)\n(\"_timestamp\", TIMESTAMP)\n(\"longitude\", DOUBLE PRECISION)\n(\"latitude\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 57,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT app_id , IIF(is_installed = 1, 'YES', 'NO') AS status FROM app_events WHERE event_id = 844",
        "target_query": "SELECT \"app_id\", CASE WHEN \"is_installed\" = 1 THEN 'YES' ELSE 'NO' END AS \"status\" FROM \"app_events\" WHERE \"event_id\" = 844;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 49,
                "dilatect_content": "IIF(is_installed = 1, 'YES', 'NO')",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 19,
                "end_index": 73,
                "dilatect_content": "CASE WHEN \"is_installed\" = 1 THEN 'YES' ELSE 'NO' END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `app_events`\nColumns:\n(`event_id`, integer, primary key)\n(`app_id`, integer, primary key)\n(`is_installed`, integer)\n(`is_active`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"app_events\"\nColumns:\n(\"event_id\", BIGINT, primary key)\n(\"app_id\", BIGINT, primary key)\n(\"is_installed\", BIGINT)\n(\"is_active\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 58,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(event_id) FROM events WHERE SUBSTR(`timestamp`, 1, 10) = '2016-04-30'",
        "target_query": "SELECT COUNT(\"event_id\") FROM \"events\" WHERE substring(\"_timestamp\" from 1 for 10) = '2016-04-30';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 41,
                "end_index": 66,
                "dilatect_content": "SUBSTR(`timestamp`, 1, 10)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 49,
                "end_index": 87,
                "dilatect_content": "substring(\"_timestamp\" from 1 for 10)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `events`\nColumns:\n(`event_id`, integer, primary key)\n(`device_id`, integer)\n(`timestamp`, datetime)\n(`longitude`, real)\n(`latitude`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"events\"\nColumns:\n(\"event_id\", BIGINT, primary key)\n(\"device_id\", BIGINT)\n(\"_timestamp\", TIMESTAMP)\n(\"longitude\", DOUBLE PRECISION)\n(\"latitude\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 59,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(gender = 'M' AND `group` = 'M27-28', 1, 0)) / SUM(IIF(gender = 'F' AND `group` = 'F27-28', 1, 0)) AS r FROM gender_age",
        "target_query": "SELECT SUM(CASE WHEN \"gender\" = 'M' AND \"group\" = 'M27-28' THEN 1 ELSE 0 END) / SUM(CASE WHEN \"gender\" = 'F' AND \"group\" = 'F27-28' THEN 1 ELSE 0 END) AS r FROM \"gender_age\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 56,
                "dilatect_content": "IIF(gender = 'M' AND `group` = 'M27-28', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 65,
                "end_index": 110,
                "dilatect_content": "IIF(gender = 'F' AND `group` = 'F27-28', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 79,
                "dilatect_content": "CASE WHEN \"gender\" = 'M' AND \"group\" = 'M27-28' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 88,
                "end_index": 156,
                "dilatect_content": "CASE WHEN \"gender\" = 'F' AND \"group\" = 'F27-28' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `gender_age`\nColumns:\n(`device_id`, integer, primary key)\n(`gender`, text)\n(`age`, integer)\n(`group`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"gender_age\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"gender\", STRING)\n(\"age\", BIGINT)\n(\"group\", STRING)\n"
        ]
    },
    {
        "sql_id": 60,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T2.event_id) FROM gender_age AS T1 INNER JOIN events AS T2 ON T2.device_id = T1.device_id WHERE T1.gender = 'M' AND SUBSTR(`timestamp`, 1, 10) = '2016-05-04' AND T1.age = 88",
        "target_query": "SELECT COUNT(\"T2\".\"event_id\") FROM \"gender_age\" AS \"T1\" INNER JOIN \"events\" AS \"T2\" ON \"T2\".\"device_id\" = \"T1\".\"device_id\" WHERE \"T1\".\"gender\" = 'M' AND substring(\"T2\".\"_timestamp\" from 1 for 10) = '2016-05-04' AND \"T1\".\"age\" = 88;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 129,
                "end_index": 154,
                "dilatect_content": "SUBSTR(`timestamp`, 1, 10)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 177,
                "end_index": 222,
                "dilatect_content": "substring(\"T2\".\"_timestamp\" from 1 for 10)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `gender_age`\nColumns:\n(`device_id`, integer, primary key)\n(`gender`, text)\n(`age`, integer)\n(`group`, text)\n",
            "Table: `events`\nColumns:\n(`event_id`, integer, primary key)\n(`device_id`, integer)\n(`timestamp`, datetime)\n(`longitude`, real)\n(`latitude`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"gender_age\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"gender\", STRING)\n(\"age\", BIGINT)\n(\"group\", STRING)\n",
            "Table: \"events\"\nColumns:\n(\"event_id\", BIGINT, primary key)\n(\"device_id\", BIGINT)\n(\"_timestamp\", TIMESTAMP)\n(\"longitude\", DOUBLE PRECISION)\n(\"latitude\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 61,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(T1.category = 'Industry tag', 1, 0)) * 100 / COUNT(T2.app_id) AS per FROM label_categories AS T1 INNER JOIN app_labels AS T2 ON T2.label_id = T1.label_id",
        "target_query": "SELECT SUM(CASE WHEN \"T1\".\"category\" = 'Industry tag' THEN 1 ELSE 0 END) * 100 / COUNT(\"T2\".\"app_id\") AS \"per\" FROM \"label_categories\" AS \"T1\" INNER JOIN \"app_labels\" AS \"T2\" ON \"T2\".\"label_id\" = \"T1\".\"label_id\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 49,
                "dilatect_content": "IIF(T1.category = 'Industry tag', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 74,
                "dilatect_content": "CASE WHEN \"T1\".\"category\" = 'Industry tag' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `label_categories`\nColumns:\n(`label_id`, integer, primary key)\n(`category`, text)\n",
            "Table: `app_labels`\nColumns:\n(`app_id`, integer)\n(`label_id`, integer)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"label_categories\"\nColumns:\n(\"label_id\", BIGINT, primary key)\n(\"category\", STRING)\n",
            "Table: \"app_labels\"\nColumns:\n(\"app_id\", BIGINT)\n(\"label_id\", BIGINT)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 62,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(T1.device_model = 'Nexus 5', 1, 0)) * 100 / COUNT(T1.device_id) AS per , SUM(IIF(T1.device_model = 'Nexus 5' AND T2.gender = 'M', 1, 0)) / SUM(IIF(T1.device_model = 'Nexus 5' AND T2.gender = 'F', 1, 0)) AS r FROM phone_brand_device_model2 AS T1 INNER JOIN gender_age AS T2 ON T2.device_id = T1.device_id WHERE T1.phone_brand = 'LG'",
        "target_query": "SELECT SUM(CASE WHEN \"T1\".\"device_model\" = 'Nexus 5' THEN 1 ELSE 0 END) * 100 / COUNT(\"T1\".\"device_id\") AS \"per\", SUM(CASE WHEN \"T1\".\"device_model\" = 'Nexus 5' AND \"T2\".\"gender\" = 'M' THEN 1 ELSE 0 END) / SUM(CASE WHEN \"T1\".\"device_model\" = 'Nexus 5' AND \"T2\".\"gender\" = 'F' THEN 1 ELSE 0 END) AS \"r\" FROM \"phone_brand_device_model2\" AS \"T1\" INNER JOIN \"gender_age\" AS \"T2\" ON \"T2\".\"device_id\" = \"T1\".\"device_id\" WHERE \"T1\".\"phone_brand\" = 'LG';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 48,
                "dilatect_content": "IIF(T1.device_model = 'Nexus 5', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 92,
                "end_index": 149,
                "dilatect_content": "IIF(T1.device_model = 'Nexus 5' AND T2.gender = 'M', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 158,
                "end_index": 215,
                "dilatect_content": "IIF(T1.device_model = 'Nexus 5' AND T2.gender = 'F', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 73,
                "dilatect_content": "CASE WHEN \"T1\".\"device_model\" = 'Nexus 5' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 128,
                "end_index": 218,
                "dilatect_content": "CASE WHEN \"T1\".\"device_model\" = 'Nexus 5' AND \"T2\".\"gender\" = 'M' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 227,
                "end_index": 317,
                "dilatect_content": "CASE WHEN \"T1\".\"device_model\" = 'Nexus 5' AND \"T2\".\"gender\" = 'F' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, integer, primary key)\n(`phone_brand`, text, primary key)\n(`device_model`, text, primary key)\n",
            "Table: `gender_age`\nColumns:\n(`device_id`, integer, primary key)\n(`gender`, text)\n(`age`, integer)\n(`group`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"phone_brand_device_model2\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"phone_brand\", STRING, primary key)\n(\"device_model\", STRING, primary key)\n",
            "Table: \"gender_age\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"gender\", STRING)\n(\"age\", BIGINT)\n(\"group\", STRING)\n"
        ]
    },
    {
        "sql_id": 63,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(event_id) FROM `events` WHERE SUBSTR(`timestamp`, 1, 4) = '2016'",
        "target_query": "SELECT COUNT(\"event_id\") FROM \"events\" WHERE substring(\"_timestamp\" from 1 for 4) = '2016';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 43,
                "end_index": 67,
                "dilatect_content": "SUBSTR(`timestamp`, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 49,
                "end_index": 86,
                "dilatect_content": "substring(\"_timestamp\" from 1 for 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `events`\nColumns:\n(`event_id`, integer, primary key)\n(`device_id`, integer)\n(`timestamp`, datetime)\n(`longitude`, real)\n(`latitude`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"events\"\nColumns:\n(\"event_id\", BIGINT, primary key)\n(\"device_id\", BIGINT)\n(\"_timestamp\", TIMESTAMP)\n(\"longitude\", DOUBLE PRECISION)\n(\"latitude\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 64,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(event_id) FROM `events` WHERE SUBSTR(`timestamp`, 1, 4) = '2016' AND device_id = 29182687948017100",
        "target_query": "SELECT COUNT(\"event_id\") FROM \"events\" WHERE substring(\"_timestamp\" from 1 for 4) = '2016' AND \"device_id\" = 29182687948017100;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 43,
                "end_index": 67,
                "dilatect_content": "SUBSTR(`timestamp`, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 49,
                "end_index": 86,
                "dilatect_content": "substring(\"_timestamp\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `events`\nColumns:\n(`event_id`, integer, primary key)\n(`device_id`, integer)\n(`timestamp`, datetime)\n(`longitude`, real)\n(`latitude`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"events\"\nColumns:\n(\"event_id\", BIGINT, primary key)\n(\"device_id\", BIGINT)\n(\"_timestamp\", TIMESTAMP)\n(\"longitude\", DOUBLE PRECISION)\n(\"latitude\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 65,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T1.event_id) FROM events AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.event_id = T2.device_id WHERE STRFTIME('%Y', T1.timestamp) = '2016' AND T2.phone_brand = 'vivo'",
        "target_query": "SELECT COUNT(\"T1\".\"event_id\") FROM \"events\" AS \"T1\" INNER JOIN \"phone_brand_device_model2\" AS \"T2\" ON \"T1\".\"event_id\" = \"T2\".\"device_id\" WHERE sys.timestamp_to_str(\"T1\".\"_timestamp\", '%Y') = '2016' AND \"T2\".\"phone_brand\" = 'vivo';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 123,
                "end_index": 150,
                "dilatect_content": "STRFTIME('%Y', T1.timestamp)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 163,
                "end_index": 211,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"_timestamp\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `events`\nColumns:\n(`event_id`, integer, primary key)\n(`device_id`, integer)\n(`timestamp`, datetime)\n(`longitude`, real)\n(`latitude`, real)\n",
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, integer, primary key)\n(`phone_brand`, text, primary key)\n(`device_model`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"events\"\nColumns:\n(\"event_id\", BIGINT, primary key)\n(\"device_id\", BIGINT)\n(\"_timestamp\", TIMESTAMP)\n(\"longitude\", DOUBLE PRECISION)\n(\"latitude\", DOUBLE PRECISION)\n",
            "Table: \"phone_brand_device_model2\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"phone_brand\", STRING, primary key)\n(\"device_model\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 66,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(T1.`group` = 'M23-26', 1.0, 0)) / COUNT(T1.device_id) AS per FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'vivo'",
        "target_query": "SELECT SUM(CASE WHEN T1.\"group\" = 'M23-26' THEN 1.0 ELSE 0 END) / COUNT(T1.device_id) AS per FROM \"gender_age\" AS T1 INNER JOIN \"phone_brand_device_model2\" AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'vivo';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 44,
                "dilatect_content": "IIF(T1.`group` = 'M23-26', 1.0, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 63,
                "dilatect_content": "CASE WHEN T1.\"group\" = 'M23-26' THEN 1.0 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `gender_age`\nColumns:\n(`device_id`, integer, primary key)\n(`gender`, text)\n(`age`, integer)\n(`group`, text)\n",
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, integer, primary key)\n(`phone_brand`, text, primary key)\n(`device_model`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"gender_age\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"gender\", STRING)\n(\"age\", BIGINT)\n(\"group\", STRING)\n",
            "Table: \"phone_brand_device_model2\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"phone_brand\", STRING, primary key)\n(\"device_model\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 67,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(T2.phone_brand = 'vivo', 1, 0)) / COUNT(T1.device_id) AS per FROM events AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.event_id = T2.device_id WHERE T1.event_id = '2'",
        "target_query": "SELECT SUM(CASE WHEN \"T2\".\"phone_brand\" = 'vivo' THEN 1 ELSE 0 END) / COUNT(\"T1\".\"device_id\") AS \"per\" FROM \"events\" AS \"T1\" INNER JOIN \"phone_brand_device_model2\" AS \"T2\" ON \"T1\".\"event_id\" = \"T2\".\"device_id\" WHERE \"T1\".\"event_id\" = '2';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 44,
                "dilatect_content": "IIF(T2.phone_brand = 'vivo', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 69,
                "dilatect_content": "CASE WHEN \"T2\".\"phone_brand\" = 'vivo' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `events`\nColumns:\n(`event_id`, integer, primary key)\n(`device_id`, integer)\n(`timestamp`, datetime)\n(`longitude`, real)\n(`latitude`, real)\n",
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, integer, primary key)\n(`phone_brand`, text, primary key)\n(`device_model`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"events\"\nColumns:\n(\"event_id\", BIGINT, primary key)\n(\"device_id\", BIGINT)\n(\"_timestamp\", TIMESTAMP)\n(\"longitude\", DOUBLE PRECISION)\n(\"latitude\", DOUBLE PRECISION)\n",
            "Table: \"phone_brand_device_model2\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"phone_brand\", STRING, primary key)\n(\"device_model\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 68,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(T1.category = '80s Japanese comic', 1, 0)) / COUNT(T1.label_id) AS J8 , SUM(IIF(T1.category = '90s Japanese comic', 1, 0)) / COUNT(T1.label_id) AS J9 FROM label_categories AS T1 INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id",
        "target_query": "SELECT SUM(CASE WHEN \"T1\".\"category\" = '80s Japanese comic' THEN 1 ELSE 0 END) / COUNT(\"T1\".\"label_id\") AS \"J8\", SUM(CASE WHEN \"T1\".\"category\" = '90s Japanese comic' THEN 1 ELSE 0 END) / COUNT(\"T1\".\"label_id\") AS \"J9\" FROM \"label_categories\" AS \"T1\" INNER JOIN \"app_labels\" AS \"T2\" ON \"T1\".\"label_id\" = \"T2\".\"label_id\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 55,
                "dilatect_content": "IIF(T1.category = '80s Japanese comic', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 91,
                "end_index": 135,
                "dilatect_content": "IIF(T1.category = '90s Japanese comic', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 80,
                "dilatect_content": "CASE WHEN \"T1\".\"category\" = '80s Japanese comic' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 127,
                "end_index": 196,
                "dilatect_content": "CASE WHEN \"T1\".\"category\" = '90s Japanese comic' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `label_categories`\nColumns:\n(`label_id`, integer, primary key)\n(`category`, text)\n",
            "Table: `app_labels`\nColumns:\n(`app_id`, integer)\n(`label_id`, integer)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"label_categories\"\nColumns:\n(\"label_id\", BIGINT, primary key)\n(\"category\", STRING)\n",
            "Table: \"app_labels\"\nColumns:\n(\"app_id\", BIGINT)\n(\"label_id\", BIGINT)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 70,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(event_id) FROM events WHERE SUBSTR(`timestamp`, 1, 10) = '2016-05-06'",
        "target_query": "SELECT COUNT(\"event_id\") FROM \"events\" WHERE substring(\"_timestamp\" from 1 for 10) = '2016-05-06';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 41,
                "end_index": 66,
                "dilatect_content": "SUBSTR(`timestamp`, 1, 10)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 49,
                "end_index": 87,
                "dilatect_content": "substring(\"_timestamp\" from 1 for 10)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `events`\nColumns:\n(`event_id`, integer, primary key)\n(`device_id`, integer)\n(`timestamp`, datetime)\n(`longitude`, real)\n(`latitude`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"events\"\nColumns:\n(\"event_id\", BIGINT, primary key)\n(\"device_id\", BIGINT)\n(\"_timestamp\", TIMESTAMP)\n(\"longitude\", DOUBLE PRECISION)\n(\"latitude\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 71,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T3.device_id) FROM app_events AS T1 INNER JOIN events AS T2 ON T1.event_id = T2.event_id INNER JOIN gender_age AS T3 ON T2.device_id = T3.device_id WHERE SUBSTR(`timestamp`, 1, 10) = '2016-05-02' AND T1.is_active = 1 AND T3.age = '30'",
        "target_query": "SELECT COUNT(\"T3\".\"device_id\") FROM \"app_events\" AS \"T1\" INNER JOIN \"events\" AS \"T2\" ON \"T1\".\"event_id\" = \"T2\".\"event_id\" INNER JOIN \"gender_age\" AS \"T3\" ON \"T2\".\"device_id\" = \"T3\".\"device_id\" WHERE substring(\"_timestamp\" from 1 for 10) = '2016-05-02' AND \"T1\".\"is_active\" = 1 AND \"T3\".\"age\" = 30;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 167,
                "end_index": 192,
                "dilatect_content": "SUBSTR(`timestamp`, 1, 10)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 231,
                "end_index": 269,
                "dilatect_content": "substring(\"_timestamp\" from 1 for 10)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `app_events`\nColumns:\n(`event_id`, integer, primary key)\n(`app_id`, integer, primary key)\n(`is_installed`, integer)\n(`is_active`, integer)\n",
            "Table: `events`\nColumns:\n(`event_id`, integer, primary key)\n(`device_id`, integer)\n(`timestamp`, datetime)\n(`longitude`, real)\n(`latitude`, real)\n",
            "Table: `gender_age`\nColumns:\n(`device_id`, integer, primary key)\n(`gender`, text)\n(`age`, integer)\n(`group`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"app_events\"\nColumns:\n(\"event_id\", BIGINT, primary key)\n(\"app_id\", BIGINT, primary key)\n(\"is_installed\", BIGINT)\n(\"is_active\", BIGINT)\n",
            "Table: \"events\"\nColumns:\n(\"event_id\", BIGINT, primary key)\n(\"device_id\", BIGINT)\n(\"_timestamp\", TIMESTAMP)\n(\"longitude\", DOUBLE PRECISION)\n(\"latitude\", DOUBLE PRECISION)\n",
            "Table: \"gender_age\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"gender\", STRING)\n(\"age\", BIGINT)\n(\"group\", STRING)\n"
        ]
    },
    {
        "sql_id": 72,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T1.event_id) FROM app_events AS T1 INNER JOIN events AS T2 ON T1.event_id = T2.event_id WHERE SUBSTR(T2.`timestamp`, 1, 10) = '2016-05-06' AND T1.is_installed = '1'",
        "target_query": "SELECT COUNT(\"T1\".\"event_id\") FROM \"app_events\" AS \"T1\" INNER JOIN \"events\" AS \"T2\" ON \"T1\".\"event_id\" = \"T2\".\"event_id\" WHERE substring(\"T2\".\"_timestamp\" from 1 for 10) = '2016-05-06' AND \"T1\".\"is_installed\" = '1';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 107,
                "end_index": 135,
                "dilatect_content": "SUBSTR(T2.`timestamp`, 1, 10)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 147,
                "end_index": 192,
                "dilatect_content": "substring(\"T2\".\"_timestamp\" from 1 for 10)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `app_events`\nColumns:\n(`event_id`, integer, primary key)\n(`app_id`, integer, primary key)\n(`is_installed`, integer)\n(`is_active`, integer)\n",
            "Table: `events`\nColumns:\n(`event_id`, integer, primary key)\n(`device_id`, integer)\n(`timestamp`, datetime)\n(`longitude`, real)\n(`latitude`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"app_events\"\nColumns:\n(\"event_id\", BIGINT, primary key)\n(\"app_id\", BIGINT, primary key)\n(\"is_installed\", BIGINT)\n(\"is_active\", BIGINT)\n",
            "Table: \"events\"\nColumns:\n(\"event_id\", BIGINT, primary key)\n(\"device_id\", BIGINT)\n(\"_timestamp\", TIMESTAMP)\n(\"longitude\", DOUBLE PRECISION)\n(\"latitude\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 73,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T1.app_id) FROM app_events AS T1 INNER JOIN events AS T2 ON T1.event_id = T2.event_id INNER JOIN gender_age AS T3 ON T2.event_id = T3.device_id WHERE SUBSTR(T2.`timestamp`, 1, 10) = '2016-05-07' AND T1.is_active = '1' AND T3.`group` = 'F29-32'",
        "target_query": "SELECT COUNT(\"T1\".\"app_id\") FROM \"app_events\" AS \"T1\" INNER JOIN \"events\" AS \"T2\" ON \"T1\".\"event_id\" = \"T2\".\"event_id\" INNER JOIN \"gender_age\" AS \"T3\" ON \"T2\".\"event_id\" = \"T3\".\"device_id\" WHERE substring(\"T2\".\"_timestamp\" from 1 for 10) = '2016-05-07' AND \"T1\".\"is_active\" = '1' AND \"T3\".\"group\" = 'F29-32';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 163,
                "end_index": 191,
                "dilatect_content": "SUBSTR(T2.`timestamp`, 1, 10)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 227,
                "end_index": 272,
                "dilatect_content": "substring(\"T2\".\"_timestamp\" from 1 for 10)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `app_events`\nColumns:\n(`event_id`, integer, primary key)\n(`app_id`, integer, primary key)\n(`is_installed`, integer)\n(`is_active`, integer)\n",
            "Table: `events`\nColumns:\n(`event_id`, integer, primary key)\n(`device_id`, integer)\n(`timestamp`, datetime)\n(`longitude`, real)\n(`latitude`, real)\n",
            "Table: `gender_age`\nColumns:\n(`device_id`, integer, primary key)\n(`gender`, text)\n(`age`, integer)\n(`group`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"app_events\"\nColumns:\n(\"event_id\", BIGINT, primary key)\n(\"app_id\", BIGINT, primary key)\n(\"is_installed\", BIGINT)\n(\"is_active\", BIGINT)\n",
            "Table: \"events\"\nColumns:\n(\"event_id\", BIGINT, primary key)\n(\"device_id\", BIGINT)\n(\"_timestamp\", TIMESTAMP)\n(\"longitude\", DOUBLE PRECISION)\n(\"latitude\", DOUBLE PRECISION)\n",
            "Table: \"gender_age\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"gender\", STRING)\n(\"age\", BIGINT)\n(\"group\", STRING)\n"
        ]
    },
    {
        "sql_id": 74,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(timestamp = '2016-05-02 7:50:28', 1, 0)) / SUM(IIF(timestamp = '2016-05-02 7:41:03', 1, 0)) AS num FROM events AS T1 INNER JOIN app_events AS T2 ON T1.event_id = T2.event_id WHERE T2.is_active = '1'",
        "target_query": "SELECT SUM(CASE WHEN \"_timestamp\" = '2016-05-02 7:50:28' THEN 1 ELSE 0 END) / SUM(CASE WHEN \"_timestamp\" = '2016-05-02 7:41:03' THEN 1 ELSE 0 END) AS num FROM \"events\" AS T1 INNER JOIN \"app_events\" AS T2 ON T1.\"event_id\" = T2.\"event_id\" WHERE T2.\"is_active\" = 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 53,
                "dilatect_content": "IIF(timestamp = '2016-05-02 7:50:28', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 62,
                "end_index": 104,
                "dilatect_content": "IIF(timestamp = '2016-05-02 7:41:03', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 75,
                "dilatect_content": "CASE WHEN \"_timestamp\" = '2016-05-02 7:50:28' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 84,
                "end_index": 148,
                "dilatect_content": "CASE WHEN \"_timestamp\" = '2016-05-02 7:41:03' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `events`\nColumns:\n(`event_id`, integer, primary key)\n(`device_id`, integer)\n(`timestamp`, datetime)\n(`longitude`, real)\n(`latitude`, real)\n",
            "Table: `app_events`\nColumns:\n(`event_id`, integer, primary key)\n(`app_id`, integer, primary key)\n(`is_installed`, integer)\n(`is_active`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"events\"\nColumns:\n(\"event_id\", BIGINT, primary key)\n(\"device_id\", BIGINT)\n(\"_timestamp\", TIMESTAMP)\n(\"longitude\", DOUBLE PRECISION)\n(\"latitude\", DOUBLE PRECISION)\n",
            "Table: \"app_events\"\nColumns:\n(\"event_id\", BIGINT, primary key)\n(\"app_id\", BIGINT, primary key)\n(\"is_installed\", BIGINT)\n(\"is_active\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 75,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(phone_brand = 'vivo', 1, 0)) - SUM(IIF(phone_brand = 'LG', 1, 0)) AS num FROM phone_brand_device_model2",
        "target_query": "SELECT SUM(CASE WHEN \"phone_brand\" = 'vivo' THEN 1 ELSE 0 END) - SUM(CASE WHEN \"phone_brand\" = 'LG' THEN 1 ELSE 0 END) AS num FROM \"phone_brand_device_model2\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 41,
                "dilatect_content": "IIF(phone_brand = 'vivo', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 50,
                "end_index": 78,
                "dilatect_content": "IIF(phone_brand = 'LG', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 62,
                "dilatect_content": "CASE WHEN \"phone_brand\" = 'vivo' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 71,
                "end_index": 120,
                "dilatect_content": "CASE WHEN \"phone_brand\" = 'LG' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, integer, primary key)\n(`phone_brand`, text, primary key)\n(`device_model`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"phone_brand_device_model2\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"phone_brand\", STRING, primary key)\n(\"device_model\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 76,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T1.device_id) FROM gender_age AS T1 INNER JOIN events AS T2 ON T1.device_id = T2.device_id WHERE STRFTIME('%Y', T2.timestamp) = '2016' AND T1.`group` = 'M23-26'",
        "target_query": "SELECT COUNT(\"T1\".\"device_id\") FROM \"gender_age\" AS \"T1\" INNER JOIN \"events\" AS \"T2\" ON \"T1\".\"device_id\" = \"T2\".\"device_id\" WHERE sys.timestamp_to_str(\"T2\".\"_timestamp\", '%Y') = '2016' AND \"T1\".\"group\" = 'M23-26';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 110,
                "end_index": 137,
                "dilatect_content": "STRFTIME('%Y', T2.timestamp)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 150,
                "end_index": 198,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"_timestamp\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `gender_age`\nColumns:\n(`device_id`, integer, primary key)\n(`gender`, text)\n(`age`, integer)\n(`group`, text)\n",
            "Table: `events`\nColumns:\n(`event_id`, integer, primary key)\n(`device_id`, integer)\n(`timestamp`, datetime)\n(`longitude`, real)\n(`latitude`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"gender_age\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"gender\", STRING)\n(\"age\", BIGINT)\n(\"group\", STRING)\n",
            "Table: \"events\"\nColumns:\n(\"event_id\", BIGINT, primary key)\n(\"device_id\", BIGINT)\n(\"_timestamp\", TIMESTAMP)\n(\"longitude\", DOUBLE PRECISION)\n(\"latitude\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 77,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT IIF(SUM(IIF(T2.category = 'Securities', 1, 0)) - SUM(IIF(T2.category = 'Finance', 1, 0)) > 0, 'Securities', 'Finance') AS diff FROM app_labels AS T1 INNER JOIN label_categories AS T2 ON T1.label_id = T2.label_id",
        "target_query": "SELECT CASE WHEN SUM(CASE WHEN \"T2\".\"category\" = 'Securities' THEN 1 ELSE 0 END) - SUM(CASE WHEN \"T2\".\"category\" = 'Finance' THEN 1 ELSE 0 END) > 0 THEN 'Securities' ELSE 'Finance' END AS \"diff\" FROM \"app_labels\" AS \"T1\" INNER JOIN \"label_categories\" AS \"T2\" ON \"T1\".\"label_id\" = \"T2\".\"label_id\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 124,
                "dilatect_content": "IIF(SUM(IIF(T2.category = 'Securities', 1, 0)) - SUM(IIF(T2.category = 'Finance', 1, 0)) > 0, 'Securities', 'Finance')",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 15,
                "end_index": 51,
                "dilatect_content": "IIF(T2.category = 'Securities', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 60,
                "end_index": 93,
                "dilatect_content": "IIF(T2.category = 'Finance', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 191,
                "dilatect_content": "CASE WHEN SUM(CASE WHEN \"T2\".\"category\" = 'Securities' THEN 1 ELSE 0 END) - SUM(CASE WHEN \"T2\".\"category\" = 'Finance' THEN 1 ELSE 0 END) > 0 THEN 'Securities' ELSE 'Finance' END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 21,
                "end_index": 82,
                "dilatect_content": "CASE WHEN \"T2\".\"category\" = 'Securities' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 91,
                "end_index": 149,
                "dilatect_content": "CASE WHEN \"T2\".\"category\" = 'Finance' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `app_labels`\nColumns:\n(`app_id`, integer)\n(`label_id`, integer)\n(`rowid`, integer, primary key)\n",
            "Table: `label_categories`\nColumns:\n(`label_id`, integer, primary key)\n(`category`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"app_labels\"\nColumns:\n(\"app_id\", BIGINT)\n(\"label_id\", BIGINT)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"label_categories\"\nColumns:\n(\"label_id\", BIGINT, primary key)\n(\"category\", STRING)\n"
        ]
    },
    {
        "sql_id": 78,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(T1.gender = 'M', 1, 0)) / SUM(IIF(T1.gender = 'F', 1, 0)) AS per FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'vivo'",
        "target_query": "SELECT SUM(CASE WHEN \"T1\".\"gender\" = 'M' THEN 1 ELSE 0 END) / SUM(CASE WHEN \"T1\".\"gender\" = 'F' THEN 1 ELSE 0 END) AS \"per\" FROM \"gender_age\" AS \"T1\" INNER JOIN \"phone_brand_device_model2\" AS \"T2\" ON \"T1\".\"device_id\" = \"T2\".\"device_id\" WHERE \"T2\".\"phone_brand\" = 'vivo';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 36,
                "dilatect_content": "IIF(T1.gender = 'M', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 45,
                "end_index": 70,
                "dilatect_content": "IIF(T1.gender = 'F', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 61,
                "dilatect_content": "CASE WHEN \"T1\".\"gender\" = 'M' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 70,
                "end_index": 120,
                "dilatect_content": "CASE WHEN \"T1\".\"gender\" = 'F' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `gender_age`\nColumns:\n(`device_id`, integer, primary key)\n(`gender`, text)\n(`age`, integer)\n(`group`, text)\n",
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, integer, primary key)\n(`phone_brand`, text, primary key)\n(`device_model`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"gender_age\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"gender\", STRING)\n(\"age\", BIGINT)\n(\"group\", STRING)\n",
            "Table: \"phone_brand_device_model2\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"phone_brand\", STRING, primary key)\n(\"device_model\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 79,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(T2.category = 'Securities', 1, 0)) / SUM(IIF(T2.category = 'Finance', 1, 0)) AS per FROM app_labels AS T1 INNER JOIN label_categories AS T2 ON T1.label_id = T2.label_id",
        "target_query": "SELECT SUM(CASE WHEN \"T2\".\"category\" = 'Securities' THEN 1 ELSE 0 END) / SUM(CASE WHEN \"T2\".\"category\" = 'Finance' THEN 1 ELSE 0 END) AS \"per\" FROM \"app_labels\" AS \"T1\" INNER JOIN \"label_categories\" AS \"T2\" ON \"T1\".\"label_id\" = \"T2\".\"label_id\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 47,
                "dilatect_content": "IIF(T2.category = 'Securities', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 56,
                "end_index": 89,
                "dilatect_content": "IIF(T2.category = 'Finance', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 72,
                "dilatect_content": "CASE WHEN \"T2\".\"category\" = 'Securities' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 81,
                "end_index": 139,
                "dilatect_content": "CASE WHEN \"T2\".\"category\" = 'Finance' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `app_labels`\nColumns:\n(`app_id`, integer)\n(`label_id`, integer)\n(`rowid`, integer, primary key)\n",
            "Table: `label_categories`\nColumns:\n(`label_id`, integer, primary key)\n(`category`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"app_labels\"\nColumns:\n(\"app_id\", BIGINT)\n(\"label_id\", BIGINT)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"label_categories\"\nColumns:\n(\"label_id\", BIGINT, primary key)\n(\"category\", STRING)\n"
        ]
    },
    {
        "sql_id": 80,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(is_active = 1, 1, 0)) / SUM(IIF(is_active = 0, 1, 0)) AS per FROM app_events WHERE event_id = 58",
        "target_query": "SELECT SUM(CASE WHEN \"is_active\" = 1 THEN 1 ELSE 0 END) / SUM(CASE WHEN \"is_active\" = 0 THEN 1 ELSE 0 END) AS \"per\" FROM \"app_events\" WHERE \"event_id\" = 58;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 34,
                "dilatect_content": "IIF(is_active = 1, 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 43,
                "end_index": 66,
                "dilatect_content": "IIF(is_active = 0, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 55,
                "dilatect_content": "CASE WHEN \"is_active\" = 1 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 64,
                "end_index": 108,
                "dilatect_content": "CASE WHEN \"is_active\" = 0 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `app_events`\nColumns:\n(`event_id`, integer, primary key)\n(`app_id`, integer, primary key)\n(`is_installed`, integer)\n(`is_active`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"app_events\"\nColumns:\n(\"event_id\", BIGINT, primary key)\n(\"app_id\", BIGINT, primary key)\n(\"is_installed\", BIGINT)\n(\"is_active\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 81,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(gender = 'M', 1, 0)) / COUNT(device_id) AS per FROM gender_age",
        "target_query": "SELECT SUM(CASE WHEN \"gender\" = 'M' THEN 1 ELSE 0 END) / COUNT(\"device_id\") AS \"per\" FROM \"gender_age\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 33,
                "dilatect_content": "IIF(gender = 'M', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 54,
                "dilatect_content": "CASE WHEN \"gender\" = 'M' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `gender_age`\nColumns:\n(`device_id`, integer, primary key)\n(`gender`, text)\n(`age`, integer)\n(`group`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"gender_age\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"gender\", STRING)\n(\"age\", BIGINT)\n(\"group\", STRING)\n"
        ]
    },
    {
        "sql_id": 82,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T1.device_id) FROM events AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'OPPO' AND STRFTIME('%Y-%m-%d', T1.`timestamp`) = '2016-05-01'",
        "target_query": "SELECT COUNT(T1.\"device_id\") FROM \"events\" AS T1 INNER JOIN \"phone_brand_device_model2\" AS T2 ON T1.\"device_id\" = T2.\"device_id\" WHERE T2.\"phone_brand\" = 'OPPO' AND sys.timestamp_to_str(T1.\"_timestamp\", '%Y-%m-%d') = '2016-05-01';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 153,
                "end_index": 188,
                "dilatect_content": "STRFTIME('%Y-%m-%d', T1.`timestamp`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 177,
                "end_index": 227,
                "dilatect_content": "sys.timestamp_to_str(T1.\"_timestamp\", '%Y-%m-%d')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `events`\nColumns:\n(`event_id`, integer, primary key)\n(`device_id`, integer)\n(`timestamp`, datetime)\n(`longitude`, real)\n(`latitude`, real)\n",
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, integer, primary key)\n(`phone_brand`, text, primary key)\n(`device_model`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"events\"\nColumns:\n(\"event_id\", BIGINT, primary key)\n(\"device_id\", BIGINT)\n(\"_timestamp\", TIMESTAMP)\n(\"longitude\", DOUBLE PRECISION)\n(\"latitude\", DOUBLE PRECISION)\n",
            "Table: \"phone_brand_device_model2\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"phone_brand\", STRING, primary key)\n(\"device_model\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 83,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(T1.gender = 'M', 1, 0)) / SUM(IIF(T1.gender = 'F', 1, 0)) AS per FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'vivo' AND T2.device_model = 'X5Pro'",
        "target_query": "SELECT SUM(CASE WHEN \"T1\".\"gender\" = 'M' THEN 1 ELSE 0 END) / SUM(CASE WHEN \"T1\".\"gender\" = 'F' THEN 1 ELSE 0 END) AS \"per\" FROM \"gender_age\" AS \"T1\" INNER JOIN \"phone_brand_device_model2\" AS \"T2\" ON \"T1\".\"device_id\" = \"T2\".\"device_id\" WHERE \"T2\".\"phone_brand\" = 'vivo' AND \"T2\".\"device_model\" = 'X5Pro';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 36,
                "dilatect_content": "IIF(T1.gender = 'M', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 45,
                "end_index": 70,
                "dilatect_content": "IIF(T1.gender = 'F', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 61,
                "dilatect_content": "CASE WHEN \"T1\".\"gender\" = 'M' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 70,
                "end_index": 120,
                "dilatect_content": "CASE WHEN \"T1\".\"gender\" = 'F' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `gender_age`\nColumns:\n(`device_id`, integer, primary key)\n(`gender`, text)\n(`age`, integer)\n(`group`, text)\n",
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, integer, primary key)\n(`phone_brand`, text, primary key)\n(`device_model`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"gender_age\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"gender\", STRING)\n(\"age\", BIGINT)\n(\"group\", STRING)\n",
            "Table: \"phone_brand_device_model2\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"phone_brand\", STRING, primary key)\n(\"device_model\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 84,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(T1.gender = 'F' AND T1.age > 80, 1, 0)) / COUNT(T1.device_id) AS per FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'HTC'",
        "target_query": "SELECT SUM(CASE WHEN \"T1\".\"gender\" = 'F' AND \"T1\".\"age\" > 80 THEN 1 ELSE 0 END) / COUNT(\"T1\".\"device_id\") AS \"per\" FROM \"gender_age\" AS \"T1\" INNER JOIN \"phone_brand_device_model2\" AS \"T2\" ON \"T1\".\"device_id\" = \"T2\".\"device_id\" WHERE \"T2\".\"phone_brand\" = 'HTC';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 52,
                "dilatect_content": "IIF(T1.gender = 'F' AND T1.age > 80, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 85,
                "dilatect_content": "CASE WHEN \"T1\".\"gender\" = 'F' AND \"T1\".\"age\" > 80 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `gender_age`\nColumns:\n(`device_id`, integer, primary key)\n(`gender`, text)\n(`age`, integer)\n(`group`, text)\n",
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, integer, primary key)\n(`phone_brand`, text, primary key)\n(`device_model`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"gender_age\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"gender\", STRING)\n(\"age\", BIGINT)\n(\"group\", STRING)\n",
            "Table: \"phone_brand_device_model2\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"phone_brand\", STRING, primary key)\n(\"device_model\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 85,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(T1.age < 50, 1, 0)) / COUNT(T1.device_id) AS per FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'OPPO'",
        "target_query": "SELECT SUM(CASE WHEN \"T1\".\"age\" < 50 THEN 1 ELSE 0 END) / COUNT(\"T1\".\"device_id\") AS \"per\" FROM \"gender_age\" AS \"T1\" INNER JOIN \"phone_brand_device_model2\" AS \"T2\" ON \"T1\".\"device_id\" = \"T2\".\"device_id\" WHERE \"T2\".\"phone_brand\" = 'OPPO';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 32,
                "dilatect_content": "IIF(T1.age < 50, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 57,
                "dilatect_content": "CASE WHEN \"T1\".\"age\" < 50 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `gender_age`\nColumns:\n(`device_id`, integer, primary key)\n(`gender`, text)\n(`age`, integer)\n(`group`, text)\n",
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, integer, primary key)\n(`phone_brand`, text, primary key)\n(`device_model`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"gender_age\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"gender\", STRING)\n(\"age\", BIGINT)\n(\"group\", STRING)\n",
            "Table: \"phone_brand_device_model2\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"phone_brand\", STRING, primary key)\n(\"device_model\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 86,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(T1.age > 20, 1, 0)) / COUNT(T1.device_id) AS per FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'SUGAR'",
        "target_query": "SELECT SUM(CASE WHEN \"T1\".\"age\" > 20 THEN 1 ELSE 0 END) / COUNT(\"T1\".\"device_id\") AS \"per\" FROM \"gender_age\" AS \"T1\" INNER JOIN \"phone_brand_device_model2\" AS \"T2\" ON \"T1\".\"device_id\" = \"T2\".\"device_id\" WHERE \"T2\".\"phone_brand\" = 'SUGAR';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 32,
                "dilatect_content": "IIF(T1.age > 20, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 57,
                "dilatect_content": "CASE WHEN \"T1\".\"age\" > 20 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `gender_age`\nColumns:\n(`device_id`, integer, primary key)\n(`gender`, text)\n(`age`, integer)\n(`group`, text)\n",
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, integer, primary key)\n(`phone_brand`, text, primary key)\n(`device_model`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"gender_age\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"gender\", STRING)\n(\"age\", BIGINT)\n(\"group\", STRING)\n",
            "Table: \"phone_brand_device_model2\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"phone_brand\", STRING, primary key)\n(\"device_model\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 87,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT longitude, latitude FROM events WHERE date(timestamp) = '2016-04-30'",
        "target_query": "SELECT \"longitude\", \"latitude\" FROM \"events\" WHERE sys.timestamp_to_str(\"_timestamp\", '%Y-%m-%d') = '2016-04-30';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 45,
                "end_index": 59,
                "dilatect_content": "date(timestamp)",
                "feature": "date(time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 57,
                "end_index": 104,
                "dilatect_content": "sys.timestamp_to_str(\"_timestamp\", '%Y-%m-%d')",
                "feature": "sys.timestamp_to_str(date-value, '%Y-%m-%d')"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "date(time-value, modifier, modifier, ...)",
                "explanation": "The date(time-value, modifier, modifier, ...) function returns the date as text in the format: YYYY-MM-DD. The function accepts a time-value and zero or more modifiers to alter the date.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day', 'start of month').\nReturns: A string in the format YYYY-MM-DD.",
                "examples": [
                    "SELECT date(); -- Returns the current date.",
                    "SELECT date('now', '+1 day'); -- Returns the date one day after the current date.",
                    "SELECT date('2024-08-21'); -- Returns '2024-08-21'."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(date-value, '%Y-%m-%d')",
                "explanation": "In MonetDB, the DATE function from SQLite can be emulated using sys.timestamp_to_str to convert a DATE or TIMESTAMP value into a string in the format YYYY-MM-DD. Date arithmetic (e.g., +1 day) can be performed using sql_add with INTERVAL expressions.",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_DATE, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_DATE, interval '1' day), '%Y-%m-%d'); -- Returns the date one day after the current date.",
                    "SELECT sys.timestamp_to_str(date '2024-08-21', '%Y-%m-%d'); -- Returns '2024-08-21'."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `events`\nColumns:\n(`event_id`, integer, primary key)\n(`device_id`, integer)\n(`timestamp`, datetime)\n(`longitude`, real)\n(`latitude`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"events\"\nColumns:\n(\"event_id\", BIGINT, primary key)\n(\"device_id\", BIGINT)\n(\"_timestamp\", TIMESTAMP)\n(\"longitude\", DOUBLE PRECISION)\n(\"latitude\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 88,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T.gender FROM ( SELECT T1.gender, COUNT(T1.device_id) AS num FROM gender_age AS T1 INNER JOIN events_relevant AS T2 ON T1.device_id = T2.device_id WHERE date(T2.timestamp) BETWEEN '2016-05-01' AND '2016-05-10' GROUP BY T1.gender ) AS T ORDER BY T.num DESC LIMIT 1",
        "target_query": "SELECT \"T\".\"gender\" FROM ( SELECT \"T1\".\"gender\", COUNT(\"T1\".\"device_id\") AS \"num\" FROM \"gender_age\" AS \"T1\" INNER JOIN \"events_relevant\" AS \"T2\" ON \"T1\".\"device_id\" = \"T2\".\"device_id\" WHERE sys.timestamp_to_str(\"T2\".\"_timestamp\", '%Y-%m-%d') BETWEEN '2016-05-01' AND '2016-05-10' GROUP BY \"T1\".\"gender\" ) AS \"T\" ORDER BY \"T\".\"num\" DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 160,
                "end_index": 177,
                "dilatect_content": "date(T2.timestamp)",
                "feature": "date(time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 220,
                "end_index": 274,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"_timestamp\", '%Y-%m-%d')",
                "feature": "sys.timestamp_to_str(date-value, '%Y-%m-%d')"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "date(time-value, modifier, modifier, ...)",
                "explanation": "The date(time-value, modifier, modifier, ...) function returns the date as text in the format: YYYY-MM-DD. The function accepts a time-value and zero or more modifiers to alter the date.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day', 'start of month').\nReturns: A string in the format YYYY-MM-DD.",
                "examples": [
                    "SELECT date(); -- Returns the current date.",
                    "SELECT date('now', '+1 day'); -- Returns the date one day after the current date.",
                    "SELECT date('2024-08-21'); -- Returns '2024-08-21'."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(date-value, '%Y-%m-%d')",
                "explanation": "In MonetDB, the DATE function from SQLite can be emulated using sys.timestamp_to_str to convert a DATE or TIMESTAMP value into a string in the format YYYY-MM-DD. Date arithmetic (e.g., +1 day) can be performed using sql_add with INTERVAL expressions.",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_DATE, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_DATE, interval '1' day), '%Y-%m-%d'); -- Returns the date one day after the current date.",
                    "SELECT sys.timestamp_to_str(date '2024-08-21', '%Y-%m-%d'); -- Returns '2024-08-21'."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `gender_age`\nColumns:\n(`device_id`, integer, primary key)\n(`gender`, text)\n(`age`, integer)\n(`group`, text)\n",
            "Table: `events_relevant`\nColumns:\n(`event_id`, integer, primary key)\n(`device_id`, integer)\n(`timestamp`, datetime)\n(`longitude`, real)\n(`latitude`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"gender_age\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"gender\", STRING)\n(\"age\", BIGINT)\n(\"group\", STRING)\n",
            "Table: \"events_relevant\"\nColumns:\n(\"event_id\", BIGINT, primary key)\n(\"device_id\", BIGINT)\n(\"_timestamp\", TIMESTAMP)\n(\"longitude\", DOUBLE PRECISION)\n(\"latitude\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 89,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(T1.gender = 'F', 1, 0)) / SUM(IIF(T1.gender = 'M', 1, 0)) AS per FROM gender_age AS T1 INNER JOIN events_relevant AS T2 ON T1.device_id = T2.device_id INNER JOIN app_events_relevant AS T3 ON T2.event_id = T3.event_id WHERE T3.is_installed = 0",
        "target_query": "SELECT SUM(CASE WHEN \"T1\".\"gender\" = 'F' THEN 1 ELSE 0 END) / SUM(CASE WHEN \"T1\".\"gender\" = 'M' THEN 1 ELSE 0 END) AS \"per\" FROM \"gender_age\" AS \"T1\" INNER JOIN \"events_relevant\" AS \"T2\" ON \"T1\".\"device_id\" = \"T2\".\"device_id\" INNER JOIN \"app_events_relevant\" AS \"T3\" ON \"T2\".\"event_id\" = \"T3\".\"event_id\" WHERE \"T3\".\"is_installed\" = 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 36,
                "dilatect_content": "IIF(T1.gender = 'F', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 45,
                "end_index": 70,
                "dilatect_content": "IIF(T1.gender = 'M', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 61,
                "dilatect_content": "CASE WHEN \"T1\".\"gender\" = 'F' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 70,
                "end_index": 120,
                "dilatect_content": "CASE WHEN \"T1\".\"gender\" = 'M' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `gender_age`\nColumns:\n(`device_id`, integer, primary key)\n(`gender`, text)\n(`age`, integer)\n(`group`, text)\n",
            "Table: `events_relevant`\nColumns:\n(`event_id`, integer, primary key)\n(`device_id`, integer)\n(`timestamp`, datetime)\n(`longitude`, real)\n(`latitude`, real)\n",
            "Table: `app_events_relevant`\nColumns:\n(`event_id`, integer, primary key)\n(`app_id`, integer, primary key)\n(`is_installed`, integer)\n(`is_active`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"gender_age\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"gender\", STRING)\n(\"age\", BIGINT)\n(\"group\", STRING)\n",
            "Table: \"events_relevant\"\nColumns:\n(\"event_id\", BIGINT, primary key)\n(\"device_id\", BIGINT)\n(\"_timestamp\", TIMESTAMP)\n(\"longitude\", DOUBLE PRECISION)\n(\"latitude\", DOUBLE PRECISION)\n",
            "Table: \"app_events_relevant\"\nColumns:\n(\"event_id\", BIGINT, primary key)\n(\"app_id\", BIGINT, primary key)\n(\"is_installed\", BIGINT)\n(\"is_active\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 90,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(latitude != 0 AND longitude != 0, 1, 0)) - SUM(IIF(latitude = 0 AND longitude = 0, 1, 0)) AS diff FROM events WHERE device_id = '-922956879900150000'",
        "target_query": "SELECT SUM(CASE WHEN \"latitude\" != 0 AND \"longitude\" != 0 THEN 1 ELSE 0 END) - SUM(CASE WHEN \"latitude\" = 0 AND \"longitude\" = 0 THEN 1 ELSE 0 END) AS diff FROM \"events\" WHERE \"device_id\" = -922956879900150000;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 53,
                "dilatect_content": "IIF(latitude != 0 AND longitude != 0, 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 62,
                "end_index": 102,
                "dilatect_content": "IIF(latitude = 0 AND longitude = 0, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 53,
                "dilatect_content": "CASE WHEN \"latitude\" != 0 AND \"longitude\" != 0 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 87,
                "end_index": 152,
                "dilatect_content": "CASE WHEN \"latitude\" = 0 AND \"longitude\" = 0 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `events`\nColumns:\n(`event_id`, integer, primary key)\n(`device_id`, integer)\n(`timestamp`, datetime)\n(`longitude`, real)\n(`latitude`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"events\"\nColumns:\n(\"event_id\", BIGINT, primary key)\n(\"device_id\", BIGINT)\n(\"_timestamp\", TIMESTAMP)\n(\"longitude\", DOUBLE PRECISION)\n(\"latitude\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 91,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(is_installed = 1 AND is_active = 0, 1, 0)) / COUNT(app_id) AS perrcent FROM app_events WHERE event_id = 6",
        "target_query": "SELECT SUM(CASE WHEN \"is_installed\" = 1 AND \"is_active\" = 0 THEN 1 ELSE 0 END) / COUNT(\"app_id\") AS \"perrcent\" FROM \"app_events\" WHERE \"event_id\" = 6;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 55,
                "dilatect_content": "IIF(is_installed = 1 AND is_active = 0, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 80,
                "dilatect_content": "CASE WHEN \"is_installed\" = 1 AND \"is_active\" = 0 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `app_events`\nColumns:\n(`event_id`, integer, primary key)\n(`app_id`, integer, primary key)\n(`is_installed`, integer)\n(`is_active`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"app_events\"\nColumns:\n(\"event_id\", BIGINT, primary key)\n(\"app_id\", BIGINT, primary key)\n(\"is_installed\", BIGINT)\n(\"is_active\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 92,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT IIF(SUM(IIF(T1.gender = 'M', 1, 0)) - SUM(IIF(T1.gender = 'F', 1, 0)) > 0, 'M', 'F') AS gender FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.device_model = 'Galaxy Note 2'",
        "target_query": "SELECT CASE WHEN SUM(CASE WHEN \"T1\".\"gender\" = 'M' THEN 1 ELSE 0 END) - SUM(CASE WHEN \"T1\".\"gender\" = 'F' THEN 1 ELSE 0 END) > 0 THEN 'M' ELSE 'F' END AS \"gender\" FROM \"gender_age\" AS \"T1\" INNER JOIN \"phone_brand_device_model2\" AS \"T2\" ON \"T1\".\"device_id\" = \"T2\".\"device_id\" WHERE \"T2\".\"device_model\" = 'Galaxy Note 2';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 90,
                "dilatect_content": "IIF(SUM(IIF(T1.gender = 'M', 1, 0)) - SUM(IIF(T1.gender = 'F', 1, 0)) > 0, 'M', 'F')",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 15,
                "end_index": 40,
                "dilatect_content": "IIF(T1.gender = 'M', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 49,
                "end_index": 74,
                "dilatect_content": "IIF(T1.gender = 'F', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 157,
                "dilatect_content": "CASE WHEN SUM(CASE WHEN \"T1\".\"gender\" = 'M' THEN 1 ELSE 0 END) - SUM(CASE WHEN \"T1\".\"gender\" = 'F' THEN 1 ELSE 0 END) > 0 THEN 'M' ELSE 'F' END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 21,
                "end_index": 71,
                "dilatect_content": "CASE WHEN \"T1\".\"gender\" = 'M' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 80,
                "end_index": 130,
                "dilatect_content": "CASE WHEN \"T1\".\"gender\" = 'F' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `gender_age`\nColumns:\n(`device_id`, integer, primary key)\n(`gender`, text)\n(`age`, integer)\n(`group`, text)\n",
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, integer, primary key)\n(`phone_brand`, text, primary key)\n(`device_model`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"gender_age\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"gender\", STRING)\n(\"age\", BIGINT)\n(\"group\", STRING)\n",
            "Table: \"phone_brand_device_model2\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"phone_brand\", STRING, primary key)\n(\"device_model\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 93,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(T1.category = 'Academic Information', 1.0, 0)) / COUNT(T2.app_id) AS per FROM label_categories AS T1 INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id",
        "target_query": "SELECT SUM(CASE WHEN \"T1\".\"category\" = 'Academic Information' THEN 1.0 ELSE 0 END) / COUNT(\"T2\".\"app_id\") AS \"per\" FROM \"label_categories\" AS \"T1\" INNER JOIN \"app_labels\" AS \"T2\" ON \"T1\".\"label_id\" = \"T2\".\"label_id\"",
        "semantic_equivalent_type": "approximate_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 59,
                "dilatect_content": "IIF(T1.category = 'Academic Information', 1.0, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 84,
                "dilatect_content": "CASE WHEN \"T1\".\"category\" = 'Academic Information' THEN 1.0 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `label_categories`\nColumns:\n(`label_id`, integer, primary key)\n(`category`, text)\n",
            "Table: `app_labels`\nColumns:\n(`app_id`, integer)\n(`label_id`, integer)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"label_categories\"\nColumns:\n(\"label_id\", BIGINT, primary key)\n(\"category\", STRING)\n",
            "Table: \"app_labels\"\nColumns:\n(\"app_id\", BIGINT)\n(\"label_id\", BIGINT)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 94,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(T1.`group` = 'F27-28', 1, 0)) / COUNT(T1.device_id) AS per FROM gender_age AS T1 INNER JOIN events_relevant AS T2 ON T1.device_id = T2.device_id WHERE SUBSTR(T2.timestamp, 1, 10) = '2016-05-03'",
        "target_query": "SELECT SUM(CASE WHEN T1.\"group\" = 'F27-28' THEN 1 ELSE 0 END) / COUNT(T1.device_id) AS per FROM \"gender_age\" AS T1 INNER JOIN \"events_relevant\" AS T2 ON T1.device_id = T2.device_id WHERE substring(T2.\"_timestamp\" from 1 for 10) = '2016-05-03';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 42,
                "dilatect_content": "IIF(T1.`group` = 'F27-28', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 166,
                "end_index": 192,
                "dilatect_content": "SUBSTR(T2.timestamp, 1, 10)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 61,
                "dilatect_content": "CASE WHEN T1.\"group\" = 'F27-28' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 193,
                "end_index": 192,
                "dilatect_content": "substring(T2.\"_timestamp\" from 1 for 10)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            },
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `gender_age`\nColumns:\n(`device_id`, integer, primary key)\n(`gender`, text)\n(`age`, integer)\n(`group`, text)\n",
            "Table: `events_relevant`\nColumns:\n(`event_id`, integer, primary key)\n(`device_id`, integer)\n(`timestamp`, datetime)\n(`longitude`, real)\n(`latitude`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"gender_age\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"gender\", STRING)\n(\"age\", BIGINT)\n(\"group\", STRING)\n",
            "Table: \"events_relevant\"\nColumns:\n(\"event_id\", BIGINT, primary key)\n(\"device_id\", BIGINT)\n(\"_timestamp\", TIMESTAMP)\n(\"longitude\", DOUBLE PRECISION)\n(\"latitude\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 95,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(T1.gender IS NULL AND T1.age IS NULL AND T1.`group` IS NULL, 1, 0)) / COUNT(T1.device_id) AS per FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'vivo'",
        "target_query": "SELECT SUM(CASE WHEN \"T1\".\"gender\" IS NULL AND \"T1\".\"age\" IS NULL AND \"T1\".\"group\" IS NULL THEN 1 ELSE 0 END) / COUNT(\"T1\".\"device_id\") AS \"per\" FROM \"gender_age\" AS \"T1\" INNER JOIN \"phone_brand_device_model2\" AS \"T2\" ON \"T1\".\"device_id\" = \"T2\".\"device_id\" WHERE \"T2\".\"phone_brand\" = 'vivo';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 80,
                "dilatect_content": "IIF(T1.gender IS NULL AND T1.age IS NULL AND T1.`group` IS NULL, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 119,
                "dilatect_content": "CASE WHEN \"T1\".\"gender\" IS NULL AND \"T1\".\"age\" IS NULL AND \"T1\".\"group\" IS NULL THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `gender_age`\nColumns:\n(`device_id`, integer, primary key)\n(`gender`, text)\n(`age`, integer)\n(`group`, text)\n",
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, integer, primary key)\n(`phone_brand`, text, primary key)\n(`device_model`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"gender_age\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"gender\", STRING)\n(\"age\", BIGINT)\n(\"group\", STRING)\n",
            "Table: \"phone_brand_device_model2\"\nColumns:\n(\"device_id\", BIGINT, primary key)\n(\"phone_brand\", STRING, primary key)\n(\"device_model\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 96,
        "database_name": "law_episode",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T1.episode_id) FROM Episode AS T1 INNER JOIN Award AS T2 ON T1.episode_id = T2.episode_id WHERE strftime('%Y', T1.air_date) = '1998' AND T2.organization = 'International Monitor Awards' AND T2.result = 'Winner'",
        "target_query": "SELECT COUNT(\"T1\".\"episode_id\") FROM \"Episode\" AS \"T1\" INNER JOIN \"Award\" AS \"T2\" ON \"T1\".\"episode_id\" = \"T2\".\"episode_id\" WHERE sys.timestamp_to_str(\"T1\".\"air_date\", '%Y') = '1998' AND \"T2\".\"organization\" = 'International Monitor Awards' AND \"T2\".\"result\" = 'Winner';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 109,
                "end_index": 135,
                "dilatect_content": "strftime('%Y', T1.air_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 149,
                "end_index": 195,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"air_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`series`, text)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, date)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n",
            "Table: `Award`\nColumns:\n(`award_id`, integer, primary key)\n(`organization`, text)\n(`year`, integer)\n(`award_category`, text)\n(`award`, text)\n(`series`, text)\n(`episode_id`, text)\n(`person_id`, text)\n(`role`, text)\n(`result`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Episode\"\nColumns:\n(\"episode_id\", STRING, primary key)\n(\"series\", STRING)\n(\"season\", BIGINT)\n(\"episode\", BIGINT)\n(\"number_in_series\", BIGINT)\n(\"title\", STRING)\n(\"summary\", STRING)\n(\"air_date\", DATE)\n(\"episode_image\", STRING)\n(\"rating\", DOUBLE PRECISION)\n(\"votes\", BIGINT)\n",
            "Table: \"Award\"\nColumns:\n(\"award_id\", BIGINT, primary key)\n(\"organization\", STRING)\n(\"_year\", BIGINT)\n(\"award_category\", STRING)\n(\"award\", STRING)\n(\"series\", STRING)\n(\"episode_id\", STRING)\n(\"person_id\", STRING)\n(\"role\", STRING)\n(\"result\", STRING)\n"
        ]
    },
    {
        "sql_id": 97,
        "database_name": "law_episode",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT t3.years, t3.episode_id FROM ( SELECT DISTINCT T2.year AS years, T2.episode_id, row_number() OVER (PARTITION BY T2.episode_id ORDER BY T2.year) AS rm FROM Person AS T1 INNER JOIN Award AS T2 ON T1.person_id = T2.person_id WHERE T2.award = 'Television' AND T2.award_category = 'Silver Gavel Award' AND T1.name = 'Constantine Makris' AND T2.result = 'Winner' AND T2.organization = 'American Bar Association Silver Gavel Awards for Media and the Arts' ) AS T3 GROUP BY t3.episode_id HAVING COUNT(t3.years - t3.rm) >= 2",
        "target_query": "SELECT \"T3\".\"years\", \"T3\".\"episode_id\" FROM ( SELECT DISTINCT \"T2\".\"_year\" AS \"years\", \"T2\".\"episode_id\", ROW_NUMBER() OVER (PARTITION BY \"T2\".\"episode_id\" ORDER BY \"T2\".\"_year\") AS \"rm\" FROM \"Person\" AS \"T1\" INNER JOIN \"Award\" AS \"T2\" ON \"T1\".\"person_id\" = \"T2\".\"person_id\" WHERE \"T2\".\"award\" = 'Television' AND \"T2\".\"award_category\" = 'Silver Gavel Award' AND \"T1\".\"name\" = 'Constantine Makris' AND \"T2\".\"result\" = 'Winner' AND \"T2\".\"organization\" = 'American Bar Association Silver Gavel Awards for Media and the Arts' ) AS \"T3\" GROUP BY \"T3\".\"years\", \"T3\".\"episode_id\" HAVING COUNT(\"T3\".\"years\" - \"T3\".\"rm\") >= 2;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 87,
                "end_index": 149,
                "dilatect_content": "row_number() OVER (PARTITION BY T2.episode_id ORDER BY T2.year)",
                "feature": "row_number()"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 124,
                "end_index": 203,
                "dilatect_content": "ROW_NUMBER() OVER (PARTITION BY \"T2\".\"episode_id\" ORDER BY \"T2\".\"_year\")",
                "feature": "ROW_NUMBER() OVER (ORDER BY ...)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "row_number()",
                "explanation": " The number of the row within the current partition. Rows are\n       numbered starting from 1 in the order defined by the ORDER BY clause in\n       the window definition, or in arbitrary order otherwise.\n  ",
                "examples": [
                    "SELECT id, name, score, ROW_NUMBER() OVER (ORDER BY score DESC) AS row_num FROM students;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "ROW_NUMBER() OVER (ORDER BY ...)",
                "explanation": "The ROW_NUMBER() window function returns the sequential number of a row within its partition, starting from 1 for the first row. The order of the numbering is determined by the ORDER BY clause provided in the window specification.",
                "examples": [
                    "SELECT id, name, score, ROW_NUMBER() OVER (ORDER BY score DESC) AS row_num FROM students;",
                    "SELECT id, ROW_NUMBER() OVER (PARTITION BY department ORDER BY hire_date) AS dept_rank FROM employees;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`person_id`, text, primary key)\n(`name`, text)\n(`birthdate`, date)\n(`birth_name`, text)\n(`birth_place`, text)\n(`birth_region`, text)\n(`birth_country`, text)\n(`height_meters`, real)\n(`nickname`, text)\n",
            "Table: `Award`\nColumns:\n(`award_id`, integer, primary key)\n(`organization`, text)\n(`year`, integer)\n(`award_category`, text)\n(`award`, text)\n(`series`, text)\n(`episode_id`, text)\n(`person_id`, text)\n(`role`, text)\n(`result`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Person\"\nColumns:\n(\"person_id\", STRING, primary key)\n(\"name\", STRING)\n(\"birthdate\", DATE)\n(\"birth_name\", STRING)\n(\"birth_place\", STRING)\n(\"birth_region\", STRING)\n(\"birth_country\", STRING)\n(\"height_meters\", DOUBLE PRECISION)\n(\"nickname\", STRING)\n",
            "Table: \"Award\"\nColumns:\n(\"award_id\", BIGINT, primary key)\n(\"organization\", STRING)\n(\"_year\", BIGINT)\n(\"award_category\", STRING)\n(\"award\", STRING)\n(\"series\", STRING)\n(\"episode_id\", STRING)\n(\"person_id\", STRING)\n(\"role\", STRING)\n(\"result\", STRING)\n"
        ]
    },
    {
        "sql_id": 98,
        "database_name": "law_episode",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT t3.name FROM ( SELECT DISTINCT T2.year AS years, T1.name, row_number() OVER (PARTITION BY T1.name ORDER BY T2.year) AS rm FROM Person AS T1 INNER JOIN Award AS T2 ON T1.person_id = T2.person_id WHERE T2.award = 'Television' AND T2.award_category = 'Silver Gavel Award' AND T2.series = 'Law and Order' AND T2.result = 'Winner' AND T2.organization = 'American Bar Association Silver Gavel Awards for Media and the Arts' ) AS T3 GROUP BY t3.name HAVING COUNT(t3.years - t3.rm) >= 2",
        "target_query": "SELECT \"T3\".\"name\" FROM ( SELECT DISTINCT \"T2\"._year AS \"years\", \"T1\".\"name\", ROW_NUMBER() OVER (PARTITION BY \"T1\".\"name\" ORDER BY \"T2\"._year) AS \"rm\" FROM \"Person\" AS \"T1\" INNER JOIN \"Award\" AS \"T2\" ON \"T1\".\"person_id\" = \"T2\".\"person_id\" WHERE \"T2\".\"award\" = 'Television' AND \"T2\".\"award_category\" = 'Silver Gavel Award' AND \"T2\".\"series\" = 'Law and Order' AND \"T2\".\"result\" = 'Winner' AND \"T2\".\"organization\" = 'American Bar Association Silver Gavel Awards for Media and the Arts' ) AS \"T3\" GROUP BY \"T3\".\"name\" HAVING COUNT(\"T3\".\"years\" - \"T3\".\"rm\") >= 2;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 65,
                "end_index": 121,
                "dilatect_content": "row_number() OVER (PARTITION BY T1.name ORDER BY T2.year)",
                "feature": "row_number()"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 90,
                "end_index": 159,
                "dilatect_content": "ROW_NUMBER() OVER (PARTITION BY \"T1\".\"name\" ORDER BY \"T2\"._year)",
                "feature": "ROW_NUMBER() OVER (ORDER BY ...)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "row_number()",
                "explanation": " The number of the row within the current partition. Rows are\n       numbered starting from 1 in the order defined by the ORDER BY clause in\n       the window definition, or in arbitrary order otherwise.\n  ",
                "examples": [
                    "SELECT id, name, score, ROW_NUMBER() OVER (ORDER BY score DESC) AS row_num FROM students;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "ROW_NUMBER() OVER (ORDER BY ...)",
                "explanation": "The ROW_NUMBER() window function returns the sequential number of a row within its partition, starting from 1 for the first row. The order of the numbering is determined by the ORDER BY clause provided in the window specification.",
                "examples": [
                    "SELECT id, name, score, ROW_NUMBER() OVER (ORDER BY score DESC) AS row_num FROM students;",
                    "SELECT id, ROW_NUMBER() OVER (PARTITION BY department ORDER BY hire_date) AS dept_rank FROM employees;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`person_id`, text, primary key)\n(`name`, text)\n(`birthdate`, date)\n(`birth_name`, text)\n(`birth_place`, text)\n(`birth_region`, text)\n(`birth_country`, text)\n(`height_meters`, real)\n(`nickname`, text)\n",
            "Table: `Award`\nColumns:\n(`award_id`, integer, primary key)\n(`organization`, text)\n(`year`, integer)\n(`award_category`, text)\n(`award`, text)\n(`series`, text)\n(`episode_id`, text)\n(`person_id`, text)\n(`role`, text)\n(`result`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Person\"\nColumns:\n(\"person_id\", STRING, primary key)\n(\"name\", STRING)\n(\"birthdate\", DATE)\n(\"birth_name\", STRING)\n(\"birth_place\", STRING)\n(\"birth_region\", STRING)\n(\"birth_country\", STRING)\n(\"height_meters\", DOUBLE PRECISION)\n(\"nickname\", STRING)\n",
            "Table: \"Award\"\nColumns:\n(\"award_id\", BIGINT, primary key)\n(\"organization\", STRING)\n(\"_year\", BIGINT)\n(\"award_category\", STRING)\n(\"award\", STRING)\n(\"series\", STRING)\n(\"episode_id\", STRING)\n(\"person_id\", STRING)\n(\"role\", STRING)\n(\"result\", STRING)\n"
        ]
    },
    {
        "sql_id": 99,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(CASE WHEN strftime('%Y', T2.date) = '2009' THEN T2.VALUE END) - SUM(CASE WHEN strftime('%Y', T2.date) = '2008' THEN T2.VALUE END) AS increase , T2.units FROM patients AS T1 INNER JOIN observations AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Elly' AND T1.last = 'Koss' AND T2.description = 'Body Height'",
        "target_query": "SELECT SUM(CASE WHEN sys.timestamp_to_str(T2.\"_DATE\", '%Y') = '2009' THEN T2.\"VALUE\" END) - SUM(CASE WHEN sys.timestamp_to_str(T2.\"_DATE\", '%Y') = '2008' THEN T2.\"VALUE\" END) AS increase, T2.\"UNITS\" FROM \"patients\" AS T1 INNER JOIN \"observations\" AS T2 ON T1.\"patient\" = T2.\"PATIENT\" WHERE T1.\"_first\" = 'Elly' AND T1.\"_last\" = 'Koss' AND T2.\"DESCRIPTION\" = 'Body Height' GROUP BY T2.\"UNITS\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 43,
                "dilatect_content": "strftime('%Y', T2.date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 89,
                "end_index": 111,
                "dilatect_content": "strftime('%Y', T2.date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 60,
                "dilatect_content": "sys.timestamp_to_str(T2.\"_DATE\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 110,
                "end_index": 149,
                "dilatect_content": "sys.timestamp_to_str(T2.\"_DATE\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `observations`\nColumns:\n(`DATE`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, text)\n(`DESCRIPTION`, text)\n(`VALUE`, real)\n(`UNITS`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"patients\"\nColumns:\n(\"patient\", STRING, primary key)\n(\"birthdate\", DATE)\n(\"deathdate\", DATE)\n(\"ssn\", STRING)\n(\"drivers\", STRING)\n(\"passport\", STRING)\n(\"prefix\", STRING)\n(\"_first\", STRING)\n(\"_last\", STRING)\n(\"suffix\", STRING)\n(\"maiden\", STRING)\n(\"marital\", STRING)\n(\"race\", STRING)\n(\"ethnicity\", STRING)\n(\"gender\", STRING)\n(\"birthplace\", STRING)\n(\"address\", STRING)\n",
            "Table: \"observations\"\nColumns:\n(\"_DATE\", DATE)\n(\"PATIENT\", STRING)\n(\"ENCOUNTER\", STRING)\n(\"CODE\", STRING)\n(\"DESCRIPTION\", STRING)\n(\"VALUE\", DOUBLE PRECISION)\n(\"UNITS\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 100,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT strftime('%J', T2.STOP) - strftime('%J', T2.START) AS days FROM patients AS T1 INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Elly' AND T1.last = 'Koss' AND T2.description LIKE 'Acetaminophen%'",
        "target_query": "SELECT \"T2\".\"STOP\" - \"T2\".\"START\" AS \"days\" FROM \"patients\" AS \"T1\" INNER JOIN \"medications\" AS \"T2\" ON \"T1\".\"patient\" = \"T2\".\"PATIENT\" WHERE \"T1\".\"_first\" = 'Elly' AND \"T1\".\"_last\" = 'Koss' AND \"T2\".\"DESCRIPTION\" LIKE 'Acetaminophen%'",
        "semantic_equivalent_type": "approximate_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 29,
                "dilatect_content": "strftime('%J', T2.STOP)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 33,
                "end_index": 56,
                "dilatect_content": "strftime('%J', T2.START)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `medications`\nColumns:\n(`START`, date, primary key)\n(`STOP`, date)\n(`PATIENT`, text, primary key)\n(`ENCOUNTER`, text, primary key)\n(`CODE`, integer, primary key)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"patients\"\nColumns:\n(\"patient\", STRING, primary key)\n(\"birthdate\", DATE)\n(\"deathdate\", DATE)\n(\"ssn\", STRING)\n(\"drivers\", STRING)\n(\"passport\", STRING)\n(\"prefix\", STRING)\n(\"_first\", STRING)\n(\"_last\", STRING)\n(\"suffix\", STRING)\n(\"maiden\", STRING)\n(\"marital\", STRING)\n(\"race\", STRING)\n(\"ethnicity\", STRING)\n(\"gender\", STRING)\n(\"birthplace\", STRING)\n(\"address\", STRING)\n",
            "Table: \"medications\"\nColumns:\n(\"START\", DATE, primary key)\n(\"STOP\", DATE)\n(\"PATIENT\", STRING, primary key)\n(\"ENCOUNTER\", STRING, primary key)\n(\"CODE\", BIGINT, primary key)\n(\"DESCRIPTION\", STRING)\n(\"REASONCODE\", BIGINT)\n(\"REASONDESCRIPTION\", STRING)\n"
        ]
    },
    {
        "sql_id": 101,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT strftime('%J', T2.STOP) - strftime('%J', T2.START) AS days FROM patients AS T1 INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Elly' AND T1.last = 'Koss' AND T2.description = 'Cystitis'",
        "target_query": "SELECT (\"T2\".\"STOP\" - \"T2\".\"START\") AS \"days\" FROM \"patients\" AS \"T1\" INNER JOIN \"conditions\" AS \"T2\" ON \"T1\".\"patient\" = \"T2\".\"PATIENT\" WHERE \"T1\".\"_first\" = 'Elly' AND \"T1\".\"_last\" = 'Koss' AND \"T2\".\"DESCRIPTION\" = 'Cystitis'",
        "semantic_equivalent_type": "approximate_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 29,
                "dilatect_content": "strftime('%J', T2.STOP)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 33,
                "end_index": 56,
                "dilatect_content": "strftime('%J', T2.START)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `conditions`\nColumns:\n(`START`, date)\n(`STOP`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, integer)\n(`DESCRIPTION`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"patients\"\nColumns:\n(\"patient\", STRING, primary key)\n(\"birthdate\", DATE)\n(\"deathdate\", DATE)\n(\"ssn\", STRING)\n(\"drivers\", STRING)\n(\"passport\", STRING)\n(\"prefix\", STRING)\n(\"_first\", STRING)\n(\"_last\", STRING)\n(\"suffix\", STRING)\n(\"maiden\", STRING)\n(\"marital\", STRING)\n(\"race\", STRING)\n(\"ethnicity\", STRING)\n(\"gender\", STRING)\n(\"birthplace\", STRING)\n(\"address\", STRING)\n",
            "Table: \"conditions\"\nColumns:\n(\"START\", DATE)\n(\"STOP\", DATE)\n(\"PATIENT\", STRING)\n(\"ENCOUNTER\", STRING)\n(\"CODE\", BIGINT)\n(\"DESCRIPTION\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 102,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(strftime('%J', T2.STOP) - strftime('%J', T2.START)) AS REAL) / COUNT(T1.patient) FROM patients AS T1 INNER JOIN careplans AS T2 ON T1.patient = T2.PATIENT WHERE T1.prefix = 'Mr.' AND T1.first = 'Wesley' AND T1.last = 'Lemke'",
        "target_query": "SELECT CAST(EXTRACT(DAY FROM SUM(\"T2\".\"STOP\" - \"T2\".\"START\")) AS REAL) / COUNT(\"T1\".\"patient\") FROM \"patients\" AS \"T1\" INNER JOIN \"careplans\" AS \"T2\" ON \"T1\".\"patient\" = \"T2\".\"PATIENT\" WHERE \"T1\".\"prefix\" = 'Mr.' AND \"T1\".\"_first\" = 'Wesley' AND \"T1\".\"_last\" = 'Lemke'",
        "semantic_equivalent_type": "approximate_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 38,
                "dilatect_content": "strftime('%J', T2.STOP)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 42,
                "end_index": 65,
                "dilatect_content": "strftime('%J', T2.START)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `careplans`\nColumns:\n(`ID`, text)\n(`START`, date)\n(`STOP`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, real)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"patients\"\nColumns:\n(\"patient\", STRING, primary key)\n(\"birthdate\", DATE)\n(\"deathdate\", DATE)\n(\"ssn\", STRING)\n(\"drivers\", STRING)\n(\"passport\", STRING)\n(\"prefix\", STRING)\n(\"_first\", STRING)\n(\"_last\", STRING)\n(\"suffix\", STRING)\n(\"maiden\", STRING)\n(\"marital\", STRING)\n(\"race\", STRING)\n(\"ethnicity\", STRING)\n(\"gender\", STRING)\n(\"birthplace\", STRING)\n(\"address\", STRING)\n",
            "Table: \"careplans\"\nColumns:\n(\"ID\", STRING)\n(\"START\", DATE)\n(\"STOP\", DATE)\n(\"PATIENT\", STRING)\n(\"ENCOUNTER\", STRING)\n(\"CODE\", DOUBLE PRECISION)\n(\"DESCRIPTION\", STRING)\n(\"REASONCODE\", BIGINT)\n(\"REASONDESCRIPTION\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 105,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(PATIENT) FROM conditions WHERE DESCRIPTION = 'Diabetes' AND strftime('%Y', START) = '1988'",
        "target_query": "SELECT COUNT(\"PATIENT\") FROM \"conditions\" WHERE \"DESCRIPTION\" = 'Diabetes' AND sys.timestamp_to_str(\"START\", '%Y') = '1988';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 73,
                "end_index": 93,
                "dilatect_content": "strftime('%Y', START)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 85,
                "end_index": 121,
                "dilatect_content": "sys.timestamp_to_str(\"START\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `conditions`\nColumns:\n(`START`, date)\n(`STOP`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, integer)\n(`DESCRIPTION`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"conditions\"\nColumns:\n(\"START\", DATE)\n(\"STOP\", DATE)\n(\"PATIENT\", STRING)\n(\"ENCOUNTER\", STRING)\n(\"CODE\", BIGINT)\n(\"DESCRIPTION\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 106,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(DISTINCT T1.patient) FROM patients AS T1 INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Ibuprofen 200 MG Oral Tablet' AND T1.ethnicity = 'dominican' AND strftime('%Y', T2.START) = '2016' AND strftime('%m', T2.STOP) - strftime('%m', T2.START) = 1",
        "target_query": "SELECT COUNT(DISTINCT \"T1\".\"patient\") FROM \"patients\" AS \"T1\" INNER JOIN \"medications\" AS \"T2\" ON \"T1\".\"patient\" = \"T2\".\"PATIENT\" WHERE \"T2\".\"DESCRIPTION\" = 'Ibuprofen 200 MG Oral Tablet' AND \"T1\".\"ethnicity\" = 'dominican' AND sys.timestamp_to_str(\"T2\".\"START\", '%Y') = '2016' AND (EXTRACT(YEAR FROM \"T2\".\"STOP\") - EXTRACT(YEAR FROM \"T2\".\"START\")) * 12 + (EXTRACT(MONTH FROM \"T2\".\"STOP\") - EXTRACT(MONTH FROM \"T2\".\"START\")) = 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 199,
                "end_index": 222,
                "dilatect_content": "strftime('%Y', T2.START)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 237,
                "end_index": 259,
                "dilatect_content": "strftime('%m', T2.STOP)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 263,
                "end_index": 286,
                "dilatect_content": "strftime('%m', T2.START)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 255,
                "end_index": 298,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"START\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `medications`\nColumns:\n(`START`, date, primary key)\n(`STOP`, date)\n(`PATIENT`, text, primary key)\n(`ENCOUNTER`, text, primary key)\n(`CODE`, integer, primary key)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"patients\"\nColumns:\n(\"patient\", STRING, primary key)\n(\"birthdate\", DATE)\n(\"deathdate\", DATE)\n(\"ssn\", STRING)\n(\"drivers\", STRING)\n(\"passport\", STRING)\n(\"prefix\", STRING)\n(\"_first\", STRING)\n(\"_last\", STRING)\n(\"suffix\", STRING)\n(\"maiden\", STRING)\n(\"marital\", STRING)\n(\"race\", STRING)\n(\"ethnicity\", STRING)\n(\"gender\", STRING)\n(\"birthplace\", STRING)\n(\"address\", STRING)\n",
            "Table: \"medications\"\nColumns:\n(\"START\", DATE, primary key)\n(\"STOP\", DATE)\n(\"PATIENT\", STRING, primary key)\n(\"ENCOUNTER\", STRING, primary key)\n(\"CODE\", BIGINT, primary key)\n(\"DESCRIPTION\", STRING)\n(\"REASONCODE\", BIGINT)\n(\"REASONDESCRIPTION\", STRING)\n"
        ]
    },
    {
        "sql_id": 107,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(DISTINCT T1.patient) FROM patients AS T1 INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT WHERE DESCRIPTION = 'Pneumonia' AND strftime('%Y', T1.birthdate) LIKE '192%'",
        "target_query": "SELECT COUNT(DISTINCT \"T1\".\"patient\") FROM \"patients\" AS \"T1\" INNER JOIN \"conditions\" AS \"T2\" ON \"T1\".\"patient\" = \"T2\".\"PATIENT\" WHERE \"T2\".\"DESCRIPTION\" = 'Pneumonia' AND sys.timestamp_to_str(\"T1\".\"birthdate\", '%Y') LIKE '192%';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 145,
                "end_index": 172,
                "dilatect_content": "strftime('%Y', T1.birthdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 196,
                "end_index": 243,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"birthdate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `conditions`\nColumns:\n(`START`, date)\n(`STOP`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, integer)\n(`DESCRIPTION`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"patients\"\nColumns:\n(\"patient\", STRING, primary key)\n(\"birthdate\", DATE)\n(\"deathdate\", DATE)\n(\"ssn\", STRING)\n(\"drivers\", STRING)\n(\"passport\", STRING)\n(\"prefix\", STRING)\n(\"_first\", STRING)\n(\"_last\", STRING)\n(\"suffix\", STRING)\n(\"maiden\", STRING)\n(\"marital\", STRING)\n(\"race\", STRING)\n(\"ethnicity\", STRING)\n(\"gender\", STRING)\n(\"birthplace\", STRING)\n(\"address\", STRING)\n",
            "Table: \"conditions\"\nColumns:\n(\"START\", DATE)\n(\"STOP\", DATE)\n(\"PATIENT\", STRING)\n(\"ENCOUNTER\", STRING)\n(\"CODE\", BIGINT)\n(\"DESCRIPTION\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 108,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT T1.first, T1.last, T1.suffix FROM patients AS T1 INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Yaz 28 Day Pack' AND strftime('%Y', T2.START) = '2011'",
        "target_query": "SELECT DISTINCT \"T1\".\"_first\", \"T1\".\"_last\", \"T1\".\"suffix\" FROM \"patients\" AS \"T1\" INNER JOIN \"medications\" AS \"T2\" ON \"T1\".\"patient\" = \"T2\".\"PATIENT\" WHERE \"T2\".\"DESCRIPTION\" = 'Yaz 28 Day Pack' AND sys.timestamp_to_str(\"T2\".\"START\", '%Y') = '2011';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 166,
                "end_index": 189,
                "dilatect_content": "strftime('%Y', T2.START)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 232,
                "end_index": 275,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"START\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `medications`\nColumns:\n(`START`, date, primary key)\n(`STOP`, date)\n(`PATIENT`, text, primary key)\n(`ENCOUNTER`, text, primary key)\n(`CODE`, integer, primary key)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"patients\"\nColumns:\n(\"patient\", STRING, primary key)\n(\"birthdate\", DATE)\n(\"deathdate\", DATE)\n(\"ssn\", STRING)\n(\"drivers\", STRING)\n(\"passport\", STRING)\n(\"prefix\", STRING)\n(\"_first\", STRING)\n(\"_last\", STRING)\n(\"suffix\", STRING)\n(\"maiden\", STRING)\n(\"marital\", STRING)\n(\"race\", STRING)\n(\"ethnicity\", STRING)\n(\"gender\", STRING)\n(\"birthplace\", STRING)\n(\"address\", STRING)\n",
            "Table: \"medications\"\nColumns:\n(\"START\", DATE, primary key)\n(\"STOP\", DATE)\n(\"PATIENT\", STRING, primary key)\n(\"ENCOUNTER\", STRING, primary key)\n(\"CODE\", BIGINT, primary key)\n(\"DESCRIPTION\", STRING)\n(\"REASONCODE\", BIGINT)\n(\"REASONDESCRIPTION\", STRING)\n"
        ]
    },
    {
        "sql_id": 109,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(DISTINCT T1.patient) FROM patients AS T1 INNER JOIN immunizations AS T2 ON T1.patient = T2.PATIENT WHERE T1.race = 'black' AND T2.DESCRIPTION = 'DTaP' AND strftime('%Y', T2.DATE) = '2013'",
        "target_query": "SELECT COUNT(DISTINCT \"T1\".\"patient\") FROM \"patients\" AS \"T1\" INNER JOIN \"immunizations\" AS \"T2\" ON \"T1\".\"patient\" = \"T2\".\"PATIENT\" WHERE \"T1\".\"race\" = 'black' AND \"T2\".\"DESCRIPTION\" = 'DTaP' AND sys.timestamp_to_str(\"T2\".\"_DATE\", '%Y') = '2013';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 168,
                "end_index": 190,
                "dilatect_content": "strftime('%Y', T2.DATE)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 224,
                "end_index": 267,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"_DATE\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `immunizations`\nColumns:\n(`DATE`, date, primary key)\n(`PATIENT`, text, primary key)\n(`ENCOUNTER`, text, primary key)\n(`CODE`, integer, primary key)\n(`DESCRIPTION`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"patients\"\nColumns:\n(\"patient\", STRING, primary key)\n(\"birthdate\", DATE)\n(\"deathdate\", DATE)\n(\"ssn\", STRING)\n(\"drivers\", STRING)\n(\"passport\", STRING)\n(\"prefix\", STRING)\n(\"_first\", STRING)\n(\"_last\", STRING)\n(\"suffix\", STRING)\n(\"maiden\", STRING)\n(\"marital\", STRING)\n(\"race\", STRING)\n(\"ethnicity\", STRING)\n(\"gender\", STRING)\n(\"birthplace\", STRING)\n(\"address\", STRING)\n",
            "Table: \"immunizations\"\nColumns:\n(\"_DATE\", DATE, primary key)\n(\"PATIENT\", STRING, primary key)\n(\"ENCOUNTER\", STRING, primary key)\n(\"CODE\", BIGINT, primary key)\n(\"DESCRIPTION\", STRING)\n"
        ]
    },
    {
        "sql_id": 110,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT strftime('%Y', T2.deathdate) - strftime('%Y', T2.birthdate) AS age FROM conditions AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE T2.first = 'Giovanni' AND T2.last = 'Russel' AND T1.DESCRIPTION = 'Hypertension'",
        "target_query": "SELECT EXTRACT(YEAR FROM \"T2\".\"deathdate\") - EXTRACT(YEAR FROM \"T2\".\"birthdate\") AS age FROM \"conditions\" AS \"T1\" INNER JOIN \"patients\" AS \"T2\" ON \"T1\".\"PATIENT\" = \"T2\".\"patient\" WHERE \"T2\".\"_first\" = 'Giovanni' AND \"T2\".\"_last\" = 'Russel' AND \"T1\".\"DESCRIPTION\" = 'Hypertension';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 34,
                "dilatect_content": "strftime('%Y', T2.deathdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 38,
                "end_index": 65,
                "dilatect_content": "strftime('%Y', T2.birthdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 15,
                "end_index": 44,
                "dilatect_content": "YEAR FROM \"T2\".\"deathdate\"",
                "feature": ""
            },
            {
                "start_index": 57,
                "end_index": 86,
                "dilatect_content": "YEAR FROM \"T2\".\"birthdate\"",
                "feature": ""
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `conditions`\nColumns:\n(`START`, date)\n(`STOP`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, integer)\n(`DESCRIPTION`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"conditions\"\nColumns:\n(\"START\", DATE)\n(\"STOP\", DATE)\n(\"PATIENT\", STRING)\n(\"ENCOUNTER\", STRING)\n(\"CODE\", BIGINT)\n(\"DESCRIPTION\", STRING)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"patients\"\nColumns:\n(\"patient\", STRING, primary key)\n(\"birthdate\", DATE)\n(\"deathdate\", DATE)\n(\"ssn\", STRING)\n(\"drivers\", STRING)\n(\"passport\", STRING)\n(\"prefix\", STRING)\n(\"_first\", STRING)\n(\"_last\", STRING)\n(\"suffix\", STRING)\n(\"maiden\", STRING)\n(\"marital\", STRING)\n(\"race\", STRING)\n(\"ethnicity\", STRING)\n(\"gender\", STRING)\n(\"birthplace\", STRING)\n(\"address\", STRING)\n"
        ]
    },
    {
        "sql_id": 111,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.DESCRIPTION FROM conditions AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE T2.deathdate IS NOT NULL ORDER BY strftime('%Y', T2.deathdate) - strftime('%Y', T2.birthdate) DESC LIMIT 1",
        "target_query": "SELECT \"T1\".\"DESCRIPTION\" FROM \"conditions\" AS \"T1\" INNER JOIN \"patients\" AS \"T2\" ON \"T1\".\"PATIENT\" = \"T2\".\"patient\" WHERE \"T2\".\"deathdate\" IS NOT NULL ORDER BY (CAST(sys.timestamp_to_str(\"T2\".\"deathdate\", '%Y') AS INTEGER) - CAST(sys.timestamp_to_str(\"T2\".\"birthdate\", '%Y') AS INTEGER)) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 137,
                "end_index": 164,
                "dilatect_content": "strftime('%Y', T2.deathdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 168,
                "end_index": 195,
                "dilatect_content": "strftime('%Y', T2.birthdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 191,
                "end_index": 238,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"deathdate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 259,
                "end_index": 306,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"birthdate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `conditions`\nColumns:\n(`START`, date)\n(`STOP`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, integer)\n(`DESCRIPTION`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"conditions\"\nColumns:\n(\"START\", DATE)\n(\"STOP\", DATE)\n(\"PATIENT\", STRING)\n(\"ENCOUNTER\", STRING)\n(\"CODE\", BIGINT)\n(\"DESCRIPTION\", STRING)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"patients\"\nColumns:\n(\"patient\", STRING, primary key)\n(\"birthdate\", DATE)\n(\"deathdate\", DATE)\n(\"ssn\", STRING)\n(\"drivers\", STRING)\n(\"passport\", STRING)\n(\"prefix\", STRING)\n(\"_first\", STRING)\n(\"_last\", STRING)\n(\"suffix\", STRING)\n(\"maiden\", STRING)\n(\"marital\", STRING)\n(\"race\", STRING)\n(\"ethnicity\", STRING)\n(\"gender\", STRING)\n(\"birthplace\", STRING)\n(\"address\", STRING)\n"
        ]
    },
    {
        "sql_id": 113,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.first, T2.last , CASE WHEN T2.deathdate IS NULL THEN strftime('%Y', T1.DATE) - strftime('%Y', T2.birthdate) ELSE strftime('%Y', T2.deathdate) - strftime('%Y', T2.birthdate) END AS age FROM observations AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE T1.DESCRIPTION = 'Systolic Blood Pressure' AND T1.VALUE = 200 AND T1.UNITS = 'mmHg' AND strftime('%Y', T1.DATE) = '2011'",
        "target_query": "SELECT \"T2\".\"_first\", \"T2\".\"_last\", CASE WHEN \"T2\".\"deathdate\" IS NULL THEN CAST(SUBSTR(sys.timestamp_to_str(\"T1\".\"_DATE\", '%Y-%m-%d'), 1, 4) AS INTEGER) - CAST(SUBSTR(sys.timestamp_to_str(\"T2\".\"birthdate\", '%Y-%m-%d'), 1, 4) AS INTEGER) ELSE CAST(SUBSTR(sys.timestamp_to_str(\"T2\".\"deathdate\", '%Y-%m-%d'), 1, 4) AS INTEGER) - CAST(SUBSTR(sys.timestamp_to_str(\"T2\".\"birthdate\", '%Y-%m-%d'), 1, 4) AS INTEGER) END AS age FROM \"observations\" AS \"T1\" INNER JOIN \"patients\" AS \"T2\" ON \"T1\".\"PATIENT\" = \"T2\".\"patient\" WHERE \"T1\".\"DESCRIPTION\" = 'Systolic Blood Pressure' AND \"T1\".\"VALUE\" = 200 AND \"T1\".\"UNITS\" = 'mmHg' AND CAST(SUBSTR(sys.timestamp_to_str(\"T1\".\"_DATE\", '%Y-%m-%d'), 1, 4) AS INTEGER) = 2011;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 63,
                "end_index": 85,
                "dilatect_content": "strftime('%Y', T1.DATE)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 89,
                "end_index": 116,
                "dilatect_content": "strftime('%Y', T2.birthdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 123,
                "end_index": 150,
                "dilatect_content": "strftime('%Y', T2.deathdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 154,
                "end_index": 181,
                "dilatect_content": "strftime('%Y', T2.birthdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 365,
                "end_index": 387,
                "dilatect_content": "strftime('%Y', T1.DATE)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 100,
                "end_index": 149,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"_DATE\", '%Y-%m-%d')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 184,
                "end_index": 237,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"birthdate\", '%Y-%m-%d')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 275,
                "end_index": 328,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"deathdate\", '%Y-%m-%d')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 363,
                "end_index": 416,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"birthdate\", '%Y-%m-%d')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 687,
                "end_index": 736,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"_DATE\", '%Y-%m-%d')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `observations`\nColumns:\n(`DATE`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, text)\n(`DESCRIPTION`, text)\n(`VALUE`, real)\n(`UNITS`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"observations\"\nColumns:\n(\"_DATE\", DATE)\n(\"PATIENT\", STRING)\n(\"ENCOUNTER\", STRING)\n(\"CODE\", STRING)\n(\"DESCRIPTION\", STRING)\n(\"VALUE\", DOUBLE PRECISION)\n(\"UNITS\", STRING)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"patients\"\nColumns:\n(\"patient\", STRING, primary key)\n(\"birthdate\", DATE)\n(\"deathdate\", DATE)\n(\"ssn\", STRING)\n(\"drivers\", STRING)\n(\"passport\", STRING)\n(\"prefix\", STRING)\n(\"_first\", STRING)\n(\"_last\", STRING)\n(\"suffix\", STRING)\n(\"maiden\", STRING)\n(\"marital\", STRING)\n(\"race\", STRING)\n(\"ethnicity\", STRING)\n(\"gender\", STRING)\n(\"birthplace\", STRING)\n(\"address\", STRING)\n"
        ]
    },
    {
        "sql_id": 114,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(CASE WHEN T2.DESCRIPTION = 'Influenza seasonal injectable preservative free' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.patient), SUM(CASE WHEN T1.ethnicity = 'english' THEN 1 ELSE 0 END) FROM patients AS T1 INNER JOIN immunizations AS T2 ON T1.patient = T2.PATIENT WHERE strftime('%Y', T2.DATE) = '2017'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"DESCRIPTION\" = 'Influenza seasonal injectable preservative free' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"patient\"), SUM(CASE WHEN \"T1\".\"ethnicity\" = 'english' THEN 1 ELSE 0 END) FROM \"patients\" AS \"T1\" INNER JOIN \"immunizations\" AS \"T2\" ON \"T1\".\"patient\" = \"T2\".\"PATIENT\" WHERE sys.timestamp_to_str(\"T2\".\"_DATE\", '%Y') = '2017';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 290,
                "end_index": 312,
                "dilatect_content": "strftime('%Y', T2.DATE)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 346,
                "end_index": 389,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"_DATE\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `immunizations`\nColumns:\n(`DATE`, date, primary key)\n(`PATIENT`, text, primary key)\n(`ENCOUNTER`, text, primary key)\n(`CODE`, integer, primary key)\n(`DESCRIPTION`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"patients\"\nColumns:\n(\"patient\", STRING, primary key)\n(\"birthdate\", DATE)\n(\"deathdate\", DATE)\n(\"ssn\", STRING)\n(\"drivers\", STRING)\n(\"passport\", STRING)\n(\"prefix\", STRING)\n(\"_first\", STRING)\n(\"_last\", STRING)\n(\"suffix\", STRING)\n(\"maiden\", STRING)\n(\"marital\", STRING)\n(\"race\", STRING)\n(\"ethnicity\", STRING)\n(\"gender\", STRING)\n(\"birthplace\", STRING)\n(\"address\", STRING)\n",
            "Table: \"immunizations\"\nColumns:\n(\"_DATE\", DATE, primary key)\n(\"PATIENT\", STRING, primary key)\n(\"ENCOUNTER\", STRING, primary key)\n(\"CODE\", BIGINT, primary key)\n(\"DESCRIPTION\", STRING)\n"
        ]
    },
    {
        "sql_id": 115,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(CASE WHEN T1.deathdate IS NULL THEN strftime('%Y', T2.STOP) - strftime('%Y', T1.birthdate) ELSE strftime('%Y', T1.deathdate) - strftime('%Y', T1.birthdate) END) AS REAL) / COUNT(DISTINCT T1.patient) FROM patients AS T1 INNER JOIN careplans AS T2 ON T1.patient = T2.PATIENT WHERE T2.REASONDESCRIPTION = 'Prediabetes'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T1\".\"deathdate\" IS NULL THEN EXTRACT(YEAR FROM \"T2\".\"STOP\") - EXTRACT(YEAR FROM \"T1\".\"birthdate\") ELSE EXTRACT(YEAR FROM \"T1\".\"deathdate\") - EXTRACT(YEAR FROM \"T1\".\"birthdate\") END) AS REAL) / COUNT(DISTINCT \"T1\".\"patient\") FROM \"patients\" AS \"T1\" INNER JOIN \"careplans\" AS \"T2\" ON \"T1\".\"patient\" = \"T2\".\"PATIENT\" WHERE \"T2\".\"REASONDESCRIPTION\" = 'Prediabetes';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 52,
                "end_index": 74,
                "dilatect_content": "strftime('%Y', T2.STOP)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 78,
                "end_index": 105,
                "dilatect_content": "strftime('%Y', T1.birthdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 112,
                "end_index": 139,
                "dilatect_content": "strftime('%Y', T1.deathdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 143,
                "end_index": 170,
                "dilatect_content": "strftime('%Y', T1.birthdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 68,
                "end_index": 92,
                "dilatect_content": "YEAR FROM \"T2\".\"STOP\"",
                "feature": ""
            },
            {
                "start_index": 105,
                "end_index": 134,
                "dilatect_content": "YEAR FROM \"T1\".\"birthdate\"",
                "feature": ""
            },
            {
                "start_index": 150,
                "end_index": 179,
                "dilatect_content": "YEAR FROM \"T1\".\"deathdate\"",
                "feature": ""
            },
            {
                "start_index": 192,
                "end_index": 221,
                "dilatect_content": "YEAR FROM \"T1\".\"birthdate\"",
                "feature": ""
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `careplans`\nColumns:\n(`ID`, text)\n(`START`, date)\n(`STOP`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, real)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"patients\"\nColumns:\n(\"patient\", STRING, primary key)\n(\"birthdate\", DATE)\n(\"deathdate\", DATE)\n(\"ssn\", STRING)\n(\"drivers\", STRING)\n(\"passport\", STRING)\n(\"prefix\", STRING)\n(\"_first\", STRING)\n(\"_last\", STRING)\n(\"suffix\", STRING)\n(\"maiden\", STRING)\n(\"marital\", STRING)\n(\"race\", STRING)\n(\"ethnicity\", STRING)\n(\"gender\", STRING)\n(\"birthplace\", STRING)\n(\"address\", STRING)\n",
            "Table: \"careplans\"\nColumns:\n(\"ID\", STRING)\n(\"START\", DATE)\n(\"STOP\", DATE)\n(\"PATIENT\", STRING)\n(\"ENCOUNTER\", STRING)\n(\"CODE\", DOUBLE PRECISION)\n(\"DESCRIPTION\", STRING)\n(\"REASONCODE\", BIGINT)\n(\"REASONDESCRIPTION\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 117,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT T1.first, T1.last FROM patients AS T1 INNER JOIN careplans AS T2 ON T1.patient = T2.PATIENT WHERE T1.marital = 'M' AND strftime('%J', T2.STOP) - strftime('%J', T2.START) > 60",
        "target_query": "SELECT DISTINCT \"T1\".\"_first\", \"T1\".\"_last\" FROM \"patients\" AS \"T1\" INNER JOIN \"careplans\" AS \"T2\" ON \"T1\".\"patient\" = \"T2\".\"PATIENT\" WHERE \"T1\".\"marital\" = 'M' AND \"T2\".\"STOP\" > sql_add(\"T2\".\"START\", interval '60' day);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 135,
                "end_index": 157,
                "dilatect_content": "strftime('%J', T2.STOP)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 161,
                "end_index": 184,
                "dilatect_content": "strftime('%J', T2.START)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `careplans`\nColumns:\n(`ID`, text)\n(`START`, date)\n(`STOP`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, real)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"patients\"\nColumns:\n(\"patient\", STRING, primary key)\n(\"birthdate\", DATE)\n(\"deathdate\", DATE)\n(\"ssn\", STRING)\n(\"drivers\", STRING)\n(\"passport\", STRING)\n(\"prefix\", STRING)\n(\"_first\", STRING)\n(\"_last\", STRING)\n(\"suffix\", STRING)\n(\"maiden\", STRING)\n(\"marital\", STRING)\n(\"race\", STRING)\n(\"ethnicity\", STRING)\n(\"gender\", STRING)\n(\"birthplace\", STRING)\n(\"address\", STRING)\n",
            "Table: \"careplans\"\nColumns:\n(\"ID\", STRING)\n(\"START\", DATE)\n(\"STOP\", DATE)\n(\"PATIENT\", STRING)\n(\"ENCOUNTER\", STRING)\n(\"CODE\", DOUBLE PRECISION)\n(\"DESCRIPTION\", STRING)\n(\"REASONCODE\", BIGINT)\n(\"REASONDESCRIPTION\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 119,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(DISTINCT T1.patient) FROM patients AS T1 INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE T1.marital = 'S' AND T2.REASONDESCRIPTION = 'Cystitis' AND T2.DESCRIPTION = 'Nitrofurantoin 5 MG/ML [Furadantin]' AND strftime('%Y', T2.START) = '2010'",
        "target_query": "SELECT COUNT(DISTINCT \"T1\".\"patient\") FROM \"patients\" AS \"T1\" INNER JOIN \"medications\" AS \"T2\" ON \"T1\".\"patient\" = \"T2\".\"PATIENT\" WHERE \"T1\".\"marital\" = 'S' AND \"T2\".\"REASONDESCRIPTION\" = 'Cystitis' AND \"T2\".\"DESCRIPTION\" = 'Nitrofurantoin 5 MG/ML [Furadantin]' AND sys.timestamp_to_str(\"T2\".\"START\", '%Y') = '2010';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 234,
                "end_index": 258,
                "dilatect_content": "strftime('%Y', T2.START)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 298,
                "end_index": 341,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"START\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `medications`\nColumns:\n(`START`, date, primary key)\n(`STOP`, date)\n(`PATIENT`, text, primary key)\n(`ENCOUNTER`, text, primary key)\n(`CODE`, integer, primary key)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"patients\"\nColumns:\n(\"patient\", STRING, primary key)\n(\"birthdate\", DATE)\n(\"deathdate\", DATE)\n(\"ssn\", STRING)\n(\"drivers\", STRING)\n(\"passport\", STRING)\n(\"prefix\", STRING)\n(\"_first\", STRING)\n(\"_last\", STRING)\n(\"suffix\", STRING)\n(\"maiden\", STRING)\n(\"marital\", STRING)\n(\"race\", STRING)\n(\"ethnicity\", STRING)\n(\"gender\", STRING)\n(\"birthplace\", STRING)\n(\"address\", STRING)\n",
            "Table: \"medications\"\nColumns:\n(\"START\", DATE, primary key)\n(\"STOP\", DATE)\n(\"PATIENT\", STRING, primary key)\n(\"ENCOUNTER\", STRING, primary key)\n(\"CODE\", BIGINT, primary key)\n(\"DESCRIPTION\", STRING)\n(\"REASONCODE\", BIGINT)\n(\"REASONDESCRIPTION\", STRING)\n"
        ]
    },
    {
        "sql_id": 120,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.REASONDESCRIPTION, T2.DESCRIPTION , strftime('%J', T2.STOP) - strftime('%J', T2.START) AS days , CASE WHEN T1.deathdate IS NULL THEN 'alive' ELSE 'dead' END FROM patients AS T1 INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE T2.ENCOUNTER = '23c293ec-dbae-4a22-896e-f12cf3c8bac3'",
        "target_query": "SELECT \"T2\".\"REASONDESCRIPTION\", \"T2\".\"DESCRIPTION\", (CAST(\"T2\".\"STOP\" AS DATE) - CAST(\"T2\".\"START\" AS DATE)) AS \"days\", CASE WHEN \"T1\".\"deathdate\" IS NULL THEN 'alive' ELSE 'dead' END FROM \"patients\" AS \"T1\" INNER JOIN \"medications\" AS \"T2\" ON \"T1\".\"patient\" = \"T2\".\"PATIENT\" WHERE \"T2\".\"ENCOUNTER\" = '23c293ec-dbae-4a22-896e-f12cf3c8bac3'",
        "semantic_equivalent_type": "approximate_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 46,
                "end_index": 68,
                "dilatect_content": "strftime('%J', T2.STOP)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 72,
                "end_index": 95,
                "dilatect_content": "strftime('%J', T2.START)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `medications`\nColumns:\n(`START`, date, primary key)\n(`STOP`, date)\n(`PATIENT`, text, primary key)\n(`ENCOUNTER`, text, primary key)\n(`CODE`, integer, primary key)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"patients\"\nColumns:\n(\"patient\", STRING, primary key)\n(\"birthdate\", DATE)\n(\"deathdate\", DATE)\n(\"ssn\", STRING)\n(\"drivers\", STRING)\n(\"passport\", STRING)\n(\"prefix\", STRING)\n(\"_first\", STRING)\n(\"_last\", STRING)\n(\"suffix\", STRING)\n(\"maiden\", STRING)\n(\"marital\", STRING)\n(\"race\", STRING)\n(\"ethnicity\", STRING)\n(\"gender\", STRING)\n(\"birthplace\", STRING)\n(\"address\", STRING)\n",
            "Table: \"medications\"\nColumns:\n(\"START\", DATE, primary key)\n(\"STOP\", DATE)\n(\"PATIENT\", STRING, primary key)\n(\"ENCOUNTER\", STRING, primary key)\n(\"CODE\", BIGINT, primary key)\n(\"DESCRIPTION\", STRING)\n(\"REASONCODE\", BIGINT)\n(\"REASONDESCRIPTION\", STRING)\n"
        ]
    },
    {
        "sql_id": 121,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.first, T1.last FROM patients AS T1 INNER JOIN allergies AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Shellfish allergy' AND CAST((strftime('%J', T1.deathdate) - strftime('%J', T1.birthdate)) AS REAL) / 365 < 12",
        "target_query": "SELECT T1.\"_first\", T1.\"_last\" FROM \"patients\" AS T1 INNER JOIN \"allergies\" AS T2 ON T1.\"patient\" = T2.\"PATIENT\" WHERE T2.\"DESCRIPTION\" = 'Shellfish allergy' AND (EXTRACT(DAY FROM (T1.\"deathdate\" - T1.\"birthdate\")) / 365) < 12;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 152,
                "end_index": 179,
                "dilatect_content": "strftime('%J', T1.deathdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 183,
                "end_index": 210,
                "dilatect_content": "strftime('%J', T1.birthdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `allergies`\nColumns:\n(`START`, text)\n(`STOP`, text)\n(`PATIENT`, text, primary key)\n(`ENCOUNTER`, text, primary key)\n(`CODE`, integer, primary key)\n(`DESCRIPTION`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"patients\"\nColumns:\n(\"patient\", STRING, primary key)\n(\"birthdate\", DATE)\n(\"deathdate\", DATE)\n(\"ssn\", STRING)\n(\"drivers\", STRING)\n(\"passport\", STRING)\n(\"prefix\", STRING)\n(\"_first\", STRING)\n(\"_last\", STRING)\n(\"suffix\", STRING)\n(\"maiden\", STRING)\n(\"marital\", STRING)\n(\"race\", STRING)\n(\"ethnicity\", STRING)\n(\"gender\", STRING)\n(\"birthplace\", STRING)\n(\"address\", STRING)\n",
            "Table: \"allergies\"\nColumns:\n(\"START\", STRING)\n(\"STOP\", STRING)\n(\"PATIENT\", STRING, primary key)\n(\"ENCOUNTER\", STRING, primary key)\n(\"CODE\", BIGINT, primary key)\n(\"DESCRIPTION\", STRING)\n"
        ]
    },
    {
        "sql_id": 123,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.DESCRIPTION FROM patients AS T1 INNER JOIN careplans AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Elly' AND T1.last = 'Koss' AND strftime('%Y', T2.START) = '2013'",
        "target_query": "SELECT \"T2\".\"DESCRIPTION\" FROM \"patients\" AS \"T1\" INNER JOIN \"careplans\" AS \"T2\" ON \"T1\".\"patient\" = \"T2\".\"PATIENT\" WHERE \"T1\".\"_first\" = 'Elly' AND \"T1\".\"_last\" = 'Koss' AND sys.timestamp_to_str(\"T2\".\"START\", '%Y') = '2013';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 145,
                "end_index": 168,
                "dilatect_content": "strftime('%Y', T2.START)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 203,
                "end_index": 246,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"START\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `careplans`\nColumns:\n(`ID`, text)\n(`START`, date)\n(`STOP`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, real)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"patients\"\nColumns:\n(\"patient\", STRING, primary key)\n(\"birthdate\", DATE)\n(\"deathdate\", DATE)\n(\"ssn\", STRING)\n(\"drivers\", STRING)\n(\"passport\", STRING)\n(\"prefix\", STRING)\n(\"_first\", STRING)\n(\"_last\", STRING)\n(\"suffix\", STRING)\n(\"maiden\", STRING)\n(\"marital\", STRING)\n(\"race\", STRING)\n(\"ethnicity\", STRING)\n(\"gender\", STRING)\n(\"birthplace\", STRING)\n(\"address\", STRING)\n",
            "Table: \"careplans\"\nColumns:\n(\"ID\", STRING)\n(\"START\", DATE)\n(\"STOP\", DATE)\n(\"PATIENT\", STRING)\n(\"ENCOUNTER\", STRING)\n(\"CODE\", DOUBLE PRECISION)\n(\"DESCRIPTION\", STRING)\n(\"REASONCODE\", BIGINT)\n(\"REASONDESCRIPTION\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 126,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(COUNT(PATIENT) AS REAL) / COUNT(DISTINCT strftime('%Y', DATE)) FROM procedures WHERE DESCRIPTION = 'Combined chemotherapy and radiation therapy (procedure)'",
        "target_query": "SELECT CAST(COUNT(\"PATIENT\") AS REAL) / COUNT(DISTINCT sys.timestamp_to_str(\"procedures\".\"_DATE\", '%Y')) FROM \"procedures\" WHERE \"DESCRIPTION\" = 'Combined chemotherapy and radiation therapy (procedure)'",
        "semantic_equivalent_type": "approximate_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 53,
                "end_index": 72,
                "dilatect_content": "strftime('%Y', DATE)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 57,
                "end_index": 108,
                "dilatect_content": "sys.timestamp_to_str(\"procedures\".\"_DATE\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `procedures`\nColumns:\n(`DATE`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, integer)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"procedures\"\nColumns:\n(\"_DATE\", DATE)\n(\"PATIENT\", STRING)\n(\"ENCOUNTER\", STRING)\n(\"CODE\", BIGINT)\n(\"DESCRIPTION\", STRING)\n(\"REASONCODE\", BIGINT)\n(\"REASONDESCRIPTION\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 127,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT strftime('%J', T2.STOP) - strftime('%J', T2.START) AS timeFrame , T2.DESCRIPTION FROM patients AS T1 INNER JOIN careplans AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Jacquelyn' AND T1.last = 'Shanahan' ORDER BY T2.START DESC LIMIT 1",
        "target_query": "SELECT (CAST(\"T2\".\"STOP\" AS DATE) - CAST(\"T2\".\"START\" AS DATE)) AS \"timeFrame\", \"T2\".\"DESCRIPTION\" FROM \"patients\" AS \"T1\" INNER JOIN \"careplans\" AS \"T2\" ON \"T1\".\"patient\" = \"T2\".\"PATIENT\" WHERE \"T1\".\"_first\" = 'Jacquelyn' AND \"T1\".\"_last\" = 'Shanahan' ORDER BY \"T2\".\"START\" DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 29,
                "dilatect_content": "strftime('%J', T2.STOP)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 33,
                "end_index": 56,
                "dilatect_content": "strftime('%J', T2.START)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `careplans`\nColumns:\n(`ID`, text)\n(`START`, date)\n(`STOP`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, real)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"patients\"\nColumns:\n(\"patient\", STRING, primary key)\n(\"birthdate\", DATE)\n(\"deathdate\", DATE)\n(\"ssn\", STRING)\n(\"drivers\", STRING)\n(\"passport\", STRING)\n(\"prefix\", STRING)\n(\"_first\", STRING)\n(\"_last\", STRING)\n(\"suffix\", STRING)\n(\"maiden\", STRING)\n(\"marital\", STRING)\n(\"race\", STRING)\n(\"ethnicity\", STRING)\n(\"gender\", STRING)\n(\"birthplace\", STRING)\n(\"address\", STRING)\n",
            "Table: \"careplans\"\nColumns:\n(\"ID\", STRING)\n(\"START\", DATE)\n(\"STOP\", DATE)\n(\"PATIENT\", STRING)\n(\"ENCOUNTER\", STRING)\n(\"CODE\", DOUBLE PRECISION)\n(\"DESCRIPTION\", STRING)\n(\"REASONCODE\", BIGINT)\n(\"REASONDESCRIPTION\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 128,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.DESCRIPTION FROM patients AS T1 INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Joye' AND T1.last = 'Homenick' AND strftime('%Y', T2.START) = '2017'",
        "target_query": "SELECT \"T2\".\"DESCRIPTION\" FROM \"patients\" AS \"T1\" INNER JOIN \"conditions\" AS \"T2\" ON \"T1\".\"patient\" = \"T2\".\"PATIENT\" WHERE \"T1\".\"_first\" = 'Joye' AND \"T1\".\"_last\" = 'Homenick' AND sys.timestamp_to_str(\"T2\".\"START\", '%Y') = '2017';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 150,
                "end_index": 173,
                "dilatect_content": "strftime('%Y', T2.START)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 208,
                "end_index": 251,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"START\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `conditions`\nColumns:\n(`START`, date)\n(`STOP`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, integer)\n(`DESCRIPTION`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"patients\"\nColumns:\n(\"patient\", STRING, primary key)\n(\"birthdate\", DATE)\n(\"deathdate\", DATE)\n(\"ssn\", STRING)\n(\"drivers\", STRING)\n(\"passport\", STRING)\n(\"prefix\", STRING)\n(\"_first\", STRING)\n(\"_last\", STRING)\n(\"suffix\", STRING)\n(\"maiden\", STRING)\n(\"marital\", STRING)\n(\"race\", STRING)\n(\"ethnicity\", STRING)\n(\"gender\", STRING)\n(\"birthplace\", STRING)\n(\"address\", STRING)\n",
            "Table: \"conditions\"\nColumns:\n(\"START\", DATE)\n(\"STOP\", DATE)\n(\"PATIENT\", STRING)\n(\"ENCOUNTER\", STRING)\n(\"CODE\", BIGINT)\n(\"DESCRIPTION\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 129,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT strftime('%J', T2.STOP) - strftime('%J', T2.START) AS days FROM patients AS T1 INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Elly' AND last = 'Koss' AND T2.DESCRIPTION = 'Acetaminophen 160 MG'",
        "target_query": "SELECT (\"T2\".\"STOP\" - \"T2\".\"START\") AS \"days\" FROM \"patients\" AS \"T1\" INNER JOIN \"medications\" AS \"T2\" ON \"T1\".\"patient\" = \"T2\".\"PATIENT\" WHERE \"T1\".\"_first\" = 'Elly' AND \"T1\".\"_last\" = 'Koss' AND \"T2\".\"DESCRIPTION\" = 'Acetaminophen 160 MG'",
        "semantic_equivalent_type": "approximate_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 29,
                "dilatect_content": "strftime('%J', T2.STOP)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 33,
                "end_index": 56,
                "dilatect_content": "strftime('%J', T2.START)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `medications`\nColumns:\n(`START`, date, primary key)\n(`STOP`, date)\n(`PATIENT`, text, primary key)\n(`ENCOUNTER`, text, primary key)\n(`CODE`, integer, primary key)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"patients\"\nColumns:\n(\"patient\", STRING, primary key)\n(\"birthdate\", DATE)\n(\"deathdate\", DATE)\n(\"ssn\", STRING)\n(\"drivers\", STRING)\n(\"passport\", STRING)\n(\"prefix\", STRING)\n(\"_first\", STRING)\n(\"_last\", STRING)\n(\"suffix\", STRING)\n(\"maiden\", STRING)\n(\"marital\", STRING)\n(\"race\", STRING)\n(\"ethnicity\", STRING)\n(\"gender\", STRING)\n(\"birthplace\", STRING)\n(\"address\", STRING)\n",
            "Table: \"medications\"\nColumns:\n(\"START\", DATE, primary key)\n(\"STOP\", DATE)\n(\"PATIENT\", STRING, primary key)\n(\"ENCOUNTER\", STRING, primary key)\n(\"CODE\", BIGINT, primary key)\n(\"DESCRIPTION\", STRING)\n(\"REASONCODE\", BIGINT)\n(\"REASONDESCRIPTION\", STRING)\n"
        ]
    },
    {
        "sql_id": 130,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(CASE WHEN T2.gender = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.PATIENT) FROM encounters AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE strftime('%Y', T1.DATE) = '2010' AND T1.REASONDESCRIPTION = 'Contact dermatitis'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"gender\" = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"PATIENT\") FROM \"encounters\" AS \"T1\" INNER JOIN \"patients\" AS \"T2\" ON \"T1\".\"PATIENT\" = \"T2\".\"patient\" WHERE sys.timestamp_to_str(\"T1\".\"_DATE\", '%Y') = '2010' AND \"T1\".\"REASONDESCRIPTION\" = 'Contact dermatitis'",
        "semantic_equivalent_type": "approximate_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 177,
                "end_index": 199,
                "dilatect_content": "strftime('%Y', T1.DATE)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 225,
                "end_index": 268,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"_DATE\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `encounters`\nColumns:\n(`ID`, text, primary key)\n(`DATE`, date)\n(`PATIENT`, text)\n(`CODE`, integer)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n",
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"encounters\"\nColumns:\n(\"ID\", STRING, primary key)\n(\"_DATE\", DATE)\n(\"PATIENT\", STRING)\n(\"CODE\", BIGINT)\n(\"DESCRIPTION\", STRING)\n(\"REASONCODE\", BIGINT)\n(\"REASONDESCRIPTION\", STRING)\n",
            "Table: \"patients\"\nColumns:\n(\"patient\", STRING, primary key)\n(\"birthdate\", DATE)\n(\"deathdate\", DATE)\n(\"ssn\", STRING)\n(\"drivers\", STRING)\n(\"passport\", STRING)\n(\"prefix\", STRING)\n(\"_first\", STRING)\n(\"_last\", STRING)\n(\"suffix\", STRING)\n(\"maiden\", STRING)\n(\"marital\", STRING)\n(\"race\", STRING)\n(\"ethnicity\", STRING)\n(\"gender\", STRING)\n(\"birthplace\", STRING)\n(\"address\", STRING)\n"
        ]
    },
    {
        "sql_id": 131,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T1.patient) , CAST(SUM(CASE WHEN T2.DESCRIPTION = 'Prenatal visit' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.patient) FROM patients AS T1 INNER JOIN encounters AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Lorri' AND T1.last = 'Simonis' AND strftime('%Y', T2.DATE) BETWEEN '2010' AND '2017'",
        "target_query": "SELECT COUNT(\"T1\".\"patient\"), CAST(SUM(CASE WHEN \"T2\".\"DESCRIPTION\" = 'Prenatal visit' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"patient\") FROM \"patients\" AS \"T1\" INNER JOIN \"encounters\" AS \"T2\" ON \"T1\".\"patient\" = \"T2\".\"PATIENT\" WHERE \"T1\".\"_first\" = 'Lorri' AND \"T1\".\"_last\" = 'Simonis' AND sys.timestamp_to_str(\"T2\".\"_DATE\", '%Y') BETWEEN '2010' AND '2017';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 262,
                "end_index": 284,
                "dilatect_content": "strftime('%Y', T2.DATE)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 335,
                "end_index": 378,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"_DATE\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `encounters`\nColumns:\n(`ID`, text, primary key)\n(`DATE`, date)\n(`PATIENT`, text)\n(`CODE`, integer)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"patients\"\nColumns:\n(\"patient\", STRING, primary key)\n(\"birthdate\", DATE)\n(\"deathdate\", DATE)\n(\"ssn\", STRING)\n(\"drivers\", STRING)\n(\"passport\", STRING)\n(\"prefix\", STRING)\n(\"_first\", STRING)\n(\"_last\", STRING)\n(\"suffix\", STRING)\n(\"maiden\", STRING)\n(\"marital\", STRING)\n(\"race\", STRING)\n(\"ethnicity\", STRING)\n(\"gender\", STRING)\n(\"birthplace\", STRING)\n(\"address\", STRING)\n",
            "Table: \"encounters\"\nColumns:\n(\"ID\", STRING, primary key)\n(\"_DATE\", DATE)\n(\"PATIENT\", STRING)\n(\"CODE\", BIGINT)\n(\"DESCRIPTION\", STRING)\n(\"REASONCODE\", BIGINT)\n(\"REASONDESCRIPTION\", STRING)\n"
        ]
    },
    {
        "sql_id": 132,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(CASE WHEN T2.race = 'hispanic' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.PATIENT) FROM careplans AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE strftime('%Y', T1.stop) = '2011'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"race\" = 'hispanic' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"PATIENT\") FROM \"careplans\" AS \"T1\" INNER JOIN \"patients\" AS \"T2\" ON \"T1\".\"PATIENT\" = \"T2\".\"patient\" WHERE sys.timestamp_to_str(\"T1\".\"STOP\", '%Y') = '2011';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 181,
                "end_index": 203,
                "dilatect_content": "strftime('%Y', T1.stop)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 229,
                "end_index": 271,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"STOP\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `careplans`\nColumns:\n(`ID`, text)\n(`START`, date)\n(`STOP`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, real)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"careplans\"\nColumns:\n(\"ID\", STRING)\n(\"START\", DATE)\n(\"STOP\", DATE)\n(\"PATIENT\", STRING)\n(\"ENCOUNTER\", STRING)\n(\"CODE\", DOUBLE PRECISION)\n(\"DESCRIPTION\", STRING)\n(\"REASONCODE\", BIGINT)\n(\"REASONDESCRIPTION\", STRING)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"patients\"\nColumns:\n(\"patient\", STRING, primary key)\n(\"birthdate\", DATE)\n(\"deathdate\", DATE)\n(\"ssn\", STRING)\n(\"drivers\", STRING)\n(\"passport\", STRING)\n(\"prefix\", STRING)\n(\"_first\", STRING)\n(\"_last\", STRING)\n(\"suffix\", STRING)\n(\"maiden\", STRING)\n(\"marital\", STRING)\n(\"race\", STRING)\n(\"ethnicity\", STRING)\n(\"gender\", STRING)\n(\"birthplace\", STRING)\n(\"address\", STRING)\n"
        ]
    },
    {
        "sql_id": 133,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(CASE WHEN T2.gender = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.PATIENT) AS percentage FROM careplans AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE strftime('%Y', T1.START) = '2010'",
        "target_query": "SELECT SUM(CASE WHEN \"T2\".\"gender\" = 'F' THEN 1 ELSE 0 END) * 100.0 / CAST(COUNT(\"T1\".\"PATIENT\") AS DOUBLE PRECISION) AS percentage FROM \"careplans\" AS \"T1\" INNER JOIN \"patients\" AS \"T2\" ON \"T1\".\"PATIENT\" = \"T2\".\"patient\" WHERE sys.timestamp_to_str(\"T1\".\"START\", '%Y') = '2010';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 190,
                "end_index": 213,
                "dilatect_content": "strftime('%Y', T1.START)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 252,
                "end_index": 295,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"START\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `careplans`\nColumns:\n(`ID`, text)\n(`START`, date)\n(`STOP`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, real)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"careplans\"\nColumns:\n(\"ID\", STRING)\n(\"START\", DATE)\n(\"STOP\", DATE)\n(\"PATIENT\", STRING)\n(\"ENCOUNTER\", STRING)\n(\"CODE\", DOUBLE PRECISION)\n(\"DESCRIPTION\", STRING)\n(\"REASONCODE\", BIGINT)\n(\"REASONDESCRIPTION\", STRING)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"patients\"\nColumns:\n(\"patient\", STRING, primary key)\n(\"birthdate\", DATE)\n(\"deathdate\", DATE)\n(\"ssn\", STRING)\n(\"drivers\", STRING)\n(\"passport\", STRING)\n(\"prefix\", STRING)\n(\"_first\", STRING)\n(\"_last\", STRING)\n(\"suffix\", STRING)\n(\"maiden\", STRING)\n(\"marital\", STRING)\n(\"race\", STRING)\n(\"ethnicity\", STRING)\n(\"gender\", STRING)\n(\"birthplace\", STRING)\n(\"address\", STRING)\n"
        ]
    },
    {
        "sql_id": 134,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(DISTINCT T2.patient) FROM careplans AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE T2.race = 'black' AND strftime('%Y', T1.STOP) = '2017'",
        "target_query": "SELECT COUNT(DISTINCT \"T2\".\"patient\") FROM \"careplans\" AS \"T1\" INNER JOIN \"patients\" AS \"T2\" ON \"T1\".\"PATIENT\" = \"T2\".\"patient\" WHERE \"T2\".\"race\" = 'black' AND sys.timestamp_to_str(\"T1\".\"STOP\", '%Y') = '2017';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 136,
                "end_index": 158,
                "dilatect_content": "strftime('%Y', T1.STOP)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 184,
                "end_index": 226,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"STOP\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `careplans`\nColumns:\n(`ID`, text)\n(`START`, date)\n(`STOP`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, real)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"careplans\"\nColumns:\n(\"ID\", STRING)\n(\"START\", DATE)\n(\"STOP\", DATE)\n(\"PATIENT\", STRING)\n(\"ENCOUNTER\", STRING)\n(\"CODE\", DOUBLE PRECISION)\n(\"DESCRIPTION\", STRING)\n(\"REASONCODE\", BIGINT)\n(\"REASONDESCRIPTION\", STRING)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"patients\"\nColumns:\n(\"patient\", STRING, primary key)\n(\"birthdate\", DATE)\n(\"deathdate\", DATE)\n(\"ssn\", STRING)\n(\"drivers\", STRING)\n(\"passport\", STRING)\n(\"prefix\", STRING)\n(\"_first\", STRING)\n(\"_last\", STRING)\n(\"suffix\", STRING)\n(\"maiden\", STRING)\n(\"marital\", STRING)\n(\"race\", STRING)\n(\"ethnicity\", STRING)\n(\"gender\", STRING)\n(\"birthplace\", STRING)\n(\"address\", STRING)\n"
        ]
    },
    {
        "sql_id": 135,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT T1.first, T1.last FROM patients AS T1 INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Penicillin V Potassium 250 MG' AND strftime('%Y', T2.START) >= '1948'",
        "target_query": "SELECT DISTINCT T1.\"_first\", T1.\"_last\" FROM \"patients\" AS T1 INNER JOIN \"medications\" AS T2 ON T1.\"patient\" = T2.\"PATIENT\" WHERE T2.\"DESCRIPTION\" = 'Penicillin V Potassium 250 MG' AND sys.timestamp_to_str(T2.\"START\", '%Y') >= '1948';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 169,
                "end_index": 192,
                "dilatect_content": "strftime('%Y', T2.START)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 199,
                "end_index": 238,
                "dilatect_content": "sys.timestamp_to_str(T2.\"START\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `medications`\nColumns:\n(`START`, date, primary key)\n(`STOP`, date)\n(`PATIENT`, text, primary key)\n(`ENCOUNTER`, text, primary key)\n(`CODE`, integer, primary key)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"patients\"\nColumns:\n(\"patient\", STRING, primary key)\n(\"birthdate\", DATE)\n(\"deathdate\", DATE)\n(\"ssn\", STRING)\n(\"drivers\", STRING)\n(\"passport\", STRING)\n(\"prefix\", STRING)\n(\"_first\", STRING)\n(\"_last\", STRING)\n(\"suffix\", STRING)\n(\"maiden\", STRING)\n(\"marital\", STRING)\n(\"race\", STRING)\n(\"ethnicity\", STRING)\n(\"gender\", STRING)\n(\"birthplace\", STRING)\n(\"address\", STRING)\n",
            "Table: \"medications\"\nColumns:\n(\"START\", DATE, primary key)\n(\"STOP\", DATE)\n(\"PATIENT\", STRING, primary key)\n(\"ENCOUNTER\", STRING, primary key)\n(\"CODE\", BIGINT, primary key)\n(\"DESCRIPTION\", STRING)\n(\"REASONCODE\", BIGINT)\n(\"REASONDESCRIPTION\", STRING)\n"
        ]
    },
    {
        "sql_id": 136,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(DISTINCT T1.patient) FROM patients AS T1 INNER JOIN conditions AS T2 ON T1.patient = T2.patient WHERE strftime('%Y', T1.birthdate) = '1935' AND T1.race = 'white' AND T2.DESCRIPTION = 'Stroke'",
        "target_query": "SELECT COUNT(DISTINCT \"T1\".\"patient\") FROM \"patients\" AS \"T1\" INNER JOIN \"conditions\" AS \"T2\" ON \"T1\".\"patient\" = \"T2\".\"PATIENT\" WHERE sys.timestamp_to_str(\"T1\".\"birthdate\", '%Y') = '1935' AND \"T1\".\"race\" = 'white' AND \"T2\".\"DESCRIPTION\" = 'Stroke';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 115,
                "end_index": 142,
                "dilatect_content": "strftime('%Y', T1.birthdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 155,
                "end_index": 202,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"birthdate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `conditions`\nColumns:\n(`START`, date)\n(`STOP`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, integer)\n(`DESCRIPTION`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"patients\"\nColumns:\n(\"patient\", STRING, primary key)\n(\"birthdate\", DATE)\n(\"deathdate\", DATE)\n(\"ssn\", STRING)\n(\"drivers\", STRING)\n(\"passport\", STRING)\n(\"prefix\", STRING)\n(\"_first\", STRING)\n(\"_last\", STRING)\n(\"suffix\", STRING)\n(\"maiden\", STRING)\n(\"marital\", STRING)\n(\"race\", STRING)\n(\"ethnicity\", STRING)\n(\"gender\", STRING)\n(\"birthplace\", STRING)\n(\"address\", STRING)\n",
            "Table: \"conditions\"\nColumns:\n(\"START\", DATE)\n(\"STOP\", DATE)\n(\"PATIENT\", STRING)\n(\"ENCOUNTER\", STRING)\n(\"CODE\", BIGINT)\n(\"DESCRIPTION\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 139,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT T3.lastName, T3.firstName FROM payments AS T1 INNER JOIN customers AS T2 ON T1.customerNumber = T2.customerNumber INNER JOIN employees AS T3 ON T2.salesRepEmployeeNumber = T3.employeeNumber WHERE STRFTIME('%Y', T1.paymentDate) = '2004' ORDER BY T1.amount DESC LIMIT 1",
        "target_query": "SELECT \"lastName\", \"firstName\" \nFROM (\n    SELECT DISTINCT \"T3\".\"lastName\", \"T3\".\"firstName\", \"T1\".\"amount\" \n    FROM \"payments\" AS \"T1\" \n    INNER JOIN \"customers\" AS \"T2\" ON \"T1\".\"customerNumber\" = \"T2\".\"customerNumber\" \n    INNER JOIN \"employees\" AS \"T3\" ON \"T2\".\"salesRepEmployeeNumber\" = \"T3\".\"employeeNumber\" \n    WHERE sys.timestamp_to_str(\"T1\".\"paymentDate\", '%Y') = '2004'\n) AS subquery \nORDER BY \"amount\" DESC \nLIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 212,
                "end_index": 241,
                "dilatect_content": "STRFTIME('%Y', T1.paymentDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 376,
                "end_index": 425,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"paymentDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `payments`\nColumns:\n(`customerNumber`, integer, primary key)\n(`checkNumber`, text, primary key)\n(`paymentDate`, date)\n(`amount`, real)\n",
            "Table: `customers`\nColumns:\n(`customerNumber`, integer, primary key)\n(`customerName`, text)\n(`contactLastName`, text)\n(`contactFirstName`, text)\n(`phone`, text)\n(`addressLine1`, text)\n(`addressLine2`, text)\n(`city`, text)\n(`state`, text)\n(`postalCode`, text)\n(`country`, text)\n(`salesRepEmployeeNumber`, integer)\n(`creditLimit`, real)\n",
            "Table: `employees`\nColumns:\n(`employeeNumber`, integer, primary key)\n(`lastName`, text)\n(`firstName`, text)\n(`extension`, text)\n(`email`, text)\n(`officeCode`, text)\n(`reportsTo`, integer)\n(`jobTitle`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"payments\"\nColumns:\n(\"customerNumber\", BIGINT, primary key)\n(\"checkNumber\", STRING, primary key)\n(\"paymentDate\", DATE)\n(\"amount\", DOUBLE PRECISION)\n",
            "Table: \"customers\"\nColumns:\n(\"customerNumber\", BIGINT, primary key)\n(\"customerName\", STRING)\n(\"contactLastName\", STRING)\n(\"contactFirstName\", STRING)\n(\"phone\", STRING)\n(\"addressLine1\", STRING)\n(\"addressLine2\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"postalCode\", STRING)\n(\"country\", STRING)\n(\"salesRepEmployeeNumber\", BIGINT)\n(\"creditLimit\", DOUBLE PRECISION)\n",
            "Table: \"employees\"\nColumns:\n(\"employeeNumber\", BIGINT, primary key)\n(\"lastName\", STRING)\n(\"firstName\", STRING)\n(\"extension\", STRING)\n(\"email\", STRING)\n(\"officeCode\", STRING)\n(\"reportsTo\", BIGINT)\n(\"jobTitle\", STRING)\n"
        ]
    },
    {
        "sql_id": 140,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T3.priceEach * T3.quantityOrdered FROM customers AS T1 INNER JOIN orders AS T2 ON T1.customerNumber = T2.customerNumber INNER JOIN orderdetails AS T3 ON T2.orderNumber = T3.orderNumber WHERE T1.customerName = 'Rovelli Gifts' AND T2.status = 'Shipped' AND STRFTIME('%Y', T2.shippedDate) = '2003'",
        "target_query": "SELECT \"T3\".\"priceEach\" * \"T3\".\"quantityOrdered\" FROM \"customers\" AS \"T1\" INNER JOIN \"orders\" AS \"T2\" ON \"T1\".\"customerNumber\" = \"T2\".\"customerNumber\" INNER JOIN \"orderdetails\" AS \"T3\" ON \"T2\".\"orderNumber\" = \"T3\".\"orderNumber\" WHERE \"T1\".\"customerName\" = 'Rovelli Gifts' AND \"T2\".\"_status\" = 'Shipped' AND sys.timestamp_to_str(\"T2\".\"shippedDate\", '%Y') = '2003';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 262,
                "end_index": 291,
                "dilatect_content": "STRFTIME('%Y', T2.shippedDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 351,
                "end_index": 400,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"shippedDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customers`\nColumns:\n(`customerNumber`, integer, primary key)\n(`customerName`, text)\n(`contactLastName`, text)\n(`contactFirstName`, text)\n(`phone`, text)\n(`addressLine1`, text)\n(`addressLine2`, text)\n(`city`, text)\n(`state`, text)\n(`postalCode`, text)\n(`country`, text)\n(`salesRepEmployeeNumber`, integer)\n(`creditLimit`, real)\n",
            "Table: `orders`\nColumns:\n(`orderNumber`, integer, primary key)\n(`orderDate`, date)\n(`requiredDate`, date)\n(`shippedDate`, date)\n(`status`, text)\n(`comments`, text)\n(`customerNumber`, integer)\n",
            "Table: `orderdetails`\nColumns:\n(`orderNumber`, integer, primary key)\n(`productCode`, text, primary key)\n(`quantityOrdered`, integer)\n(`priceEach`, real)\n(`orderLineNumber`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"customers\"\nColumns:\n(\"customerNumber\", BIGINT, primary key)\n(\"customerName\", STRING)\n(\"contactLastName\", STRING)\n(\"contactFirstName\", STRING)\n(\"phone\", STRING)\n(\"addressLine1\", STRING)\n(\"addressLine2\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"postalCode\", STRING)\n(\"country\", STRING)\n(\"salesRepEmployeeNumber\", BIGINT)\n(\"creditLimit\", DOUBLE PRECISION)\n",
            "Table: \"orders\"\nColumns:\n(\"orderNumber\", BIGINT, primary key)\n(\"orderDate\", DATE)\n(\"requiredDate\", DATE)\n(\"shippedDate\", DATE)\n(\"_status\", STRING)\n(\"comments\", STRING)\n(\"customerNumber\", BIGINT)\n",
            "Table: \"orderdetails\"\nColumns:\n(\"orderNumber\", BIGINT, primary key)\n(\"productCode\", STRING, primary key)\n(\"quantityOrdered\", BIGINT)\n(\"priceEach\", DOUBLE PRECISION)\n(\"orderLineNumber\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 141,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T1.checkNumber) FROM payments AS T1 INNER JOIN customers AS T2 ON T1.customerNumber = T2.customerNumber WHERE customerName = 'Euro+ Shopping Channel' AND STRFTIME('%Y', T1.paymentDate) = '2004'",
        "target_query": "SELECT COUNT(\"T1\".\"checkNumber\") FROM \"payments\" AS \"T1\" INNER JOIN \"customers\" AS \"T2\" ON \"T1\".\"customerNumber\" = \"T2\".\"customerNumber\" WHERE \"T2\".\"customerName\" = 'Euro+ Shopping Channel' AND sys.timestamp_to_str(\"T1\".\"paymentDate\", '%Y') = '2004';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 167,
                "end_index": 196,
                "dilatect_content": "STRFTIME('%Y', T1.paymentDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 218,
                "end_index": 267,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"paymentDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `payments`\nColumns:\n(`customerNumber`, integer, primary key)\n(`checkNumber`, text, primary key)\n(`paymentDate`, date)\n(`amount`, real)\n",
            "Table: `customers`\nColumns:\n(`customerNumber`, integer, primary key)\n(`customerName`, text)\n(`contactLastName`, text)\n(`contactFirstName`, text)\n(`phone`, text)\n(`addressLine1`, text)\n(`addressLine2`, text)\n(`city`, text)\n(`state`, text)\n(`postalCode`, text)\n(`country`, text)\n(`salesRepEmployeeNumber`, integer)\n(`creditLimit`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"payments\"\nColumns:\n(\"customerNumber\", BIGINT, primary key)\n(\"checkNumber\", STRING, primary key)\n(\"paymentDate\", DATE)\n(\"amount\", DOUBLE PRECISION)\n",
            "Table: \"customers\"\nColumns:\n(\"customerNumber\", BIGINT, primary key)\n(\"customerName\", STRING)\n(\"contactLastName\", STRING)\n(\"contactFirstName\", STRING)\n(\"phone\", STRING)\n(\"addressLine1\", STRING)\n(\"addressLine2\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"postalCode\", STRING)\n(\"country\", STRING)\n(\"salesRepEmployeeNumber\", BIGINT)\n(\"creditLimit\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 142,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT ( SELECT COUNT(customerNumber) FROM customers WHERE creditLimit <= 100000 AND customerNumber IN ( SELECT customerNumber FROM payments WHERE STRFTIME('%Y', paymentDate) = '2004' ) ), T1.customerName FROM customers AS T1 INNER JOIN payments AS T2 ON T1.customerNumber = T2.customerNumber WHERE T1.creditLimit <= 100000 AND STRFTIME('%Y', T2.paymentDate) = '2004' GROUP BY T1.customerNumber, T1.customerName ORDER BY SUM(T2.amount) DESC LIMIT 1",
        "target_query": "SELECT ( SELECT COUNT(\"customerNumber\") FROM \"customers\" WHERE \"creditLimit\" <= 100000 AND \"customerNumber\" IN ( SELECT \"customerNumber\" FROM \"payments\" WHERE sys.timestamp_to_str(\"paymentDate\", '%Y') = '2004' ) ), T1.\"customerName\" FROM \"customers\" AS T1 INNER JOIN \"payments\" AS T2 ON T1.\"customerNumber\" = T2.\"customerNumber\" WHERE T1.\"creditLimit\" <= 100000 AND sys.timestamp_to_str(T2.\"paymentDate\", '%Y') = '2004' GROUP BY T1.\"customerNumber\", T1.\"customerName\" ORDER BY SUM(T2.\"amount\") DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 147,
                "end_index": 173,
                "dilatect_content": "STRFTIME('%Y', paymentDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 328,
                "end_index": 357,
                "dilatect_content": "STRFTIME('%Y', T2.paymentDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 171,
                "end_index": 213,
                "dilatect_content": "sys.timestamp_to_str(\"paymentDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 392,
                "end_index": 437,
                "dilatect_content": "sys.timestamp_to_str(T2.\"paymentDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customers`\nColumns:\n(`customerNumber`, integer, primary key)\n(`customerName`, text)\n(`contactLastName`, text)\n(`contactFirstName`, text)\n(`phone`, text)\n(`addressLine1`, text)\n(`addressLine2`, text)\n(`city`, text)\n(`state`, text)\n(`postalCode`, text)\n(`country`, text)\n(`salesRepEmployeeNumber`, integer)\n(`creditLimit`, real)\n",
            "Table: `payments`\nColumns:\n(`customerNumber`, integer, primary key)\n(`checkNumber`, text, primary key)\n(`paymentDate`, date)\n(`amount`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"customers\"\nColumns:\n(\"customerNumber\", BIGINT, primary key)\n(\"customerName\", STRING)\n(\"contactLastName\", STRING)\n(\"contactFirstName\", STRING)\n(\"phone\", STRING)\n(\"addressLine1\", STRING)\n(\"addressLine2\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"postalCode\", STRING)\n(\"country\", STRING)\n(\"salesRepEmployeeNumber\", BIGINT)\n(\"creditLimit\", DOUBLE PRECISION)\n",
            "Table: \"payments\"\nColumns:\n(\"customerNumber\", BIGINT, primary key)\n(\"checkNumber\", STRING, primary key)\n(\"paymentDate\", DATE)\n(\"amount\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 143,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(DISTINCT T1.orderNumber) FROM orderdetails AS T1 INNER JOIN orders AS T2 ON T1.orderNumber = T2.orderNumber WHERE T1.quantityOrdered < 30 AND STRFTIME('%Y', T2.orderDate) = '2003'",
        "target_query": "SELECT COUNT(DISTINCT \"T1\".\"orderNumber\") FROM \"orderdetails\" AS \"T1\" INNER JOIN \"orders\" AS \"T2\" ON \"T1\".\"orderNumber\" = \"T2\".\"orderNumber\" WHERE \"T1\".\"quantityOrdered\" < 30 AND sys.timestamp_to_str(\"T2\".\"orderDate\", '%Y') = '2003';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 155,
                "end_index": 182,
                "dilatect_content": "STRFTIME('%Y', T2.orderDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 203,
                "end_index": 250,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"orderDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `orderdetails`\nColumns:\n(`orderNumber`, integer, primary key)\n(`productCode`, text, primary key)\n(`quantityOrdered`, integer)\n(`priceEach`, real)\n(`orderLineNumber`, integer)\n",
            "Table: `orders`\nColumns:\n(`orderNumber`, integer, primary key)\n(`orderDate`, date)\n(`requiredDate`, date)\n(`shippedDate`, date)\n(`status`, text)\n(`comments`, text)\n(`customerNumber`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"orderdetails\"\nColumns:\n(\"orderNumber\", BIGINT, primary key)\n(\"productCode\", STRING, primary key)\n(\"quantityOrdered\", BIGINT)\n(\"priceEach\", DOUBLE PRECISION)\n(\"orderLineNumber\", BIGINT)\n",
            "Table: \"orders\"\nColumns:\n(\"orderNumber\", BIGINT, primary key)\n(\"orderDate\", DATE)\n(\"requiredDate\", DATE)\n(\"shippedDate\", DATE)\n(\"_status\", STRING)\n(\"comments\", STRING)\n(\"customerNumber\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 144,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(T2.quantityOrdered * T2.priceEach) / COUNT(T3.orderNumber) FROM products AS T1 INNER JOIN orderdetails AS T2 ON T1.productCode = T2.productCode INNER JOIN orders AS T3 ON T2.orderNumber = T3.orderNumber WHERE T1.productVendor = 'Exoto Designs' AND STRFTIME('%Y', T3.orderDate) = '2005'",
        "target_query": "SELECT SUM(\"T2\".\"quantityOrdered\" * \"T2\".\"priceEach\") / COUNT(\"T3\".\"orderNumber\") \nFROM \"products\" AS \"T1\" \nINNER JOIN \"orderdetails\" AS \"T2\" ON \"T1\".\"productCode\" = \"T2\".\"productCode\" \nINNER JOIN \"orders\" AS \"T3\" ON \"T2\".\"orderNumber\" = \"T3\".\"orderNumber\" \nWHERE \"T1\".\"productVendor\" = 'Exoto Designs' \nAND sys.timestamp_to_str(\"T3\".\"orderDate\", '%Y') = '2005';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 259,
                "end_index": 286,
                "dilatect_content": "STRFTIME('%Y', T3.orderDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 357,
                "end_index": 404,
                "dilatect_content": "sys.timestamp_to_str(\"T3\".\"orderDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `products`\nColumns:\n(`productCode`, text, primary key)\n(`productName`, text)\n(`productLine`, text)\n(`productScale`, text)\n(`productVendor`, text)\n(`productDescription`, text)\n(`quantityInStock`, integer)\n(`buyPrice`, real)\n(`MSRP`, real)\n",
            "Table: `orderdetails`\nColumns:\n(`orderNumber`, integer, primary key)\n(`productCode`, text, primary key)\n(`quantityOrdered`, integer)\n(`priceEach`, real)\n(`orderLineNumber`, integer)\n",
            "Table: `orders`\nColumns:\n(`orderNumber`, integer, primary key)\n(`orderDate`, date)\n(`requiredDate`, date)\n(`shippedDate`, date)\n(`status`, text)\n(`comments`, text)\n(`customerNumber`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"products\"\nColumns:\n(\"productCode\", STRING, primary key)\n(\"productName\", STRING)\n(\"productLine\", STRING)\n(\"productScale\", STRING)\n(\"productVendor\", STRING)\n(\"productDescription\", STRING)\n(\"quantityInStock\", BIGINT)\n(\"buyPrice\", DOUBLE PRECISION)\n(\"MSRP\", DOUBLE PRECISION)\n",
            "Table: \"orderdetails\"\nColumns:\n(\"orderNumber\", BIGINT, primary key)\n(\"productCode\", STRING, primary key)\n(\"quantityOrdered\", BIGINT)\n(\"priceEach\", DOUBLE PRECISION)\n(\"orderLineNumber\", BIGINT)\n",
            "Table: \"orders\"\nColumns:\n(\"orderNumber\", BIGINT, primary key)\n(\"orderDate\", DATE)\n(\"requiredDate\", DATE)\n(\"shippedDate\", DATE)\n(\"_status\", STRING)\n(\"comments\", STRING)\n(\"customerNumber\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 145,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(amount) FROM payments WHERE STRFTIME('%Y', paymentDate) = '2003' AND customerNumber IN ( SELECT customerNumber FROM customers WHERE creditLimit = 0 )",
        "target_query": "SELECT SUM(\"amount\") FROM \"payments\" WHERE sys.timestamp_to_str(\"paymentDate\", '%Y') = '2003' AND \"customerNumber\" IN ( SELECT \"customerNumber\" FROM \"customers\" WHERE \"creditLimit\" = 0 );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 39,
                "end_index": 65,
                "dilatect_content": "STRFTIME('%Y', paymentDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 47,
                "end_index": 89,
                "dilatect_content": "sys.timestamp_to_str(\"paymentDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `payments`\nColumns:\n(`customerNumber`, integer, primary key)\n(`checkNumber`, text, primary key)\n(`paymentDate`, date)\n(`amount`, real)\n",
            "Table: `customers`\nColumns:\n(`customerNumber`, integer, primary key)\n(`customerName`, text)\n(`contactLastName`, text)\n(`contactFirstName`, text)\n(`phone`, text)\n(`addressLine1`, text)\n(`addressLine2`, text)\n(`city`, text)\n(`state`, text)\n(`postalCode`, text)\n(`country`, text)\n(`salesRepEmployeeNumber`, integer)\n(`creditLimit`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"payments\"\nColumns:\n(\"customerNumber\", BIGINT, primary key)\n(\"checkNumber\", STRING, primary key)\n(\"paymentDate\", DATE)\n(\"amount\", DOUBLE PRECISION)\n",
            "Table: \"customers\"\nColumns:\n(\"customerNumber\", BIGINT, primary key)\n(\"customerName\", STRING)\n(\"contactLastName\", STRING)\n(\"contactFirstName\", STRING)\n(\"phone\", STRING)\n(\"addressLine1\", STRING)\n(\"addressLine2\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"postalCode\", STRING)\n(\"country\", STRING)\n(\"salesRepEmployeeNumber\", BIGINT)\n(\"creditLimit\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 146,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(customernumber) FROM ( SELECT customernumber FROM payments WHERE STRFTIME('%Y', paymentDate) >= '2003' AND STRFTIME('%Y', paymentDate) <= '2004' GROUP BY customernumber HAVING COUNT(customernumber) > 3 ) T",
        "target_query": "SELECT COUNT(\"customerNumber\") FROM ( SELECT \"customerNumber\" FROM \"payments\" WHERE sys.timestamp_to_str(\"paymentDate\", '%Y') >= '2003' AND sys.timestamp_to_str(\"paymentDate\", '%Y') <= '2004' GROUP BY \"customerNumber\" HAVING COUNT(\"customerNumber\") > 3 ) T;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 78,
                "end_index": 104,
                "dilatect_content": "STRFTIME('%Y', paymentDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 120,
                "end_index": 146,
                "dilatect_content": "STRFTIME('%Y', paymentDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 90,
                "end_index": 132,
                "dilatect_content": "sys.timestamp_to_str(\"paymentDate\", '%Y')",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 148,
                "end_index": 190,
                "dilatect_content": "sys.timestamp_to_str(\"paymentDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `payments`\nColumns:\n(`customerNumber`, integer, primary key)\n(`checkNumber`, text, primary key)\n(`paymentDate`, date)\n(`amount`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"payments\"\nColumns:\n(\"customerNumber\", BIGINT, primary key)\n(\"checkNumber\", STRING, primary key)\n(\"paymentDate\", DATE)\n(\"amount\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 147,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T3.addressLine1, T3.addressLine2, T3.phone FROM orderdetails AS T1 INNER JOIN orders AS T2 ON T1.orderNumber = T2.orderNumber INNER JOIN customers AS T3 ON T2.customerNumber = T3.customerNumber INNER JOIN employees AS T4 ON T3.salesRepEmployeeNumber = T4.employeeNumber INNER JOIN offices AS T5 ON T4.officeCode = T5.officeCode WHERE STRFTIME('%Y', T2.orderDate) = '2005' AND T4.jobTitle = 'Sales Rep' ORDER BY T1.quantityOrdered DESC LIMIT 1",
        "target_query": "SELECT \"T3\".\"addressLine1\", \"T3\".\"addressLine2\", \"T3\".\"phone\" \nFROM \"orderdetails\" AS \"T1\" \nINNER JOIN \"orders\" AS \"T2\" ON \"T1\".\"orderNumber\" = \"T2\".\"orderNumber\" \nINNER JOIN \"customers\" AS \"T3\" ON \"T2\".\"customerNumber\" = \"T3\".\"customerNumber\" \nINNER JOIN \"employees\" AS \"T4\" ON \"T3\".\"salesRepEmployeeNumber\" = \"T4\".\"employeeNumber\" \nINNER JOIN \"offices\" AS \"T5\" ON \"T4\".\"officeCode\" = \"T5\".\"officeCode\" \nWHERE sys.timestamp_to_str(\"T2\".\"orderDate\", '%Y') = '2005' \nAND \"T4\".\"jobTitle\" = 'Sales Rep' \nORDER BY \"T1\".\"quantityOrdered\" DESC \nLIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 341,
                "end_index": 368,
                "dilatect_content": "STRFTIME('%Y', T2.orderDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 481,
                "end_index": 528,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"orderDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `orderdetails`\nColumns:\n(`orderNumber`, integer, primary key)\n(`productCode`, text, primary key)\n(`quantityOrdered`, integer)\n(`priceEach`, real)\n(`orderLineNumber`, integer)\n",
            "Table: `orders`\nColumns:\n(`orderNumber`, integer, primary key)\n(`orderDate`, date)\n(`requiredDate`, date)\n(`shippedDate`, date)\n(`status`, text)\n(`comments`, text)\n(`customerNumber`, integer)\n",
            "Table: `customers`\nColumns:\n(`customerNumber`, integer, primary key)\n(`customerName`, text)\n(`contactLastName`, text)\n(`contactFirstName`, text)\n(`phone`, text)\n(`addressLine1`, text)\n(`addressLine2`, text)\n(`city`, text)\n(`state`, text)\n(`postalCode`, text)\n(`country`, text)\n(`salesRepEmployeeNumber`, integer)\n(`creditLimit`, real)\n",
            "Table: `employees`\nColumns:\n(`employeeNumber`, integer, primary key)\n(`lastName`, text)\n(`firstName`, text)\n(`extension`, text)\n(`email`, text)\n(`officeCode`, text)\n(`reportsTo`, integer)\n(`jobTitle`, text)\n",
            "Table: `offices`\nColumns:\n(`officeCode`, text, primary key)\n(`city`, text)\n(`phone`, text)\n(`addressLine1`, text)\n(`addressLine2`, text)\n(`state`, text)\n(`country`, text)\n(`postalCode`, text)\n(`territory`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"orderdetails\"\nColumns:\n(\"orderNumber\", BIGINT, primary key)\n(\"productCode\", STRING, primary key)\n(\"quantityOrdered\", BIGINT)\n(\"priceEach\", DOUBLE PRECISION)\n(\"orderLineNumber\", BIGINT)\n",
            "Table: \"orders\"\nColumns:\n(\"orderNumber\", BIGINT, primary key)\n(\"orderDate\", DATE)\n(\"requiredDate\", DATE)\n(\"shippedDate\", DATE)\n(\"_status\", STRING)\n(\"comments\", STRING)\n(\"customerNumber\", BIGINT)\n",
            "Table: \"customers\"\nColumns:\n(\"customerNumber\", BIGINT, primary key)\n(\"customerName\", STRING)\n(\"contactLastName\", STRING)\n(\"contactFirstName\", STRING)\n(\"phone\", STRING)\n(\"addressLine1\", STRING)\n(\"addressLine2\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"postalCode\", STRING)\n(\"country\", STRING)\n(\"salesRepEmployeeNumber\", BIGINT)\n(\"creditLimit\", DOUBLE PRECISION)\n",
            "Table: \"employees\"\nColumns:\n(\"employeeNumber\", BIGINT, primary key)\n(\"lastName\", STRING)\n(\"firstName\", STRING)\n(\"extension\", STRING)\n(\"email\", STRING)\n(\"officeCode\", STRING)\n(\"reportsTo\", BIGINT)\n(\"jobTitle\", STRING)\n",
            "Table: \"offices\"\nColumns:\n(\"officeCode\", STRING, primary key)\n(\"city\", STRING)\n(\"phone\", STRING)\n(\"addressLine1\", STRING)\n(\"addressLine2\", STRING)\n(\"state\", STRING)\n(\"country\", STRING)\n(\"postalCode\", STRING)\n(\"territory\", STRING)\n"
        ]
    },
    {
        "sql_id": 148,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.orderDate FROM orderdetails AS T1 INNER JOIN orders AS T2 ON T1.orderNumber = T2.orderNumber WHERE STRFTIME('%Y-%m-%d', T2.orderDate) = '2005-04-08' OR STRFTIME('%Y-%m-%d', T2.orderDate) = '2005-04-10' ORDER BY T1.quantityOrdered * T1.priceEach DESC LIMIT 1",
        "target_query": "SELECT \"T2\".\"orderDate\" FROM \"orderdetails\" AS \"T1\" INNER JOIN \"orders\" AS \"T2\" ON \"T1\".\"orderNumber\" = \"T2\".\"orderNumber\" WHERE sys.timestamp_to_str(\"T2\".\"orderDate\", '%Y-%m-%d') = '2005-04-08' OR sys.timestamp_to_str(\"T2\".\"orderDate\", '%Y-%m-%d') = '2005-04-10' ORDER BY \"T1\".\"quantityOrdered\" * \"T1\".\"priceEach\" DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 109,
                "end_index": 142,
                "dilatect_content": "STRFTIME('%Y-%m-%d', T2.orderDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 162,
                "end_index": 195,
                "dilatect_content": "STRFTIME('%Y-%m-%d', T2.orderDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 149,
                "end_index": 202,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"orderDate\", '%Y-%m-%d')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 222,
                "end_index": 275,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"orderDate\", '%Y-%m-%d')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `orderdetails`\nColumns:\n(`orderNumber`, integer, primary key)\n(`productCode`, text, primary key)\n(`quantityOrdered`, integer)\n(`priceEach`, real)\n(`orderLineNumber`, integer)\n",
            "Table: `orders`\nColumns:\n(`orderNumber`, integer, primary key)\n(`orderDate`, date)\n(`requiredDate`, date)\n(`shippedDate`, date)\n(`status`, text)\n(`comments`, text)\n(`customerNumber`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"orderdetails\"\nColumns:\n(\"orderNumber\", BIGINT, primary key)\n(\"productCode\", STRING, primary key)\n(\"quantityOrdered\", BIGINT)\n(\"priceEach\", DOUBLE PRECISION)\n(\"orderLineNumber\", BIGINT)\n",
            "Table: \"orders\"\nColumns:\n(\"orderNumber\", BIGINT, primary key)\n(\"orderDate\", DATE)\n(\"requiredDate\", DATE)\n(\"shippedDate\", DATE)\n(\"_status\", STRING)\n(\"comments\", STRING)\n(\"customerNumber\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 149,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(CASE WHEN JULIANDAY(t1.shippeddate) - JULIANDAY(t1.requireddate) > 3 THEN T1.customerNumber ELSE NULL END) FROM orders AS T1 INNER JOIN orderdetails AS T2 ON T1.orderNumber = T2.orderNumber WHERE T1.status = 'Shipped'",
        "target_query": "SELECT COUNT(CASE WHEN 2440587.5 + EXTRACT(EPOCH FROM \"T1\".\"shippedDate\") / 86400 - 2440587.5 - EXTRACT(EPOCH FROM \"T1\".\"requiredDate\") / 86400 > 3 THEN \"T1\".\"customerNumber\" ELSE NULL END) FROM \"orders\" AS \"T1\" INNER JOIN \"orderdetails\" AS \"T2\" ON \"T1\".\"orderNumber\" = \"T2\".\"orderNumber\" WHERE \"T1\".\"_status\" = 'Shipped';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 23,
                "end_index": 47,
                "dilatect_content": "JULIANDAY(t1.shippeddate)",
                "feature": "julianday(time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 51,
                "end_index": 76,
                "dilatect_content": "JULIANDAY(t1.requireddate)",
                "feature": "julianday(time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 23,
                "end_index": 84,
                "dilatect_content": "2440587.5 + EXTRACT(EPOCH FROM \"T1\".\"shippedDate\") / 86400",
                "feature": "2440587.5 + EXTRACT(EPOCH FROM time-value) / 86400"
            },
            {
                "start_index": 88,
                "end_index": 150,
                "dilatect_content": "2440587.5 - EXTRACT(EPOCH FROM \"T1\".\"requiredDate\") / 86400",
                "feature": "2440587.5 + EXTRACT(EPOCH FROM time-value) / 86400"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "julianday(time-value, modifier, modifier, ...)",
                "explanation": "The julianday(time-value, modifier, modifier, ...) function returns the Julian day number - the fractional number of days since noon in Greenwich on November 24, 4714 B.C. (Proleptic Gregorian calendar). It accepts a time-value and zero or more modifiers.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day').\nReturns: A real number representing the Julian day number.",
                "examples": [
                    "SELECT julianday(); -- Returns the current Julian day number.",
                    "SELECT julianday('2024-08-21'); -- Returns the Julian day number for August 21, 2024.",
                    "SELECT julianday('now', '+1 day'); -- Returns the Julian day number for one day after the current date."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "2440587.5 + EXTRACT(EPOCH FROM time-value) / 86400",
                "explanation": "This expression calculates the Julian day number in MonetDB. It returns the fractional number of days since noon in Greenwich on November 24, 4714 B.C. by converting the input date or timestamp to seconds since the Unix epoch, dividing by 86400 (seconds per day), and adding the Julian base offset 2440587.5.\n\nParameters:\n- time-value: a DATE or TIMESTAMP value.\nReturns: A real number representing the Julian day number.",
                "examples": [
                    "SELECT 2440587.5 + EXTRACT(EPOCH FROM CURRENT_TIMESTAMP) / 86400; -- Returns the current Julian day number.",
                    "SELECT 2440587.5 + EXTRACT(EPOCH FROM DATE '2024-08-21') / 86400; -- Julian day for August 21, 2024.",
                    "SELECT 2440587.5 + EXTRACT(EPOCH FROM TIMESTAMP '2024-08-21 12:00:00') / 86400; -- Julian day with time component."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `orders`\nColumns:\n(`orderNumber`, integer, primary key)\n(`orderDate`, date)\n(`requiredDate`, date)\n(`shippedDate`, date)\n(`status`, text)\n(`comments`, text)\n(`customerNumber`, integer)\n",
            "Table: `orderdetails`\nColumns:\n(`orderNumber`, integer, primary key)\n(`productCode`, text, primary key)\n(`quantityOrdered`, integer)\n(`priceEach`, real)\n(`orderLineNumber`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"orders\"\nColumns:\n(\"orderNumber\", BIGINT, primary key)\n(\"orderDate\", DATE)\n(\"requiredDate\", DATE)\n(\"shippedDate\", DATE)\n(\"_status\", STRING)\n(\"comments\", STRING)\n(\"customerNumber\", BIGINT)\n",
            "Table: \"orderdetails\"\nColumns:\n(\"orderNumber\", BIGINT, primary key)\n(\"productCode\", STRING, primary key)\n(\"quantityOrdered\", BIGINT)\n(\"priceEach\", DOUBLE PRECISION)\n(\"orderLineNumber\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 150,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT t2.customerName FROM payments AS t1 INNER JOIN customers AS t2 ON t1.customerNumber = t2.customerNumber WHERE STRFTIME('%Y', t1.paymentDate) = '2005' GROUP BY t2.customerNumber, t2.customerName ORDER BY SUM(t1.amount) DESC LIMIT 1",
        "target_query": "SELECT \"t2\".\"customerName\" FROM \"payments\" AS \"t1\" INNER JOIN \"customers\" AS \"t2\" ON \"t1\".\"customerNumber\" = \"t2\".\"customerNumber\" WHERE sys.timestamp_to_str(\"t1\".\"paymentDate\", '%Y') = '2005' GROUP BY \"t2\".\"customerNumber\", \"t2\".\"customerName\" ORDER BY SUM(\"t1\".\"amount\") DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 117,
                "end_index": 146,
                "dilatect_content": "STRFTIME('%Y', t1.paymentDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 157,
                "end_index": 206,
                "dilatect_content": "sys.timestamp_to_str(\"t1\".\"paymentDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `payments`\nColumns:\n(`customerNumber`, integer, primary key)\n(`checkNumber`, text, primary key)\n(`paymentDate`, date)\n(`amount`, real)\n",
            "Table: `customers`\nColumns:\n(`customerNumber`, integer, primary key)\n(`customerName`, text)\n(`contactLastName`, text)\n(`contactFirstName`, text)\n(`phone`, text)\n(`addressLine1`, text)\n(`addressLine2`, text)\n(`city`, text)\n(`state`, text)\n(`postalCode`, text)\n(`country`, text)\n(`salesRepEmployeeNumber`, integer)\n(`creditLimit`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"payments\"\nColumns:\n(\"customerNumber\", BIGINT, primary key)\n(\"checkNumber\", STRING, primary key)\n(\"paymentDate\", DATE)\n(\"amount\", DOUBLE PRECISION)\n",
            "Table: \"customers\"\nColumns:\n(\"customerNumber\", BIGINT, primary key)\n(\"customerName\", STRING)\n(\"contactLastName\", STRING)\n(\"contactFirstName\", STRING)\n(\"phone\", STRING)\n(\"addressLine1\", STRING)\n(\"addressLine2\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"postalCode\", STRING)\n(\"country\", STRING)\n(\"salesRepEmployeeNumber\", BIGINT)\n(\"creditLimit\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 151,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(CASE WHEN t1.customerName = 'Atelier graphique' THEN t2.amount ELSE 0 END) * 100 / SUM(t2.amount) FROM customers AS t1 INNER JOIN payments AS t2 ON t1.customerNumber = t2.customerNumber WHERE STRFTIME('%Y', t2.paymentDate) = '2004'",
        "target_query": "SELECT SUM(CASE WHEN \"t1\".\"customerName\" = 'Atelier graphique' THEN \"t2\".\"amount\" ELSE 0 END) * 100 / SUM(\"t2\".\"amount\") FROM \"customers\" AS \"t1\" INNER JOIN \"payments\" AS \"t2\" ON \"t1\".\"customerNumber\" = \"t2\".\"customerNumber\" WHERE sys.timestamp_to_str(\"t2\".\"paymentDate\", '%Y') = '2004';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 203,
                "end_index": 232,
                "dilatect_content": "STRFTIME('%Y', t2.paymentDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 259,
                "end_index": 308,
                "dilatect_content": "sys.timestamp_to_str(\"t2\".\"paymentDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customers`\nColumns:\n(`customerNumber`, integer, primary key)\n(`customerName`, text)\n(`contactLastName`, text)\n(`contactFirstName`, text)\n(`phone`, text)\n(`addressLine1`, text)\n(`addressLine2`, text)\n(`city`, text)\n(`state`, text)\n(`postalCode`, text)\n(`country`, text)\n(`salesRepEmployeeNumber`, integer)\n(`creditLimit`, real)\n",
            "Table: `payments`\nColumns:\n(`customerNumber`, integer, primary key)\n(`checkNumber`, text, primary key)\n(`paymentDate`, date)\n(`amount`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"customers\"\nColumns:\n(\"customerNumber\", BIGINT, primary key)\n(\"customerName\", STRING)\n(\"contactLastName\", STRING)\n(\"contactFirstName\", STRING)\n(\"phone\", STRING)\n(\"addressLine1\", STRING)\n(\"addressLine2\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"postalCode\", STRING)\n(\"country\", STRING)\n(\"salesRepEmployeeNumber\", BIGINT)\n(\"creditLimit\", DOUBLE PRECISION)\n",
            "Table: \"payments\"\nColumns:\n(\"customerNumber\", BIGINT, primary key)\n(\"checkNumber\", STRING, primary key)\n(\"paymentDate\", DATE)\n(\"amount\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 152,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(t2.quantityOrdered) FROM orders AS t1 INNER JOIN orderdetails AS t2 ON t1.orderNumber = t2.orderNumber INNER JOIN products AS t3 ON t2.productCode = t3.productCode WHERE t3.productLine = 'motorcycles' AND STRFTIME('%Y', t1.orderDate) = '2004'",
        "target_query": "SELECT SUM(\"t2\".\"quantityOrdered\") FROM \"orders\" AS \"t1\" INNER JOIN \"orderdetails\" AS \"t2\" ON \"t1\".\"orderNumber\" = \"t2\".\"orderNumber\" INNER JOIN \"products\" AS \"t3\" ON \"t2\".\"productCode\" = \"t3\".\"productCode\" WHERE \"t3\".\"productLine\" = 'motorcycles' AND sys.timestamp_to_str(\"t1\".\"orderDate\", '%Y') = '2004';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 216,
                "end_index": 243,
                "dilatect_content": "STRFTIME('%Y', t1.orderDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 288,
                "end_index": 335,
                "dilatect_content": "sys.timestamp_to_str(\"t1\".\"orderDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `orders`\nColumns:\n(`orderNumber`, integer, primary key)\n(`orderDate`, date)\n(`requiredDate`, date)\n(`shippedDate`, date)\n(`status`, text)\n(`comments`, text)\n(`customerNumber`, integer)\n",
            "Table: `orderdetails`\nColumns:\n(`orderNumber`, integer, primary key)\n(`productCode`, text, primary key)\n(`quantityOrdered`, integer)\n(`priceEach`, real)\n(`orderLineNumber`, integer)\n",
            "Table: `products`\nColumns:\n(`productCode`, text, primary key)\n(`productName`, text)\n(`productLine`, text)\n(`productScale`, text)\n(`productVendor`, text)\n(`productDescription`, text)\n(`quantityInStock`, integer)\n(`buyPrice`, real)\n(`MSRP`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"orders\"\nColumns:\n(\"orderNumber\", BIGINT, primary key)\n(\"orderDate\", DATE)\n(\"requiredDate\", DATE)\n(\"shippedDate\", DATE)\n(\"_status\", STRING)\n(\"comments\", STRING)\n(\"customerNumber\", BIGINT)\n",
            "Table: \"orderdetails\"\nColumns:\n(\"orderNumber\", BIGINT, primary key)\n(\"productCode\", STRING, primary key)\n(\"quantityOrdered\", BIGINT)\n(\"priceEach\", DOUBLE PRECISION)\n(\"orderLineNumber\", BIGINT)\n",
            "Table: \"products\"\nColumns:\n(\"productCode\", STRING, primary key)\n(\"productName\", STRING)\n(\"productLine\", STRING)\n(\"productScale\", STRING)\n(\"productVendor\", STRING)\n(\"productDescription\", STRING)\n(\"quantityInStock\", BIGINT)\n(\"buyPrice\", DOUBLE PRECISION)\n(\"MSRP\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 153,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT STRFTIME('%Y', t1.paymentDate), COUNT(t1.customerNumber) FROM payments AS t1 WHERE t1.amount < 10000 GROUP BY STRFTIME('%Y', t1.paymentDate)",
        "target_query": "SELECT sys.timestamp_to_str(\"t1\".\"paymentDate\", '%Y'), COUNT(\"t1\".\"customerNumber\") FROM \"payments\" AS \"t1\" WHERE \"t1\".\"amount\" < 10000 GROUP BY sys.timestamp_to_str(\"t1\".\"paymentDate\", '%Y');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 36,
                "dilatect_content": "STRFTIME('%Y', t1.paymentDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 117,
                "end_index": 146,
                "dilatect_content": "STRFTIME('%Y', t1.paymentDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 56,
                "dilatect_content": "sys.timestamp_to_str(\"t1\".\"paymentDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 161,
                "end_index": 210,
                "dilatect_content": "sys.timestamp_to_str(\"t1\".\"paymentDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `payments`\nColumns:\n(`customerNumber`, integer, primary key)\n(`checkNumber`, text, primary key)\n(`paymentDate`, date)\n(`amount`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"payments\"\nColumns:\n(\"customerNumber\", BIGINT, primary key)\n(\"checkNumber\", STRING, primary key)\n(\"paymentDate\", DATE)\n(\"amount\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 154,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT t3.productName, SUM(t2.quantityOrdered) FROM orders AS t1 INNER JOIN orderdetails AS t2 ON t1.orderNumber = t2.orderNumber INNER JOIN products AS t3 ON t2.productCode = t3.productCode WHERE STRFTIME('%Y', t1.orderDate) = '2003' GROUP BY t3.productName ORDER BY SUM(t2.quantityOrdered) DESC LIMIT 3",
        "target_query": "SELECT \"t3\".\"productName\", SUM(\"t2\".\"quantityOrdered\") FROM \"orders\" AS \"t1\" INNER JOIN \"orderdetails\" AS \"t2\" ON \"t1\".\"orderNumber\" = \"t2\".\"orderNumber\" INNER JOIN \"products\" AS \"t3\" ON \"t2\".\"productCode\" = \"t3\".\"productCode\" WHERE sys.timestamp_to_str(\"t1\".\"orderDate\", '%Y') = '2003' GROUP BY \"t3\".\"productName\" ORDER BY SUM(\"t2\".\"quantityOrdered\") DESC LIMIT 3;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 197,
                "end_index": 224,
                "dilatect_content": "STRFTIME('%Y', t1.orderDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 269,
                "end_index": 316,
                "dilatect_content": "sys.timestamp_to_str(\"t1\".\"orderDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `orders`\nColumns:\n(`orderNumber`, integer, primary key)\n(`orderDate`, date)\n(`requiredDate`, date)\n(`shippedDate`, date)\n(`status`, text)\n(`comments`, text)\n(`customerNumber`, integer)\n",
            "Table: `orderdetails`\nColumns:\n(`orderNumber`, integer, primary key)\n(`productCode`, text, primary key)\n(`quantityOrdered`, integer)\n(`priceEach`, real)\n(`orderLineNumber`, integer)\n",
            "Table: `products`\nColumns:\n(`productCode`, text, primary key)\n(`productName`, text)\n(`productLine`, text)\n(`productScale`, text)\n(`productVendor`, text)\n(`productDescription`, text)\n(`quantityInStock`, integer)\n(`buyPrice`, real)\n(`MSRP`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"orders\"\nColumns:\n(\"orderNumber\", BIGINT, primary key)\n(\"orderDate\", DATE)\n(\"requiredDate\", DATE)\n(\"shippedDate\", DATE)\n(\"_status\", STRING)\n(\"comments\", STRING)\n(\"customerNumber\", BIGINT)\n",
            "Table: \"orderdetails\"\nColumns:\n(\"orderNumber\", BIGINT, primary key)\n(\"productCode\", STRING, primary key)\n(\"quantityOrdered\", BIGINT)\n(\"priceEach\", DOUBLE PRECISION)\n(\"orderLineNumber\", BIGINT)\n",
            "Table: \"products\"\nColumns:\n(\"productCode\", STRING, primary key)\n(\"productName\", STRING)\n(\"productLine\", STRING)\n(\"productScale\", STRING)\n(\"productVendor\", STRING)\n(\"productDescription\", STRING)\n(\"quantityInStock\", BIGINT)\n(\"buyPrice\", DOUBLE PRECISION)\n(\"MSRP\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 155,
        "database_name": "restaurant",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.food_type = 'mexican', 1, 0)) AS REAL) * 100 / COUNT(T2.id_restaurant) FROM geographic AS T1 INNER JOIN generalinfo AS T2 ON T1.city = T2.city WHERE T1.county = 'monterey county'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"food_type\" = 'mexican' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T2\".\"id_restaurant\") FROM \"geographic\" AS \"T1\" INNER JOIN \"generalinfo\" AS \"T2\" ON \"T1\".\"city\" = \"T2\".\"city\" WHERE \"T1\".\"county\" = 'monterey county';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 50,
                "dilatect_content": "IIF(T2.food_type = 'mexican', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 75,
                "dilatect_content": "CASE WHEN \"T2\".\"food_type\" = 'mexican' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `geographic`\nColumns:\n(`city`, text, primary key)\n(`county`, text)\n(`region`, text)\n",
            "Table: `generalinfo`\nColumns:\n(`id_restaurant`, integer, primary key)\n(`label`, text)\n(`food_type`, text)\n(`city`, text)\n(`review`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"geographic\"\nColumns:\n(\"city\", STRING, primary key)\n(\"county\", STRING)\n(\"region\", STRING)\n",
            "Table: \"generalinfo\"\nColumns:\n(\"id_restaurant\", BIGINT, primary key)\n(\"label\", STRING)\n(\"food_type\", STRING)\n(\"city\", STRING)\n(\"review\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 156,
        "database_name": "restaurant",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T1.street_name = '11th st', 1, 0)) AS REAL) * 100 / COUNT(T1.id_restaurant) FROM location AS T1 INNER JOIN geographic AS T2 ON T1.city = T2.city WHERE T2.County = 'alameda county'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T1\".\"street_name\" = '11th st' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"id_restaurant\") FROM \"location\" AS \"T1\" INNER JOIN \"geographic\" AS \"T2\" ON \"T1\".\"city\" = \"T2\".\"city\" WHERE \"T2\".\"county\" = 'alameda county';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 52,
                "dilatect_content": "IIF(T1.street_name = '11th st', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 77,
                "dilatect_content": "CASE WHEN \"T1\".\"street_name\" = '11th st' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `location`\nColumns:\n(`id_restaurant`, integer, primary key)\n(`street_num`, integer)\n(`street_name`, text)\n(`city`, text)\n",
            "Table: `geographic`\nColumns:\n(`city`, text, primary key)\n(`county`, text)\n(`region`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"location\"\nColumns:\n(\"id_restaurant\", BIGINT, primary key)\n(\"street_num\", BIGINT)\n(\"street_name\", STRING)\n(\"city\", STRING)\n",
            "Table: \"geographic\"\nColumns:\n(\"city\", STRING, primary key)\n(\"county\", STRING)\n(\"region\", STRING)\n"
        ]
    },
    {
        "sql_id": 157,
        "database_name": "restaurant",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(food_type = 'american food', 1, 0)) AS REAL) * 100 / COUNT(id_restaurant) FROM generalinfo WHERE city = 'dublin'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"food_type\" = 'american food' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"id_restaurant\") FROM \"generalinfo\" WHERE \"city\" = 'dublin';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 53,
                "dilatect_content": "IIF(food_type = 'american food', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 74,
                "dilatect_content": "CASE WHEN \"food_type\" = 'american food' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `generalinfo`\nColumns:\n(`id_restaurant`, integer, primary key)\n(`label`, text)\n(`food_type`, text)\n(`city`, text)\n(`review`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"generalinfo\"\nColumns:\n(\"id_restaurant\", BIGINT, primary key)\n(\"label\", STRING)\n(\"food_type\", STRING)\n(\"city\", STRING)\n(\"review\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 158,
        "database_name": "restaurant",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.review > 4, 1, 0)) AS REAL) * 100 / COUNT(T2.id_restaurant) FROM geographic AS T1 RIGHT JOIN generalinfo AS T2 ON T1.city = T2.city WHERE T1.region = 'bay area'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"review\" > 4 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T2\".\"id_restaurant\") FROM \"geographic\" AS \"T1\" RIGHT JOIN \"generalinfo\" AS \"T2\" ON \"T1\".\"city\" = \"T2\".\"city\" WHERE \"T1\".\"region\" = 'bay area';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 39,
                "dilatect_content": "IIF(T2.review > 4, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 74,
                "dilatect_content": "CASE WHEN \"T2\".\"review\" > 4 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `geographic`\nColumns:\n(`city`, text, primary key)\n(`county`, text)\n(`region`, text)\n",
            "Table: `generalinfo`\nColumns:\n(`id_restaurant`, integer, primary key)\n(`label`, text)\n(`food_type`, text)\n(`city`, text)\n(`review`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"geographic\"\nColumns:\n(\"city\", STRING, primary key)\n(\"county\", STRING)\n(\"region\", STRING)\n",
            "Table: \"generalinfo\"\nColumns:\n(\"id_restaurant\", BIGINT, primary key)\n(\"label\", STRING)\n(\"food_type\", STRING)\n(\"city\", STRING)\n(\"review\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 159,
        "database_name": "restaurant",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T1.region = 'bay area', 1, 0)) AS REAL) * 100 / COUNT(T2.id_restaurant) FROM geographic AS T1 INNER JOIN location AS T2 ON T1.city = T2.city",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T1\".\"region\" = 'bay area' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T2\".\"id_restaurant\") FROM \"geographic\" AS \"T1\" INNER JOIN \"location\" AS \"T2\" ON \"T1\".\"city\" = \"T2\".\"city\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 48,
                "dilatect_content": "IIF(T1.region = 'bay area', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 73,
                "dilatect_content": "CASE WHEN \"T1\".\"region\" = 'bay area' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `geographic`\nColumns:\n(`city`, text, primary key)\n(`county`, text)\n(`region`, text)\n",
            "Table: `location`\nColumns:\n(`id_restaurant`, integer, primary key)\n(`street_num`, integer)\n(`street_name`, text)\n(`city`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"geographic\"\nColumns:\n(\"city\", STRING, primary key)\n(\"county\", STRING)\n(\"region\", STRING)\n",
            "Table: \"location\"\nColumns:\n(\"id_restaurant\", BIGINT, primary key)\n(\"street_num\", BIGINT)\n(\"street_name\", STRING)\n(\"city\", STRING)\n"
        ]
    },
    {
        "sql_id": 160,
        "database_name": "restaurant",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(region = 'Napa Valley', 1, 0)) AS REAL) * 100 / COUNT(region) FROM geographic",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"region\" = 'Napa Valley' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"region\") FROM \"geographic\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 48,
                "dilatect_content": "IIF(region = 'Napa Valley', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 69,
                "dilatect_content": "CASE WHEN \"region\" = 'Napa Valley' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `geographic`\nColumns:\n(`city`, text, primary key)\n(`county`, text)\n(`region`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"geographic\"\nColumns:\n(\"city\", STRING, primary key)\n(\"county\", STRING)\n(\"region\", STRING)\n"
        ]
    },
    {
        "sql_id": 161,
        "database_name": "restaurant",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.food_type = 'afghani', 1, 0)) AS REAL) * 100 / COUNT(T1.id_restaurant) FROM location AS T1 INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE 1000 <= T1.street_num <= 2000",
        "target_query": "SELECT CAST(SUM(CASE WHEN T2.food_type = 'afghani' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.\"id_restaurant\") FROM \"location\" AS T1 INNER JOIN \"generalinfo\" AS T2 ON T1.\"id_restaurant\" = T2.\"id_restaurant\" WHERE T1.\"street_num\" >= 1000 AND T1.\"street_num\" <= 2000;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 50,
                "dilatect_content": "IIF(T2.food_type = 'afghani', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 67,
                "dilatect_content": "CASE WHEN T2.food_type = 'afghani' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `location`\nColumns:\n(`id_restaurant`, integer, primary key)\n(`street_num`, integer)\n(`street_name`, text)\n(`city`, text)\n",
            "Table: `generalinfo`\nColumns:\n(`id_restaurant`, integer, primary key)\n(`label`, text)\n(`food_type`, text)\n(`city`, text)\n(`review`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"location\"\nColumns:\n(\"id_restaurant\", BIGINT, primary key)\n(\"street_num\", BIGINT)\n(\"street_name\", STRING)\n(\"city\", STRING)\n",
            "Table: \"generalinfo\"\nColumns:\n(\"id_restaurant\", BIGINT, primary key)\n(\"label\", STRING)\n(\"food_type\", STRING)\n(\"city\", STRING)\n(\"review\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 163,
        "database_name": "soccer_2016",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(Match_Id) FROM `Match` WHERE SUBSTR(Match_Date, 1, 4) = '2008' AND SUBSTR(Match_Date, 7, 1) = '5'",
        "target_query": "SELECT COUNT(\"Match_Id\") FROM \"Match\" WHERE substring(\"Match_Date\" from 1 for 4) = '2008' AND substring(\"Match_Date\" from 7 for 1) = '5';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 42,
                "end_index": 65,
                "dilatect_content": "SUBSTR(Match_Date, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 80,
                "end_index": 103,
                "dilatect_content": "SUBSTR(Match_Date, 7, 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 48,
                "end_index": 85,
                "dilatect_content": "substring(\"Match_Date\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 100,
                "end_index": 137,
                "dilatect_content": "substring(\"Match_Date\" from 7 for 1)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Match`\nColumns:\n(`Match_Id`, integer, primary key)\n(`Team_1`, integer)\n(`Team_2`, integer)\n(`Match_Date`, date)\n(`Season_Id`, integer)\n(`Venue_Id`, integer)\n(`Toss_Winner`, integer)\n(`Toss_Decide`, integer)\n(`Win_Type`, integer)\n(`Win_Margin`, integer)\n(`Outcome_type`, integer)\n(`Match_Winner`, integer)\n(`Man_of_the_Match`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"Match\"\nColumns:\n(\"Match_Id\", BIGINT, primary key)\n(\"Team_1\", BIGINT)\n(\"Team_2\", BIGINT)\n(\"Match_Date\", DATE)\n(\"Season_Id\", BIGINT)\n(\"Venue_Id\", BIGINT)\n(\"Toss_Winner\", BIGINT)\n(\"Toss_Decide\", BIGINT)\n(\"Win_Type\", BIGINT)\n(\"Win_Margin\", BIGINT)\n(\"Outcome_type\", BIGINT)\n(\"Match_Winner\", BIGINT)\n(\"Man_of_the_Match\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 164,
        "database_name": "soccer_2016",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT Match_Id FROM `Match` WHERE SUBSTR(Match_Date, 1, 4) = '2008'",
        "target_query": "SELECT \"Match_Id\" FROM \"Match\" WHERE substring(\"Match_Date\" from 1 for 4) = '2008';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 35,
                "end_index": 58,
                "dilatect_content": "SUBSTR(Match_Date, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 41,
                "end_index": 78,
                "dilatect_content": "substring(\"Match_Date\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Match`\nColumns:\n(`Match_Id`, integer, primary key)\n(`Team_1`, integer)\n(`Team_2`, integer)\n(`Match_Date`, date)\n(`Season_Id`, integer)\n(`Venue_Id`, integer)\n(`Toss_Winner`, integer)\n(`Toss_Decide`, integer)\n(`Win_Type`, integer)\n(`Win_Margin`, integer)\n(`Outcome_type`, integer)\n(`Match_Winner`, integer)\n(`Man_of_the_Match`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"Match\"\nColumns:\n(\"Match_Id\", BIGINT, primary key)\n(\"Team_1\", BIGINT)\n(\"Team_2\", BIGINT)\n(\"Match_Date\", DATE)\n(\"Season_Id\", BIGINT)\n(\"Venue_Id\", BIGINT)\n(\"Toss_Winner\", BIGINT)\n(\"Toss_Decide\", BIGINT)\n(\"Win_Type\", BIGINT)\n(\"Win_Margin\", BIGINT)\n(\"Outcome_type\", BIGINT)\n(\"Match_Winner\", BIGINT)\n(\"Man_of_the_Match\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 167,
        "database_name": "soccer_2016",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(CASE WHEN SUBSTR(Match_Date, 7, 1) = '5' THEN 1 ELSE 0 END) FROM `Match` WHERE SUBSTR(Match_Date, 1, 4) = '2008'",
        "target_query": "SELECT SUM(CASE WHEN substring(\"Match_Date\" from 7 for 1) = '5' THEN 1 ELSE 0 END) FROM \"Match\" WHERE substring(\"Match_Date\" from 1 for 4) = '2008';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 44,
                "dilatect_content": "SUBSTR(Match_Date, 7, 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 90,
                "end_index": 113,
                "dilatect_content": "SUBSTR(Match_Date, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 58,
                "dilatect_content": "substring(\"Match_Date\" from 7 for 1)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 106,
                "end_index": 143,
                "dilatect_content": "substring(\"Match_Date\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Match`\nColumns:\n(`Match_Id`, integer, primary key)\n(`Team_1`, integer)\n(`Team_2`, integer)\n(`Match_Date`, date)\n(`Season_Id`, integer)\n(`Venue_Id`, integer)\n(`Toss_Winner`, integer)\n(`Toss_Decide`, integer)\n(`Win_Type`, integer)\n(`Win_Margin`, integer)\n(`Outcome_type`, integer)\n(`Match_Winner`, integer)\n(`Man_of_the_Match`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"Match\"\nColumns:\n(\"Match_Id\", BIGINT, primary key)\n(\"Team_1\", BIGINT)\n(\"Team_2\", BIGINT)\n(\"Match_Date\", DATE)\n(\"Season_Id\", BIGINT)\n(\"Venue_Id\", BIGINT)\n(\"Toss_Winner\", BIGINT)\n(\"Toss_Decide\", BIGINT)\n(\"Win_Type\", BIGINT)\n(\"Win_Margin\", BIGINT)\n(\"Outcome_type\", BIGINT)\n(\"Match_Winner\", BIGINT)\n(\"Man_of_the_Match\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 168,
        "database_name": "soccer_2016",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(CASE WHEN Team_1 = 10 OR Team_2 = 10 THEN 1 ELSE 0 END) FROM `Match` WHERE SUBSTR(Match_Date, 1, 4) = '2012'",
        "target_query": "SELECT SUM(CASE WHEN \"Team_1\" = 10 OR \"Team_2\" = 10 THEN 1 ELSE 0 END) FROM \"Match\" WHERE substring(\"Match_Date\" from 1 for 4) = '2012';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 86,
                "end_index": 109,
                "dilatect_content": "SUBSTR(Match_Date, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 96,
                "end_index": 133,
                "dilatect_content": "substring(\"Match_Date\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Match`\nColumns:\n(`Match_Id`, integer, primary key)\n(`Team_1`, integer)\n(`Team_2`, integer)\n(`Match_Date`, date)\n(`Season_Id`, integer)\n(`Venue_Id`, integer)\n(`Toss_Winner`, integer)\n(`Toss_Decide`, integer)\n(`Win_Type`, integer)\n(`Win_Margin`, integer)\n(`Outcome_type`, integer)\n(`Match_Winner`, integer)\n(`Man_of_the_Match`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"Match\"\nColumns:\n(\"Match_Id\", BIGINT, primary key)\n(\"Team_1\", BIGINT)\n(\"Team_2\", BIGINT)\n(\"Match_Date\", DATE)\n(\"Season_Id\", BIGINT)\n(\"Venue_Id\", BIGINT)\n(\"Toss_Winner\", BIGINT)\n(\"Toss_Decide\", BIGINT)\n(\"Win_Type\", BIGINT)\n(\"Win_Margin\", BIGINT)\n(\"Outcome_type\", BIGINT)\n(\"Match_Winner\", BIGINT)\n(\"Man_of_the_Match\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 169,
        "database_name": "soccer_2016",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(COUNT(CASE WHEN Win_Margin > 100 THEN 1 ELSE 0 END) AS REAL) * 100 / TOTAL(Match_Id) FROM `Match`",
        "target_query": "SELECT CAST(COUNT(CASE WHEN \"Win_Margin\" > 100 THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(\"Match_Id\") FROM \"Match\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 81,
                "end_index": 95,
                "dilatect_content": "TOTAL(Match_Id)",
                "feature": "TOTAL(expression)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 85,
                "end_index": 101,
                "dilatect_content": "SUM(\"Match_Id\")",
                "feature": "SUM(expression)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "TOTAL(expression)",
                "explanation": "The `TOTAL` function in SQLite is an aggregate function that returns the sum of all non-null values in a group. Unlike `SUM`, it always returns a floating-point value (REAL) even if all inputs are integers. If no non-null values exist, it returns 0.0 instead of NULL.",
                "examples": [
                    "SELECT TOTAL(salary) FROM employees;",
                    "SELECT department, TOTAL(bonus) FROM employees GROUP BY department;",
                    "SELECT TOTAL(price * quantity) AS total_revenue FROM sales;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "SUM(expression)",
                "explanation": "The `SUM` function in MonetDB is similar to the `TOTAL` function in SQLite. It calculates the sum of all non-null values in a group. Unlike `TOTAL`, MonetDB's `SUM` does not always return a floating-point value but will return an integer if all values are integers. If no non-null values exist, `SUM` returns NULL.",
                "examples": [
                    "SELECT SUM(salary) FROM employees;",
                    "SELECT department, SUM(bonus) FROM employees GROUP BY department;",
                    "SELECT SUM(price * quantity) AS total_revenue FROM sales;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Match`\nColumns:\n(`Match_Id`, integer, primary key)\n(`Team_1`, integer)\n(`Team_2`, integer)\n(`Match_Date`, date)\n(`Season_Id`, integer)\n(`Venue_Id`, integer)\n(`Toss_Winner`, integer)\n(`Toss_Decide`, integer)\n(`Win_Type`, integer)\n(`Win_Margin`, integer)\n(`Outcome_type`, integer)\n(`Match_Winner`, integer)\n(`Man_of_the_Match`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"Match\"\nColumns:\n(\"Match_Id\", BIGINT, primary key)\n(\"Team_1\", BIGINT)\n(\"Team_2\", BIGINT)\n(\"Match_Date\", DATE)\n(\"Season_Id\", BIGINT)\n(\"Venue_Id\", BIGINT)\n(\"Toss_Winner\", BIGINT)\n(\"Toss_Decide\", BIGINT)\n(\"Win_Type\", BIGINT)\n(\"Win_Margin\", BIGINT)\n(\"Outcome_type\", BIGINT)\n(\"Match_Winner\", BIGINT)\n(\"Man_of_the_Match\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 171,
        "database_name": "soccer_2016",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(CASE WHEN T2.Bowling_skill = ' Legbreak' THEN 1 ELSE 0 END) AS REAL) * 100 / TOTAL(T1.Player_Id) FROM Player AS T1 INNER JOIN Bowling_Style AS T2 ON T1.Bowling_skill = T2.Bowling_Id",
        "target_query": "SELECT CAST(SUM(CASE WHEN T2.\"Bowling_skill\" = ' Legbreak' THEN 1 ELSE 0 END) AS REAL) * 100 / CAST(SUM(1) AS REAL) FROM \"Player\" AS T1 INNER JOIN \"Bowling_Style\" AS T2 ON T1.\"Bowling_skill\" = T2.\"Bowling_Id\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 93,
                "end_index": 111,
                "dilatect_content": "TOTAL(T1.Player_Id)",
                "feature": "TOTAL(expression)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 102,
                "end_index": 108,
                "dilatect_content": "SUM(1)",
                "feature": "SUM(expression)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "TOTAL(expression)",
                "explanation": "The `TOTAL` function in SQLite is an aggregate function that returns the sum of all non-null values in a group. Unlike `SUM`, it always returns a floating-point value (REAL) even if all inputs are integers. If no non-null values exist, it returns 0.0 instead of NULL.",
                "examples": [
                    "SELECT TOTAL(salary) FROM employees;",
                    "SELECT department, TOTAL(bonus) FROM employees GROUP BY department;",
                    "SELECT TOTAL(price * quantity) AS total_revenue FROM sales;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "SUM(expression)",
                "explanation": "The `SUM` function in MonetDB is similar to the `TOTAL` function in SQLite. It calculates the sum of all non-null values in a group. Unlike `TOTAL`, MonetDB's `SUM` does not always return a floating-point value but will return an integer if all values are integers. If no non-null values exist, `SUM` returns NULL.",
                "examples": [
                    "SELECT SUM(salary) FROM employees;",
                    "SELECT department, SUM(bonus) FROM employees GROUP BY department;",
                    "SELECT SUM(price * quantity) AS total_revenue FROM sales;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Player`\nColumns:\n(`Player_Id`, integer, primary key)\n(`Player_Name`, text)\n(`DOB`, date)\n(`Batting_hand`, integer)\n(`Bowling_skill`, integer)\n(`Country_Name`, integer)\n",
            "Table: `Bowling_Style`\nColumns:\n(`Bowling_Id`, integer, primary key)\n(`Bowling_skill`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Player\"\nColumns:\n(\"Player_Id\", BIGINT, primary key)\n(\"Player_Name\", STRING)\n(\"DOB\", DATE)\n(\"Batting_hand\", BIGINT)\n(\"Bowling_skill\", BIGINT)\n(\"Country_Name\", BIGINT)\n",
            "Table: \"Bowling_Style\"\nColumns:\n(\"Bowling_Id\", BIGINT, primary key)\n(\"Bowling_skill\", STRING)\n"
        ]
    },
    {
        "sql_id": 172,
        "database_name": "soccer_2016",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(COUNT(CASE WHEN T1.Team_1 = T1.Match_Winner = T1.Toss_Winner THEN 1 ELSE 0 END) AS REAL) * 100 / TOTAL(T1.Team_1) FROM `Match` AS T1 INNER JOIN Win_By AS T2 ON T1.Win_Type = T2.Win_Id INNER JOIN Toss_Decision AS T3 ON T1.Toss_Decide = T3.Toss_Id WHERE T3.Toss_Name = 'field' AND T2.Win_Type = 'runs'",
        "target_query": "SELECT CAST(COUNT(CASE WHEN \"Match\".\"Team_1\" = \"Match\".\"Match_Winner\" AND \"Match\".\"Team_1\" = \"Match\".\"Toss_Winner\" THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(\"Match\".\"Team_1\") FROM \"Match\" AS \"Match\" INNER JOIN \"Win_By\" AS \"Win_By\" ON \"Match\".\"Win_Type\" = \"Win_By\".\"Win_Id\" INNER JOIN \"Toss_Decision\" AS \"Toss_Decision\" ON \"Match\".\"Toss_Decide\" = \"Toss_Decision\".\"Toss_Id\" WHERE \"Toss_Decision\".\"Toss_Name\" = 'field' AND \"Win_By\".\"Win_Type\" = 'runs'",
        "semantic_equivalent_type": "approximate_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 109,
                "end_index": 124,
                "dilatect_content": "TOTAL(T1.Team_1)",
                "feature": "TOTAL(expression)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 167,
                "end_index": 191,
                "dilatect_content": "SUM(\"Match\".\"Team_1\")",
                "feature": "SUM(expression)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "TOTAL(expression)",
                "explanation": "The `TOTAL` function in SQLite is an aggregate function that returns the sum of all non-null values in a group. Unlike `SUM`, it always returns a floating-point value (REAL) even if all inputs are integers. If no non-null values exist, it returns 0.0 instead of NULL.",
                "examples": [
                    "SELECT TOTAL(salary) FROM employees;",
                    "SELECT department, TOTAL(bonus) FROM employees GROUP BY department;",
                    "SELECT TOTAL(price * quantity) AS total_revenue FROM sales;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "SUM(expression)",
                "explanation": "The `SUM` function in MonetDB is similar to the `TOTAL` function in SQLite. It calculates the sum of all non-null values in a group. Unlike `TOTAL`, MonetDB's `SUM` does not always return a floating-point value but will return an integer if all values are integers. If no non-null values exist, `SUM` returns NULL.",
                "examples": [
                    "SELECT SUM(salary) FROM employees;",
                    "SELECT department, SUM(bonus) FROM employees GROUP BY department;",
                    "SELECT SUM(price * quantity) AS total_revenue FROM sales;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Match`\nColumns:\n(`Match_Id`, integer, primary key)\n(`Team_1`, integer)\n(`Team_2`, integer)\n(`Match_Date`, date)\n(`Season_Id`, integer)\n(`Venue_Id`, integer)\n(`Toss_Winner`, integer)\n(`Toss_Decide`, integer)\n(`Win_Type`, integer)\n(`Win_Margin`, integer)\n(`Outcome_type`, integer)\n(`Match_Winner`, integer)\n(`Man_of_the_Match`, integer)\n",
            "Table: `Win_By`\nColumns:\n(`Win_Id`, integer, primary key)\n(`Win_Type`, text)\n",
            "Table: `Toss_Decision`\nColumns:\n(`Toss_Id`, integer, primary key)\n(`Toss_Name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Match\"\nColumns:\n(\"Match_Id\", BIGINT, primary key)\n(\"Team_1\", BIGINT)\n(\"Team_2\", BIGINT)\n(\"Match_Date\", DATE)\n(\"Season_Id\", BIGINT)\n(\"Venue_Id\", BIGINT)\n(\"Toss_Winner\", BIGINT)\n(\"Toss_Decide\", BIGINT)\n(\"Win_Type\", BIGINT)\n(\"Win_Margin\", BIGINT)\n(\"Outcome_type\", BIGINT)\n(\"Match_Winner\", BIGINT)\n(\"Man_of_the_Match\", BIGINT)\n",
            "Table: \"Win_By\"\nColumns:\n(\"Win_Id\", BIGINT, primary key)\n(\"Win_Type\", STRING)\n",
            "Table: \"Toss_Decision\"\nColumns:\n(\"Toss_Id\", BIGINT, primary key)\n(\"Toss_Name\", STRING)\n"
        ]
    },
    {
        "sql_id": 173,
        "database_name": "soccer_2016",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(COUNT(CASE WHEN T2.Win_Margin < 10 THEN 1 ELSE 0 END) AS REAL) * 100 / TOTAL(T1.Venue_Id) FROM Venue AS T1 INNER JOIN Match AS T2 ON T1.Venue_Id = T2.Venue_Id WHERE T1.Venue_Name = 'Dr DY Patil Sports Academy'",
        "target_query": "SELECT CAST(COUNT(CASE WHEN \"T2\".\"Win_Margin\" < 10 THEN 1 ELSE 0 END) AS REAL) * 100.0 / SUM(\"T1\".\"Venue_Id\") FROM \"Venue\" AS \"T1\" INNER JOIN \"Match\" AS \"T2\" ON \"T1\".\"Venue_Id\" = \"T2\".\"Venue_Id\" WHERE \"T1\".\"Venue_Name\" = 'Dr DY Patil Sports Academy';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 83,
                "end_index": 100,
                "dilatect_content": "TOTAL(T1.Venue_Id)",
                "feature": "TOTAL(expression)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 93,
                "end_index": 116,
                "dilatect_content": "SUM(\"T1\".\"Venue_Id\")",
                "feature": "SUM(expression)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "TOTAL(expression)",
                "explanation": "The `TOTAL` function in SQLite is an aggregate function that returns the sum of all non-null values in a group. Unlike `SUM`, it always returns a floating-point value (REAL) even if all inputs are integers. If no non-null values exist, it returns 0.0 instead of NULL.",
                "examples": [
                    "SELECT TOTAL(salary) FROM employees;",
                    "SELECT department, TOTAL(bonus) FROM employees GROUP BY department;",
                    "SELECT TOTAL(price * quantity) AS total_revenue FROM sales;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "SUM(expression)",
                "explanation": "The `SUM` function in MonetDB is similar to the `TOTAL` function in SQLite. It calculates the sum of all non-null values in a group. Unlike `TOTAL`, MonetDB's `SUM` does not always return a floating-point value but will return an integer if all values are integers. If no non-null values exist, `SUM` returns NULL.",
                "examples": [
                    "SELECT SUM(salary) FROM employees;",
                    "SELECT department, SUM(bonus) FROM employees GROUP BY department;",
                    "SELECT SUM(price * quantity) AS total_revenue FROM sales;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Venue`\nColumns:\n(`Venue_Id`, integer, primary key)\n(`Venue_Name`, text)\n(`City_Id`, integer)\n",
            "Table: `Match`\nColumns:\n(`Match_Id`, integer, primary key)\n(`Team_1`, integer)\n(`Team_2`, integer)\n(`Match_Date`, date)\n(`Season_Id`, integer)\n(`Venue_Id`, integer)\n(`Toss_Winner`, integer)\n(`Toss_Decide`, integer)\n(`Win_Type`, integer)\n(`Win_Margin`, integer)\n(`Outcome_type`, integer)\n(`Match_Winner`, integer)\n(`Man_of_the_Match`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"Venue\"\nColumns:\n(\"Venue_Id\", BIGINT, primary key)\n(\"Venue_Name\", STRING)\n(\"City_Id\", BIGINT)\n",
            "Table: \"Match\"\nColumns:\n(\"Match_Id\", BIGINT, primary key)\n(\"Team_1\", BIGINT)\n(\"Team_2\", BIGINT)\n(\"Match_Date\", DATE)\n(\"Season_Id\", BIGINT)\n(\"Venue_Id\", BIGINT)\n(\"Toss_Winner\", BIGINT)\n(\"Toss_Decide\", BIGINT)\n(\"Win_Type\", BIGINT)\n(\"Win_Margin\", BIGINT)\n(\"Outcome_type\", BIGINT)\n(\"Match_Winner\", BIGINT)\n(\"Man_of_the_Match\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 174,
        "database_name": "soccer_2016",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.Player_Name FROM Player AS T1 INNER JOIN Season AS T2 ON T1.Player_Id = T2.Purple_Cap ORDER BY T2.Season_Year - SUBSTR(T1.DOB, 1, 4) LIMIT 1",
        "target_query": "SELECT T1.\"Player_Name\" FROM \"Player\" AS T1 INNER JOIN \"Season\" AS T2 ON T1.\"Player_Id\" = T2.\"Purple_Cap\" ORDER BY T2.\"Season_Year\" - substring(T1.\"DOB\" from 1 for 4) LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 122,
                "end_index": 141,
                "dilatect_content": "SUBSTR(T1.DOB, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 146,
                "end_index": 179,
                "dilatect_content": "substring(T1.\"DOB\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Player`\nColumns:\n(`Player_Id`, integer, primary key)\n(`Player_Name`, text)\n(`DOB`, date)\n(`Batting_hand`, integer)\n(`Bowling_skill`, integer)\n(`Country_Name`, integer)\n",
            "Table: `Season`\nColumns:\n(`Season_Id`, integer, primary key)\n(`Man_of_the_Series`, integer)\n(`Orange_Cap`, integer)\n(`Purple_Cap`, integer)\n(`Season_Year`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"Player\"\nColumns:\n(\"Player_Id\", BIGINT, primary key)\n(\"Player_Name\", STRING)\n(\"DOB\", DATE)\n(\"Batting_hand\", BIGINT)\n(\"Bowling_skill\", BIGINT)\n(\"Country_Name\", BIGINT)\n",
            "Table: \"Season\"\nColumns:\n(\"Season_Id\", BIGINT, primary key)\n(\"Man_of_the_Series\", BIGINT)\n(\"Orange_Cap\", BIGINT)\n(\"Purple_Cap\", BIGINT)\n(\"Season_Year\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 175,
        "database_name": "soccer_2016",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT 2022 - SUBSTR(DOB, 1, 4) FROM Player WHERE Player_Name = 'Ishan Kishan'",
        "target_query": "SELECT CAST(2022 - substring(\"DOB\" from 1 for 4) AS INTEGER) FROM \"Player\" WHERE \"Player_Name\" = 'Ishan Kishan';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 14,
                "end_index": 30,
                "dilatect_content": "SUBSTR(DOB, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 19,
                "end_index": 49,
                "dilatect_content": "substring(\"DOB\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Player`\nColumns:\n(`Player_Id`, integer, primary key)\n(`Player_Name`, text)\n(`DOB`, date)\n(`Batting_hand`, integer)\n(`Bowling_skill`, integer)\n(`Country_Name`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"Player\"\nColumns:\n(\"Player_Id\", BIGINT, primary key)\n(\"Player_Name\", STRING)\n(\"DOB\", DATE)\n(\"Batting_hand\", BIGINT)\n(\"Bowling_skill\", BIGINT)\n(\"Country_Name\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 176,
        "database_name": "soccer_2016",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.Player_Name FROM Player AS T1 INNER JOIN Player_Match AS T2 ON T1.Player_Id = T2.Player_Id INNER JOIN Match AS T3 ON T2.Match_Id = T3.Match_Id WHERE SUBSTR(T3.Match_Date, 1, 4) = '2014' AND SUBSTR(T3.Match_Date, 7, 1) = '6' LIMIT 2",
        "target_query": "SELECT \"T1\".\"Player_Name\" FROM \"Player\" AS \"T1\" INNER JOIN \"Player_Match\" AS \"T2\" ON \"T1\".\"Player_Id\" = \"T2\".\"Player_Id\" INNER JOIN \"Match\" AS \"T3\" ON \"T2\".\"Match_Id\" = \"T3\".\"Match_Id\" WHERE substring(\"T3\".\"Match_Date\" from 1 for 4) = '2014' AND substring(\"T3\".\"Match_Date\" from 7 for 1) = '6' LIMIT 2;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 159,
                "end_index": 185,
                "dilatect_content": "SUBSTR(T3.Match_Date, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 200,
                "end_index": 226,
                "dilatect_content": "SUBSTR(T3.Match_Date, 7, 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 223,
                "end_index": 267,
                "dilatect_content": "substring(\"T3\".\"Match_Date\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 282,
                "end_index": 326,
                "dilatect_content": "substring(\"T3\".\"Match_Date\" from 7 for 1)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Player`\nColumns:\n(`Player_Id`, integer, primary key)\n(`Player_Name`, text)\n(`DOB`, date)\n(`Batting_hand`, integer)\n(`Bowling_skill`, integer)\n(`Country_Name`, integer)\n",
            "Table: `Player_Match`\nColumns:\n(`Match_Id`, integer, primary key)\n(`Player_Id`, integer, primary key)\n(`Role_Id`, integer, primary key)\n(`Team_Id`, integer)\n",
            "Table: `Match`\nColumns:\n(`Match_Id`, integer, primary key)\n(`Team_1`, integer)\n(`Team_2`, integer)\n(`Match_Date`, date)\n(`Season_Id`, integer)\n(`Venue_Id`, integer)\n(`Toss_Winner`, integer)\n(`Toss_Decide`, integer)\n(`Win_Type`, integer)\n(`Win_Margin`, integer)\n(`Outcome_type`, integer)\n(`Match_Winner`, integer)\n(`Man_of_the_Match`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"Player\"\nColumns:\n(\"Player_Id\", BIGINT, primary key)\n(\"Player_Name\", STRING)\n(\"DOB\", DATE)\n(\"Batting_hand\", BIGINT)\n(\"Bowling_skill\", BIGINT)\n(\"Country_Name\", BIGINT)\n",
            "Table: \"Player_Match\"\nColumns:\n(\"Match_Id\", BIGINT, primary key)\n(\"Player_Id\", BIGINT, primary key)\n(\"Role_Id\", BIGINT, primary key)\n(\"Team_Id\", BIGINT)\n",
            "Table: \"Match\"\nColumns:\n(\"Match_Id\", BIGINT, primary key)\n(\"Team_1\", BIGINT)\n(\"Team_2\", BIGINT)\n(\"Match_Date\", DATE)\n(\"Season_Id\", BIGINT)\n(\"Venue_Id\", BIGINT)\n(\"Toss_Winner\", BIGINT)\n(\"Toss_Decide\", BIGINT)\n(\"Win_Type\", BIGINT)\n(\"Win_Margin\", BIGINT)\n(\"Outcome_type\", BIGINT)\n(\"Match_Winner\", BIGINT)\n(\"Man_of_the_Match\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 177,
        "database_name": "soccer_2016",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.Team_Name FROM Team AS T1 INNER JOIN Match AS T2 ON T1.Team_Id = T2.Team_1 OR T1.Team_Id = T2.Team_2 INNER JOIN Win_By AS T3 ON T2.Win_Type = T3.Win_Id WHERE SUBSTR(T2.Match_Date, 1, 4) = '2015' AND T3.Win_Type = 'Tie' LIMIT 1",
        "target_query": "SELECT \"T1\".\"Team_Name\" FROM \"Team\" AS \"T1\" INNER JOIN \"Match\" AS \"T2\" ON \"T1\".\"Team_Id\" = \"T2\".\"Team_1\" OR \"T1\".\"Team_Id\" = \"T2\".\"Team_2\" INNER JOIN \"Win_By\" AS \"T3\" ON \"T2\".\"Win_Type\" = \"T3\".\"Win_Id\" WHERE substring(\"T2\".\"Match_Date\" from 1 for 4) = '2015' AND \"T3\".\"Win_Type\" = 'Tie' LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 168,
                "end_index": 194,
                "dilatect_content": "SUBSTR(T2.Match_Date, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 248,
                "end_index": 292,
                "dilatect_content": "substring(\"T2\".\"Match_Date\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Team`\nColumns:\n(`Team_Id`, integer, primary key)\n(`Team_Name`, text)\n",
            "Table: `Match`\nColumns:\n(`Match_Id`, integer, primary key)\n(`Team_1`, integer)\n(`Team_2`, integer)\n(`Match_Date`, date)\n(`Season_Id`, integer)\n(`Venue_Id`, integer)\n(`Toss_Winner`, integer)\n(`Toss_Decide`, integer)\n(`Win_Type`, integer)\n(`Win_Margin`, integer)\n(`Outcome_type`, integer)\n(`Match_Winner`, integer)\n(`Man_of_the_Match`, integer)\n",
            "Table: `Win_By`\nColumns:\n(`Win_Id`, integer, primary key)\n(`Win_Type`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Team\"\nColumns:\n(\"Team_Id\", BIGINT, primary key)\n(\"Team_Name\", STRING)\n",
            "Table: \"Match\"\nColumns:\n(\"Match_Id\", BIGINT, primary key)\n(\"Team_1\", BIGINT)\n(\"Team_2\", BIGINT)\n(\"Match_Date\", DATE)\n(\"Season_Id\", BIGINT)\n(\"Venue_Id\", BIGINT)\n(\"Toss_Winner\", BIGINT)\n(\"Toss_Decide\", BIGINT)\n(\"Win_Type\", BIGINT)\n(\"Win_Margin\", BIGINT)\n(\"Outcome_type\", BIGINT)\n(\"Match_Winner\", BIGINT)\n(\"Man_of_the_Match\", BIGINT)\n",
            "Table: \"Win_By\"\nColumns:\n(\"Win_Id\", BIGINT, primary key)\n(\"Win_Type\", STRING)\n"
        ]
    },
    {
        "sql_id": 178,
        "database_name": "soccer_2016",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT 2008 - strftime('%Y', DOB) FROM Player WHERE Player_Name = 'SC Ganguly'",
        "target_query": "SELECT 2008 - CAST(sys.timestamp_to_str(\"DOB\", '%Y') AS INTEGER) FROM \"Player\" WHERE \"Player_Name\" = 'SC Ganguly';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 14,
                "end_index": 32,
                "dilatect_content": "strftime('%Y', DOB)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 19,
                "end_index": 53,
                "dilatect_content": "sys.timestamp_to_str(\"DOB\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Player`\nColumns:\n(`Player_Id`, integer, primary key)\n(`Player_Name`, text)\n(`DOB`, date)\n(`Batting_hand`, integer)\n(`Bowling_skill`, integer)\n(`Country_Name`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"Player\"\nColumns:\n(\"Player_Id\", BIGINT, primary key)\n(\"Player_Name\", STRING)\n(\"DOB\", DATE)\n(\"Batting_hand\", BIGINT)\n(\"Bowling_skill\", BIGINT)\n(\"Country_Name\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 179,
        "database_name": "soccer_2016",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(CASE WHEN T2.Country_Name = 'India' THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.Player_Id) FROM Player AS T1 INNER JOIN Country AS T2 ON T1.Country_Name = T2.Country_ID WHERE strftime('%Y', T1.DOB) BETWEEN '1975' AND '1985'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"Country_Name\" = 'India' THEN 1 ELSE 0 END) AS REAL) / COUNT(\"T1\".\"Player_Id\") FROM \"Player\" AS \"T1\" INNER JOIN \"Country\" AS \"T2\" ON \"T1\".\"Country_Name\" = \"T2\".\"Country_Id\" WHERE sys.timestamp_to_str(\"T1\".\"DOB\", '%Y') BETWEEN '1975' AND '1985';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 186,
                "end_index": 207,
                "dilatect_content": "strftime('%Y', T1.DOB)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 234,
                "end_index": 275,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"DOB\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Player`\nColumns:\n(`Player_Id`, integer, primary key)\n(`Player_Name`, text)\n(`DOB`, date)\n(`Batting_hand`, integer)\n(`Bowling_skill`, integer)\n(`Country_Name`, integer)\n",
            "Table: `Country`\nColumns:\n(`Country_Id`, integer, primary key)\n(`Country_Name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Player\"\nColumns:\n(\"Player_Id\", BIGINT, primary key)\n(\"Player_Name\", STRING)\n(\"DOB\", DATE)\n(\"Batting_hand\", BIGINT)\n(\"Bowling_skill\", BIGINT)\n(\"Country_Name\", BIGINT)\n",
            "Table: \"Country\"\nColumns:\n(\"Country_Id\", BIGINT, primary key)\n(\"Country_Name\", STRING)\n"
        ]
    },
    {
        "sql_id": 180,
        "database_name": "soccer_2016",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(Player_Id) FROM Player WHERE strftime('%Y', DOB) BETWEEN '1970' AND '1975'",
        "target_query": "SELECT COUNT(\"Player_Id\") FROM \"Player\" WHERE sys.timestamp_to_str(\"DOB\", '%Y') BETWEEN '1970' AND '1975';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 42,
                "end_index": 60,
                "dilatect_content": "strftime('%Y', DOB)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 50,
                "end_index": 84,
                "dilatect_content": "sys.timestamp_to_str(\"DOB\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Player`\nColumns:\n(`Player_Id`, integer, primary key)\n(`Player_Name`, text)\n(`DOB`, date)\n(`Batting_hand`, integer)\n(`Bowling_skill`, integer)\n(`Country_Name`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"Player\"\nColumns:\n(\"Player_Id\", BIGINT, primary key)\n(\"Player_Name\", STRING)\n(\"DOB\", DATE)\n(\"Batting_hand\", BIGINT)\n(\"Bowling_skill\", BIGINT)\n(\"Country_Name\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 181,
        "database_name": "movielens",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.u_gender = 'F', 1, 0)) AS REAL) * 100 / COUNT(T2.userid) FROM u2base AS T1 INNER JOIN users AS T2 ON T1.userid = T2.userid WHERE T1.rating = 2",
        "target_query": "SELECT CAST(SUM(CASE WHEN T2.u_gender = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.userid) FROM \"u2base\" AS T1 INNER JOIN \"_users\" AS T2 ON T1.userid = T2.userid WHERE T1.rating = 2;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 43,
                "dilatect_content": "IIF(T2.u_gender = 'F', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 60,
                "dilatect_content": "CASE WHEN T2.u_gender = 'F' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `u2base`\nColumns:\n(`userid`, integer, primary key)\n(`movieid`, integer, primary key)\n(`rating`, text)\n",
            "Table: `users`\nColumns:\n(`userid`, integer, primary key)\n(`age`, text)\n(`u_gender`, text)\n(`occupation`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"u2base\"\nColumns:\n(\"userid\", BIGINT, primary key)\n(\"movieid\", BIGINT, primary key)\n(\"rating\", STRING)\n",
            "Table: \"_users\"\nColumns:\n(\"userid\", BIGINT, primary key)\n(\"age\", STRING)\n(\"u_gender\", STRING)\n(\"occupation\", STRING)\n"
        ]
    },
    {
        "sql_id": 183,
        "database_name": "movielens",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T3.a_quality >= 3, 1, 0)) AS REAL) * 100 / COUNT(T1.movieid) FROM movies AS T1 INNER JOIN movies2actors AS T2 ON T1.movieid = T2.movieid INNER JOIN actors AS T3 ON T2.actorid = T3.actorid WHERE T1.country = 'UK'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T3\".\"a_quality\" >= 3 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"movieid\") FROM \"movies\" AS \"T1\" INNER JOIN \"movies2actors\" AS \"T2\" ON \"T1\".\"movieid\" = \"T2\".\"movieid\" INNER JOIN \"actors\" AS \"T3\" ON \"T2\".\"actorid\" = \"T3\".\"actorid\" WHERE \"T1\".\"country\" = 'UK';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 43,
                "dilatect_content": "IIF(T3.a_quality >= 3, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 68,
                "dilatect_content": "CASE WHEN \"T3\".\"a_quality\" >= 3 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies`\nColumns:\n(`movieid`, integer, primary key)\n(`year`, integer)\n(`isEnglish`, text)\n(`country`, text)\n(`runningtime`, integer)\n",
            "Table: `movies2actors`\nColumns:\n(`movieid`, integer, primary key)\n(`actorid`, integer, primary key)\n(`cast_num`, integer)\n",
            "Table: `actors`\nColumns:\n(`actorid`, integer, primary key)\n(`a_gender`, text)\n(`a_quality`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"movies\"\nColumns:\n(\"movieid\", BIGINT, primary key)\n(\"_year\", BIGINT)\n(\"isEnglish\", STRING)\n(\"country\", STRING)\n(\"runningtime\", BIGINT)\n",
            "Table: \"movies2actors\"\nColumns:\n(\"movieid\", BIGINT, primary key)\n(\"actorid\", BIGINT, primary key)\n(\"cast_num\", BIGINT)\n",
            "Table: \"actors\"\nColumns:\n(\"actorid\", BIGINT, primary key)\n(\"a_gender\", STRING)\n(\"a_quality\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 184,
        "database_name": "movielens",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.avg_revenue > T2.d_quality, 1, 0)) AS REAL) * 100 / COUNT(T1.movieid) FROM movies2directors AS T1 INNER JOIN directors AS T2 ON T1.directorid = T2.directorid WHERE T1.genre = 'Action'",
        "target_query": "SELECT CAST(SUM(CASE WHEN T2.avg_revenue > T2.d_quality THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.\"movieid\") FROM \"movies2directors\" AS T1 INNER JOIN \"directors\" AS T2 ON T1.\"directorid\" = T2.\"directorid\" WHERE T1.\"genre\" = 'Action';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 55,
                "dilatect_content": "IIF(T2.avg_revenue > T2.d_quality, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 72,
                "dilatect_content": "CASE WHEN T2.avg_revenue > T2.d_quality THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies2directors`\nColumns:\n(`movieid`, integer, primary key)\n(`directorid`, integer, primary key)\n(`genre`, text)\n",
            "Table: `directors`\nColumns:\n(`directorid`, integer, primary key)\n(`d_quality`, integer)\n(`avg_revenue`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"movies2directors\"\nColumns:\n(\"movieid\", BIGINT, primary key)\n(\"directorid\", BIGINT, primary key)\n(\"genre\", STRING)\n",
            "Table: \"directors\"\nColumns:\n(\"directorid\", BIGINT, primary key)\n(\"d_quality\", BIGINT)\n(\"avg_revenue\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 185,
        "database_name": "movielens",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T1.rating = 1, 1, 0)) AS REAL) * 100 / COUNT(T1.movieid) FROM u2base AS T1 INNER JOIN movies AS T2 ON T1.movieid = T2.movieid WHERE T2.country = 'USA'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T1\".\"rating\" = '1' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"movieid\") FROM \"u2base\" AS \"T1\" INNER JOIN \"movies\" AS \"T2\" ON \"T1\".\"movieid\" = \"T2\".\"movieid\" WHERE \"T2\".\"country\" = 'USA';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 39,
                "dilatect_content": "IIF(T1.rating = 1, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 66,
                "dilatect_content": "CASE WHEN \"T1\".\"rating\" = '1' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `u2base`\nColumns:\n(`userid`, integer, primary key)\n(`movieid`, integer, primary key)\n(`rating`, text)\n",
            "Table: `movies`\nColumns:\n(`movieid`, integer, primary key)\n(`year`, integer)\n(`isEnglish`, text)\n(`country`, text)\n(`runningtime`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"u2base\"\nColumns:\n(\"userid\", BIGINT, primary key)\n(\"movieid\", BIGINT, primary key)\n(\"rating\", STRING)\n",
            "Table: \"movies\"\nColumns:\n(\"movieid\", BIGINT, primary key)\n(\"_year\", BIGINT)\n(\"isEnglish\", STRING)\n(\"country\", STRING)\n(\"runningtime\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 186,
        "database_name": "movielens",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T3.a_gender = 'M', 1, 0)) AS REAL) / SUM(IIF(T3.a_gender = 'F', 1, 0)) FROM movies AS T1 INNER JOIN movies2actors AS T2 ON T1.movieid = T2.movieid INNER JOIN actors AS T3 ON T2.actorid = T3.actorid WHERE T1.country = 'UK'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T3\".\"a_gender\" = 'M' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN \"T3\".\"a_gender\" = 'F' THEN 1 ELSE 0 END) FROM \"movies\" AS \"T1\" INNER JOIN \"movies2actors\" AS \"T2\" ON \"T1\".\"movieid\" = \"T2\".\"movieid\" INNER JOIN \"actors\" AS \"T3\" ON \"T2\".\"actorid\" = \"T3\".\"actorid\" WHERE \"T1\".\"country\" = 'UK';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 43,
                "dilatect_content": "IIF(T3.a_gender = 'M', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 61,
                "end_index": 88,
                "dilatect_content": "IIF(T3.a_gender = 'F', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 68,
                "dilatect_content": "CASE WHEN \"T3\".\"a_gender\" = 'M' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 86,
                "end_index": 138,
                "dilatect_content": "CASE WHEN \"T3\".\"a_gender\" = 'F' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies`\nColumns:\n(`movieid`, integer, primary key)\n(`year`, integer)\n(`isEnglish`, text)\n(`country`, text)\n(`runningtime`, integer)\n",
            "Table: `movies2actors`\nColumns:\n(`movieid`, integer, primary key)\n(`actorid`, integer, primary key)\n(`cast_num`, integer)\n",
            "Table: `actors`\nColumns:\n(`actorid`, integer, primary key)\n(`a_gender`, text)\n(`a_quality`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"movies\"\nColumns:\n(\"movieid\", BIGINT, primary key)\n(\"_year\", BIGINT)\n(\"isEnglish\", STRING)\n(\"country\", STRING)\n(\"runningtime\", BIGINT)\n",
            "Table: \"movies2actors\"\nColumns:\n(\"movieid\", BIGINT, primary key)\n(\"actorid\", BIGINT, primary key)\n(\"cast_num\", BIGINT)\n",
            "Table: \"actors\"\nColumns:\n(\"actorid\", BIGINT, primary key)\n(\"a_gender\", STRING)\n(\"a_quality\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 187,
        "database_name": "movielens",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.cast_num = 2 AND T1.a_quality = 2, 1, 0)) AS REAL) * 100 / COUNT(T1.actorid) FROM actors AS T1 INNER JOIN movies2actors AS T2 ON T1.actorid = T2.actorid WHERE T2.movieid = 1672580 AND T1.a_gender = 'F'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"cast_num\" = 2 AND \"T1\".\"a_quality\" = 2 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"actorid\") \nFROM \"actors\" AS \"T1\" \nINNER JOIN \"movies2actors\" AS \"T2\" ON \"T1\".\"actorid\" = \"T2\".\"actorid\" \nWHERE \"T2\".\"movieid\" = 1672580 AND \"T1\".\"a_gender\" = 'F';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 62,
                "dilatect_content": "IIF(T2.cast_num = 2 AND T1.a_quality = 2, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 95,
                "dilatect_content": "CASE WHEN \"T2\".\"cast_num\" = 2 AND \"T1\".\"a_quality\" = 2 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `actors`\nColumns:\n(`actorid`, integer, primary key)\n(`a_gender`, text)\n(`a_quality`, integer)\n",
            "Table: `movies2actors`\nColumns:\n(`movieid`, integer, primary key)\n(`actorid`, integer, primary key)\n(`cast_num`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"actors\"\nColumns:\n(\"actorid\", BIGINT, primary key)\n(\"a_gender\", STRING)\n(\"a_quality\", BIGINT)\n",
            "Table: \"movies2actors\"\nColumns:\n(\"movieid\", BIGINT, primary key)\n(\"actorid\", BIGINT, primary key)\n(\"cast_num\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 188,
        "database_name": "movielens",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(a_gender = 'M', 1, 0)) AS REAL) / SUM(IIF(a_gender = 'F', 1, 0)) FROM actors WHERE a_quality = 0",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"a_gender\" = 'M' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN \"a_gender\" = 'F' THEN 1 ELSE 0 END) FROM \"actors\" WHERE \"a_quality\" = 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 40,
                "dilatect_content": "IIF(a_gender = 'M', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 58,
                "end_index": 82,
                "dilatect_content": "IIF(a_gender = 'F', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 61,
                "dilatect_content": "CASE WHEN \"a_gender\" = 'M' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 79,
                "end_index": 124,
                "dilatect_content": "CASE WHEN \"a_gender\" = 'F' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `actors`\nColumns:\n(`actorid`, integer, primary key)\n(`a_gender`, text)\n(`a_quality`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"actors\"\nColumns:\n(\"actorid\", BIGINT, primary key)\n(\"a_gender\", STRING)\n(\"a_quality\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 189,
        "database_name": "movielens",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(T1.a_gender = 'F', 1, 0)) , T3.country, T3.runningtime FROM actors AS T1 INNER JOIN movies2actors AS T2 ON T1.actorid = T2.actorid INNER JOIN movies AS T3 ON T2.movieid = T3.movieid WHERE T2.movieid = 2312852 GROUP BY T3.country, T3.runningtime",
        "target_query": "SELECT SUM(CASE WHEN \"T1\".\"a_gender\" = 'F' THEN 1 ELSE 0 END), \"T3\".\"country\", \"T3\".\"runningtime\" FROM \"actors\" AS \"T1\" INNER JOIN \"movies2actors\" AS \"T2\" ON \"T1\".\"actorid\" = \"T2\".\"actorid\" INNER JOIN \"movies\" AS \"T3\" ON \"T2\".\"movieid\" = \"T3\".\"movieid\" WHERE \"T2\".\"movieid\" = 2312852 GROUP BY \"T3\".\"country\", \"T3\".\"runningtime\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 38,
                "dilatect_content": "IIF(T1.a_gender = 'F', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 63,
                "dilatect_content": "CASE WHEN \"T1\".\"a_gender\" = 'F' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `actors`\nColumns:\n(`actorid`, integer, primary key)\n(`a_gender`, text)\n(`a_quality`, integer)\n",
            "Table: `movies2actors`\nColumns:\n(`movieid`, integer, primary key)\n(`actorid`, integer, primary key)\n(`cast_num`, integer)\n",
            "Table: `movies`\nColumns:\n(`movieid`, integer, primary key)\n(`year`, integer)\n(`isEnglish`, text)\n(`country`, text)\n(`runningtime`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"actors\"\nColumns:\n(\"actorid\", BIGINT, primary key)\n(\"a_gender\", STRING)\n(\"a_quality\", BIGINT)\n",
            "Table: \"movies2actors\"\nColumns:\n(\"movieid\", BIGINT, primary key)\n(\"actorid\", BIGINT, primary key)\n(\"cast_num\", BIGINT)\n",
            "Table: \"movies\"\nColumns:\n(\"movieid\", BIGINT, primary key)\n(\"_year\", BIGINT)\n(\"isEnglish\", STRING)\n(\"country\", STRING)\n(\"runningtime\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 190,
        "database_name": "movielens",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T1.isEnglish = 'T', 1, 0)) - SUM(IIF(T1.isEnglish = 'F', 1, 0)) AS REAL) * 100 / COUNT(T1.movieid) FROM movies AS T1 INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid WHERE T1.country = 'other' AND T1.year = 3",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T1\".\"isEnglish\" = 'T' THEN 1 ELSE 0 END) - SUM(CASE WHEN \"T1\".\"isEnglish\" = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"movieid\") FROM \"movies\" AS \"T1\" INNER JOIN \"movies2directors\" AS \"T2\" ON \"T1\".\"movieid\" = \"T2\".\"movieid\" WHERE \"T1\".\"country\" = 'other' AND \"T1\".\"_year\" = 3",
        "semantic_equivalent_type": "approximate_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 44,
                "dilatect_content": "IIF(T1.isEnglish = 'T', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 53,
                "end_index": 81,
                "dilatect_content": "IIF(T1.isEnglish = 'F', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 69,
                "dilatect_content": "CASE WHEN \"T1\".\"isEnglish\" = 'T' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 78,
                "end_index": 131,
                "dilatect_content": "CASE WHEN \"T1\".\"isEnglish\" = 'F' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies`\nColumns:\n(`movieid`, integer, primary key)\n(`year`, integer)\n(`isEnglish`, text)\n(`country`, text)\n(`runningtime`, integer)\n",
            "Table: `movies2directors`\nColumns:\n(`movieid`, integer, primary key)\n(`directorid`, integer, primary key)\n(`genre`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"movies\"\nColumns:\n(\"movieid\", BIGINT, primary key)\n(\"_year\", BIGINT)\n(\"isEnglish\", STRING)\n(\"country\", STRING)\n(\"runningtime\", BIGINT)\n",
            "Table: \"movies2directors\"\nColumns:\n(\"movieid\", BIGINT, primary key)\n(\"directorid\", BIGINT, primary key)\n(\"genre\", STRING)\n"
        ]
    },
    {
        "sql_id": 191,
        "database_name": "movielens",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(a_gender = 'M', 1, 0)) , SUM(IIF(a_gender = 'F', 1, 0)) , CAST(SUM(IIF(a_quality = 5, 1, 0)) AS REAL) * 100 / COUNT(*) , CAST(SUM(IIF(a_quality = 0, 1, 0)) AS REAL) * 100 / COUNT(*), ( SELECT directorid FROM movies2directors WHERE movieid = 1684910 ) , ( SELECT genre FROM movies2directors WHERE movieid = 1684910 ) FROM actors WHERE actorid IN ( SELECT actorid FROM movies2actors WHERE movieid = 1684910 )",
        "target_query": "SELECT SUM(CASE WHEN \"a_gender\" = 'M' THEN 1 ELSE 0 END), SUM(CASE WHEN \"a_gender\" = 'F' THEN 1 ELSE 0 END), CAST(SUM(CASE WHEN \"a_quality\" = 5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*), CAST(SUM(CASE WHEN \"a_quality\" = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*), (SELECT \"directorid\" FROM \"movies2directors\" WHERE \"movieid\" = 1684910), (SELECT \"genre\" FROM \"movies2directors\" WHERE \"movieid\" = 1684910) FROM \"actors\" WHERE \"actorid\" IN (SELECT \"actorid\" FROM \"movies2actors\" WHERE \"movieid\" = 1684910);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 35,
                "dilatect_content": "IIF(a_gender = 'M', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 44,
                "end_index": 68,
                "dilatect_content": "IIF(a_gender = 'F', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 82,
                "end_index": 105,
                "dilatect_content": "IIF(a_quality = 5, 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 145,
                "end_index": 168,
                "dilatect_content": "IIF(a_quality = 0, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 56,
                "dilatect_content": "CASE WHEN \"a_gender\" = 'M' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 64,
                "end_index": 109,
                "dilatect_content": "CASE WHEN \"a_gender\" = 'F' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 122,
                "end_index": 166,
                "dilatect_content": "CASE WHEN \"a_quality\" = 5 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 205,
                "end_index": 249,
                "dilatect_content": "CASE WHEN \"a_quality\" = 0 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `actors`\nColumns:\n(`actorid`, integer, primary key)\n(`a_gender`, text)\n(`a_quality`, integer)\n",
            "Table: `movies2directors`\nColumns:\n(`movieid`, integer, primary key)\n(`directorid`, integer, primary key)\n(`genre`, text)\n",
            "Table: `movies2actors`\nColumns:\n(`movieid`, integer, primary key)\n(`actorid`, integer, primary key)\n(`cast_num`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"actors\"\nColumns:\n(\"actorid\", BIGINT, primary key)\n(\"a_gender\", STRING)\n(\"a_quality\", BIGINT)\n",
            "Table: \"movies2directors\"\nColumns:\n(\"movieid\", BIGINT, primary key)\n(\"directorid\", BIGINT, primary key)\n(\"genre\", STRING)\n",
            "Table: \"movies2actors\"\nColumns:\n(\"movieid\", BIGINT, primary key)\n(\"actorid\", BIGINT, primary key)\n(\"cast_num\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 192,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT MAX(strftime('%J', `Ship Date`) - strftime('%J', `Order Date`)) AS longestTimeDays FROM people AS T1 INNER JOIN central_superstore AS T2 ON T1.`Customer ID` = T2.`Customer ID` WHERE T1.`Customer Name` = 'Aimee Bixby'",
        "target_query": "SELECT MAX(\"Ship_Date\" - \"Order_Date\") AS \"longestTimeDays\" FROM \"people\" AS \"T1\" INNER JOIN \"central_superstore\" AS \"T2\" ON \"T1\".\"Customer_ID\" = \"T2\".\"Customer_ID\" WHERE \"T1\".\"Customer_Name\" = 'Aimee Bixby'",
        "semantic_equivalent_type": "approximate_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 37,
                "dilatect_content": "strftime('%J', `Ship Date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 41,
                "end_index": 68,
                "dilatect_content": "strftime('%J', `Order Date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `people`\nColumns:\n(`Customer ID`, text, primary key)\n(`Customer Name`, text)\n(`Segment`, text)\n(`Country`, text)\n(`City`, text)\n(`State`, text)\n(`Postal Code`, integer)\n(`Region`, text, primary key)\n",
            "Table: `central_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"people\"\nColumns:\n(\"Customer_ID\", STRING, primary key)\n(\"Customer_Name\", STRING)\n(\"Segment\", STRING)\n(\"Country\", STRING)\n(\"City\", STRING)\n(\"State\", STRING)\n(\"Postal_Code\", BIGINT)\n(\"Region\", STRING, primary key)\n",
            "Table: \"central_superstore\"\nColumns:\n(\"Row_ID\", BIGINT, primary key)\n(\"Order_ID\", STRING)\n(\"Order_Date\", DATE)\n(\"Ship_Date\", DATE)\n(\"Ship_Mode\", STRING)\n(\"Customer_ID\", STRING)\n(\"Region\", STRING)\n(\"Product_ID\", STRING)\n(\"Sales\", DOUBLE PRECISION)\n(\"Quantity\", BIGINT)\n(\"Discount\", DOUBLE PRECISION)\n(\"Profit\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 193,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT T3.`Product Name` FROM people AS T1 INNER JOIN central_superstore AS T2 ON T1.`Customer ID` = T2.`Customer ID` INNER JOIN product AS T3 ON T3.`Product ID` = T2.`Product ID` WHERE T1.`Customer Name` = 'Aimee Bixby' AND STRFTIME('%Y', T2.`Ship Date`) = '2016'",
        "target_query": "SELECT DISTINCT T3.\"Product_Name\" FROM \"people\" AS T1 INNER JOIN \"central_superstore\" AS T2 ON T1.\"Customer_ID\" = T2.\"Customer_ID\" INNER JOIN \"product\" AS T3 ON T3.\"Product_ID\" = T2.\"Product_ID\" WHERE T1.\"Customer_Name\" = 'Aimee Bixby' AND sys.timestamp_to_str(T2.\"Ship_Date\", '%Y') = '2016';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 234,
                "end_index": 263,
                "dilatect_content": "STRFTIME('%Y', T2.`Ship Date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 258,
                "end_index": 301,
                "dilatect_content": "sys.timestamp_to_str(T2.\"Ship_Date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `people`\nColumns:\n(`Customer ID`, text, primary key)\n(`Customer Name`, text)\n(`Segment`, text)\n(`Country`, text)\n(`City`, text)\n(`State`, text)\n(`Postal Code`, integer)\n(`Region`, text, primary key)\n",
            "Table: `central_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n",
            "Table: `product`\nColumns:\n(`Product ID`, text, primary key)\n(`Product Name`, text)\n(`Category`, text)\n(`Sub-Category`, text)\n(`Region`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"people\"\nColumns:\n(\"Customer_ID\", STRING, primary key)\n(\"Customer_Name\", STRING)\n(\"Segment\", STRING)\n(\"Country\", STRING)\n(\"City\", STRING)\n(\"State\", STRING)\n(\"Postal_Code\", BIGINT)\n(\"Region\", STRING, primary key)\n",
            "Table: \"central_superstore\"\nColumns:\n(\"Row_ID\", BIGINT, primary key)\n(\"Order_ID\", STRING)\n(\"Order_Date\", DATE)\n(\"Ship_Date\", DATE)\n(\"Ship_Mode\", STRING)\n(\"Customer_ID\", STRING)\n(\"Region\", STRING)\n(\"Product_ID\", STRING)\n(\"Sales\", DOUBLE PRECISION)\n(\"Quantity\", BIGINT)\n(\"Discount\", DOUBLE PRECISION)\n(\"Profit\", DOUBLE PRECISION)\n",
            "Table: \"product\"\nColumns:\n(\"Product_ID\", STRING, primary key)\n(\"Product_Name\", STRING)\n(\"Category\", STRING)\n(\"Sub_Category\", STRING)\n(\"Region\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 194,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(DISTINCT T1.`Product ID`) FROM east_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` WHERE T2.`Sub-Category` = 'Art' AND T1.Region = 'East' AND STRFTIME('%Y', T1.`Order Date`) = '2013'",
        "target_query": "SELECT COUNT(DISTINCT T1.\"Product_ID\") FROM \"east_superstore\" AS T1 INNER JOIN \"product\" AS T2 ON T1.\"Product_ID\" = T2.\"Product_ID\" WHERE T2.\"Sub_Category\" = 'Art' AND T1.\"Region\" = 'East' AND sys.timestamp_to_str(T1.\"Order_Date\", '%Y') = '2013';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 187,
                "end_index": 217,
                "dilatect_content": "STRFTIME('%Y', T1.`Order Date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 207,
                "end_index": 251,
                "dilatect_content": "sys.timestamp_to_str(T1.\"Order_Date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `east_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n",
            "Table: `product`\nColumns:\n(`Product ID`, text, primary key)\n(`Product Name`, text)\n(`Category`, text)\n(`Sub-Category`, text)\n(`Region`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"east_superstore\"\nColumns:\n(\"Row_ID\", BIGINT, primary key)\n(\"Order_ID\", STRING)\n(\"Order_Date\", DATE)\n(\"Ship_Date\", DATE)\n(\"Ship_Mode\", STRING)\n(\"Customer_ID\", STRING)\n(\"Region\", STRING)\n(\"Product_ID\", STRING)\n(\"Sales\", DOUBLE PRECISION)\n(\"Quantity\", BIGINT)\n(\"Discount\", DOUBLE PRECISION)\n(\"Profit\", DOUBLE PRECISION)\n",
            "Table: \"product\"\nColumns:\n(\"Product_ID\", STRING, primary key)\n(\"Product_Name\", STRING)\n(\"Category\", STRING)\n(\"Sub_Category\", STRING)\n(\"Region\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 195,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(DISTINCT T1.`Order ID`) FROM east_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` WHERE T2.`Customer Name` = 'Maxwell Schwartz' AND STRFTIME('%Y', T1.`Order Date`) = '2015'",
        "target_query": "SELECT COUNT(DISTINCT T1.\"Order_ID\") FROM \"east_superstore\" AS T1 INNER JOIN \"people\" AS T2 ON T1.\"Customer_ID\" = T2.\"Customer_ID\" WHERE T2.\"Customer_Name\" = 'Maxwell Schwartz' AND sys.timestamp_to_str(T1.\"Order_Date\", '%Y') = '2015';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 177,
                "end_index": 207,
                "dilatect_content": "STRFTIME('%Y', T1.`Order Date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 193,
                "end_index": 237,
                "dilatect_content": "sys.timestamp_to_str(T1.\"Order_Date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `east_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n",
            "Table: `people`\nColumns:\n(`Customer ID`, text, primary key)\n(`Customer Name`, text)\n(`Segment`, text)\n(`Country`, text)\n(`City`, text)\n(`State`, text)\n(`Postal Code`, integer)\n(`Region`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"east_superstore\"\nColumns:\n(\"Row_ID\", BIGINT, primary key)\n(\"Order_ID\", STRING)\n(\"Order_Date\", DATE)\n(\"Ship_Date\", DATE)\n(\"Ship_Mode\", STRING)\n(\"Customer_ID\", STRING)\n(\"Region\", STRING)\n(\"Product_ID\", STRING)\n(\"Sales\", DOUBLE PRECISION)\n(\"Quantity\", BIGINT)\n(\"Discount\", DOUBLE PRECISION)\n(\"Profit\", DOUBLE PRECISION)\n",
            "Table: \"people\"\nColumns:\n(\"Customer_ID\", STRING, primary key)\n(\"Customer_Name\", STRING)\n(\"Segment\", STRING)\n(\"Country\", STRING)\n(\"City\", STRING)\n(\"State\", STRING)\n(\"Postal_Code\", BIGINT)\n(\"Region\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 196,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT T3.`Product Name` FROM west_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` INNER JOIN product AS T3 ON T3.`Product ID` = T1.`Product ID` WHERE T2.`Customer Name` = 'Matt Abelman' AND STRFTIME('%Y', T1.`Order Date`) = '2013'",
        "target_query": "SELECT DISTINCT \"T3\".\"Product_Name\" FROM \"west_superstore\" AS \"T1\" INNER JOIN \"people\" AS \"T2\" ON \"T1\".\"Customer_ID\" = \"T2\".\"Customer_ID\" INNER JOIN \"product\" AS \"T3\" ON \"T3\".\"Product_ID\" = \"T1\".\"Product_ID\" WHERE \"T2\".\"Customer_Name\" = 'Matt Abelman' AND sys.timestamp_to_str(\"T1\".\"Order_Date\", '%Y') = '2013';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 232,
                "end_index": 262,
                "dilatect_content": "STRFTIME('%Y', T1.`Order Date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 292,
                "end_index": 340,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"Order_Date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `west_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n",
            "Table: `people`\nColumns:\n(`Customer ID`, text, primary key)\n(`Customer Name`, text)\n(`Segment`, text)\n(`Country`, text)\n(`City`, text)\n(`State`, text)\n(`Postal Code`, integer)\n(`Region`, text, primary key)\n",
            "Table: `product`\nColumns:\n(`Product ID`, text, primary key)\n(`Product Name`, text)\n(`Category`, text)\n(`Sub-Category`, text)\n(`Region`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"west_superstore\"\nColumns:\n(\"Row_ID\", BIGINT, primary key)\n(\"Order_ID\", STRING)\n(\"Order_Date\", DATE)\n(\"Ship_Date\", DATE)\n(\"Ship_Mode\", STRING)\n(\"Customer_ID\", STRING)\n(\"Region\", STRING)\n(\"Product_ID\", STRING)\n(\"Sales\", DOUBLE PRECISION)\n(\"Quantity\", BIGINT)\n(\"Discount\", DOUBLE PRECISION)\n(\"Profit\", DOUBLE PRECISION)\n",
            "Table: \"people\"\nColumns:\n(\"Customer_ID\", STRING, primary key)\n(\"Customer_Name\", STRING)\n(\"Segment\", STRING)\n(\"Country\", STRING)\n(\"City\", STRING)\n(\"State\", STRING)\n(\"Postal_Code\", BIGINT)\n(\"Region\", STRING, primary key)\n",
            "Table: \"product\"\nColumns:\n(\"Product_ID\", STRING, primary key)\n(\"Product_Name\", STRING)\n(\"Category\", STRING)\n(\"Sub_Category\", STRING)\n(\"Region\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 197,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM((T1.Sales / (1 - T1.Discount)) * T1.Quantity - T1.Profit) AS cost FROM east_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` INNER JOIN product AS T3 ON T1.`Product ID` = T3.`Product ID` AND T1.Region = T3.Region WHERE T1.Region = 'East' AND T2.`Customer Name` = 'Brad Thomas' AND strftime('%Y', T1.`Order Date`) = '2016'",
        "target_query": "SELECT SUM((T1.\"Sales\" / (1 - T1.\"Discount\")) * T1.\"Quantity\" - T1.\"Profit\") AS \"cost\" FROM \"east_superstore\" AS T1 INNER JOIN \"people\" AS T2 ON T1.\"Customer_ID\" = T2.\"Customer_ID\" INNER JOIN \"product\" AS T3 ON T1.\"Product_ID\" = T3.\"Product_ID\" AND T1.\"Region\" = T3.\"Region\" WHERE T1.\"Region\" = 'East' AND T2.\"Customer_Name\" = 'Brad Thomas' AND sys.timestamp_to_str(T1.\"Order_Date\", '%Y') = '2016';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 323,
                "end_index": 353,
                "dilatect_content": "strftime('%Y', T1.`Order Date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 377,
                "end_index": 421,
                "dilatect_content": "sys.timestamp_to_str(T1.\"Order_Date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `east_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n",
            "Table: `people`\nColumns:\n(`Customer ID`, text, primary key)\n(`Customer Name`, text)\n(`Segment`, text)\n(`Country`, text)\n(`City`, text)\n(`State`, text)\n(`Postal Code`, integer)\n(`Region`, text, primary key)\n",
            "Table: `product`\nColumns:\n(`Product ID`, text, primary key)\n(`Product Name`, text)\n(`Category`, text)\n(`Sub-Category`, text)\n(`Region`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"east_superstore\"\nColumns:\n(\"Row_ID\", BIGINT, primary key)\n(\"Order_ID\", STRING)\n(\"Order_Date\", DATE)\n(\"Ship_Date\", DATE)\n(\"Ship_Mode\", STRING)\n(\"Customer_ID\", STRING)\n(\"Region\", STRING)\n(\"Product_ID\", STRING)\n(\"Sales\", DOUBLE PRECISION)\n(\"Quantity\", BIGINT)\n(\"Discount\", DOUBLE PRECISION)\n(\"Profit\", DOUBLE PRECISION)\n",
            "Table: \"people\"\nColumns:\n(\"Customer_ID\", STRING, primary key)\n(\"Customer_Name\", STRING)\n(\"Segment\", STRING)\n(\"Country\", STRING)\n(\"City\", STRING)\n(\"State\", STRING)\n(\"Postal_Code\", BIGINT)\n(\"Region\", STRING, primary key)\n",
            "Table: \"product\"\nColumns:\n(\"Product_ID\", STRING, primary key)\n(\"Product_Name\", STRING)\n(\"Category\", STRING)\n(\"Sub_Category\", STRING)\n(\"Region\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 198,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(T1.Sales) FROM east_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` WHERE STRFTIME('%Y', T1.`Order Date`) = '2016' AND T2.Category = 'Furniture'",
        "target_query": "SELECT SUM(\"T1\".\"Sales\") FROM \"east_superstore\" AS \"T1\" INNER JOIN \"product\" AS \"T2\" ON \"T1\".\"Product_ID\" = \"T2\".\"Product_ID\" WHERE sys.timestamp_to_str(\"T1\".\"Order_Date\", '%Y') = '2016' AND \"T2\".\"Category\" = 'Furniture';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 116,
                "end_index": 146,
                "dilatect_content": "STRFTIME('%Y', T1.`Order Date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 152,
                "end_index": 200,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"Order_Date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `east_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n",
            "Table: `product`\nColumns:\n(`Product ID`, text, primary key)\n(`Product Name`, text)\n(`Category`, text)\n(`Sub-Category`, text)\n(`Region`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"east_superstore\"\nColumns:\n(\"Row_ID\", BIGINT, primary key)\n(\"Order_ID\", STRING)\n(\"Order_Date\", DATE)\n(\"Ship_Date\", DATE)\n(\"Ship_Mode\", STRING)\n(\"Customer_ID\", STRING)\n(\"Region\", STRING)\n(\"Product_ID\", STRING)\n(\"Sales\", DOUBLE PRECISION)\n(\"Quantity\", BIGINT)\n(\"Discount\", DOUBLE PRECISION)\n(\"Profit\", DOUBLE PRECISION)\n",
            "Table: \"product\"\nColumns:\n(\"Product_ID\", STRING, primary key)\n(\"Product_Name\", STRING)\n(\"Category\", STRING)\n(\"Sub_Category\", STRING)\n(\"Region\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 199,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT T2.`Customer Name` FROM south_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` WHERE STRFTIME('%Y', T1.`Order Date`) = '2015' GROUP BY T2.`Customer Name` HAVING COUNT(T2.`Customer Name`) > 3",
        "target_query": "SELECT DISTINCT T2.\"Customer_Name\" FROM \"south_superstore\" AS T1 INNER JOIN \"people\" AS T2 ON T1.\"Customer_ID\" = T2.\"Customer_ID\" WHERE sys.timestamp_to_str(T1.\"Order_Date\", '%Y') = '2015' GROUP BY T2.\"Customer_Name\" HAVING COUNT(T2.\"Customer_Name\") > 3;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 132,
                "end_index": 162,
                "dilatect_content": "STRFTIME('%Y', T1.`Order Date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 146,
                "end_index": 192,
                "dilatect_content": "sys.timestamp_to_str(T1.\"Order_Date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `south_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n",
            "Table: `people`\nColumns:\n(`Customer ID`, text, primary key)\n(`Customer Name`, text)\n(`Segment`, text)\n(`Country`, text)\n(`City`, text)\n(`State`, text)\n(`Postal Code`, integer)\n(`Region`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"south_superstore\"\nColumns:\n(\"Row_ID\", BIGINT, primary key)\n(\"Order_ID\", STRING)\n(\"Order_Date\", DATE)\n(\"Ship_Date\", DATE)\n(\"Ship_Mode\", STRING)\n(\"Customer_ID\", STRING)\n(\"Region\", STRING)\n(\"Product_ID\", STRING)\n(\"Sales\", DOUBLE PRECISION)\n(\"Quantity\", BIGINT)\n(\"Discount\", DOUBLE PRECISION)\n(\"Profit\", DOUBLE PRECISION)\n",
            "Table: \"people\"\nColumns:\n(\"Customer_ID\", STRING, primary key)\n(\"Customer_Name\", STRING)\n(\"Segment\", STRING)\n(\"Country\", STRING)\n(\"City\", STRING)\n(\"State\", STRING)\n(\"Postal_Code\", BIGINT)\n(\"Region\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 200,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T2.`Customer ID`) FROM people AS T1 INNER JOIN central_superstore AS T2 ON T1.`Customer ID` = T2.`Customer ID` WHERE T1.`Customer Name` = 'Corey Roper' AND STRFTIME('%Y', T2.`Ship Date`) = '2015'",
        "target_query": "SELECT COUNT(T2.\"Customer_ID\") FROM \"people\" AS T1 INNER JOIN \"central_superstore\" AS T2 ON T1.\"Customer_ID\" = T2.\"Customer_ID\" WHERE T1.\"Customer_Name\" = 'Corey Roper' AND sys.timestamp_to_str(T2.\"Ship_Date\", '%Y') = '2015';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 169,
                "end_index": 198,
                "dilatect_content": "STRFTIME('%Y', T2.`Ship Date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 185,
                "end_index": 228,
                "dilatect_content": "sys.timestamp_to_str(T2.\"Ship_Date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `people`\nColumns:\n(`Customer ID`, text, primary key)\n(`Customer Name`, text)\n(`Segment`, text)\n(`Country`, text)\n(`City`, text)\n(`State`, text)\n(`Postal Code`, integer)\n(`Region`, text, primary key)\n",
            "Table: `central_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"people\"\nColumns:\n(\"Customer_ID\", STRING, primary key)\n(\"Customer_Name\", STRING)\n(\"Segment\", STRING)\n(\"Country\", STRING)\n(\"City\", STRING)\n(\"State\", STRING)\n(\"Postal_Code\", BIGINT)\n(\"Region\", STRING, primary key)\n",
            "Table: \"central_superstore\"\nColumns:\n(\"Row_ID\", BIGINT, primary key)\n(\"Order_ID\", STRING)\n(\"Order_Date\", DATE)\n(\"Ship_Date\", DATE)\n(\"Ship_Mode\", STRING)\n(\"Customer_ID\", STRING)\n(\"Region\", STRING)\n(\"Product_ID\", STRING)\n(\"Sales\", DOUBLE PRECISION)\n(\"Quantity\", BIGINT)\n(\"Discount\", DOUBLE PRECISION)\n(\"Profit\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 201,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.`Customer Name` FROM east_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` WHERE T2.Segment = 'Corporate' AND T2.State = 'Rhode Island' AND T2.Region = 'East' AND STRFTIME('%Y', T1.`Order Date`) = '2016' GROUP BY T2.`Customer Name` ORDER BY COUNT(T2.`Customer Name`) DESC LIMIT 1",
        "target_query": "SELECT T2.\"Customer_Name\" FROM \"east_superstore\" AS T1 INNER JOIN \"people\" AS T2 ON T1.\"Customer_ID\" = T2.\"Customer_ID\" WHERE T2.\"Segment\" = 'Corporate' AND T2.\"State\" = 'Rhode Island' AND T2.\"Region\" = 'East' AND sys.timestamp_to_str(T1.\"Order_Date\", '%Y') = '2016' GROUP BY T2.\"Customer_Name\" ORDER BY COUNT(T2.\"Customer_Name\") DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 204,
                "end_index": 234,
                "dilatect_content": "STRFTIME('%Y', T1.`Order Date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 230,
                "end_index": 274,
                "dilatect_content": "sys.timestamp_to_str(T1.\"Order_Date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `east_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n",
            "Table: `people`\nColumns:\n(`Customer ID`, text, primary key)\n(`Customer Name`, text)\n(`Segment`, text)\n(`Country`, text)\n(`City`, text)\n(`State`, text)\n(`Postal Code`, integer)\n(`Region`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"east_superstore\"\nColumns:\n(\"Row_ID\", BIGINT, primary key)\n(\"Order_ID\", STRING)\n(\"Order_Date\", DATE)\n(\"Ship_Date\", DATE)\n(\"Ship_Mode\", STRING)\n(\"Customer_ID\", STRING)\n(\"Region\", STRING)\n(\"Product_ID\", STRING)\n(\"Sales\", DOUBLE PRECISION)\n(\"Quantity\", BIGINT)\n(\"Discount\", DOUBLE PRECISION)\n(\"Profit\", DOUBLE PRECISION)\n",
            "Table: \"people\"\nColumns:\n(\"Customer_ID\", STRING, primary key)\n(\"Customer_Name\", STRING)\n(\"Segment\", STRING)\n(\"Country\", STRING)\n(\"City\", STRING)\n(\"State\", STRING)\n(\"Postal_Code\", BIGINT)\n(\"Region\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 202,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT strftime('%J', `Ship Date`) - strftime('%J', `Order Date`) AS duration FROM central_superstore WHERE `Order ID` = 'CA-2011-134103'",
        "target_query": "SELECT DISTINCT (\"Ship_Date\" - \"Order_Date\") AS duration FROM \"central_superstore\" WHERE \"Order_ID\" = 'CA-2011-134103'",
        "semantic_equivalent_type": "approximate_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 42,
                "dilatect_content": "strftime('%J', `Ship Date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 46,
                "end_index": 73,
                "dilatect_content": "strftime('%J', `Order Date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `central_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"central_superstore\"\nColumns:\n(\"Row_ID\", BIGINT, primary key)\n(\"Order_ID\", STRING)\n(\"Order_Date\", DATE)\n(\"Ship_Date\", DATE)\n(\"Ship_Mode\", STRING)\n(\"Customer_ID\", STRING)\n(\"Region\", STRING)\n(\"Product_ID\", STRING)\n(\"Sales\", DOUBLE PRECISION)\n(\"Quantity\", BIGINT)\n(\"Discount\", DOUBLE PRECISION)\n(\"Profit\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 203,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT T2.`Product Name` FROM central_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` WHERE strftime('%Y-%m', T1.`Ship Date`) = '2013-03'",
        "target_query": "SELECT DISTINCT T2.\"Product_Name\" FROM \"central_superstore\" AS T1 INNER JOIN \"product\" AS T2 ON T1.\"Product_ID\" = T2.\"Product_ID\" WHERE sys.timestamp_to_str(T1.\"Ship_Date\", '%Y-%m') = '2013-03';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 132,
                "end_index": 164,
                "dilatect_content": "strftime('%Y-%m', T1.`Ship Date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 146,
                "end_index": 192,
                "dilatect_content": "sys.timestamp_to_str(T1.\"Ship_Date\", '%Y-%m')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `central_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n",
            "Table: `product`\nColumns:\n(`Product ID`, text, primary key)\n(`Product Name`, text)\n(`Category`, text)\n(`Sub-Category`, text)\n(`Region`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"central_superstore\"\nColumns:\n(\"Row_ID\", BIGINT, primary key)\n(\"Order_ID\", STRING)\n(\"Order_Date\", DATE)\n(\"Ship_Date\", DATE)\n(\"Ship_Mode\", STRING)\n(\"Customer_ID\", STRING)\n(\"Region\", STRING)\n(\"Product_ID\", STRING)\n(\"Sales\", DOUBLE PRECISION)\n(\"Quantity\", BIGINT)\n(\"Discount\", DOUBLE PRECISION)\n(\"Profit\", DOUBLE PRECISION)\n",
            "Table: \"product\"\nColumns:\n(\"Product_ID\", STRING, primary key)\n(\"Product_Name\", STRING)\n(\"Category\", STRING)\n(\"Sub_Category\", STRING)\n(\"Region\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 204,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(DISTINCT T2.`Order ID`) FROM people AS T1 INNER JOIN central_superstore AS T2 ON T1.`Customer ID` = T2.`Customer ID` WHERE T1.`Customer Name` = 'Alan Barnes' AND STRFTIME('%Y', T2.`Order Date`) = '2015'",
        "target_query": "SELECT COUNT(DISTINCT T2.\"Order_ID\") FROM \"people\" AS T1 INNER JOIN \"central_superstore\" AS T2 ON T1.\"Customer_ID\" = T2.\"Customer_ID\" WHERE T1.\"Customer_Name\" = 'Alan Barnes' AND sys.timestamp_to_str(T2.\"Order_Date\", '%Y') = '2015';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 175,
                "end_index": 205,
                "dilatect_content": "STRFTIME('%Y', T2.`Order Date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 191,
                "end_index": 235,
                "dilatect_content": "sys.timestamp_to_str(T2.\"Order_Date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `people`\nColumns:\n(`Customer ID`, text, primary key)\n(`Customer Name`, text)\n(`Segment`, text)\n(`Country`, text)\n(`City`, text)\n(`State`, text)\n(`Postal Code`, integer)\n(`Region`, text, primary key)\n",
            "Table: `central_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"people\"\nColumns:\n(\"Customer_ID\", STRING, primary key)\n(\"Customer_Name\", STRING)\n(\"Segment\", STRING)\n(\"Country\", STRING)\n(\"City\", STRING)\n(\"State\", STRING)\n(\"Postal_Code\", BIGINT)\n(\"Region\", STRING, primary key)\n",
            "Table: \"central_superstore\"\nColumns:\n(\"Row_ID\", BIGINT, primary key)\n(\"Order_ID\", STRING)\n(\"Order_Date\", DATE)\n(\"Ship_Date\", DATE)\n(\"Ship_Mode\", STRING)\n(\"Customer_ID\", STRING)\n(\"Region\", STRING)\n(\"Product_ID\", STRING)\n(\"Sales\", DOUBLE PRECISION)\n(\"Quantity\", BIGINT)\n(\"Discount\", DOUBLE PRECISION)\n(\"Profit\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 205,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(CASE  WHEN T1.`Ship Mode` = 'First Class' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM central_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` WHERE T2.Category = 'Furniture' AND STRFTIME('%Y', T1.`Ship Date`) = '2013'",
        "target_query": "SELECT CAST(SUM(CASE WHEN T1.\"Ship_Mode\" = 'First Class' THEN 1 ELSE 0 END) AS DOUBLE PRECISION) * 100 / COUNT(*) FROM \"central_superstore\" AS T1 INNER JOIN \"product\" AS T2 ON T1.\"Product_ID\" = T2.\"Product_ID\" WHERE T2.\"Category\" = 'Furniture' AND sys.timestamp_to_str(T1.\"Ship_Date\", '%Y') = '2013';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 231,
                "end_index": 260,
                "dilatect_content": "STRFTIME('%Y', T1.`Ship Date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 260,
                "end_index": 303,
                "dilatect_content": "sys.timestamp_to_str(T1.\"Ship_Date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `central_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n",
            "Table: `product`\nColumns:\n(`Product ID`, text, primary key)\n(`Product Name`, text)\n(`Category`, text)\n(`Sub-Category`, text)\n(`Region`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"central_superstore\"\nColumns:\n(\"Row_ID\", BIGINT, primary key)\n(\"Order_ID\", STRING)\n(\"Order_Date\", DATE)\n(\"Ship_Date\", DATE)\n(\"Ship_Mode\", STRING)\n(\"Customer_ID\", STRING)\n(\"Region\", STRING)\n(\"Product_ID\", STRING)\n(\"Sales\", DOUBLE PRECISION)\n(\"Quantity\", BIGINT)\n(\"Discount\", DOUBLE PRECISION)\n(\"Profit\", DOUBLE PRECISION)\n",
            "Table: \"product\"\nColumns:\n(\"Product_ID\", STRING, primary key)\n(\"Product_Name\", STRING)\n(\"Category\", STRING)\n(\"Sub_Category\", STRING)\n(\"Region\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 206,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.`Product Name` FROM central_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` WHERE T2.Region = 'Central' AND STRFTIME('%Y', T1.`Order Date`) = '2016' ORDER BY T1.Profit ASC LIMIT 1",
        "target_query": "SELECT T2.\"Product_Name\" FROM \"central_superstore\" AS T1 INNER JOIN \"product\" AS T2 ON T1.\"Product_ID\" = T2.\"Product_ID\" WHERE T2.\"Region\" = 'Central' AND sys.timestamp_to_str(T1.\"Order_Date\", '%Y') = '2016' ORDER BY T1.\"Profit\" ASC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 149,
                "end_index": 179,
                "dilatect_content": "STRFTIME('%Y', T1.`Order Date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 167,
                "end_index": 211,
                "dilatect_content": "sys.timestamp_to_str(T1.\"Order_Date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `central_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n",
            "Table: `product`\nColumns:\n(`Product ID`, text, primary key)\n(`Product Name`, text)\n(`Category`, text)\n(`Sub-Category`, text)\n(`Region`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"central_superstore\"\nColumns:\n(\"Row_ID\", BIGINT, primary key)\n(\"Order_ID\", STRING)\n(\"Order_Date\", DATE)\n(\"Ship_Date\", DATE)\n(\"Ship_Mode\", STRING)\n(\"Customer_ID\", STRING)\n(\"Region\", STRING)\n(\"Product_ID\", STRING)\n(\"Sales\", DOUBLE PRECISION)\n(\"Quantity\", BIGINT)\n(\"Discount\", DOUBLE PRECISION)\n(\"Profit\", DOUBLE PRECISION)\n",
            "Table: \"product\"\nColumns:\n(\"Product_ID\", STRING, primary key)\n(\"Product_Name\", STRING)\n(\"Category\", STRING)\n(\"Sub_Category\", STRING)\n(\"Region\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 207,
        "database_name": "shooting",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(race = 'W', 1, 0)) AS REAL) * 100 / COUNT(case_number) FROM officers WHERE gender = 'M'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"race\" = 'W' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"case_number\") FROM \"officers\" WHERE \"gender\" = 'M'",
        "semantic_equivalent_type": "approximate_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 36,
                "dilatect_content": "IIF(race = 'W', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 57,
                "dilatect_content": "CASE WHEN \"race\" = 'W' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `officers`\nColumns:\n(`case_number`, text)\n(`race`, text)\n(`gender`, text)\n(`last_name`, text)\n(`first_name`, text)\n(`full_name`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"officers\"\nColumns:\n(\"case_number\", STRING)\n(\"race\", STRING)\n(\"gender\", STRING)\n(\"last_name\", STRING)\n(\"first_name\", STRING)\n(\"full_name\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 209,
        "database_name": "shooting",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT STRFTIME('%Y', date) FROM incidents WHERE subject_weapon = 'Handgun' GROUP BY STRFTIME('%Y', date) ORDER BY COUNT(case_number) DESC LIMIT 1",
        "target_query": "SELECT sys.timestamp_to_str(_date, '%Y') FROM \"incidents\" WHERE \"subject_weapon\" = 'Handgun' GROUP BY sys.timestamp_to_str(_date, '%Y') ORDER BY COUNT(\"case_number\") DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 26,
                "dilatect_content": "STRFTIME('%Y', date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 85,
                "end_index": 104,
                "dilatect_content": "STRFTIME('%Y', date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 39,
                "dilatect_content": "sys.timestamp_to_str(_date, '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 106,
                "end_index": 138,
                "dilatect_content": "sys.timestamp_to_str(_date, '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `incidents`\nColumns:\n(`case_number`, text, primary key)\n(`date`, date)\n(`location`, text)\n(`subject_statuses`, text)\n(`subject_weapon`, text)\n(`subjects`, text)\n(`subject_count`, integer)\n(`officers`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"incidents\"\nColumns:\n(\"case_number\", STRING, primary key)\n(\"_date\", DATE)\n(\"location\", STRING)\n(\"subject_statuses\", STRING)\n(\"subject_weapon\", STRING)\n(\"subjects\", STRING)\n(\"subject_count\", BIGINT)\n(\"officers\", STRING)\n"
        ]
    },
    {
        "sql_id": 210,
        "database_name": "shooting",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(STRFTIME('%Y', date) = '2007', 1, 0)) - SUM(IIF(STRFTIME('%Y', date) = '2008', 1, 0)) FROM incidents WHERE subject_weapon = 'Vehicle'",
        "target_query": "SELECT SUM(CASE WHEN sys.timestamp_to_str(\"_date\", '%Y') = '2007' THEN 1 ELSE 0 END) - SUM(CASE WHEN sys.timestamp_to_str(\"_date\", '%Y') = '2008' THEN 1 ELSE 0 END) FROM \"incidents\" WHERE \"subject_weapon\" = 'Vehicle';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 50,
                "dilatect_content": "IIF(STRFTIME('%Y', date) = '2007', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 15,
                "end_index": 34,
                "dilatect_content": "STRFTIME('%Y', date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 59,
                "end_index": 98,
                "dilatect_content": "IIF(STRFTIME('%Y', date) = '2008', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 63,
                "end_index": 82,
                "dilatect_content": "STRFTIME('%Y', date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 84,
                "dilatect_content": "CASE WHEN sys.timestamp_to_str(\"_date\", '%Y') = '2007' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 21,
                "end_index": 57,
                "dilatect_content": "sys.timestamp_to_str(\"_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 93,
                "end_index": 166,
                "dilatect_content": "CASE WHEN sys.timestamp_to_str(\"_date\", '%Y') = '2008' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 103,
                "end_index": 139,
                "dilatect_content": "sys.timestamp_to_str(\"_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            },
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            },
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `incidents`\nColumns:\n(`case_number`, text, primary key)\n(`date`, date)\n(`location`, text)\n(`subject_statuses`, text)\n(`subject_weapon`, text)\n(`subjects`, text)\n(`subject_count`, integer)\n(`officers`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"incidents\"\nColumns:\n(\"case_number\", STRING, primary key)\n(\"_date\", DATE)\n(\"location\", STRING)\n(\"subject_statuses\", STRING)\n(\"subject_weapon\", STRING)\n(\"subjects\", STRING)\n(\"subject_count\", BIGINT)\n(\"officers\", STRING)\n"
        ]
    },
    {
        "sql_id": 211,
        "database_name": "shooting",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT case_number FROM incidents WHERE STRFTIME('%Y', date) > '2011' AND subject_statuses = 'Deceased'",
        "target_query": "SELECT \"case_number\" FROM \"incidents\" WHERE sys.timestamp_to_str(\"_date\", '%Y') > '2011' AND \"subject_statuses\" = 'Deceased';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 40,
                "end_index": 59,
                "dilatect_content": "STRFTIME('%Y', date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 48,
                "end_index": 84,
                "dilatect_content": "sys.timestamp_to_str(\"_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `incidents`\nColumns:\n(`case_number`, text, primary key)\n(`date`, date)\n(`location`, text)\n(`subject_statuses`, text)\n(`subject_weapon`, text)\n(`subjects`, text)\n(`subject_count`, integer)\n(`officers`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"incidents\"\nColumns:\n(\"case_number\", STRING, primary key)\n(\"_date\", DATE)\n(\"location\", STRING)\n(\"subject_statuses\", STRING)\n(\"subject_weapon\", STRING)\n(\"subjects\", STRING)\n(\"subject_count\", BIGINT)\n(\"officers\", STRING)\n"
        ]
    },
    {
        "sql_id": 212,
        "database_name": "genes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T1.Chromosome > 10 AND T3.Chromosome > 10, 1, 0)) AS REAL) * 100 / COUNT(T1.GeneID) FROM Genes AS T1 INNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1 INNER JOIN Genes AS T3 ON T3.GeneID = T2.GeneID2 WHERE T2.Expression_Corr > 0",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T1\".\"Chromosome\" > 10 AND \"T3\".\"Chromosome\" > 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"GeneID\") FROM \"Genes\" AS \"T1\" INNER JOIN \"Interactions\" AS \"T2\" ON \"T1\".\"GeneID\" = \"T2\".\"GeneID1\" INNER JOIN \"Genes\" AS \"T3\" ON \"T3\".\"GeneID\" = \"T2\".\"GeneID2\" WHERE \"T2\".\"Expression_Corr\" > 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 67,
                "dilatect_content": "IIF(T1.Chromosome > 10 AND T3.Chromosome > 10, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 100,
                "dilatect_content": "CASE WHEN \"T1\".\"Chromosome\" > 10 AND \"T3\".\"Chromosome\" > 10 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Genes`\nColumns:\n(`GeneID`, text)\n(`Essential`, text)\n(`Class`, text)\n(`Complex`, text)\n(`Phenotype`, text)\n(`Motif`, text)\n(`Chromosome`, integer)\n(`Function`, text)\n(`Localization`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `Interactions`\nColumns:\n(`GeneID1`, text, primary key)\n(`GeneID2`, text, primary key)\n(`Type`, text)\n(`Expression_Corr`, real)\n",
            "Table: `Genes`\nColumns:\n(`GeneID`, text)\n(`Essential`, text)\n(`Class`, text)\n(`Complex`, text)\n(`Phenotype`, text)\n(`Motif`, text)\n(`Chromosome`, integer)\n(`Function`, text)\n(`Localization`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"Genes\"\nColumns:\n(\"GeneID\", STRING)\n(\"Essential\", STRING)\n(\"Class\", STRING)\n(\"Complex\", STRING)\n(\"Phenotype\", STRING)\n(\"Motif\", STRING)\n(\"Chromosome\", BIGINT)\n(\"Function\", STRING)\n(\"Localization\", STRING)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"Interactions\"\nColumns:\n(\"GeneID1\", STRING, primary key)\n(\"GeneID2\", STRING, primary key)\n(\"Type\", STRING)\n(\"Expression_Corr\", DOUBLE PRECISION)\n",
            "Table: \"Genes\"\nColumns:\n(\"GeneID\", STRING)\n(\"Essential\", STRING)\n(\"Class\", STRING)\n(\"Complex\", STRING)\n(\"Phenotype\", STRING)\n(\"Motif\", STRING)\n(\"Chromosome\", BIGINT)\n(\"Function\", STRING)\n(\"Localization\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 213,
        "database_name": "genes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.Expression_Corr > 0, 1, 0)) AS REAL) * 100 / COUNT(T2.GeneID1) FROM Genes AS T1 INNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1 WHERE T1.Phenotype = 'Nucleic acid metabolism defects' AND T1.Motif = 'PS00107'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"Expression_Corr\" > 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T2\".\"GeneID1\") FROM \"Genes\" AS \"T1\" INNER JOIN \"Interactions\" AS \"T2\" ON \"T1\".\"GeneID\" = \"T2\".\"GeneID1\" WHERE \"T1\".\"Phenotype\" = 'Nucleic acid metabolism defects' AND \"T1\".\"Motif\" = 'PS00107'",
        "semantic_equivalent_type": "approximate_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 48,
                "dilatect_content": "IIF(T2.Expression_Corr > 0, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 73,
                "dilatect_content": "CASE WHEN \"T2\".\"Expression_Corr\" > 0 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Genes`\nColumns:\n(`GeneID`, text)\n(`Essential`, text)\n(`Class`, text)\n(`Complex`, text)\n(`Phenotype`, text)\n(`Motif`, text)\n(`Chromosome`, integer)\n(`Function`, text)\n(`Localization`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `Interactions`\nColumns:\n(`GeneID1`, text, primary key)\n(`GeneID2`, text, primary key)\n(`Type`, text)\n(`Expression_Corr`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"Genes\"\nColumns:\n(\"GeneID\", STRING)\n(\"Essential\", STRING)\n(\"Class\", STRING)\n(\"Complex\", STRING)\n(\"Phenotype\", STRING)\n(\"Motif\", STRING)\n(\"Chromosome\", BIGINT)\n(\"Function\", STRING)\n(\"Localization\", STRING)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"Interactions\"\nColumns:\n(\"GeneID1\", STRING, primary key)\n(\"GeneID2\", STRING, primary key)\n(\"Type\", STRING)\n(\"Expression_Corr\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 216,
        "database_name": "app_store",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(CASE WHEN SUBSTR('Last Updated', -4) > '2018' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(App) PER FROM playstore WHERE Type = 'Free' AND Rating >= 4.5",
        "target_query": "SELECT CAST(SUM(CASE WHEN substring('Last Updated' from char_length('Last Updated') - 3 for 4) > '2018' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"App\") FROM \"playstore\" WHERE \"Type\" = 'Free' AND \"Rating\" >= 4.5;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 26,
                "end_index": 51,
                "dilatect_content": "SUBSTR('Last Updated', -4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 26,
                "end_index": 93,
                "dilatect_content": "substring('Last Updated' from char_length('Last Updated') - 3 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `playstore`\nColumns:\n(`App`, text)\n(`Category`, text)\n(`Rating`, real)\n(`Reviews`, integer)\n(`Size`, text)\n(`Installs`, text)\n(`Type`, text)\n(`Price`, text)\n(`Content Rating`, text)\n(`Genres`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"playstore\"\nColumns:\n(\"App\", STRING)\n(\"Category\", STRING)\n(\"Rating\", DOUBLE PRECISION)\n(\"Reviews\", BIGINT)\n(\"Size\", STRING)\n(\"Installs\", STRING)\n(\"Type\", STRING)\n(\"Price\", STRING)\n(\"Content_Rating\", STRING)\n(\"Genres\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 217,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T FROM ( SELECT IIF(`Customer Names` LIKE '%Group%', `Customer Names`, NULL) AS T FROM Customers ) WHERE T IS NOT NULL",
        "target_query": "SELECT T FROM ( SELECT CASE WHEN \"Customer_Names\" LIKE '%Group%' THEN \"Customer_Names\" ELSE NULL END AS T FROM \"Customers\" ) WHERE T IS NOT NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 23,
                "end_index": 82,
                "dilatect_content": "IIF(`Customer Names` LIKE '%Group%', `Customer Names`, NULL)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 23,
                "end_index": 103,
                "dilatect_content": "CASE WHEN \"Customer_Names\" LIKE '%Group%' THEN \"Customer_Names\" ELSE NULL END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Customers`\nColumns:\n(`CustomerID`, integer, primary key)\n(`Customer Names`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Customers\"\nColumns:\n(\"CustomerID\", BIGINT, primary key)\n(\"Customer_Names\", STRING)\n"
        ]
    },
    {
        "sql_id": 218,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT T1.`Customer Names` FROM Customers AS T1 INNER JOIN `Sales Orders` AS T2 ON T2._CustomerID = T1.CustomerID INNER JOIN Products AS T3 ON T3.ProductID = T2._ProductID WHERE T3.`Product Name` = 'Cocktail Glasses' AND SUBSTR(T2.OrderDate, -2) = '20' AND T2.`Discount Applied` = ( SELECT T2.`Discount Applied` FROM Customers AS T1 INNER JOIN `Sales Orders` AS T2 ON T2._CustomerID = T1.CustomerID INNER JOIN Products AS T3 ON T3.ProductID = T2._ProductID WHERE T3.`Product Name` = 'Cocktail Glasses' AND T2.OrderDate LIKE '%/%/20' ORDER BY T2.`Discount Applied` DESC LIMIT 1 )",
        "target_query": "SELECT DISTINCT T1.\"Customer_Names\" FROM \"Customers\" AS T1 INNER JOIN \"Sales_Orders\" AS T2 ON T2.\"_CustomerID\" = T1.\"CustomerID\" INNER JOIN \"Products\" AS T3 ON T3.\"ProductID\" = T2.\"_ProductID\" WHERE T3.\"Product_Name\" = 'Cocktail Glasses' AND substring(T2.\"OrderDate\" from char_length(T2.\"OrderDate\") - 1 for 2) = '20' AND T2.\"Discount_Applied\" = ( SELECT MAX(T2.\"Discount_Applied\") FROM \"Customers\" AS T1 INNER JOIN \"Sales_Orders\" AS T2 ON T2.\"_CustomerID\" = T1.\"CustomerID\" INNER JOIN \"Products\" AS T3 ON T3.\"ProductID\" = T2.\"_ProductID\" WHERE T3.\"Product_Name\" = 'Cocktail Glasses' AND T2.\"OrderDate\" LIKE '%/%/20' );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 230,
                "end_index": 253,
                "dilatect_content": "SUBSTR(T2.OrderDate, -2)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 260,
                "end_index": 331,
                "dilatect_content": "substring(T2.\"OrderDate\" from char_length(T2.\"OrderDate\") - 1 for 2)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Customers`\nColumns:\n(`CustomerID`, integer, primary key)\n(`Customer Names`, text)\n",
            "Table: `Sales Orders`\nColumns:\n(`OrderNumber`, text, primary key)\n(`Sales Channel`, text)\n(`WarehouseCode`, text)\n(`ProcuredDate`, text)\n(`OrderDate`, text)\n(`ShipDate`, text)\n(`DeliveryDate`, text)\n(`CurrencyCode`, text)\n(`_SalesTeamID`, integer)\n(`_CustomerID`, integer)\n(`_StoreID`, integer)\n(`_ProductID`, integer)\n(`Order Quantity`, integer)\n(`Discount Applied`, real)\n(`Unit Price`, text)\n(`Unit Cost`, text)\n",
            "Table: `Products`\nColumns:\n(`ProductID`, integer, primary key)\n(`Product Name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Customers\"\nColumns:\n(\"CustomerID\", BIGINT, primary key)\n(\"Customer_Names\", STRING)\n",
            "Table: \"Sales_Orders\"\nColumns:\n(\"OrderNumber\", STRING, primary key)\n(\"Sales_Channel\", STRING)\n(\"WarehouseCode\", STRING)\n(\"ProcuredDate\", STRING)\n(\"OrderDate\", STRING)\n(\"ShipDate\", STRING)\n(\"DeliveryDate\", STRING)\n(\"CurrencyCode\", STRING)\n(\"_SalesTeamID\", BIGINT)\n(\"_CustomerID\", BIGINT)\n(\"_StoreID\", BIGINT)\n(\"_ProductID\", BIGINT)\n(\"Order_Quantity\", BIGINT)\n(\"Discount_Applied\", DOUBLE PRECISION)\n(\"Unit_Price\", STRING)\n(\"Unit_Cost\", STRING)\n",
            "Table: \"Products\"\nColumns:\n(\"ProductID\", BIGINT, primary key)\n(\"Product_Name\", STRING)\n"
        ]
    },
    {
        "sql_id": 219,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(OrderDate = '5/31/18', 1, 0)) FROM `Sales Orders`",
        "target_query": "SELECT SUM(CASE WHEN \"OrderDate\" = '5/31/18' THEN 1 ELSE 0 END) FROM \"Sales_Orders\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 42,
                "dilatect_content": "IIF(OrderDate = '5/31/18', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 63,
                "dilatect_content": "CASE WHEN \"OrderDate\" = '5/31/18' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales Orders`\nColumns:\n(`OrderNumber`, text, primary key)\n(`Sales Channel`, text)\n(`WarehouseCode`, text)\n(`ProcuredDate`, text)\n(`OrderDate`, text)\n(`ShipDate`, text)\n(`DeliveryDate`, text)\n(`CurrencyCode`, text)\n(`_SalesTeamID`, integer)\n(`_CustomerID`, integer)\n(`_StoreID`, integer)\n(`_ProductID`, integer)\n(`Order Quantity`, integer)\n(`Discount Applied`, real)\n(`Unit Price`, text)\n(`Unit Cost`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Sales_Orders\"\nColumns:\n(\"OrderNumber\", STRING, primary key)\n(\"Sales_Channel\", STRING)\n(\"WarehouseCode\", STRING)\n(\"ProcuredDate\", STRING)\n(\"OrderDate\", STRING)\n(\"ShipDate\", STRING)\n(\"DeliveryDate\", STRING)\n(\"CurrencyCode\", STRING)\n(\"_SalesTeamID\", BIGINT)\n(\"_CustomerID\", BIGINT)\n(\"_StoreID\", BIGINT)\n(\"_ProductID\", BIGINT)\n(\"Order_Quantity\", BIGINT)\n(\"Discount_Applied\", DOUBLE PRECISION)\n(\"Unit_Price\", STRING)\n(\"Unit_Cost\", STRING)\n"
        ]
    },
    {
        "sql_id": 220,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT T FROM ( SELECT IIF(DeliveryDate = '6/13/18', OrderNumber, NULL) AS T FROM `Sales Orders` ) WHERE T IS NOT NULL",
        "target_query": "SELECT DISTINCT T FROM ( SELECT CASE WHEN \"DeliveryDate\" = '6/13/18' THEN \"OrderNumber\" ELSE NULL END AS T FROM \"Sales_Orders\" ) AS subquery WHERE T IS NOT NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 32,
                "end_index": 79,
                "dilatect_content": "IIF(DeliveryDate = '6/13/18', OrderNumber, NULL)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 32,
                "end_index": 104,
                "dilatect_content": "CASE WHEN \"DeliveryDate\" = '6/13/18' THEN \"OrderNumber\" ELSE NULL END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales Orders`\nColumns:\n(`OrderNumber`, text, primary key)\n(`Sales Channel`, text)\n(`WarehouseCode`, text)\n(`ProcuredDate`, text)\n(`OrderDate`, text)\n(`ShipDate`, text)\n(`DeliveryDate`, text)\n(`CurrencyCode`, text)\n(`_SalesTeamID`, integer)\n(`_CustomerID`, integer)\n(`_StoreID`, integer)\n(`_ProductID`, integer)\n(`Order Quantity`, integer)\n(`Discount Applied`, real)\n(`Unit Price`, text)\n(`Unit Cost`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Sales_Orders\"\nColumns:\n(\"OrderNumber\", STRING, primary key)\n(\"Sales_Channel\", STRING)\n(\"WarehouseCode\", STRING)\n(\"ProcuredDate\", STRING)\n(\"OrderDate\", STRING)\n(\"ShipDate\", STRING)\n(\"DeliveryDate\", STRING)\n(\"CurrencyCode\", STRING)\n(\"_SalesTeamID\", BIGINT)\n(\"_CustomerID\", BIGINT)\n(\"_StoreID\", BIGINT)\n(\"_ProductID\", BIGINT)\n(\"Order_Quantity\", BIGINT)\n(\"Discount_Applied\", DOUBLE PRECISION)\n(\"Unit_Price\", STRING)\n(\"Unit_Cost\", STRING)\n"
        ]
    },
    {
        "sql_id": 221,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(`Order Quantity` > 5, 1, 0)) FROM `Sales Orders`",
        "target_query": "SELECT SUM(CASE WHEN \"Order_Quantity\" > 5 THEN 1 ELSE 0 END) FROM \"Sales_Orders\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 41,
                "dilatect_content": "IIF(`Order Quantity` > 5, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 60,
                "dilatect_content": "CASE WHEN \"Order_Quantity\" > 5 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales Orders`\nColumns:\n(`OrderNumber`, text, primary key)\n(`Sales Channel`, text)\n(`WarehouseCode`, text)\n(`ProcuredDate`, text)\n(`OrderDate`, text)\n(`ShipDate`, text)\n(`DeliveryDate`, text)\n(`CurrencyCode`, text)\n(`_SalesTeamID`, integer)\n(`_CustomerID`, integer)\n(`_StoreID`, integer)\n(`_ProductID`, integer)\n(`Order Quantity`, integer)\n(`Discount Applied`, real)\n(`Unit Price`, text)\n(`Unit Cost`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Sales_Orders\"\nColumns:\n(\"OrderNumber\", STRING, primary key)\n(\"Sales_Channel\", STRING)\n(\"WarehouseCode\", STRING)\n(\"ProcuredDate\", STRING)\n(\"OrderDate\", STRING)\n(\"ShipDate\", STRING)\n(\"DeliveryDate\", STRING)\n(\"CurrencyCode\", STRING)\n(\"_SalesTeamID\", BIGINT)\n(\"_CustomerID\", BIGINT)\n(\"_StoreID\", BIGINT)\n(\"_ProductID\", BIGINT)\n(\"Order_Quantity\", BIGINT)\n(\"Discount_Applied\", DOUBLE PRECISION)\n(\"Unit_Price\", STRING)\n(\"Unit_Cost\", STRING)\n"
        ]
    },
    {
        "sql_id": 222,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T FROM ( SELECT IIF(StateCode = 'GA', State, NULL) AS T FROM Regions ) WHERE T IS NOT NULL",
        "target_query": "SELECT \"T\" FROM ( SELECT CASE WHEN \"StateCode\" = 'GA' THEN \"State\" ELSE NULL END AS \"T\" FROM \"Regions\" ) AS \"subquery\" WHERE \"T\" IS NOT NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 23,
                "end_index": 56,
                "dilatect_content": "IIF(StateCode = 'GA', State, NULL)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 27,
                "end_index": 85,
                "dilatect_content": "CASE WHEN \"StateCode\" = 'GA' THEN \"State\" ELSE NULL END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Regions`\nColumns:\n(`StateCode`, text, primary key)\n(`State`, text)\n(`Region`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Regions\"\nColumns:\n(\"StateCode\", STRING, primary key)\n(\"State\", STRING)\n(\"Region\", STRING)\n"
        ]
    },
    {
        "sql_id": 223,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T FROM ( SELECT DISTINCT IIF(T1.`Unit Cost` = 781.22, T2.`Product Name`, NULL) AS T FROM `Sales Orders` T1 INNER JOIN Products T2 ON T2.ProductID = T1._ProductID ) WHERE T IS NOT NULL",
        "target_query": "SELECT T FROM ( SELECT DISTINCT CASE WHEN T1.\"Unit_Cost\" = '781.22' THEN T2.\"Product_Name\" ELSE NULL END AS T FROM \"Sales_Orders\" T1 INNER JOIN \"Products\" T2 ON T2.\"ProductID\" = T1.\"_ProductID\" ) AS subquery WHERE T IS NOT NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 32,
                "end_index": 84,
                "dilatect_content": "IIF(T1.`Unit Cost` = 781.22, T2.`Product Name`, NULL)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 32,
                "end_index": 107,
                "dilatect_content": "CASE WHEN T1.\"Unit_Cost\" = '781.22' THEN T2.\"Product_Name\" ELSE NULL END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales Orders`\nColumns:\n(`OrderNumber`, text, primary key)\n(`Sales Channel`, text)\n(`WarehouseCode`, text)\n(`ProcuredDate`, text)\n(`OrderDate`, text)\n(`ShipDate`, text)\n(`DeliveryDate`, text)\n(`CurrencyCode`, text)\n(`_SalesTeamID`, integer)\n(`_CustomerID`, integer)\n(`_StoreID`, integer)\n(`_ProductID`, integer)\n(`Order Quantity`, integer)\n(`Discount Applied`, real)\n(`Unit Price`, text)\n(`Unit Cost`, text)\n",
            "Table: `Products`\nColumns:\n(`ProductID`, integer, primary key)\n(`Product Name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Sales_Orders\"\nColumns:\n(\"OrderNumber\", STRING, primary key)\n(\"Sales_Channel\", STRING)\n(\"WarehouseCode\", STRING)\n(\"ProcuredDate\", STRING)\n(\"OrderDate\", STRING)\n(\"ShipDate\", STRING)\n(\"DeliveryDate\", STRING)\n(\"CurrencyCode\", STRING)\n(\"_SalesTeamID\", BIGINT)\n(\"_CustomerID\", BIGINT)\n(\"_StoreID\", BIGINT)\n(\"_ProductID\", BIGINT)\n(\"Order_Quantity\", BIGINT)\n(\"Discount_Applied\", DOUBLE PRECISION)\n(\"Unit_Price\", STRING)\n(\"Unit_Cost\", STRING)\n",
            "Table: \"Products\"\nColumns:\n(\"ProductID\", BIGINT, primary key)\n(\"Product_Name\", STRING)\n"
        ]
    },
    {
        "sql_id": 224,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T FROM ( SELECT DISTINCT IIF(T2.`Product Name` = 'Cookware', T1.DeliveryDate, NULL) AS T FROM `Sales Orders` T1 INNER JOIN Products T2 ON T2.ProductID = T1._ProductID ) WHERE T IS NOT NULL",
        "target_query": "SELECT T FROM ( SELECT DISTINCT CASE WHEN T2.\"Product_Name\" = 'Cookware' THEN T1.\"DeliveryDate\" ELSE NULL END AS T FROM \"Sales_Orders\" T1 INNER JOIN \"Products\" T2 ON T2.\"ProductID\" = T1.\"_ProductID\" ) WHERE T IS NOT NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 32,
                "end_index": 89,
                "dilatect_content": "IIF(T2.`Product Name` = 'Cookware', T1.DeliveryDate, NULL)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 32,
                "end_index": 112,
                "dilatect_content": "CASE WHEN T2.\"Product_Name\" = 'Cookware' THEN T1.\"DeliveryDate\" ELSE NULL END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales Orders`\nColumns:\n(`OrderNumber`, text, primary key)\n(`Sales Channel`, text)\n(`WarehouseCode`, text)\n(`ProcuredDate`, text)\n(`OrderDate`, text)\n(`ShipDate`, text)\n(`DeliveryDate`, text)\n(`CurrencyCode`, text)\n(`_SalesTeamID`, integer)\n(`_CustomerID`, integer)\n(`_StoreID`, integer)\n(`_ProductID`, integer)\n(`Order Quantity`, integer)\n(`Discount Applied`, real)\n(`Unit Price`, text)\n(`Unit Cost`, text)\n",
            "Table: `Products`\nColumns:\n(`ProductID`, integer, primary key)\n(`Product Name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Sales_Orders\"\nColumns:\n(\"OrderNumber\", STRING, primary key)\n(\"Sales_Channel\", STRING)\n(\"WarehouseCode\", STRING)\n(\"ProcuredDate\", STRING)\n(\"OrderDate\", STRING)\n(\"ShipDate\", STRING)\n(\"DeliveryDate\", STRING)\n(\"CurrencyCode\", STRING)\n(\"_SalesTeamID\", BIGINT)\n(\"_CustomerID\", BIGINT)\n(\"_StoreID\", BIGINT)\n(\"_ProductID\", BIGINT)\n(\"Order_Quantity\", BIGINT)\n(\"Discount_Applied\", DOUBLE PRECISION)\n(\"Unit_Price\", STRING)\n(\"Unit_Cost\", STRING)\n",
            "Table: \"Products\"\nColumns:\n(\"ProductID\", BIGINT, primary key)\n(\"Product_Name\", STRING)\n"
        ]
    },
    {
        "sql_id": 225,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T FROM ( SELECT DISTINCT IIF(T1.`Discount Applied` = 0.1, T2.`Product Name`, NULL) AS T FROM `Sales Orders` T1 INNER JOIN Products T2 ON T2.ProductID = T1._ProductID ) WHERE T IS NOT NULL",
        "target_query": "SELECT T FROM ( SELECT DISTINCT CASE WHEN T1.\"Discount_Applied\" = 0.1 THEN T2.\"Product_Name\" ELSE NULL END AS T FROM \"Sales_Orders\" T1 INNER JOIN \"Products\" T2 ON T2.\"ProductID\" = T1.\"_ProductID\" ) WHERE T IS NOT NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 32,
                "end_index": 88,
                "dilatect_content": "IIF(T1.`Discount Applied` = 0.1, T2.`Product Name`, NULL)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 32,
                "end_index": 109,
                "dilatect_content": "CASE WHEN T1.\"Discount_Applied\" = 0.1 THEN T2.\"Product_Name\" ELSE NULL END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales Orders`\nColumns:\n(`OrderNumber`, text, primary key)\n(`Sales Channel`, text)\n(`WarehouseCode`, text)\n(`ProcuredDate`, text)\n(`OrderDate`, text)\n(`ShipDate`, text)\n(`DeliveryDate`, text)\n(`CurrencyCode`, text)\n(`_SalesTeamID`, integer)\n(`_CustomerID`, integer)\n(`_StoreID`, integer)\n(`_ProductID`, integer)\n(`Order Quantity`, integer)\n(`Discount Applied`, real)\n(`Unit Price`, text)\n(`Unit Cost`, text)\n",
            "Table: `Products`\nColumns:\n(`ProductID`, integer, primary key)\n(`Product Name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Sales_Orders\"\nColumns:\n(\"OrderNumber\", STRING, primary key)\n(\"Sales_Channel\", STRING)\n(\"WarehouseCode\", STRING)\n(\"ProcuredDate\", STRING)\n(\"OrderDate\", STRING)\n(\"ShipDate\", STRING)\n(\"DeliveryDate\", STRING)\n(\"CurrencyCode\", STRING)\n(\"_SalesTeamID\", BIGINT)\n(\"_CustomerID\", BIGINT)\n(\"_StoreID\", BIGINT)\n(\"_ProductID\", BIGINT)\n(\"Order_Quantity\", BIGINT)\n(\"Discount_Applied\", DOUBLE PRECISION)\n(\"Unit_Price\", STRING)\n(\"Unit_Cost\", STRING)\n",
            "Table: \"Products\"\nColumns:\n(\"ProductID\", BIGINT, primary key)\n(\"Product_Name\", STRING)\n"
        ]
    },
    {
        "sql_id": 226,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUBSTR(T1.OrderDate, -2, 2) FROM `Sales Orders` AS T1 INNER JOIN `Sales Team` AS T2 ON T2.SalesTeamID = T1._SalesTeamID WHERE T2.`Sales Team` = 'George Lewis' GROUP BY SUBSTR(T1.OrderDate, -2, 2) ORDER BY COUNT(T1.OrderNumber) DESC LIMIT 1",
        "target_query": "SELECT substring(T1.\"OrderDate\" from char_length(T1.\"OrderDate\") - 1 for 2) FROM \"Sales_Orders\" AS T1 INNER JOIN \"Sales_Team\" AS T2 ON T2.\"SalesTeamID\" = T1.\"_SalesTeamID\" WHERE T2.\"Sales_Team\" = 'George Lewis' GROUP BY substring(T1.\"OrderDate\" from char_length(T1.\"OrderDate\") - 1 for 2) ORDER BY COUNT(T1.\"OrderNumber\") DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 33,
                "dilatect_content": "SUBSTR(T1.OrderDate, -2, 2)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 175,
                "end_index": 201,
                "dilatect_content": "SUBSTR(T1.OrderDate, -2, 2)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 78,
                "dilatect_content": "substring(T1.\"OrderDate\" from char_length(T1.\"OrderDate\") - 1 for 2)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 234,
                "end_index": 305,
                "dilatect_content": "substring(T1.\"OrderDate\" from char_length(T1.\"OrderDate\") - 1 for 2)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales Orders`\nColumns:\n(`OrderNumber`, text, primary key)\n(`Sales Channel`, text)\n(`WarehouseCode`, text)\n(`ProcuredDate`, text)\n(`OrderDate`, text)\n(`ShipDate`, text)\n(`DeliveryDate`, text)\n(`CurrencyCode`, text)\n(`_SalesTeamID`, integer)\n(`_CustomerID`, integer)\n(`_StoreID`, integer)\n(`_ProductID`, integer)\n(`Order Quantity`, integer)\n(`Discount Applied`, real)\n(`Unit Price`, text)\n(`Unit Cost`, text)\n",
            "Table: `Sales Team`\nColumns:\n(`SalesTeamID`, integer, primary key)\n(`Sales Team`, text)\n(`Region`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Sales_Orders\"\nColumns:\n(\"OrderNumber\", STRING, primary key)\n(\"Sales_Channel\", STRING)\n(\"WarehouseCode\", STRING)\n(\"ProcuredDate\", STRING)\n(\"OrderDate\", STRING)\n(\"ShipDate\", STRING)\n(\"DeliveryDate\", STRING)\n(\"CurrencyCode\", STRING)\n(\"_SalesTeamID\", BIGINT)\n(\"_CustomerID\", BIGINT)\n(\"_StoreID\", BIGINT)\n(\"_ProductID\", BIGINT)\n(\"Order_Quantity\", BIGINT)\n(\"Discount_Applied\", DOUBLE PRECISION)\n(\"Unit_Price\", STRING)\n(\"Unit_Cost\", STRING)\n",
            "Table: \"Sales_Team\"\nColumns:\n(\"SalesTeamID\", BIGINT, primary key)\n(\"Sales_Team\", STRING)\n(\"Region\", STRING)\n"
        ]
    },
    {
        "sql_id": 227,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT T FROM ( SELECT IIF(OrderNumber = 'SO - 000103', `Unit Cost`, NULL) AS T FROM `Sales Orders` ) WHERE T IS NOT NULL",
        "target_query": "SELECT DISTINCT T FROM ( SELECT CASE WHEN \"OrderNumber\" = 'SO - 000103' THEN \"Unit_Cost\" ELSE NULL END AS T FROM \"Sales_Orders\" ) WHERE T IS NOT NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 32,
                "end_index": 82,
                "dilatect_content": "IIF(OrderNumber = 'SO - 000103', `Unit Cost`, NULL)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 32,
                "end_index": 105,
                "dilatect_content": "CASE WHEN \"OrderNumber\" = 'SO - 000103' THEN \"Unit_Cost\" ELSE NULL END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales Orders`\nColumns:\n(`OrderNumber`, text, primary key)\n(`Sales Channel`, text)\n(`WarehouseCode`, text)\n(`ProcuredDate`, text)\n(`OrderDate`, text)\n(`ShipDate`, text)\n(`DeliveryDate`, text)\n(`CurrencyCode`, text)\n(`_SalesTeamID`, integer)\n(`_CustomerID`, integer)\n(`_StoreID`, integer)\n(`_ProductID`, integer)\n(`Order Quantity`, integer)\n(`Discount Applied`, real)\n(`Unit Price`, text)\n(`Unit Cost`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Sales_Orders\"\nColumns:\n(\"OrderNumber\", STRING, primary key)\n(\"Sales_Channel\", STRING)\n(\"WarehouseCode\", STRING)\n(\"ProcuredDate\", STRING)\n(\"OrderDate\", STRING)\n(\"ShipDate\", STRING)\n(\"DeliveryDate\", STRING)\n(\"CurrencyCode\", STRING)\n(\"_SalesTeamID\", BIGINT)\n(\"_CustomerID\", BIGINT)\n(\"_StoreID\", BIGINT)\n(\"_ProductID\", BIGINT)\n(\"Order_Quantity\", BIGINT)\n(\"Discount_Applied\", DOUBLE PRECISION)\n(\"Unit_Price\", STRING)\n(\"Unit_Cost\", STRING)\n"
        ]
    },
    {
        "sql_id": 228,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT IIF(COUNT(T2.CustomerID) > 3, T2.`Customer Names`, NULL) FROM `Sales Orders` AS T1 INNER JOIN Customers AS T2 ON T2.CustomerID = T1._CustomerID WHERE T1.OrderDate LIKE '%/%/18' GROUP BY T1._CustomerID HAVING COUNT(T2.CustomerID)",
        "target_query": "SELECT DISTINCT CASE WHEN COUNT(T2.\"CustomerID\") > 3 THEN T2.\"Customer_Names\" ELSE NULL END FROM \"Sales_Orders\" AS T1 INNER JOIN \"Customers\" AS T2 ON T2.\"CustomerID\" = T1.\"_CustomerID\" WHERE T1.\"OrderDate\" LIKE '%/%/18' GROUP BY T1.\"_CustomerID\", T2.\"Customer_Names\" HAVING COUNT(T2.\"CustomerID\") > 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 39,
                "dilatect_content": "IIF(COUNT(T2.CustomerID)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 94,
                "dilatect_content": "CASE WHEN COUNT(T2.\"CustomerID\") > 3 THEN T2.\"Customer_Names\" ELSE NULL END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales Orders`\nColumns:\n(`OrderNumber`, text, primary key)\n(`Sales Channel`, text)\n(`WarehouseCode`, text)\n(`ProcuredDate`, text)\n(`OrderDate`, text)\n(`ShipDate`, text)\n(`DeliveryDate`, text)\n(`CurrencyCode`, text)\n(`_SalesTeamID`, integer)\n(`_CustomerID`, integer)\n(`_StoreID`, integer)\n(`_ProductID`, integer)\n(`Order Quantity`, integer)\n(`Discount Applied`, real)\n(`Unit Price`, text)\n(`Unit Cost`, text)\n",
            "Table: `Customers`\nColumns:\n(`CustomerID`, integer, primary key)\n(`Customer Names`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Sales_Orders\"\nColumns:\n(\"OrderNumber\", STRING, primary key)\n(\"Sales_Channel\", STRING)\n(\"WarehouseCode\", STRING)\n(\"ProcuredDate\", STRING)\n(\"OrderDate\", STRING)\n(\"ShipDate\", STRING)\n(\"DeliveryDate\", STRING)\n(\"CurrencyCode\", STRING)\n(\"_SalesTeamID\", BIGINT)\n(\"_CustomerID\", BIGINT)\n(\"_StoreID\", BIGINT)\n(\"_ProductID\", BIGINT)\n(\"Order_Quantity\", BIGINT)\n(\"Discount_Applied\", DOUBLE PRECISION)\n(\"Unit_Price\", STRING)\n(\"Unit_Cost\", STRING)\n",
            "Table: \"Customers\"\nColumns:\n(\"CustomerID\", BIGINT, primary key)\n(\"Customer_Names\", STRING)\n"
        ]
    },
    {
        "sql_id": 229,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(CASE WHEN SUBSTR(T1.OrderDate, -2) IN ('18', '19', '20') AND T2.`Customer Names` = 'Medsep Group' THEN 1 ELSE 0 END) FROM `Sales Orders` AS T1 INNER JOIN Customers AS T2 ON T2.CustomerID = T1._CustomerID",
        "target_query": "SELECT SUM(CASE WHEN substring(T1.\"OrderDate\" from char_length(T1.\"OrderDate\") - 1 for 2) IN ('18', '19', '20') AND T2.\"Customer_Names\" = 'Medsep Group' THEN 1 ELSE 0 END) FROM \"Sales_Orders\" AS T1 INNER JOIN \"Customers\" AS T2 ON T2.\"CustomerID\" = T1.\"_CustomerID\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 44,
                "dilatect_content": "SUBSTR(T1.OrderDate, -2)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 92,
                "dilatect_content": "substring(T1.\"OrderDate\" from char_length(T1.\"OrderDate\") - 1 for 2)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales Orders`\nColumns:\n(`OrderNumber`, text, primary key)\n(`Sales Channel`, text)\n(`WarehouseCode`, text)\n(`ProcuredDate`, text)\n(`OrderDate`, text)\n(`ShipDate`, text)\n(`DeliveryDate`, text)\n(`CurrencyCode`, text)\n(`_SalesTeamID`, integer)\n(`_CustomerID`, integer)\n(`_StoreID`, integer)\n(`_ProductID`, integer)\n(`Order Quantity`, integer)\n(`Discount Applied`, real)\n(`Unit Price`, text)\n(`Unit Cost`, text)\n",
            "Table: `Customers`\nColumns:\n(`CustomerID`, integer, primary key)\n(`Customer Names`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Sales_Orders\"\nColumns:\n(\"OrderNumber\", STRING, primary key)\n(\"Sales_Channel\", STRING)\n(\"WarehouseCode\", STRING)\n(\"ProcuredDate\", STRING)\n(\"OrderDate\", STRING)\n(\"ShipDate\", STRING)\n(\"DeliveryDate\", STRING)\n(\"CurrencyCode\", STRING)\n(\"_SalesTeamID\", BIGINT)\n(\"_CustomerID\", BIGINT)\n(\"_StoreID\", BIGINT)\n(\"_ProductID\", BIGINT)\n(\"Order_Quantity\", BIGINT)\n(\"Discount_Applied\", DOUBLE PRECISION)\n(\"Unit_Price\", STRING)\n(\"Unit_Cost\", STRING)\n",
            "Table: \"Customers\"\nColumns:\n(\"CustomerID\", BIGINT, primary key)\n(\"Customer_Names\", STRING)\n"
        ]
    },
    {
        "sql_id": 230,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(WarehouseCode = 'WARE-MKL1006', 1, 0)) - SUM(IIF(WarehouseCode = 'WARE-NBV1002', 1, 0)) AS difference FROM `Sales Orders`",
        "target_query": "SELECT SUM(CASE WHEN \"WarehouseCode\" = 'WARE-MKL1006' THEN 1 ELSE 0 END) - SUM(CASE WHEN \"WarehouseCode\" = 'WARE-NBV1002' THEN 1 ELSE 0 END) AS \"difference\" FROM \"Sales_Orders\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 51,
                "dilatect_content": "IIF(WarehouseCode = 'WARE-MKL1006', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 60,
                "end_index": 100,
                "dilatect_content": "IIF(WarehouseCode = 'WARE-NBV1002', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 72,
                "dilatect_content": "CASE WHEN \"WarehouseCode\" = 'WARE-MKL1006' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 81,
                "end_index": 142,
                "dilatect_content": "CASE WHEN \"WarehouseCode\" = 'WARE-NBV1002' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales Orders`\nColumns:\n(`OrderNumber`, text, primary key)\n(`Sales Channel`, text)\n(`WarehouseCode`, text)\n(`ProcuredDate`, text)\n(`OrderDate`, text)\n(`ShipDate`, text)\n(`DeliveryDate`, text)\n(`CurrencyCode`, text)\n(`_SalesTeamID`, integer)\n(`_CustomerID`, integer)\n(`_StoreID`, integer)\n(`_ProductID`, integer)\n(`Order Quantity`, integer)\n(`Discount Applied`, real)\n(`Unit Price`, text)\n(`Unit Cost`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Sales_Orders\"\nColumns:\n(\"OrderNumber\", STRING, primary key)\n(\"Sales_Channel\", STRING)\n(\"WarehouseCode\", STRING)\n(\"ProcuredDate\", STRING)\n(\"OrderDate\", STRING)\n(\"ShipDate\", STRING)\n(\"DeliveryDate\", STRING)\n(\"CurrencyCode\", STRING)\n(\"_SalesTeamID\", BIGINT)\n(\"_CustomerID\", BIGINT)\n(\"_StoreID\", BIGINT)\n(\"_ProductID\", BIGINT)\n(\"Order_Quantity\", BIGINT)\n(\"Discount_Applied\", DOUBLE PRECISION)\n(\"Unit_Price\", STRING)\n(\"Unit_Cost\", STRING)\n"
        ]
    },
    {
        "sql_id": 232,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT T FROM ( SELECT IIF(_CustomerID = 11, ProcuredDate, NULL) AS T FROM `Sales Orders` ) WHERE T IS NOT NULL",
        "target_query": "SELECT DISTINCT T FROM ( SELECT CASE WHEN \"_CustomerID\" = 11 THEN \"ProcuredDate\" ELSE NULL END AS T FROM \"Sales_Orders\" ) WHERE T IS NOT NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 32,
                "end_index": 72,
                "dilatect_content": "IIF(_CustomerID = 11, ProcuredDate, NULL)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 32,
                "end_index": 97,
                "dilatect_content": "CASE WHEN \"_CustomerID\" = 11 THEN \"ProcuredDate\" ELSE NULL END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales Orders`\nColumns:\n(`OrderNumber`, text, primary key)\n(`Sales Channel`, text)\n(`WarehouseCode`, text)\n(`ProcuredDate`, text)\n(`OrderDate`, text)\n(`ShipDate`, text)\n(`DeliveryDate`, text)\n(`CurrencyCode`, text)\n(`_SalesTeamID`, integer)\n(`_CustomerID`, integer)\n(`_StoreID`, integer)\n(`_ProductID`, integer)\n(`Order Quantity`, integer)\n(`Discount Applied`, real)\n(`Unit Price`, text)\n(`Unit Cost`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Sales_Orders\"\nColumns:\n(\"OrderNumber\", STRING, primary key)\n(\"Sales_Channel\", STRING)\n(\"WarehouseCode\", STRING)\n(\"ProcuredDate\", STRING)\n(\"OrderDate\", STRING)\n(\"ShipDate\", STRING)\n(\"DeliveryDate\", STRING)\n(\"CurrencyCode\", STRING)\n(\"_SalesTeamID\", BIGINT)\n(\"_CustomerID\", BIGINT)\n(\"_StoreID\", BIGINT)\n(\"_ProductID\", BIGINT)\n(\"Order_Quantity\", BIGINT)\n(\"Discount_Applied\", DOUBLE PRECISION)\n(\"Unit_Price\", STRING)\n(\"Unit_Cost\", STRING)\n"
        ]
    },
    {
        "sql_id": 233,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(ShipDate LIKE '6/%/18' AND `Sales Channel` = 'Online', 1, 0)) FROM `Sales Orders`",
        "target_query": "SELECT SUM(CASE WHEN \"ShipDate\" LIKE '6/%/18' AND \"Sales_Channel\" = 'Online' THEN 1 ELSE 0 END) FROM \"Sales_Orders\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 74,
                "dilatect_content": "IIF(ShipDate LIKE '6/%/18' AND `Sales Channel` = 'Online', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 97,
                "dilatect_content": "CASE WHEN \"ShipDate\" LIKE '6/%/18' AND \"Sales_Channel\" = 'Online' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales Orders`\nColumns:\n(`OrderNumber`, text, primary key)\n(`Sales Channel`, text)\n(`WarehouseCode`, text)\n(`ProcuredDate`, text)\n(`OrderDate`, text)\n(`ShipDate`, text)\n(`DeliveryDate`, text)\n(`CurrencyCode`, text)\n(`_SalesTeamID`, integer)\n(`_CustomerID`, integer)\n(`_StoreID`, integer)\n(`_ProductID`, integer)\n(`Order Quantity`, integer)\n(`Discount Applied`, real)\n(`Unit Price`, text)\n(`Unit Cost`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Sales_Orders\"\nColumns:\n(\"OrderNumber\", STRING, primary key)\n(\"Sales_Channel\", STRING)\n(\"WarehouseCode\", STRING)\n(\"ProcuredDate\", STRING)\n(\"OrderDate\", STRING)\n(\"ShipDate\", STRING)\n(\"DeliveryDate\", STRING)\n(\"CurrencyCode\", STRING)\n(\"_SalesTeamID\", BIGINT)\n(\"_CustomerID\", BIGINT)\n(\"_StoreID\", BIGINT)\n(\"_ProductID\", BIGINT)\n(\"Order_Quantity\", BIGINT)\n(\"Discount_Applied\", DOUBLE PRECISION)\n(\"Unit_Price\", STRING)\n(\"Unit_Cost\", STRING)\n"
        ]
    },
    {
        "sql_id": 234,
        "database_name": "professional_basketball",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT draftYear - strftime('%Y', birthDate) FROM draft AS T1 INNER JOIN players AS T2 ON T1.playerID = T2.playerID WHERE T1.firstName = 'Alexis' AND T1.lastName = 'Ajinca' AND draftRound = 1",
        "target_query": "SELECT \"draftYear\" - CAST(sys.timestamp_to_str(\"birthDate\", '%Y') AS BIGINT) FROM \"draft\" AS T1 INNER JOIN \"players\" AS T2 ON T1.\"playerID\" = T2.\"playerID\" WHERE T1.\"firstName\" = 'Alexis' AND T1.\"lastName\" = 'Ajinca' AND T1.\"draftRound\" = 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 19,
                "end_index": 43,
                "dilatect_content": "strftime('%Y', birthDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 28,
                "end_index": 68,
                "dilatect_content": "sys.timestamp_to_str(\"birthDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `draft`\nColumns:\n(`id`, integer, primary key)\n(`draftYear`, integer)\n(`draftRound`, integer)\n(`draftSelection`, integer)\n(`draftOverall`, integer)\n(`tmID`, text)\n(`firstName`, text)\n(`lastName`, text)\n(`suffixName`, text)\n(`playerID`, text)\n(`draftFrom`, text)\n(`lgID`, text)\n",
            "Table: `players`\nColumns:\n(`playerID`, text, primary key)\n(`useFirst`, text)\n(`firstName`, text)\n(`middleName`, text)\n(`lastName`, text)\n(`nameGiven`, text)\n(`fullGivenName`, text)\n(`nameSuffix`, text)\n(`nameNick`, text)\n(`pos`, text)\n(`firstseason`, integer)\n(`lastseason`, integer)\n(`height`, real)\n(`weight`, integer)\n(`college`, text)\n(`collegeOther`, text)\n(`birthDate`, date)\n(`birthCity`, text)\n(`birthState`, text)\n(`birthCountry`, text)\n(`highSchool`, text)\n(`hsCity`, text)\n(`hsState`, text)\n(`hsCountry`, text)\n(`deathDate`, date)\n(`race`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"draft\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"draftYear\", BIGINT)\n(\"draftRound\", BIGINT)\n(\"draftSelection\", BIGINT)\n(\"draftOverall\", BIGINT)\n(\"tmID\", STRING)\n(\"firstName\", STRING)\n(\"lastName\", STRING)\n(\"suffixName\", STRING)\n(\"playerID\", STRING)\n(\"draftFrom\", STRING)\n(\"lgID\", STRING)\n",
            "Table: \"players\"\nColumns:\n(\"playerID\", STRING, primary key)\n(\"useFirst\", STRING)\n(\"firstName\", STRING)\n(\"middleName\", STRING)\n(\"lastName\", STRING)\n(\"nameGiven\", STRING)\n(\"fullGivenName\", STRING)\n(\"nameSuffix\", STRING)\n(\"nameNick\", STRING)\n(\"pos\", STRING)\n(\"firstseason\", BIGINT)\n(\"lastseason\", BIGINT)\n(\"height\", DOUBLE PRECISION)\n(\"weight\", BIGINT)\n(\"college\", STRING)\n(\"collegeOther\", STRING)\n(\"birthDate\", DATE)\n(\"birthCity\", STRING)\n(\"birthState\", STRING)\n(\"birthCountry\", STRING)\n(\"highSchool\", STRING)\n(\"hsCity\", STRING)\n(\"hsState\", STRING)\n(\"hsCountry\", STRING)\n(\"deathDate\", DATE)\n(\"race\", STRING)\n"
        ]
    },
    {
        "sql_id": 235,
        "database_name": "professional_basketball",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.firstName, T1.middleName, T1.lastName , 2003 - strftime('%Y', T1.birthDate) FROM awards_players AS T2 JOIN players AS T1 ON T2.playerID = T1.playerID WHERE T2.award = 'Finals MVP' AND T2.year = 2003",
        "target_query": "SELECT \"T1\".\"firstName\", \"T1\".\"middleName\", \"T1\".\"lastName\", 2003 - EXTRACT(YEAR FROM \"T1\".\"birthDate\") FROM \"awards_players\" AS \"T2\" JOIN \"players\" AS \"T1\" ON \"T2\".\"playerID\" = \"T1\".\"playerID\" WHERE \"T2\".\"award\" = 'Finals MVP' AND \"T2\"._year = 2003;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 57,
                "end_index": 84,
                "dilatect_content": "strftime('%Y', T1.birthDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 88,
                "end_index": 117,
                "dilatect_content": "YEAR FROM \"T1\".\"birthDate\"",
                "feature": ""
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `awards_players`\nColumns:\n(`playerID`, text, primary key)\n(`award`, text, primary key)\n(`year`, integer, primary key)\n(`lgID`, text)\n(`note`, text)\n(`pos`, text)\n",
            "Table: `players`\nColumns:\n(`playerID`, text, primary key)\n(`useFirst`, text)\n(`firstName`, text)\n(`middleName`, text)\n(`lastName`, text)\n(`nameGiven`, text)\n(`fullGivenName`, text)\n(`nameSuffix`, text)\n(`nameNick`, text)\n(`pos`, text)\n(`firstseason`, integer)\n(`lastseason`, integer)\n(`height`, real)\n(`weight`, integer)\n(`college`, text)\n(`collegeOther`, text)\n(`birthDate`, date)\n(`birthCity`, text)\n(`birthState`, text)\n(`birthCountry`, text)\n(`highSchool`, text)\n(`hsCity`, text)\n(`hsState`, text)\n(`hsCountry`, text)\n(`deathDate`, date)\n(`race`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"awards_players\"\nColumns:\n(\"playerID\", STRING, primary key)\n(\"award\", STRING, primary key)\n(\"_year\", BIGINT, primary key)\n(\"lgID\", STRING)\n(\"note\", STRING)\n(\"pos\", STRING)\n",
            "Table: \"players\"\nColumns:\n(\"playerID\", STRING, primary key)\n(\"useFirst\", STRING)\n(\"firstName\", STRING)\n(\"middleName\", STRING)\n(\"lastName\", STRING)\n(\"nameGiven\", STRING)\n(\"fullGivenName\", STRING)\n(\"nameSuffix\", STRING)\n(\"nameNick\", STRING)\n(\"pos\", STRING)\n(\"firstseason\", BIGINT)\n(\"lastseason\", BIGINT)\n(\"height\", DOUBLE PRECISION)\n(\"weight\", BIGINT)\n(\"college\", STRING)\n(\"collegeOther\", STRING)\n(\"birthDate\", DATE)\n(\"birthCity\", STRING)\n(\"birthState\", STRING)\n(\"birthCountry\", STRING)\n(\"highSchool\", STRING)\n(\"hsCity\", STRING)\n(\"hsState\", STRING)\n(\"hsCountry\", STRING)\n(\"deathDate\", DATE)\n(\"race\", STRING)\n"
        ]
    },
    {
        "sql_id": 237,
        "database_name": "professional_basketball",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.steals IS NOT NULL AND T1.tmID = 'LAL', 1, 0)) AS REAL) * 100 / COUNT(T1.tmID) FROM teams AS T1 INNER JOIN players_teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"steals\" IS NOT NULL AND \"T1\".\"tmID\" = 'LAL' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"tmID\") FROM \"teams\" AS \"T1\" INNER JOIN \"players_teams\" AS \"T2\" ON \"T1\".\"tmID\" = \"T2\".\"tmID\" AND \"T1\".\"_year\" = \"T2\".\"_year\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 67,
                "dilatect_content": "IIF(T2.steals IS NOT NULL AND T1.tmID = 'LAL', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 100,
                "dilatect_content": "CASE WHEN \"T2\".\"steals\" IS NOT NULL AND \"T1\".\"tmID\" = 'LAL' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `teams`\nColumns:\n(`year`, integer, primary key)\n(`lgID`, text)\n(`tmID`, text, primary key)\n(`franchID`, text)\n(`confID`, text)\n(`divID`, text)\n(`rank`, integer)\n(`confRank`, integer)\n(`playoff`, text)\n(`name`, text)\n(`o_fgm`, integer)\n(`o_ftm`, integer)\n(`o_pts`, integer)\n(`d_pts`, integer)\n(`homeWon`, integer)\n(`homeLost`, integer)\n(`awayWon`, integer)\n(`awayLost`, integer)\n(`won`, integer)\n(`lost`, integer)\n(`games`, integer)\n(`arena`, text)\n",
            "Table: `players_teams`\nColumns:\n(`id`, integer, primary key)\n(`playerID`, text)\n(`year`, integer)\n(`stint`, integer)\n(`tmID`, text)\n(`lgID`, text)\n(`GP`, integer)\n(`GS`, integer)\n(`minutes`, integer)\n(`points`, integer)\n(`oRebounds`, integer)\n(`dRebounds`, integer)\n(`rebounds`, integer)\n(`assists`, integer)\n(`steals`, integer)\n(`blocks`, integer)\n(`turnovers`, integer)\n(`PF`, integer)\n(`fgAttempted`, integer)\n(`fgMade`, integer)\n(`ftAttempted`, integer)\n(`ftMade`, integer)\n(`threeAttempted`, integer)\n(`threeMade`, integer)\n(`PostGP`, integer)\n(`PostGS`, integer)\n(`PostMinutes`, integer)\n(`PostPoints`, integer)\n(`PostoRebounds`, integer)\n(`PostdRebounds`, integer)\n(`PostRebounds`, integer)\n(`PostAssists`, integer)\n(`PostSteals`, integer)\n(`PostBlocks`, integer)\n(`PostTurnovers`, integer)\n(`PostPF`, integer)\n(`PostfgAttempted`, integer)\n(`PostfgMade`, integer)\n(`PostftAttempted`, integer)\n(`PostftMade`, integer)\n(`PostthreeAttempted`, integer)\n(`PostthreeMade`, integer)\n(`note`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"teams\"\nColumns:\n(\"_year\", BIGINT, primary key)\n(\"lgID\", STRING)\n(\"tmID\", STRING, primary key)\n(\"franchID\", STRING)\n(\"confID\", STRING)\n(\"divID\", STRING)\n(\"_rank\", BIGINT)\n(\"confRank\", BIGINT)\n(\"playoff\", STRING)\n(\"name\", STRING)\n(\"o_fgm\", BIGINT)\n(\"o_ftm\", BIGINT)\n(\"o_pts\", BIGINT)\n(\"d_pts\", BIGINT)\n(\"homeWon\", BIGINT)\n(\"homeLost\", BIGINT)\n(\"awayWon\", BIGINT)\n(\"awayLost\", BIGINT)\n(\"won\", BIGINT)\n(\"lost\", BIGINT)\n(\"games\", BIGINT)\n(\"arena\", STRING)\n",
            "Table: \"players_teams\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"playerID\", STRING)\n(\"_year\", BIGINT)\n(\"stint\", BIGINT)\n(\"tmID\", STRING)\n(\"lgID\", STRING)\n(\"GP\", BIGINT)\n(\"GS\", BIGINT)\n(\"minutes\", BIGINT)\n(\"points\", BIGINT)\n(\"oRebounds\", BIGINT)\n(\"dRebounds\", BIGINT)\n(\"rebounds\", BIGINT)\n(\"assists\", BIGINT)\n(\"steals\", BIGINT)\n(\"blocks\", BIGINT)\n(\"turnovers\", BIGINT)\n(\"PF\", BIGINT)\n(\"fgAttempted\", BIGINT)\n(\"fgMade\", BIGINT)\n(\"ftAttempted\", BIGINT)\n(\"ftMade\", BIGINT)\n(\"threeAttempted\", BIGINT)\n(\"threeMade\", BIGINT)\n(\"PostGP\", BIGINT)\n(\"PostGS\", BIGINT)\n(\"PostMinutes\", BIGINT)\n(\"PostPoints\", BIGINT)\n(\"PostoRebounds\", BIGINT)\n(\"PostdRebounds\", BIGINT)\n(\"PostRebounds\", BIGINT)\n(\"PostAssists\", BIGINT)\n(\"PostSteals\", BIGINT)\n(\"PostBlocks\", BIGINT)\n(\"PostTurnovers\", BIGINT)\n(\"PostPF\", BIGINT)\n(\"PostfgAttempted\", BIGINT)\n(\"PostfgMade\", BIGINT)\n(\"PostftAttempted\", BIGINT)\n(\"PostftMade\", BIGINT)\n(\"PostthreeAttempted\", BIGINT)\n(\"PostthreeMade\", BIGINT)\n(\"note\", STRING)\n"
        ]
    },
    {
        "sql_id": 238,
        "database_name": "shakespeare",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(T2.Act = 1, 1, 0)) - SUM(IIF(T2.Act = 5, 1, 0)) AS more FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE T1.Title = 'Twelfth Night'",
        "target_query": "SELECT SUM(CASE WHEN \"T2\".\"Act\" = 1 THEN 1 ELSE 0 END) - SUM(CASE WHEN \"T2\".\"Act\" = 5 THEN 1 ELSE 0 END) AS \"more\" FROM \"works\" AS \"T1\" INNER JOIN \"chapters\" AS \"T2\" ON \"T1\".\"id\" = \"T2\".\"work_id\" WHERE \"T1\".\"Title\" = 'Twelfth Night';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 31,
                "dilatect_content": "IIF(T2.Act = 1, 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 40,
                "end_index": 60,
                "dilatect_content": "IIF(T2.Act = 5, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 56,
                "dilatect_content": "CASE WHEN \"T2\".\"Act\" = 1 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 65,
                "end_index": 110,
                "dilatect_content": "CASE WHEN \"T2\".\"Act\" = 5 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `works`\nColumns:\n(`id`, integer, primary key)\n(`Title`, text)\n(`LongTitle`, text)\n(`Date`, integer)\n(`GenreType`, text)\n",
            "Table: `chapters`\nColumns:\n(`id`, integer, primary key)\n(`Act`, integer)\n(`Scene`, integer)\n(`Description`, text)\n(`work_id`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"works\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"Title\", STRING)\n(\"LongTitle\", STRING)\n(\"_Date\", BIGINT)\n(\"GenreType\", STRING)\n",
            "Table: \"chapters\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"Act\", BIGINT)\n(\"Scene\", BIGINT)\n(\"Description\", STRING)\n(\"work_id\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 239,
        "database_name": "shakespeare",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.GenreType = 'Tragedy', 1, 0)) AS REAL) * 100 / COUNT(T1.Scene) FROM chapters AS T1 INNER JOIN works AS T2 ON T1.work_id = T2.id WHERE T2.Date = '1594'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"GenreType\" = 'Tragedy' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"Scene\") FROM \"chapters\" AS \"T1\" INNER JOIN \"works\" AS \"T2\" ON \"T1\".\"work_id\" = \"T2\".\"id\" WHERE \"T2\".\"_Date\" = '1594'",
        "semantic_equivalent_type": "approximate_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 50,
                "dilatect_content": "IIF(T2.GenreType = 'Tragedy', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 75,
                "dilatect_content": "CASE WHEN \"T2\".\"GenreType\" = 'Tragedy' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `chapters`\nColumns:\n(`id`, integer, primary key)\n(`Act`, integer)\n(`Scene`, integer)\n(`Description`, text)\n(`work_id`, integer)\n",
            "Table: `works`\nColumns:\n(`id`, integer, primary key)\n(`Title`, text)\n(`LongTitle`, text)\n(`Date`, integer)\n(`GenreType`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"chapters\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"Act\", BIGINT)\n(\"Scene\", BIGINT)\n(\"Description\", STRING)\n(\"work_id\", BIGINT)\n",
            "Table: \"works\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"Title\", STRING)\n(\"LongTitle\", STRING)\n(\"_Date\", BIGINT)\n(\"GenreType\", STRING)\n"
        ]
    },
    {
        "sql_id": 240,
        "database_name": "shakespeare",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(T4.CharName = 'Romeo', 1, 0)), SUM(IIF(T4.CharName = 'Juliet', 1, 0)), CAST(SUM(IIF(T4.CharName = 'Romeo', 1, 0)) + SUM(IIF(T4.CharName = 'Juliet', 1, 0)) AS REAL) * 100 / COUNT(T1.id) FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id INNER JOIN characters AS T4 ON T3.character_id = T4.id",
        "target_query": "SELECT SUM(CASE WHEN \"T4\".\"CharName\" = 'Romeo' THEN 1 ELSE 0 END), SUM(CASE WHEN \"T4\".\"CharName\" = 'Juliet' THEN 1 ELSE 0 END), CAST(SUM(CASE WHEN \"T4\".\"CharName\" = 'Romeo' THEN 1 ELSE 0 END) + SUM(CASE WHEN \"T4\".\"CharName\" = 'Juliet' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"id\") FROM \"works\" AS \"T1\" INNER JOIN \"chapters\" AS \"T2\" ON \"T1\".\"id\" = \"T2\".\"work_id\" INNER JOIN \"paragraphs\" AS \"T3\" ON \"T2\".\"id\" = \"T3\".\"chapter_id\" INNER JOIN \"characters\" AS \"T4\" ON \"T3\".\"character_id\" = \"T4\".\"id\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 42,
                "dilatect_content": "IIF(T4.CharName = 'Romeo', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 50,
                "end_index": 82,
                "dilatect_content": "IIF(T4.CharName = 'Juliet', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 95,
                "end_index": 126,
                "dilatect_content": "IIF(T4.CharName = 'Romeo', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 135,
                "end_index": 167,
                "dilatect_content": "IIF(T4.CharName = 'Juliet', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 67,
                "dilatect_content": "CASE WHEN \"T4\".\"CharName\" = 'Romeo' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 75,
                "end_index": 132,
                "dilatect_content": "CASE WHEN \"T4\".\"CharName\" = 'Juliet' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 145,
                "end_index": 201,
                "dilatect_content": "CASE WHEN \"T4\".\"CharName\" = 'Romeo' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 210,
                "end_index": 267,
                "dilatect_content": "CASE WHEN \"T4\".\"CharName\" = 'Juliet' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `works`\nColumns:\n(`id`, integer, primary key)\n(`Title`, text)\n(`LongTitle`, text)\n(`Date`, integer)\n(`GenreType`, text)\n",
            "Table: `chapters`\nColumns:\n(`id`, integer, primary key)\n(`Act`, integer)\n(`Scene`, integer)\n(`Description`, text)\n(`work_id`, integer)\n",
            "Table: `paragraphs`\nColumns:\n(`id`, integer, primary key)\n(`ParagraphNum`, integer)\n(`PlainText`, text)\n(`character_id`, integer)\n(`chapter_id`, integer)\n",
            "Table: `characters`\nColumns:\n(`id`, integer, primary key)\n(`CharName`, text)\n(`Abbrev`, text)\n(`Description`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"works\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"Title\", STRING)\n(\"LongTitle\", STRING)\n(\"_Date\", BIGINT)\n(\"GenreType\", STRING)\n",
            "Table: \"chapters\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"Act\", BIGINT)\n(\"Scene\", BIGINT)\n(\"Description\", STRING)\n(\"work_id\", BIGINT)\n",
            "Table: \"paragraphs\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"ParagraphNum\", BIGINT)\n(\"PlainText\", STRING)\n(\"character_id\", BIGINT)\n(\"chapter_id\", BIGINT)\n",
            "Table: \"characters\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"CharName\", STRING)\n(\"Abbrev\", STRING)\n(\"Description\", STRING)\n"
        ]
    },
    {
        "sql_id": 241,
        "database_name": "shakespeare",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T1.Title = 'All''s Well That Ends Well', 1, 0)) AS REAL) * 100 / COUNT(T3.id) FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T1\".\"Title\" = 'All''s Well That Ends Well' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T3\".\"id\") FROM \"works\" AS \"T1\" INNER JOIN \"chapters\" AS \"T2\" ON \"T1\".\"id\" = \"T2\".\"work_id\" INNER JOIN \"paragraphs\" AS \"T3\" ON \"T2\".\"id\" = \"T3\".\"chapter_id\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 65,
                "dilatect_content": "IIF(T1.Title = 'All''s Well That Ends Well', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 90,
                "dilatect_content": "CASE WHEN \"T1\".\"Title\" = 'All''s Well That Ends Well' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `works`\nColumns:\n(`id`, integer, primary key)\n(`Title`, text)\n(`LongTitle`, text)\n(`Date`, integer)\n(`GenreType`, text)\n",
            "Table: `chapters`\nColumns:\n(`id`, integer, primary key)\n(`Act`, integer)\n(`Scene`, integer)\n(`Description`, text)\n(`work_id`, integer)\n",
            "Table: `paragraphs`\nColumns:\n(`id`, integer, primary key)\n(`ParagraphNum`, integer)\n(`PlainText`, text)\n(`character_id`, integer)\n(`chapter_id`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"works\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"Title\", STRING)\n(\"LongTitle\", STRING)\n(\"_Date\", BIGINT)\n(\"GenreType\", STRING)\n",
            "Table: \"chapters\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"Act\", BIGINT)\n(\"Scene\", BIGINT)\n(\"Description\", STRING)\n(\"work_id\", BIGINT)\n",
            "Table: \"paragraphs\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"ParagraphNum\", BIGINT)\n(\"PlainText\", STRING)\n(\"character_id\", BIGINT)\n(\"chapter_id\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 242,
        "database_name": "shakespeare",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(GenreType = 'Comedy', 1, 0)) - SUM(IIF(GenreType = 'History', 1, 0)) FROM works WHERE Date > 1593",
        "target_query": "SELECT SUM(CASE WHEN \"GenreType\" = 'Comedy' THEN 1 ELSE 0 END) - SUM(CASE WHEN \"GenreType\" = 'History' THEN 1 ELSE 0 END) FROM \"works\" WHERE \"_Date\" > 1593;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 41,
                "dilatect_content": "IIF(GenreType = 'Comedy', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 50,
                "end_index": 81,
                "dilatect_content": "IIF(GenreType = 'History', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 62,
                "dilatect_content": "CASE WHEN \"GenreType\" = 'Comedy' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 71,
                "end_index": 123,
                "dilatect_content": "CASE WHEN \"GenreType\" = 'History' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `works`\nColumns:\n(`id`, integer, primary key)\n(`Title`, text)\n(`LongTitle`, text)\n(`Date`, integer)\n(`GenreType`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"works\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"Title\", STRING)\n(\"LongTitle\", STRING)\n(\"_Date\", BIGINT)\n(\"GenreType\", STRING)\n"
        ]
    },
    {
        "sql_id": 243,
        "database_name": "shakespeare",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.act = 5, 1, 0)) AS REAL) * 100 / COUNT(T2.act) FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE T1.Title = 'Titus Andronicus'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"Act\" = 5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T2\".\"Act\") FROM \"works\" AS \"T1\" INNER JOIN \"chapters\" AS \"T2\" ON \"T1\".\"id\" = \"T2\".\"work_id\" WHERE \"T1\".\"Title\" = 'Titus Andronicus'",
        "semantic_equivalent_type": "approximate_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 36,
                "dilatect_content": "IIF(T2.act = 5, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 61,
                "dilatect_content": "CASE WHEN \"T2\".\"Act\" = 5 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `works`\nColumns:\n(`id`, integer, primary key)\n(`Title`, text)\n(`LongTitle`, text)\n(`Date`, integer)\n(`GenreType`, text)\n",
            "Table: `chapters`\nColumns:\n(`id`, integer, primary key)\n(`Act`, integer)\n(`Scene`, integer)\n(`Description`, text)\n(`work_id`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"works\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"Title\", STRING)\n(\"LongTitle\", STRING)\n(\"_Date\", BIGINT)\n(\"GenreType\", STRING)\n",
            "Table: \"chapters\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"Act\", BIGINT)\n(\"Scene\", BIGINT)\n(\"Description\", STRING)\n(\"work_id\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 244,
        "database_name": "shakespeare",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.LongTitle FROM works AS T1 RIGHT JOIN chapters AS T2 ON T1.id = T2.work_id WHERE T2.Description = 'Mytilene. A street before the brothel.'",
        "target_query": "SELECT \"T1\".\"LongTitle\" FROM \"works\" AS \"T1\" RIGHT JOIN \"chapters\" AS \"T2\" ON \"T1\".\"id\" = \"T2\".\"work_id\" WHERE \"T2\".\"Description\" = 'Mytilene. A street before the brothel.';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [],
        "target_dialect_knowledge": [],
        "source_related_schemas": [
            "Table: `works`\nColumns:\n(`id`, integer, primary key)\n(`Title`, text)\n(`LongTitle`, text)\n(`Date`, integer)\n(`GenreType`, text)\n",
            "Table: `chapters`\nColumns:\n(`id`, integer, primary key)\n(`Act`, integer)\n(`Scene`, integer)\n(`Description`, text)\n(`work_id`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"works\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"Title\", STRING)\n(\"LongTitle\", STRING)\n(\"_Date\", BIGINT)\n(\"GenreType\", STRING)\n",
            "Table: \"chapters\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"Act\", BIGINT)\n(\"Scene\", BIGINT)\n(\"Description\", STRING)\n(\"work_id\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 245,
        "database_name": "shakespeare",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.Description FROM works AS T1 RIGHT JOIN chapters AS T2 ON T1.id = T2.work_id WHERE T1.Title = 'Venus and Adonis' ORDER BY T2.Scene DESC LIMIT 1",
        "target_query": "SELECT \"T2\".\"Description\" FROM \"chapters\" AS \"T2\" LEFT JOIN \"works\" AS \"T1\" ON \"T1\".\"id\" = \"T2\".\"work_id\" WHERE \"T1\".\"Title\" = 'Venus and Adonis' ORDER BY \"T2\".\"Scene\" DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [],
        "target_dialect_knowledge": [],
        "source_related_schemas": [
            "Table: `works`\nColumns:\n(`id`, integer, primary key)\n(`Title`, text)\n(`LongTitle`, text)\n(`Date`, integer)\n(`GenreType`, text)\n",
            "Table: `chapters`\nColumns:\n(`id`, integer, primary key)\n(`Act`, integer)\n(`Scene`, integer)\n(`Description`, text)\n(`work_id`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"works\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"Title\", STRING)\n(\"LongTitle\", STRING)\n(\"_Date\", BIGINT)\n(\"GenreType\", STRING)\n",
            "Table: \"chapters\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"Act\", BIGINT)\n(\"Scene\", BIGINT)\n(\"Description\", STRING)\n(\"work_id\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 246,
        "database_name": "shakespeare",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T4.CharName = 'antonio', 1, 0)) AS REAL) * 100 / COUNT(T1.id) FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id INNER JOIN characters AS T4 ON T3.character_id = T4.id WHERE T1.GenreType = 'Comedy'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T4\".\"CharName\" = 'antonio' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"id\") FROM \"works\" AS \"T1\" INNER JOIN \"chapters\" AS \"T2\" ON \"T1\".\"id\" = \"T2\".\"work_id\" INNER JOIN \"paragraphs\" AS \"T3\" ON \"T2\".\"id\" = \"T3\".\"chapter_id\" INNER JOIN \"characters\" AS \"T4\" ON \"T3\".\"character_id\" = \"T4\".\"id\" WHERE \"T1\".\"GenreType\" = 'Comedy';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 49,
                "dilatect_content": "IIF(T4.CharName = 'antonio', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 74,
                "dilatect_content": "CASE WHEN \"T4\".\"CharName\" = 'antonio' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `works`\nColumns:\n(`id`, integer, primary key)\n(`Title`, text)\n(`LongTitle`, text)\n(`Date`, integer)\n(`GenreType`, text)\n",
            "Table: `chapters`\nColumns:\n(`id`, integer, primary key)\n(`Act`, integer)\n(`Scene`, integer)\n(`Description`, text)\n(`work_id`, integer)\n",
            "Table: `paragraphs`\nColumns:\n(`id`, integer, primary key)\n(`ParagraphNum`, integer)\n(`PlainText`, text)\n(`character_id`, integer)\n(`chapter_id`, integer)\n",
            "Table: `characters`\nColumns:\n(`id`, integer, primary key)\n(`CharName`, text)\n(`Abbrev`, text)\n(`Description`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"works\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"Title\", STRING)\n(\"LongTitle\", STRING)\n(\"_Date\", BIGINT)\n(\"GenreType\", STRING)\n",
            "Table: \"chapters\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"Act\", BIGINT)\n(\"Scene\", BIGINT)\n(\"Description\", STRING)\n(\"work_id\", BIGINT)\n",
            "Table: \"paragraphs\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"ParagraphNum\", BIGINT)\n(\"PlainText\", STRING)\n(\"character_id\", BIGINT)\n(\"chapter_id\", BIGINT)\n",
            "Table: \"characters\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"CharName\", STRING)\n(\"Abbrev\", STRING)\n(\"Description\", STRING)\n"
        ]
    },
    {
        "sql_id": 247,
        "database_name": "donor",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT teacher_ny_teaching_fellow end FROM projects WHERE teacher_acctid = '42d43fa6f37314365d08692e08680973'",
        "target_query": "SELECT \"teacher_ny_teaching_fellow\" FROM \"projects\" WHERE \"teacher_acctid\" = '42d43fa6f37314365d08692e08680973';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [],
        "target_dialect_knowledge": [],
        "source_related_schemas": [
            "Table: `projects`\nColumns:\n(`projectid`, text, primary key)\n(`teacher_acctid`, text)\n(`schoolid`, text)\n(`school_ncesid`, text)\n(`school_latitude`, real)\n(`school_longitude`, real)\n(`school_city`, text)\n(`school_state`, text)\n(`school_zip`, integer)\n(`school_metro`, text)\n(`school_district`, text)\n(`school_county`, text)\n(`school_charter`, text)\n(`school_magnet`, text)\n(`school_year_round`, text)\n(`school_nlns`, text)\n(`school_kipp`, text)\n(`school_charter_ready_promise`, text)\n(`teacher_prefix`, text)\n(`teacher_teach_for_america`, text)\n(`teacher_ny_teaching_fellow`, text)\n(`primary_focus_subject`, text)\n(`primary_focus_area`, text)\n(`secondary_focus_subject`, text)\n(`secondary_focus_area`, text)\n(`resource_type`, text)\n(`poverty_level`, text)\n(`grade_level`, text)\n(`fulfillment_labor_materials`, real)\n(`total_price_excluding_optional_support`, real)\n(`total_price_including_optional_support`, real)\n(`students_reached`, integer)\n(`eligible_double_your_impact_match`, text)\n(`eligible_almost_home_match`, text)\n(`date_posted`, date)\n"
        ],
        "target_related_schemas": [
            "Table: \"projects\"\nColumns:\n(\"projectid\", STRING, primary key)\n(\"teacher_acctid\", STRING)\n(\"schoolid\", STRING)\n(\"school_ncesid\", STRING)\n(\"school_latitude\", DOUBLE PRECISION)\n(\"school_longitude\", DOUBLE PRECISION)\n(\"school_city\", STRING)\n(\"school_state\", STRING)\n(\"school_zip\", BIGINT)\n(\"school_metro\", STRING)\n(\"school_district\", STRING)\n(\"school_county\", STRING)\n(\"school_charter\", STRING)\n(\"school_magnet\", STRING)\n(\"school_year_round\", STRING)\n(\"school_nlns\", STRING)\n(\"school_kipp\", STRING)\n(\"school_charter_ready_promise\", STRING)\n(\"teacher_prefix\", STRING)\n(\"teacher_teach_for_america\", STRING)\n(\"teacher_ny_teaching_fellow\", STRING)\n(\"primary_focus_subject\", STRING)\n(\"primary_focus_area\", STRING)\n(\"secondary_focus_subject\", STRING)\n(\"secondary_focus_area\", STRING)\n(\"resource_type\", STRING)\n(\"poverty_level\", STRING)\n(\"grade_level\", STRING)\n(\"fulfillment_labor_materials\", DOUBLE PRECISION)\n(\"total_price_excluding_optional_support\", DOUBLE PRECISION)\n(\"total_price_including_optional_support\", DOUBLE PRECISION)\n(\"students_reached\", BIGINT)\n(\"eligible_double_your_impact_match\", STRING)\n(\"eligible_almost_home_match\", STRING)\n(\"date_posted\", DATE)\n"
        ]
    },
    {
        "sql_id": 248,
        "database_name": "video_games",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T.game_name FROM game AS T ORDER BY LENGTH(T.game_name) DESC LIMIT 1",
        "target_query": "SELECT \"T\".\"game_name\" FROM \"game\" AS \"T\" ORDER BY length(\"T\".\"game_name\") DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 43,
                "end_index": 61,
                "dilatect_content": "LENGTH(T.game_name)",
                "feature": "length(X)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 59,
                "end_index": 95,
                "dilatect_content": "length(\"T\".\"game_name\")",
                "feature": "length(X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "length(X)",
                "explanation": "MonetDB supports the length() function for both string and BLOB values. For a string value X, the function returns the number of characters (code points) in the string. For a BLOB value, it returns the byte-length of the BLOB.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `game`\nColumns:\n(`id`, integer, primary key)\n(`genre_id`, integer)\n(`game_name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"game\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"genre_id\", BIGINT)\n(\"game_name\", STRING)\n"
        ]
    },
    {
        "sql_id": 249,
        "database_name": "authors",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT FullName FROM Conference ORDER BY LENGTH(FullName) DESC LIMIT 1",
        "target_query": "SELECT \"FullName\" FROM \"Conference\" ORDER BY length(\"FullName\") DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 41,
                "end_index": 56,
                "dilatect_content": "LENGTH(FullName)",
                "feature": "length(X)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 49,
                "end_index": 68,
                "dilatect_content": "length(\"FullName\")",
                "feature": "length(X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "length(X)",
                "explanation": "MonetDB supports the length() function for both string and BLOB values. For a string value X, the function returns the number of characters (code points) in the string. For a BLOB value, it returns the byte-length of the BLOB.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Conference`\nColumns:\n(`Id`, integer, primary key)\n(`ShortName`, text)\n(`FullName`, text)\n(`HomePage`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Conference\"\nColumns:\n(\"Id\", BIGINT, primary key)\n(\"ShortName\", STRING)\n(\"FullName\", STRING)\n(\"HomePage\", STRING)\n"
        ]
    },
    {
        "sql_id": 250,
        "database_name": "college_completion",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT IIF(SUM(CASE WHEN T2.gender = 'F' THEN T2.grad_150 ELSE 0 END) > SUM(CASE WHEN T2.gender = 'M' THEN T2.grad_150 ELSE 0 END), 'female White students', 'male White students') FROM institution_details AS T1 INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE T1.chronname = 'Central Alabama Community College' AND T2.year = 2011 AND T2.race = 'W'",
        "target_query": "SELECT CASE WHEN SUM(CASE WHEN \"T2\".\"gender\" = 'F' THEN \"T2\".\"grad_150\" ELSE 0 END) > SUM(CASE WHEN \"T2\".\"gender\" = 'M' THEN \"T2\".\"grad_150\" ELSE 0 END) THEN 'female White students' ELSE 'male White students' END FROM \"institution_details\" AS \"T1\" INNER JOIN \"institution_grads\" AS \"T2\" ON \"T2\".\"unitid\" = \"T1\".\"unitid\" WHERE \"T1\".\"chronname\" = 'Central Alabama Community College' AND \"T2\".\"_year\" = 2011 AND \"T2\".\"race\" = 'W';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 178,
                "dilatect_content": "IIF(SUM(CASE WHEN T2.gender = 'F' THEN T2.grad_150 ELSE 0 END) > SUM(CASE WHEN T2.gender = 'M' THEN T2.grad_150 ELSE 0 END), 'female White students', 'male White students')",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 227,
                "dilatect_content": "CASE WHEN SUM(CASE WHEN \"T2\".\"gender\" = 'F' THEN \"T2\".\"grad_150\" ELSE 0 END) > SUM(CASE WHEN \"T2\".\"gender\" = 'M' THEN \"T2\".\"grad_150\" ELSE 0 END) THEN 'female White students' ELSE 'male White students' END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `institution_details`\nColumns:\n(`unitid`, integer, primary key)\n(`chronname`, text)\n(`city`, text)\n(`state`, text)\n(`level`, text)\n(`control`, text)\n(`basic`, text)\n(`hbcu`, text)\n(`flagship`, text)\n(`long_x`, real)\n(`lat_y`, real)\n(`site`, text)\n(`student_count`, integer)\n(`awards_per_value`, real)\n(`awards_per_state_value`, real)\n(`awards_per_natl_value`, real)\n(`exp_award_value`, integer)\n(`exp_award_state_value`, integer)\n(`exp_award_natl_value`, integer)\n(`exp_award_percentile`, integer)\n(`ft_pct`, real)\n(`fte_value`, integer)\n(`fte_percentile`, integer)\n(`med_sat_value`, text)\n(`med_sat_percentile`, text)\n(`aid_value`, integer)\n(`aid_percentile`, integer)\n(`endow_value`, text)\n(`endow_percentile`, text)\n(`grad_100_value`, real)\n(`grad_100_percentile`, integer)\n(`grad_150_value`, real)\n(`grad_150_percentile`, integer)\n(`pell_value`, real)\n(`pell_percentile`, integer)\n(`retain_value`, real)\n(`retain_percentile`, integer)\n(`ft_fac_value`, real)\n(`ft_fac_percentile`, integer)\n(`vsa_year`, text)\n(`vsa_grad_after4_first`, text)\n(`vsa_grad_elsewhere_after4_first`, text)\n(`vsa_enroll_after4_first`, text)\n(`vsa_enroll_elsewhere_after4_first`, text)\n(`vsa_grad_after6_first`, text)\n(`vsa_grad_elsewhere_after6_first`, text)\n(`vsa_enroll_after6_first`, text)\n(`vsa_enroll_elsewhere_after6_first`, text)\n(`vsa_grad_after4_transfer`, text)\n(`vsa_grad_elsewhere_after4_transfer`, text)\n(`vsa_enroll_after4_transfer`, text)\n(`vsa_enroll_elsewhere_after4_transfer`, text)\n(`vsa_grad_after6_transfer`, text)\n(`vsa_grad_elsewhere_after6_transfer`, text)\n(`vsa_enroll_after6_transfer`, text)\n(`vsa_enroll_elsewhere_after6_transfer`, text)\n(`similar`, text)\n(`state_sector_ct`, integer)\n(`carnegie_ct`, integer)\n(`counted_pct`, text)\n(`nicknames`, text)\n(`cohort_size`, integer)\n",
            "Table: `institution_grads`\nColumns:\n(`unitid`, integer)\n(`year`, integer)\n(`gender`, text)\n(`race`, text)\n(`cohort`, text)\n(`grad_cohort`, text)\n(`grad_100`, text)\n(`grad_150`, text)\n(`grad_100_rate`, text)\n(`grad_150_rate`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"institution_details\"\nColumns:\n(\"unitid\", BIGINT, primary key)\n(\"chronname\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"level\", STRING)\n(\"control\", STRING)\n(\"basic\", STRING)\n(\"hbcu\", STRING)\n(\"flagship\", STRING)\n(\"long_x\", DOUBLE PRECISION)\n(\"lat_y\", DOUBLE PRECISION)\n(\"site\", STRING)\n(\"student_count\", BIGINT)\n(\"awards_per_value\", DOUBLE PRECISION)\n(\"awards_per_state_value\", DOUBLE PRECISION)\n(\"awards_per_natl_value\", DOUBLE PRECISION)\n(\"exp_award_value\", BIGINT)\n(\"exp_award_state_value\", BIGINT)\n(\"exp_award_natl_value\", BIGINT)\n(\"exp_award_percentile\", BIGINT)\n(\"ft_pct\", DOUBLE PRECISION)\n(\"fte_value\", BIGINT)\n(\"fte_percentile\", BIGINT)\n(\"med_sat_value\", STRING)\n(\"med_sat_percentile\", STRING)\n(\"aid_value\", BIGINT)\n(\"aid_percentile\", BIGINT)\n(\"endow_value\", STRING)\n(\"endow_percentile\", STRING)\n(\"grad_100_value\", DOUBLE PRECISION)\n(\"grad_100_percentile\", BIGINT)\n(\"grad_150_value\", DOUBLE PRECISION)\n(\"grad_150_percentile\", BIGINT)\n(\"pell_value\", DOUBLE PRECISION)\n(\"pell_percentile\", BIGINT)\n(\"retain_value\", DOUBLE PRECISION)\n(\"retain_percentile\", BIGINT)\n(\"ft_fac_value\", DOUBLE PRECISION)\n(\"ft_fac_percentile\", BIGINT)\n(\"vsa_year\", STRING)\n(\"vsa_grad_after4_first\", STRING)\n(\"vsa_grad_elsewhere_after4_first\", STRING)\n(\"vsa_enroll_after4_first\", STRING)\n(\"vsa_enroll_elsewhere_after4_first\", STRING)\n(\"vsa_grad_after6_first\", STRING)\n(\"vsa_grad_elsewhere_after6_first\", STRING)\n(\"vsa_enroll_after6_first\", STRING)\n(\"vsa_enroll_elsewhere_after6_first\", STRING)\n(\"vsa_grad_after4_transfer\", STRING)\n(\"vsa_grad_elsewhere_after4_transfer\", STRING)\n(\"vsa_enroll_after4_transfer\", STRING)\n(\"vsa_enroll_elsewhere_after4_transfer\", STRING)\n(\"vsa_grad_after6_transfer\", STRING)\n(\"vsa_grad_elsewhere_after6_transfer\", STRING)\n(\"vsa_enroll_after6_transfer\", STRING)\n(\"vsa_enroll_elsewhere_after6_transfer\", STRING)\n(\"similar\", STRING)\n(\"state_sector_ct\", BIGINT)\n(\"carnegie_ct\", BIGINT)\n(\"counted_pct\", STRING)\n(\"nicknames\", STRING)\n(\"cohort_size\", BIGINT)\n",
            "Table: \"institution_grads\"\nColumns:\n(\"unitid\", BIGINT)\n(\"_year\", BIGINT)\n(\"gender\", STRING)\n(\"race\", STRING)\n(\"cohort\", STRING)\n(\"grad_cohort\", STRING)\n(\"grad_100\", STRING)\n(\"grad_150\", STRING)\n(\"grad_100_rate\", STRING)\n(\"grad_150_rate\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 251,
        "database_name": "public_review_platform",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T1.business_id) , strftime('%Y', 'now') - T2.user_yelping_since_year FROM Reviews AS T1 INNER JOIN Users AS T2 ON T1.user_id = T2.user_id WHERE T1.user_id = 3",
        "target_query": "SELECT COUNT(\"T1\".\"business_id\"), EXTRACT(YEAR FROM CURRENT_TIMESTAMP) - \"T2\".\"user_yelping_since_year\" FROM \"Reviews\" AS \"T1\" INNER JOIN \"_Users\" AS \"T2\" ON \"T1\".\"user_id\" = \"T2\".\"user_id\" WHERE \"T1\".\"user_id\" = 3 GROUP BY \"T2\".\"user_yelping_since_year\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 31,
                "end_index": 51,
                "dilatect_content": "strftime('%Y', 'now')",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 46,
                "end_index": 72,
                "dilatect_content": "YEAR FROM CURRENT_TIMESTAMP",
                "feature": ""
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Reviews`\nColumns:\n(`business_id`, integer, primary key)\n(`user_id`, integer, primary key)\n(`review_stars`, integer)\n(`review_votes_funny`, text)\n(`review_votes_useful`, text)\n(`review_votes_cool`, text)\n(`review_length`, text)\n",
            "Table: `Users`\nColumns:\n(`user_id`, integer, primary key)\n(`user_yelping_since_year`, integer)\n(`user_average_stars`, text)\n(`user_votes_funny`, text)\n(`user_votes_useful`, text)\n(`user_votes_cool`, text)\n(`user_review_count`, text)\n(`user_fans`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Reviews\"\nColumns:\n(\"business_id\", BIGINT, primary key)\n(\"user_id\", BIGINT, primary key)\n(\"review_stars\", BIGINT)\n(\"review_votes_funny\", STRING)\n(\"review_votes_useful\", STRING)\n(\"review_votes_cool\", STRING)\n(\"review_length\", STRING)\n",
            "Table: \"_Users\"\nColumns:\n(\"user_id\", BIGINT, primary key)\n(\"user_yelping_since_year\", BIGINT)\n(\"user_average_stars\", STRING)\n(\"user_votes_funny\", STRING)\n(\"user_votes_useful\", STRING)\n(\"user_votes_cool\", STRING)\n(\"user_review_count\", STRING)\n(\"user_fans\", STRING)\n"
        ]
    },
    {
        "sql_id": 253,
        "database_name": "public_review_platform",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUBSTR(T1.closing_time, 1, 2) + 12 - SUBSTR(T1.opening_time, 1, 2) AS YYSJ FROM Business_Hours AS T1 INNER JOIN Days AS T2 ON T1.day_id = T2.day_id WHERE T2.day_of_week = 'Monday' AND T1.business_id = 15098",
        "target_query": "SELECT CAST(substring(\"T1\".\"closing_time\" from 1 for 2) AS INTEGER) + 12 - CAST(substring(\"T1\".\"opening_time\" from 1 for 2) AS INTEGER) AS \"YYSJ\" FROM \"Business_Hours\" AS \"T1\" INNER JOIN \"Days\" AS \"T2\" ON \"T1\".\"day_id\" = \"T2\".\"day_id\" WHERE \"T2\".\"day_of_week\" = 'Monday' AND \"T1\".\"business_id\" = 15098;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 35,
                "dilatect_content": "SUBSTR(T1.closing_time, 1, 2)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 44,
                "end_index": 72,
                "dilatect_content": "SUBSTR(T1.opening_time, 1, 2)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 12,
                "end_index": 58,
                "dilatect_content": "substring(\"T1\".\"closing_time\" from 1 for 2)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 84,
                "end_index": 129,
                "dilatect_content": "substring(\"T1\".\"opening_time\" from 1 for 2",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Business_Hours`\nColumns:\n(`business_id`, integer, primary key)\n(`day_id`, integer, primary key)\n(`opening_time`, text)\n(`closing_time`, text)\n",
            "Table: `Days`\nColumns:\n(`day_id`, integer, primary key)\n(`day_of_week`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Business_Hours\"\nColumns:\n(\"business_id\", BIGINT, primary key)\n(\"day_id\", BIGINT, primary key)\n(\"opening_time\", STRING)\n(\"closing_time\", STRING)\n",
            "Table: \"Days\"\nColumns:\n(\"day_id\", BIGINT, primary key)\n(\"day_of_week\", STRING)\n"
        ]
    },
    {
        "sql_id": 254,
        "database_name": "public_review_platform",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.business_id FROM Business_Hours AS T1 INNER JOIN Business_Categories AS T2 ON T1.business_id = T2.business_id INNER JOIN Categories AS T3 ON T2.category_id = T3.category_id WHERE T3.category_name = 'Accessories' AND SUBSTR(T1.opening_time, -4, 2) * 1 < 7 AND T1.opening_time LIKE '%AM'",
        "target_query": "SELECT \"T1\".\"business_id\" FROM \"Business_Hours\" AS \"T1\" INNER JOIN \"Business_Categories\" AS \"T2\" ON \"T1\".\"business_id\" = \"T2\".\"business_id\" INNER JOIN \"Categories\" AS \"T3\" ON \"T2\".\"category_id\" = \"T3\".\"category_id\" WHERE \"T3\".\"category_name\" = 'Accessories' AND substring(\"T1\".\"opening_time\" from char_length(\"T1\".\"opening_time\") - 4 for 2) * 1 < 7 AND \"T1\".\"opening_time\" LIKE '%AM';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 226,
                "end_index": 255,
                "dilatect_content": "SUBSTR(T1.opening_time, -4, 2)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 298,
                "end_index": 383,
                "dilatect_content": "substring(\"T1\".\"opening_time\" from char_length(\"T1\".\"opening_time\") - 4 for 2)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Business_Hours`\nColumns:\n(`business_id`, integer, primary key)\n(`day_id`, integer, primary key)\n(`opening_time`, text)\n(`closing_time`, text)\n",
            "Table: `Business_Categories`\nColumns:\n(`business_id`, integer, primary key)\n(`category_id`, integer, primary key)\n",
            "Table: `Categories`\nColumns:\n(`category_id`, integer, primary key)\n(`category_name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Business_Hours\"\nColumns:\n(\"business_id\", BIGINT, primary key)\n(\"day_id\", BIGINT, primary key)\n(\"opening_time\", STRING)\n(\"closing_time\", STRING)\n",
            "Table: \"Business_Categories\"\nColumns:\n(\"business_id\", BIGINT, primary key)\n(\"category_id\", BIGINT, primary key)\n",
            "Table: \"Categories\"\nColumns:\n(\"category_id\", BIGINT, primary key)\n(\"category_name\", STRING)\n"
        ]
    },
    {
        "sql_id": 255,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(name) FROM Person WHERE birth_region = 'New York' AND SUBSTR(birthdate, 1, 4) > '1970';",
        "target_query": "SELECT COUNT(\"name\") FROM \"Person\" WHERE \"birth_region\" = 'New York' AND substring(\"birthdate\" from 1 for 4) > '1970';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 67,
                "end_index": 89,
                "dilatect_content": "SUBSTR(birthdate, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 79,
                "end_index": 115,
                "dilatect_content": "substring(\"birthdate\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`name`, text, primary key)\n(`birthdate`, text)\n(`birth_name`, text)\n(`birth_place`, text)\n(`birth_region`, text)\n(`birth_country`, text)\n(`height_meters`, real)\n(`nickname`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Person\"\nColumns:\n(\"name\", STRING, primary key)\n(\"birthdate\", STRING)\n(\"birth_name\", STRING)\n(\"birth_place\", STRING)\n(\"birth_region\", STRING)\n(\"birth_country\", STRING)\n(\"height_meters\", DOUBLE PRECISION)\n(\"nickname\", STRING)\n"
        ]
    },
    {
        "sql_id": 256,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.rating FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE T1.award = 'Outstanding Voice-Over Performance' AND SUBSTR(T1.year, 1, 4) = '2009' AND T1.person = 'Dan Castellaneta';",
        "target_query": "SELECT \"T2\".\"rating\" FROM \"Award\" AS \"T1\" INNER JOIN \"Episode\" AS \"T2\" ON \"T1\".\"episode_id\" = \"T2\".\"episode_id\" WHERE \"T1\".\"award\" = 'Outstanding Voice-Over Performance' AND substring(\"T1\".\"_year\" from 1 for 4) = '2009' AND \"T1\".\"person\" = 'Dan Castellaneta';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 150,
                "end_index": 170,
                "dilatect_content": "SUBSTR(T1.year, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 198,
                "end_index": 237,
                "dilatect_content": "substring(\"T1\".\"_year\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, integer, primary key)\n(`organization`, text)\n(`year`, integer)\n(`award_category`, text)\n(`award`, text)\n(`person`, text)\n(`role`, text)\n(`episode_id`, text)\n(`season`, text)\n(`song`, text)\n(`result`, text)\n",
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"Award\"\nColumns:\n(\"award_id\", BIGINT, primary key)\n(\"organization\", STRING)\n(\"_year\", BIGINT)\n(\"award_category\", STRING)\n(\"award\", STRING)\n(\"person\", STRING)\n(\"role\", STRING)\n(\"episode_id\", STRING)\n(\"season\", STRING)\n(\"song\", STRING)\n(\"result\", STRING)\n",
            "Table: \"Episode\"\nColumns:\n(\"episode_id\", STRING, primary key)\n(\"season\", BIGINT)\n(\"episode\", BIGINT)\n(\"number_in_series\", BIGINT)\n(\"title\", STRING)\n(\"summary\", STRING)\n(\"air_date\", STRING)\n(\"episode_image\", STRING)\n(\"rating\", DOUBLE PRECISION)\n(\"votes\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 257,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(*) FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE SUBSTR(T1.air_date, 1, 4) = '2009' AND T2.stars = 10 AND T2.percent > 15;",
        "target_query": "SELECT COUNT(*) FROM \"Episode\" AS \"T1\" INNER JOIN \"Vote\" AS \"T2\" ON \"T2\".\"episode_id\" = \"T1\".\"episode_id\" WHERE substring(\"T1\".\"air_date\" from 1 for 4) = '2009' AND \"T2\".\"stars\" = 10 AND \"T2\".\"percent\" > 15;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 96,
                "end_index": 120,
                "dilatect_content": "SUBSTR(T1.air_date, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 128,
                "end_index": 170,
                "dilatect_content": "substring(\"T1\".\"air_date\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n",
            "Table: `Vote`\nColumns:\n(`episode_id`, text)\n(`stars`, integer)\n(`votes`, integer)\n(`percent`, real)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"Episode\"\nColumns:\n(\"episode_id\", STRING, primary key)\n(\"season\", BIGINT)\n(\"episode\", BIGINT)\n(\"number_in_series\", BIGINT)\n(\"title\", STRING)\n(\"summary\", STRING)\n(\"air_date\", STRING)\n(\"episode_image\", STRING)\n(\"rating\", DOUBLE PRECISION)\n(\"votes\", BIGINT)\n",
            "Table: \"Vote\"\nColumns:\n(\"episode_id\", STRING)\n(\"stars\", BIGINT)\n(\"votes\", BIGINT)\n(\"percent\", DOUBLE PRECISION)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 259,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.title FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE SUBSTR(T1.year, 1, 4) = '2017' AND T1.award = 'Best International TV Series' AND T1.result = 'Winner';",
        "target_query": "SELECT \"T2\".\"title\" FROM \"Award\" AS \"T1\" INNER JOIN \"Episode\" AS \"T2\" ON \"T1\".\"episode_id\" = \"T2\".\"episode_id\" WHERE substring(cast(\"T1\".\"_year\" as varchar) from 1 for 4) = '2017' AND \"T1\".\"award\" = 'Best International TV Series' AND \"T1\".\"result\" = 'Winner';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 97,
                "end_index": 117,
                "dilatect_content": "SUBSTR(T1.year, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 137,
                "end_index": 193,
                "dilatect_content": "substring(cast(\"T1\".\"_year\" as varchar) from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, integer, primary key)\n(`organization`, text)\n(`year`, integer)\n(`award_category`, text)\n(`award`, text)\n(`person`, text)\n(`role`, text)\n(`episode_id`, text)\n(`season`, text)\n(`song`, text)\n(`result`, text)\n",
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"Award\"\nColumns:\n(\"award_id\", BIGINT, primary key)\n(\"organization\", STRING)\n(\"_year\", BIGINT)\n(\"award_category\", STRING)\n(\"award\", STRING)\n(\"person\", STRING)\n(\"role\", STRING)\n(\"episode_id\", STRING)\n(\"season\", STRING)\n(\"song\", STRING)\n(\"result\", STRING)\n",
            "Table: \"Episode\"\nColumns:\n(\"episode_id\", STRING, primary key)\n(\"season\", BIGINT)\n(\"episode\", BIGINT)\n(\"number_in_series\", BIGINT)\n(\"title\", STRING)\n(\"summary\", STRING)\n(\"air_date\", STRING)\n(\"episode_image\", STRING)\n(\"rating\", DOUBLE PRECISION)\n(\"votes\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 260,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT T2.person FROM Episode AS T1 INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE SUBSTR(T1.air_date, 6, 2) BETWEEN '10' AND '11';",
        "target_query": "SELECT DISTINCT \"T2\".\"person\" FROM \"Episode\" AS \"T1\" INNER JOIN \"Credit\" AS \"T2\" ON \"T1\".\"episode_id\" = \"T2\".\"episode_id\" WHERE substring(\"T1\".\"air_date\" from 6 for 2) BETWEEN '10' AND '11';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 108,
                "end_index": 132,
                "dilatect_content": "SUBSTR(T1.air_date, 6, 2)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 148,
                "end_index": 190,
                "dilatect_content": "substring(\"T1\".\"air_date\" from 6 for 2)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n",
            "Table: `Credit`\nColumns:\n(`episode_id`, text)\n(`category`, text)\n(`person`, text)\n(`role`, text)\n(`credited`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"Episode\"\nColumns:\n(\"episode_id\", STRING, primary key)\n(\"season\", BIGINT)\n(\"episode\", BIGINT)\n(\"number_in_series\", BIGINT)\n(\"title\", STRING)\n(\"summary\", STRING)\n(\"air_date\", STRING)\n(\"episode_image\", STRING)\n(\"rating\", DOUBLE PRECISION)\n(\"votes\", BIGINT)\n",
            "Table: \"Credit\"\nColumns:\n(\"episode_id\", STRING)\n(\"category\", STRING)\n(\"person\", STRING)\n(\"role\", STRING)\n(\"credited\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 261,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.year - CAST(SUBSTR(T1.birthdate, 1, 4) AS int) AS age FROM Person AS T1 INNER JOIN Award AS T2 ON T1.name = T2.person WHERE T2.award = 'Outstanding Voice-Over Performance' AND T2.organization = 'Primetime Emmy Awards' AND T2.result = 'Winner';",
        "target_query": "SELECT \"T2\".\"_year\" - CAST(substring(\"T1\".\"birthdate\" from 1 for 4) AS int) AS age FROM \"Person\" AS \"T1\" INNER JOIN \"Award\" AS \"T2\" ON \"T1\".\"name\" = \"T2\".\"person\" WHERE \"T2\".\"award\" = 'Outstanding Voice-Over Performance' AND \"T2\".\"organization\" = 'Primetime Emmy Awards' AND \"T2\".\"result\" = 'Winner';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 22,
                "end_index": 47,
                "dilatect_content": "SUBSTR(T1.birthdate, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 31,
                "end_index": 74,
                "dilatect_content": "substring(\"T1\".\"birthdate\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`name`, text, primary key)\n(`birthdate`, text)\n(`birth_name`, text)\n(`birth_place`, text)\n(`birth_region`, text)\n(`birth_country`, text)\n(`height_meters`, real)\n(`nickname`, text)\n",
            "Table: `Award`\nColumns:\n(`award_id`, integer, primary key)\n(`organization`, text)\n(`year`, integer)\n(`award_category`, text)\n(`award`, text)\n(`person`, text)\n(`role`, text)\n(`episode_id`, text)\n(`season`, text)\n(`song`, text)\n(`result`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Person\"\nColumns:\n(\"name\", STRING, primary key)\n(\"birthdate\", STRING)\n(\"birth_name\", STRING)\n(\"birth_place\", STRING)\n(\"birth_region\", STRING)\n(\"birth_country\", STRING)\n(\"height_meters\", DOUBLE PRECISION)\n(\"nickname\", STRING)\n",
            "Table: \"Award\"\nColumns:\n(\"award_id\", BIGINT, primary key)\n(\"organization\", STRING)\n(\"_year\", BIGINT)\n(\"award_category\", STRING)\n(\"award\", STRING)\n(\"person\", STRING)\n(\"role\", STRING)\n(\"episode_id\", STRING)\n(\"season\", STRING)\n(\"song\", STRING)\n(\"result\", STRING)\n"
        ]
    },
    {
        "sql_id": 262,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T1.episode_id) FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE SUBSTR(T1.year, 1, 4) = '2009' AND T2.air_date LIKE '2009-04%';",
        "target_query": "SELECT COUNT(\"T1\".\"episode_id\") FROM \"Award\" AS \"T1\" INNER JOIN \"Episode\" AS \"T2\" ON \"T1\".\"episode_id\" = \"T2\".\"episode_id\" WHERE substring(\"T1\".\"_year\" from 1 for 4) = '2009' AND \"T2\".\"air_date\" LIKE '2009-04%';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 109,
                "end_index": 129,
                "dilatect_content": "SUBSTR(T1.year, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 149,
                "end_index": 188,
                "dilatect_content": "substring(\"T1\".\"_year\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, integer, primary key)\n(`organization`, text)\n(`year`, integer)\n(`award_category`, text)\n(`award`, text)\n(`person`, text)\n(`role`, text)\n(`episode_id`, text)\n(`season`, text)\n(`song`, text)\n(`result`, text)\n",
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"Award\"\nColumns:\n(\"award_id\", BIGINT, primary key)\n(\"organization\", STRING)\n(\"_year\", BIGINT)\n(\"award_category\", STRING)\n(\"award\", STRING)\n(\"person\", STRING)\n(\"role\", STRING)\n(\"episode_id\", STRING)\n(\"season\", STRING)\n(\"song\", STRING)\n(\"result\", STRING)\n",
            "Table: \"Episode\"\nColumns:\n(\"episode_id\", STRING, primary key)\n(\"season\", BIGINT)\n(\"episode\", BIGINT)\n(\"number_in_series\", BIGINT)\n(\"title\", STRING)\n(\"summary\", STRING)\n(\"air_date\", STRING)\n(\"episode_image\", STRING)\n(\"rating\", DOUBLE PRECISION)\n(\"votes\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 263,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT award, person FROM Award WHERE result = 'Winner' AND SUBSTR(year, 1, 4) = '2009';",
        "target_query": "SELECT \"award\", \"person\" FROM \"Award\" WHERE \"result\" = 'Winner' AND substring(\"_year\" from 1 for 4) = '2009';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 60,
                "end_index": 77,
                "dilatect_content": "SUBSTR(year, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 76,
                "end_index": 108,
                "dilatect_content": "substring(\"_year\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, integer, primary key)\n(`organization`, text)\n(`year`, integer)\n(`award_category`, text)\n(`award`, text)\n(`person`, text)\n(`role`, text)\n(`episode_id`, text)\n(`season`, text)\n(`song`, text)\n(`result`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Award\"\nColumns:\n(\"award_id\", BIGINT, primary key)\n(\"organization\", STRING)\n(\"_year\", BIGINT)\n(\"award_category\", STRING)\n(\"award\", STRING)\n(\"person\", STRING)\n(\"role\", STRING)\n(\"episode_id\", STRING)\n(\"season\", STRING)\n(\"song\", STRING)\n(\"result\", STRING)\n"
        ]
    },
    {
        "sql_id": 264,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT episode, title, rating FROM Episode WHERE SUBSTR(air_date, 1, 7) LIKE '2008-10%';",
        "target_query": "SELECT \"episode\", \"title\", \"rating\" FROM \"Episode\" WHERE substring(\"air_date\" from 1 for 7) LIKE '2008-10%';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 49,
                "end_index": 70,
                "dilatect_content": "SUBSTR(air_date, 1, 7)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 65,
                "end_index": 100,
                "dilatect_content": "substring(\"air_date\" from 1 for 7)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"Episode\"\nColumns:\n(\"episode_id\", STRING, primary key)\n(\"season\", BIGINT)\n(\"episode\", BIGINT)\n(\"number_in_series\", BIGINT)\n(\"title\", STRING)\n(\"summary\", STRING)\n(\"air_date\", STRING)\n(\"episode_image\", STRING)\n(\"rating\", DOUBLE PRECISION)\n(\"votes\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 265,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.title, T2.episode_image, T1.award, T1.person FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE T2.rating BETWEEN 7 AND 10 AND SUBSTR(T2.air_date, 1, 4) = '2008' AND T1.result = 'Nominee';",
        "target_query": "SELECT \"T2\".\"title\", \"T2\".\"episode_image\", \"T1\".\"award\", \"T1\".\"person\" \nFROM \"Award\" AS \"T1\" \nINNER JOIN \"Episode\" AS \"T2\" ON \"T1\".\"episode_id\" = \"T2\".\"episode_id\" \nWHERE \"T2\".\"rating\" BETWEEN 7 AND 10 \nAND substring(\"T2\".\"air_date\" from 1 for 4) = '2008' \nAND \"T1\".\"result\" = 'Nominee';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 167,
                "end_index": 191,
                "dilatect_content": "SUBSTR(T2.air_date, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 247,
                "end_index": 289,
                "dilatect_content": "substring(\"T2\".\"air_date\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, integer, primary key)\n(`organization`, text)\n(`year`, integer)\n(`award_category`, text)\n(`award`, text)\n(`person`, text)\n(`role`, text)\n(`episode_id`, text)\n(`season`, text)\n(`song`, text)\n(`result`, text)\n",
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"Award\"\nColumns:\n(\"award_id\", BIGINT, primary key)\n(\"organization\", STRING)\n(\"_year\", BIGINT)\n(\"award_category\", STRING)\n(\"award\", STRING)\n(\"person\", STRING)\n(\"role\", STRING)\n(\"episode_id\", STRING)\n(\"season\", STRING)\n(\"song\", STRING)\n(\"result\", STRING)\n",
            "Table: \"Episode\"\nColumns:\n(\"episode_id\", STRING, primary key)\n(\"season\", BIGINT)\n(\"episode\", BIGINT)\n(\"number_in_series\", BIGINT)\n(\"title\", STRING)\n(\"summary\", STRING)\n(\"air_date\", STRING)\n(\"episode_image\", STRING)\n(\"rating\", DOUBLE PRECISION)\n(\"votes\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 266,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.name, T1.birth_place, T2.role, 2022 - CAST(SUBSTR(T1.birthdate, 1, 4) AS int) AS age FROM Person AS T1 INNER JOIN Credit AS T2 ON T1.name = T2.person WHERE T1.birthdate IS NOT NULL ORDER BY T1.birthdate LIMIT 1;",
        "target_query": "SELECT \"T1\".\"name\", \"T1\".\"birth_place\", \"T2\".\"role\", 2022 - CAST(substring(\"T1\".\"birthdate\" from 1 for 4) AS int) AS \"age\" FROM \"Person\" AS \"T1\" INNER JOIN \"Credit\" AS \"T2\" ON \"T1\".\"name\" = \"T2\".\"person\" WHERE \"T1\".\"birthdate\" IS NOT NULL ORDER BY \"T1\".\"birthdate\" LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 53,
                "end_index": 78,
                "dilatect_content": "SUBSTR(T1.birthdate, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 77,
                "end_index": 120,
                "dilatect_content": "substring(\"T1\".\"birthdate\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`name`, text, primary key)\n(`birthdate`, text)\n(`birth_name`, text)\n(`birth_place`, text)\n(`birth_region`, text)\n(`birth_country`, text)\n(`height_meters`, real)\n(`nickname`, text)\n",
            "Table: `Credit`\nColumns:\n(`episode_id`, text)\n(`category`, text)\n(`person`, text)\n(`role`, text)\n(`credited`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"Person\"\nColumns:\n(\"name\", STRING, primary key)\n(\"birthdate\", STRING)\n(\"birth_name\", STRING)\n(\"birth_place\", STRING)\n(\"birth_region\", STRING)\n(\"birth_country\", STRING)\n(\"height_meters\", DOUBLE PRECISION)\n(\"nickname\", STRING)\n",
            "Table: \"Credit\"\nColumns:\n(\"episode_id\", STRING)\n(\"category\", STRING)\n(\"person\", STRING)\n(\"role\", STRING)\n(\"credited\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 268,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(award_id) FROM Award WHERE person = 'Billy Kimball' AND SUBSTR(year, 1, 4) = '2010' AND result = 'Nominee';",
        "target_query": "SELECT COUNT(\"award_id\") FROM \"Award\" WHERE \"person\" = 'Billy Kimball' AND \"_year\" = 2010 AND \"result\" = 'Nominee';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 69,
                "end_index": 86,
                "dilatect_content": "SUBSTR(year, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, integer, primary key)\n(`organization`, text)\n(`year`, integer)\n(`award_category`, text)\n(`award`, text)\n(`person`, text)\n(`role`, text)\n(`episode_id`, text)\n(`season`, text)\n(`song`, text)\n(`result`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Award\"\nColumns:\n(\"award_id\", BIGINT, primary key)\n(\"organization\", STRING)\n(\"_year\", BIGINT)\n(\"award_category\", STRING)\n(\"award\", STRING)\n(\"person\", STRING)\n(\"role\", STRING)\n(\"episode_id\", STRING)\n(\"season\", STRING)\n(\"song\", STRING)\n(\"result\", STRING)\n"
        ]
    },
    {
        "sql_id": 269,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT name FROM Person WHERE SUBSTR(birthdate, 1, 4) < '1970';",
        "target_query": "SELECT \"name\" FROM \"Person\" WHERE substring(\"birthdate\" from 1 for 4) < '1970';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 30,
                "end_index": 52,
                "dilatect_content": "SUBSTR(birthdate, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 38,
                "end_index": 74,
                "dilatect_content": "substring(\"birthdate\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`name`, text, primary key)\n(`birthdate`, text)\n(`birth_name`, text)\n(`birth_place`, text)\n(`birth_region`, text)\n(`birth_country`, text)\n(`height_meters`, real)\n(`nickname`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Person\"\nColumns:\n(\"name\", STRING, primary key)\n(\"birthdate\", STRING)\n(\"birth_name\", STRING)\n(\"birth_place\", STRING)\n(\"birth_region\", STRING)\n(\"birth_country\", STRING)\n(\"height_meters\", DOUBLE PRECISION)\n(\"nickname\", STRING)\n"
        ]
    },
    {
        "sql_id": 270,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT name FROM Person WHERE SUBSTR(birthdate, 1, 4) = '1958' AND birth_place = 'California' AND birth_country = 'USA';",
        "target_query": "SELECT \"name\" FROM \"Person\" WHERE substring(\"birthdate\" from 1 for 4) = '1958' AND \"birth_place\" = 'California' AND \"birth_country\" = 'USA';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 30,
                "end_index": 52,
                "dilatect_content": "SUBSTR(birthdate, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 38,
                "end_index": 74,
                "dilatect_content": "substring(\"birthdate\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`name`, text, primary key)\n(`birthdate`, text)\n(`birth_name`, text)\n(`birth_place`, text)\n(`birth_region`, text)\n(`birth_country`, text)\n(`height_meters`, real)\n(`nickname`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Person\"\nColumns:\n(\"name\", STRING, primary key)\n(\"birthdate\", STRING)\n(\"birth_name\", STRING)\n(\"birth_place\", STRING)\n(\"birth_region\", STRING)\n(\"birth_country\", STRING)\n(\"height_meters\", DOUBLE PRECISION)\n(\"nickname\", STRING)\n"
        ]
    },
    {
        "sql_id": 271,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.person FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE SUBSTR(T1.year, 1, 4) = '2009' AND T1.role = 'writer' AND T2.votes > 5;",
        "target_query": "SELECT \"T1\".\"person\" FROM \"Award\" AS \"T1\" INNER JOIN \"Episode\" AS \"T2\" ON \"T1\".\"episode_id\" = \"T2\".\"episode_id\" WHERE substring(\"T1\".\"_year\" from 1 for 4) = '2009' AND \"T1\".\"role\" = 'writer' AND \"T2\".\"votes\" > 5;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 98,
                "end_index": 118,
                "dilatect_content": "SUBSTR(T1.year, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 138,
                "end_index": 177,
                "dilatect_content": "substring(\"T1\".\"_year\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, integer, primary key)\n(`organization`, text)\n(`year`, integer)\n(`award_category`, text)\n(`award`, text)\n(`person`, text)\n(`role`, text)\n(`episode_id`, text)\n(`season`, text)\n(`song`, text)\n(`result`, text)\n",
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"Award\"\nColumns:\n(\"award_id\", BIGINT, primary key)\n(\"organization\", STRING)\n(\"_year\", BIGINT)\n(\"award_category\", STRING)\n(\"award\", STRING)\n(\"person\", STRING)\n(\"role\", STRING)\n(\"episode_id\", STRING)\n(\"season\", STRING)\n(\"song\", STRING)\n(\"result\", STRING)\n",
            "Table: \"Episode\"\nColumns:\n(\"episode_id\", STRING, primary key)\n(\"season\", BIGINT)\n(\"episode\", BIGINT)\n(\"number_in_series\", BIGINT)\n(\"title\", STRING)\n(\"summary\", STRING)\n(\"air_date\", STRING)\n(\"episode_image\", STRING)\n(\"rating\", DOUBLE PRECISION)\n(\"votes\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 272,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.episode_id FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE SUBSTR(T1.year, 1, 4) = '2009' AND T1.person = 'Al Jean' AND T1.award_category = 'Primetime Emmy';",
        "target_query": "SELECT T2.\"episode_id\" FROM \"Award\" AS T1 INNER JOIN \"Episode\" AS T2 ON T1.\"episode_id\" = T2.\"episode_id\" WHERE substring(T1.\"_year\" from 1 for 4) = '2009' AND T1.\"person\" = 'Al Jean' AND T1.\"award_category\" = 'Primetime Emmy';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 102,
                "end_index": 122,
                "dilatect_content": "SUBSTR(T1.year, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 122,
                "end_index": 157,
                "dilatect_content": "substring(T1.\"_year\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, integer, primary key)\n(`organization`, text)\n(`year`, integer)\n(`award_category`, text)\n(`award`, text)\n(`person`, text)\n(`role`, text)\n(`episode_id`, text)\n(`season`, text)\n(`song`, text)\n(`result`, text)\n",
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"Award\"\nColumns:\n(\"award_id\", BIGINT, primary key)\n(\"organization\", STRING)\n(\"_year\", BIGINT)\n(\"award_category\", STRING)\n(\"award\", STRING)\n(\"person\", STRING)\n(\"role\", STRING)\n(\"episode_id\", STRING)\n(\"season\", STRING)\n(\"song\", STRING)\n(\"result\", STRING)\n",
            "Table: \"Episode\"\nColumns:\n(\"episode_id\", STRING, primary key)\n(\"season\", BIGINT)\n(\"episode\", BIGINT)\n(\"number_in_series\", BIGINT)\n(\"title\", STRING)\n(\"summary\", STRING)\n(\"air_date\", STRING)\n(\"episode_image\", STRING)\n(\"rating\", DOUBLE PRECISION)\n(\"votes\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 273,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT name FROM Person WHERE SUBSTR(birthdate, 1, 4) = '1962' AND birth_region = 'California';",
        "target_query": "SELECT \"name\" FROM \"Person\" WHERE substring(\"birthdate\" from 1 for 4) = '1962' AND \"birth_region\" = 'California';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 30,
                "end_index": 52,
                "dilatect_content": "SUBSTR(birthdate, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 38,
                "end_index": 74,
                "dilatect_content": "substring(\"birthdate\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`name`, text, primary key)\n(`birthdate`, text)\n(`birth_name`, text)\n(`birth_place`, text)\n(`birth_region`, text)\n(`birth_country`, text)\n(`height_meters`, real)\n(`nickname`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Person\"\nColumns:\n(\"name\", STRING, primary key)\n(\"birthdate\", STRING)\n(\"birth_name\", STRING)\n(\"birth_place\", STRING)\n(\"birth_region\", STRING)\n(\"birth_country\", STRING)\n(\"height_meters\", DOUBLE PRECISION)\n(\"nickname\", STRING)\n"
        ]
    },
    {
        "sql_id": 274,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.episode_id FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE SUBSTR(T1.air_date, 1, 4) = '2008' ORDER BY T2.votes DESC LIMIT 1;",
        "target_query": "SELECT \"T1\".\"episode_id\" FROM \"Episode\" AS \"T1\" INNER JOIN \"Vote\" AS \"T2\" ON \"T2\".\"episode_id\" = \"T1\".\"episode_id\" WHERE substring(\"T1\".\"air_date\" from 1 for 4) = '2008' ORDER BY \"T2\".\"votes\" DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 101,
                "end_index": 125,
                "dilatect_content": "SUBSTR(T1.air_date, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 141,
                "end_index": 183,
                "dilatect_content": "substring(\"T1\".\"air_date\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n",
            "Table: `Vote`\nColumns:\n(`episode_id`, text)\n(`stars`, integer)\n(`votes`, integer)\n(`percent`, real)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"Episode\"\nColumns:\n(\"episode_id\", STRING, primary key)\n(\"season\", BIGINT)\n(\"episode\", BIGINT)\n(\"number_in_series\", BIGINT)\n(\"title\", STRING)\n(\"summary\", STRING)\n(\"air_date\", STRING)\n(\"episode_image\", STRING)\n(\"rating\", DOUBLE PRECISION)\n(\"votes\", BIGINT)\n",
            "Table: \"Vote\"\nColumns:\n(\"episode_id\", STRING)\n(\"stars\", BIGINT)\n(\"votes\", BIGINT)\n(\"percent\", DOUBLE PRECISION)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 275,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.title FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE SUBSTR(T1.year, 1, 4) = '2010' AND T1.person = 'Joel H. Cohen';",
        "target_query": "SELECT \"T2\".\"title\" FROM \"Award\" AS \"T1\" INNER JOIN \"Episode\" AS \"T2\" ON \"T1\".\"episode_id\" = \"T2\".\"episode_id\" WHERE substring(CAST(\"T1\".\"_year\" AS STRING) from 1 for 4) = '2010' AND \"T1\".\"person\" = 'Joel H. Cohen';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 97,
                "end_index": 117,
                "dilatect_content": "SUBSTR(T1.year, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 137,
                "end_index": 192,
                "dilatect_content": "substring(CAST(\"T1\".\"_year\" AS STRING) from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, integer, primary key)\n(`organization`, text)\n(`year`, integer)\n(`award_category`, text)\n(`award`, text)\n(`person`, text)\n(`role`, text)\n(`episode_id`, text)\n(`season`, text)\n(`song`, text)\n(`result`, text)\n",
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"Award\"\nColumns:\n(\"award_id\", BIGINT, primary key)\n(\"organization\", STRING)\n(\"_year\", BIGINT)\n(\"award_category\", STRING)\n(\"award\", STRING)\n(\"person\", STRING)\n(\"role\", STRING)\n(\"episode_id\", STRING)\n(\"season\", STRING)\n(\"song\", STRING)\n(\"result\", STRING)\n",
            "Table: \"Episode\"\nColumns:\n(\"episode_id\", STRING, primary key)\n(\"season\", BIGINT)\n(\"episode\", BIGINT)\n(\"number_in_series\", BIGINT)\n(\"title\", STRING)\n(\"summary\", STRING)\n(\"air_date\", STRING)\n(\"episode_image\", STRING)\n(\"rating\", DOUBLE PRECISION)\n(\"votes\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 276,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(CASE WHEN birth_region = 'California' AND SUBSTR(birthdate, 1, 4) > '1970' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(birthdate) FROM Person;",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"birth_region\" = 'California' AND substring(\"birthdate\" from 1 for 4) > '1970' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"birthdate\") FROM \"Person\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 58,
                "end_index": 80,
                "dilatect_content": "SUBSTR(birthdate, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 62,
                "end_index": 98,
                "dilatect_content": "substring(\"birthdate\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`name`, text, primary key)\n(`birthdate`, text)\n(`birth_name`, text)\n(`birth_place`, text)\n(`birth_region`, text)\n(`birth_country`, text)\n(`height_meters`, real)\n(`nickname`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Person\"\nColumns:\n(\"name\", STRING, primary key)\n(\"birthdate\", STRING)\n(\"birth_name\", STRING)\n(\"birth_place\", STRING)\n(\"birth_region\", STRING)\n(\"birth_country\", STRING)\n(\"height_meters\", DOUBLE PRECISION)\n(\"nickname\", STRING)\n"
        ]
    },
    {
        "sql_id": 277,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(*) FROM Person AS T1 INNER JOIN Credit AS T2 ON T1.name = T2.person WHERE STRFTIME(T1.birthdate) > '1970' AND T2.role = 'animation executive producer';",
        "target_query": "SELECT COUNT(*) FROM \"Person\" AS \"T1\" INNER JOIN \"Credit\" AS \"T2\" ON \"T1\".\"name\" = \"T2\".\"person\" WHERE sys.timestamp_to_str(\"T1\".\"birthdate\", '%Y') > '1970' AND \"T2\".\"role\" = 'animation executive producer';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 87,
                "end_index": 108,
                "dilatect_content": "STRFTIME(T1.birthdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 119,
                "end_index": 166,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"birthdate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`name`, text, primary key)\n(`birthdate`, text)\n(`birth_name`, text)\n(`birth_place`, text)\n(`birth_region`, text)\n(`birth_country`, text)\n(`height_meters`, real)\n(`nickname`, text)\n",
            "Table: `Credit`\nColumns:\n(`episode_id`, text)\n(`category`, text)\n(`person`, text)\n(`role`, text)\n(`credited`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"Person\"\nColumns:\n(\"name\", STRING, primary key)\n(\"birthdate\", STRING)\n(\"birth_name\", STRING)\n(\"birth_place\", STRING)\n(\"birth_region\", STRING)\n(\"birth_country\", STRING)\n(\"height_meters\", DOUBLE PRECISION)\n(\"nickname\", STRING)\n",
            "Table: \"Credit\"\nColumns:\n(\"episode_id\", STRING)\n(\"category\", STRING)\n(\"person\", STRING)\n(\"role\", STRING)\n(\"credited\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 278,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.title FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE T1.award = 'Best International TV Series' AND SUBSTR(T1.year, 1, 4) = '2017';",
        "target_query": "SELECT \"T2\".\"title\" FROM \"Award\" AS \"T1\" INNER JOIN \"Episode\" AS \"T2\" ON \"T1\".\"episode_id\" = \"T2\".\"episode_id\" WHERE \"T1\".\"award\" = 'Best International TV Series' AND substring(\"T1\".\"_year\" from 1 for 4) = '2017';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 143,
                "end_index": 163,
                "dilatect_content": "SUBSTR(T1.year, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 191,
                "end_index": 230,
                "dilatect_content": "substring(\"T1\".\"_year\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, integer, primary key)\n(`organization`, text)\n(`year`, integer)\n(`award_category`, text)\n(`award`, text)\n(`person`, text)\n(`role`, text)\n(`episode_id`, text)\n(`season`, text)\n(`song`, text)\n(`result`, text)\n",
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"Award\"\nColumns:\n(\"award_id\", BIGINT, primary key)\n(\"organization\", STRING)\n(\"_year\", BIGINT)\n(\"award_category\", STRING)\n(\"award\", STRING)\n(\"person\", STRING)\n(\"role\", STRING)\n(\"episode_id\", STRING)\n(\"season\", STRING)\n(\"song\", STRING)\n(\"result\", STRING)\n",
            "Table: \"Episode\"\nColumns:\n(\"episode_id\", STRING, primary key)\n(\"season\", BIGINT)\n(\"episode\", BIGINT)\n(\"number_in_series\", BIGINT)\n(\"title\", STRING)\n(\"summary\", STRING)\n(\"air_date\", STRING)\n(\"episode_image\", STRING)\n(\"rating\", DOUBLE PRECISION)\n(\"votes\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 279,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(award_id) FROM Award WHERE SUBSTR(year, 1, 4) = '2009';",
        "target_query": "SELECT COUNT(\"award_id\") FROM \"Award\" WHERE substring(\"_year\" from 1 for 4) = '2009';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 40,
                "end_index": 57,
                "dilatect_content": "SUBSTR(year, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 48,
                "end_index": 80,
                "dilatect_content": "substring(\"_year\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, integer, primary key)\n(`organization`, text)\n(`year`, integer)\n(`award_category`, text)\n(`award`, text)\n(`person`, text)\n(`role`, text)\n(`episode_id`, text)\n(`season`, text)\n(`song`, text)\n(`result`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Award\"\nColumns:\n(\"award_id\", BIGINT, primary key)\n(\"organization\", STRING)\n(\"_year\", BIGINT)\n(\"award_category\", STRING)\n(\"award\", STRING)\n(\"person\", STRING)\n(\"role\", STRING)\n(\"episode_id\", STRING)\n(\"season\", STRING)\n(\"song\", STRING)\n(\"result\", STRING)\n"
        ]
    },
    {
        "sql_id": 280,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(DISTINCT T2.episode_id) FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE strftime('%Y', T1.air_date) = '2008' AND T2.stars > 5;",
        "target_query": "SELECT COUNT(DISTINCT \"T2\".\"episode_id\") FROM \"Episode\" AS \"T1\" INNER JOIN \"Vote\" AS \"T2\" ON \"T2\".\"episode_id\" = \"T1\".\"episode_id\" WHERE sys.timestamp_to_str(\"T1\".\"air_date\", '%Y') = '2008' AND \"T2\".\"stars\" > 5;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 117,
                "end_index": 143,
                "dilatect_content": "strftime('%Y', T1.air_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 157,
                "end_index": 203,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"air_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n",
            "Table: `Vote`\nColumns:\n(`episode_id`, text)\n(`stars`, integer)\n(`votes`, integer)\n(`percent`, real)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"Episode\"\nColumns:\n(\"episode_id\", STRING, primary key)\n(\"season\", BIGINT)\n(\"episode\", BIGINT)\n(\"number_in_series\", BIGINT)\n(\"title\", STRING)\n(\"summary\", STRING)\n(\"air_date\", STRING)\n(\"episode_image\", STRING)\n(\"rating\", DOUBLE PRECISION)\n(\"votes\", BIGINT)\n",
            "Table: \"Vote\"\nColumns:\n(\"episode_id\", STRING)\n(\"stars\", BIGINT)\n(\"votes\", BIGINT)\n(\"percent\", DOUBLE PRECISION)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 281,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.keyword FROM Episode AS T1 INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE SUBSTR(T1.air_date, 1, 4) = '2008';",
        "target_query": "SELECT \"T2\".\"keyword\" FROM \"Episode\" AS \"T1\" INNER JOIN \"Keyword\" AS \"T2\" ON \"T1\".\"episode_id\" = \"T2\".\"episode_id\" WHERE substring(\"T1\".\"air_date\" from 1 for 4) = '2008';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 101,
                "end_index": 125,
                "dilatect_content": "SUBSTR(T1.air_date, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 141,
                "end_index": 183,
                "dilatect_content": "substring(\"T1\".\"air_date\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n",
            "Table: `Keyword`\nColumns:\n(`episode_id`, text, primary key)\n(`keyword`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"Episode\"\nColumns:\n(\"episode_id\", STRING, primary key)\n(\"season\", BIGINT)\n(\"episode\", BIGINT)\n(\"number_in_series\", BIGINT)\n(\"title\", STRING)\n(\"summary\", STRING)\n(\"air_date\", STRING)\n(\"episode_image\", STRING)\n(\"rating\", DOUBLE PRECISION)\n(\"votes\", BIGINT)\n",
            "Table: \"Keyword\"\nColumns:\n(\"episode_id\", STRING, primary key)\n(\"keyword\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 282,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(DISTINCT T2.episode_id) FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE strftime('%Y', T1.air_date) = '2009' AND T2.stars < 8;",
        "target_query": "SELECT COUNT(DISTINCT \"T2\".\"episode_id\") FROM \"Episode\" AS \"T1\" INNER JOIN \"Vote\" AS \"T2\" ON \"T2\".\"episode_id\" = \"T1\".\"episode_id\" WHERE sys.timestamp_to_str(\"T1\".\"air_date\", '%Y') = '2009' AND \"T2\".\"stars\" < 8;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 117,
                "end_index": 143,
                "dilatect_content": "strftime('%Y', T1.air_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 157,
                "end_index": 203,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"air_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n",
            "Table: `Vote`\nColumns:\n(`episode_id`, text)\n(`stars`, integer)\n(`votes`, integer)\n(`percent`, real)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"Episode\"\nColumns:\n(\"episode_id\", STRING, primary key)\n(\"season\", BIGINT)\n(\"episode\", BIGINT)\n(\"number_in_series\", BIGINT)\n(\"title\", STRING)\n(\"summary\", STRING)\n(\"air_date\", STRING)\n(\"episode_image\", STRING)\n(\"rating\", DOUBLE PRECISION)\n(\"votes\", BIGINT)\n",
            "Table: \"Vote\"\nColumns:\n(\"episode_id\", STRING)\n(\"stars\", BIGINT)\n(\"votes\", BIGINT)\n(\"percent\", DOUBLE PRECISION)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 283,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(award_id) FROM Award WHERE SUBSTR(year, 1, 4) = '2009' AND result = 'Winner';",
        "target_query": "SELECT COUNT(\"award_id\") FROM \"Award\" WHERE substring(cast(\"_year\" as varchar) from 1 for 4) = '2009' AND \"result\" = 'Winner';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 40,
                "end_index": 57,
                "dilatect_content": "SUBSTR(year, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 48,
                "end_index": 97,
                "dilatect_content": "substring(cast(\"_year\" as varchar) from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, integer, primary key)\n(`organization`, text)\n(`year`, integer)\n(`award_category`, text)\n(`award`, text)\n(`person`, text)\n(`role`, text)\n(`episode_id`, text)\n(`season`, text)\n(`song`, text)\n(`result`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Award\"\nColumns:\n(\"award_id\", BIGINT, primary key)\n(\"organization\", STRING)\n(\"_year\", BIGINT)\n(\"award_category\", STRING)\n(\"award\", STRING)\n(\"person\", STRING)\n(\"role\", STRING)\n(\"episode_id\", STRING)\n(\"season\", STRING)\n(\"song\", STRING)\n(\"result\", STRING)\n"
        ]
    },
    {
        "sql_id": 284,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT T1.episode_id FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE SUBSTR(T1.air_date, 1, 4) = '2008' AND T2.stars < 5;",
        "target_query": "SELECT DISTINCT \"T1\".\"episode_id\" FROM \"Episode\" AS \"T1\" INNER JOIN \"Vote\" AS \"T2\" ON \"T2\".\"episode_id\" = \"T1\".\"episode_id\" WHERE substring(\"T1\".\"air_date\" from 1 for 4) = '2008' AND \"T2\".\"stars\" < 5;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 110,
                "end_index": 134,
                "dilatect_content": "SUBSTR(T1.air_date, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 150,
                "end_index": 192,
                "dilatect_content": "substring(\"T1\".\"air_date\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n",
            "Table: `Vote`\nColumns:\n(`episode_id`, text)\n(`stars`, integer)\n(`votes`, integer)\n(`percent`, real)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"Episode\"\nColumns:\n(\"episode_id\", STRING, primary key)\n(\"season\", BIGINT)\n(\"episode\", BIGINT)\n(\"number_in_series\", BIGINT)\n(\"title\", STRING)\n(\"summary\", STRING)\n(\"air_date\", STRING)\n(\"episode_image\", STRING)\n(\"rating\", DOUBLE PRECISION)\n(\"votes\", BIGINT)\n",
            "Table: \"Vote\"\nColumns:\n(\"episode_id\", STRING)\n(\"stars\", BIGINT)\n(\"votes\", BIGINT)\n(\"percent\", DOUBLE PRECISION)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 285,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.percent FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE SUBSTR(T1.air_date, 1, 4) = '2008' AND T1.votes BETWEEN 950 AND 960;",
        "target_query": "SELECT \"T2\".\"percent\" FROM \"Episode\" AS \"T1\" INNER JOIN \"Vote\" AS \"T2\" ON \"T2\".\"episode_id\" = \"T1\".\"episode_id\" WHERE substring(\"T1\".\"air_date\" from 1 for 4) = '2008' AND \"T1\".\"votes\" BETWEEN 950 AND 960;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 98,
                "end_index": 122,
                "dilatect_content": "SUBSTR(T1.air_date, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 138,
                "end_index": 180,
                "dilatect_content": "substring(\"T1\".\"air_date\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n",
            "Table: `Vote`\nColumns:\n(`episode_id`, text)\n(`stars`, integer)\n(`votes`, integer)\n(`percent`, real)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"Episode\"\nColumns:\n(\"episode_id\", STRING, primary key)\n(\"season\", BIGINT)\n(\"episode\", BIGINT)\n(\"number_in_series\", BIGINT)\n(\"title\", STRING)\n(\"summary\", STRING)\n(\"air_date\", STRING)\n(\"episode_image\", STRING)\n(\"rating\", DOUBLE PRECISION)\n(\"votes\", BIGINT)\n",
            "Table: \"Vote\"\nColumns:\n(\"episode_id\", STRING)\n(\"stars\", BIGINT)\n(\"votes\", BIGINT)\n(\"percent\", DOUBLE PRECISION)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 286,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.stars FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE SUBSTR(T1.air_date, 1, 7) = '2008-11';",
        "target_query": "SELECT \"T2\".\"stars\" FROM \"Episode\" AS \"T1\" INNER JOIN \"Vote\" AS \"T2\" ON \"T2\".\"episode_id\" = \"T1\".\"episode_id\" WHERE substring(\"T1\".\"air_date\" from 1 for 7) = '2008-11';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 96,
                "end_index": 120,
                "dilatect_content": "SUBSTR(T1.air_date, 1, 7)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 134,
                "end_index": 176,
                "dilatect_content": "substring(\"T1\".\"air_date\" from 1 for 7)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n",
            "Table: `Vote`\nColumns:\n(`episode_id`, text)\n(`stars`, integer)\n(`votes`, integer)\n(`percent`, real)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"Episode\"\nColumns:\n(\"episode_id\", STRING, primary key)\n(\"season\", BIGINT)\n(\"episode\", BIGINT)\n(\"number_in_series\", BIGINT)\n(\"title\", STRING)\n(\"summary\", STRING)\n(\"air_date\", STRING)\n(\"episode_image\", STRING)\n(\"rating\", DOUBLE PRECISION)\n(\"votes\", BIGINT)\n",
            "Table: \"Vote\"\nColumns:\n(\"episode_id\", STRING)\n(\"stars\", BIGINT)\n(\"votes\", BIGINT)\n(\"percent\", DOUBLE PRECISION)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 287,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(*) FROM Episode AS T1 INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE T2.credited = 'true' AND T2.person = 'Sam Im' AND SUBSTR(T1.air_date, 1, 4) = '2009' AND T2.role = 'additional timer';",
        "target_query": "SELECT COUNT(*) FROM \"Episode\" AS \"T1\" INNER JOIN \"Credit\" AS \"T2\" ON \"T1\".\"episode_id\" = \"T2\".\"episode_id\" WHERE \"T2\".\"credited\" = 'true' AND \"T2\".\"person\" = 'Sam Im' AND substring(\"T1\".\"air_date\" from 1 for 4) = '2009' AND \"T2\".\"role\" = 'additional timer';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 148,
                "end_index": 172,
                "dilatect_content": "SUBSTR(T1.air_date, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 196,
                "end_index": 238,
                "dilatect_content": "substring(\"T1\".\"air_date\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n",
            "Table: `Credit`\nColumns:\n(`episode_id`, text)\n(`category`, text)\n(`person`, text)\n(`role`, text)\n(`credited`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"Episode\"\nColumns:\n(\"episode_id\", STRING, primary key)\n(\"season\", BIGINT)\n(\"episode\", BIGINT)\n(\"number_in_series\", BIGINT)\n(\"title\", STRING)\n(\"summary\", STRING)\n(\"air_date\", STRING)\n(\"episode_image\", STRING)\n(\"rating\", DOUBLE PRECISION)\n(\"votes\", BIGINT)\n",
            "Table: \"Credit\"\nColumns:\n(\"episode_id\", STRING)\n(\"category\", STRING)\n(\"person\", STRING)\n(\"role\", STRING)\n(\"credited\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 288,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T1.bool = 'pos', 1, 0)) AS REAL) * 100 / SUM(IIF(T1.bool = 'neg', 1, 0)) FROM no_payment_due AS T1 INNER JOIN enlist AS T2 ON T1.`name` = T2.`name` WHERE T2.organ = 'foreign_legion'",
        "target_query": "SELECT CAST(SUM(CASE WHEN T1.\"bool\" = 'pos' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN T1.\"bool\" = 'neg' THEN 1 ELSE 0 END) FROM \"no_payment_due\" AS T1 INNER JOIN \"enlist\" AS T2 ON T1.\"name\" = T2.\"name\" WHERE T2.\"organ\" = 'foreign_legion'",
        "semantic_equivalent_type": "approximate_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 41,
                "dilatect_content": "IIF(T1.bool = 'pos', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 65,
                "end_index": 90,
                "dilatect_content": "IIF(T1.bool = 'neg', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 62,
                "dilatect_content": "CASE WHEN T1.\"bool\" = 'pos' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 86,
                "end_index": 132,
                "dilatect_content": "CASE WHEN T1.\"bool\" = 'neg' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `no_payment_due`\nColumns:\n(`name`, text, primary key)\n(`bool`, text)\n",
            "Table: `enlist`\nColumns:\n(`name`, text)\n(`organ`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"no_payment_due\"\nColumns:\n(\"name\", STRING, primary key)\n(\"bool\", STRING)\n",
            "Table: \"enlist\"\nColumns:\n(\"name\", STRING)\n(\"organ\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 289,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T1.school = 'occ', 1.0, 0)) AS REAL) * 100 / COUNT(T1.name) FROM enrolled AS T1 INNER JOIN enlist AS T2 ON T1.`name` = T2.`name` WHERE T2.organ = 'navy'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T1\".\"school\" = 'occ' THEN 1.0 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"name\") FROM \"enrolled\" AS \"T1\" INNER JOIN \"enlist\" AS \"T2\" ON \"T1\".\"name\" = \"T2\".\"name\" WHERE \"T2\".\"organ\" = 'navy';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 45,
                "dilatect_content": "IIF(T1.school = 'occ', 1.0, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 70,
                "dilatect_content": "CASE WHEN \"T1\".\"school\" = 'occ' THEN 1.0 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `enrolled`\nColumns:\n(`name`, text, primary key)\n(`school`, text, primary key)\n(`month`, integer)\n",
            "Table: `enlist`\nColumns:\n(`name`, text)\n(`organ`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"enrolled\"\nColumns:\n(\"name\", STRING, primary key)\n(\"school\", STRING, primary key)\n(\"_month\", BIGINT)\n",
            "Table: \"enlist\"\nColumns:\n(\"name\", STRING)\n(\"organ\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 290,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT IIF(T2.name IS NULL, 'female', 'male') FROM male AS T1 LEFT JOIN disabled AS T2 ON T1.name = T2.name WHERE T1.name = 'student124'",
        "target_query": "SELECT CASE WHEN \"T2\".\"name\" IS NULL THEN 'female' ELSE 'male' END FROM \"male\" AS \"T1\" LEFT JOIN \"disabled\" AS \"T2\" ON \"T1\".\"name\" = \"T2\".\"name\" WHERE \"T1\".\"name\" = 'student124';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 44,
                "dilatect_content": "IIF(T2.name IS NULL, 'female', 'male')",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 69,
                "dilatect_content": "CASE WHEN \"T2\".\"name\" IS NULL THEN 'female' ELSE 'male' END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `male`\nColumns:\n(`name`, text, primary key)\n",
            "Table: `disabled`\nColumns:\n(`name`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"male\"\nColumns:\n(\"name\", STRING, primary key)\n",
            "Table: \"disabled\"\nColumns:\n(\"name\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 291,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.name IS NULL, 1, 0)) AS REAL) * 100 / COUNT(T2.name) FROM disabled AS T1 LEFT JOIN male AS T2 ON T1.`name` = T2.`name`",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"name\" IS NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T2\".\"name\") FROM \"disabled\" AS \"T1\" LEFT JOIN \"male\" AS \"T2\" ON \"T1\".\"name\" = \"T2\".\"name\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 41,
                "dilatect_content": "IIF(T2.name IS NULL, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 66,
                "dilatect_content": "CASE WHEN \"T2\".\"name\" IS NULL THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `disabled`\nColumns:\n(`name`, text, primary key)\n",
            "Table: `male`\nColumns:\n(`name`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"disabled\"\nColumns:\n(\"name\", STRING, primary key)\n",
            "Table: \"male\"\nColumns:\n(\"name\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 292,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T1.month > 5, 1, 0)) AS REAL) * 100 / COUNT(T1.month) FROM longest_absense_from_school AS T1 INNER JOIN unemployed AS T2 ON T1.name = T2.name",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T1\".\"_month\" > 5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"_month\") FROM \"longest_absense_from_school\" AS \"T1\" INNER JOIN \"unemployed\" AS \"T2\" ON \"T1\".\"name\" = \"T2\".\"name\"",
        "semantic_equivalent_type": "approximate_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 38,
                "dilatect_content": "IIF(T1.month > 5, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 64,
                "dilatect_content": "CASE WHEN \"T1\".\"_month\" > 5 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `longest_absense_from_school`\nColumns:\n(`name`, text, primary key)\n(`month`, integer)\n",
            "Table: `unemployed`\nColumns:\n(`name`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"longest_absense_from_school\"\nColumns:\n(\"name\", STRING, primary key)\n(\"_month\", BIGINT)\n",
            "Table: \"unemployed\"\nColumns:\n(\"name\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 293,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT IIF(T.result = 0, 'female', 'male') AS re FROM ( SELECT COUNT(name) AS result FROM male WHERE name = 'studenT1000' ) T",
        "target_query": "SELECT CASE WHEN T.result = 0 THEN 'female' ELSE 'male' END AS re FROM ( SELECT COUNT(\"name\") AS result FROM \"male\" WHERE \"name\" = 'studenT1000' ) T;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 41,
                "dilatect_content": "IIF(T.result = 0, 'female', 'male')",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 58,
                "dilatect_content": "CASE WHEN T.result = 0 THEN 'female' ELSE 'male' END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `male`\nColumns:\n(`name`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"male\"\nColumns:\n(\"name\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 294,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T3.name IS NULL, 1, 0)) AS REAL) / COUNT(T1.name) FROM disabled AS T1 INNER JOIN enlist AS T2 ON T1.name = T2.name LEFT JOIN male AS T3 ON T2.name = T3.name WHERE T2.organ = 'foreign_legion'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T3\".\"name\" IS NULL THEN 1 ELSE 0 END) AS REAL) / COUNT(\"T1\".\"name\") FROM \"disabled\" AS \"T1\" INNER JOIN \"enlist\" AS \"T2\" ON \"T1\".\"name\" = \"T2\".\"name\" LEFT JOIN \"male\" AS \"T3\" ON \"T2\".\"name\" = \"T3\".\"name\" WHERE \"T2\".\"organ\" = 'foreign_legion';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 41,
                "dilatect_content": "IIF(T3.name IS NULL, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 66,
                "dilatect_content": "CASE WHEN \"T3\".\"name\" IS NULL THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `disabled`\nColumns:\n(`name`, text, primary key)\n",
            "Table: `enlist`\nColumns:\n(`name`, text)\n(`organ`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `male`\nColumns:\n(`name`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"disabled\"\nColumns:\n(\"name\", STRING, primary key)\n",
            "Table: \"enlist\"\nColumns:\n(\"name\", STRING)\n(\"organ\", STRING)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"male\"\nColumns:\n(\"name\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 295,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.name IS NULL, 1, 0)) AS REAL) * 100 / COUNT(T1.name), CAST(SUM(IIF(T2.name IS NOT NULL, 1, 0)) AS REAL) * 100 / COUNT(T1.name) FROM enlist AS T1 LEFT JOIN male AS T2 ON T2.name = T1.name WHERE T1.organ = 'fire_department'",
        "target_query": "SELECT CAST(SUM(CASE WHEN T2.name IS NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.name), CAST(SUM(CASE WHEN T2.name IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.name) FROM \"enlist\" AS T1 LEFT JOIN \"male\" AS T2 ON T2.name = T1.name WHERE T1.organ = 'fire_department'",
        "semantic_equivalent_type": "approximate_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 41,
                "dilatect_content": "IIF(T2.name IS NULL, 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 86,
                "end_index": 115,
                "dilatect_content": "IIF(T2.name IS NOT NULL, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 58,
                "dilatect_content": "CASE WHEN T2.name IS NULL THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 103,
                "end_index": 149,
                "dilatect_content": "CASE WHEN T2.name IS NOT NULL THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `enlist`\nColumns:\n(`name`, text)\n(`organ`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `male`\nColumns:\n(`name`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"enlist\"\nColumns:\n(\"name\", STRING)\n(\"organ\", STRING)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"male\"\nColumns:\n(\"name\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 296,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(month = 0, 1, 0)) AS REAL) * 100 / COUNT(name) FROM longest_absense_from_school",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"_month\" = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"name\") FROM \"longest_absense_from_school\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 35,
                "dilatect_content": "IIF(month = 0, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 57,
                "dilatect_content": "CASE WHEN \"_month\" = 0 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `longest_absense_from_school`\nColumns:\n(`name`, text, primary key)\n(`month`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"longest_absense_from_school\"\nColumns:\n(\"name\", STRING, primary key)\n(\"_month\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 297,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(`bool` = 'pos', 1, 0)) AS REAL) / SUM(IIF(`bool` = 'neg', 1, 0)) FROM no_payment_due",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"bool\" = 'pos' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN \"bool\" = 'neg' THEN 1 ELSE 0 END) FROM \"no_payment_due\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 40,
                "dilatect_content": "IIF(`bool` = 'pos', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 58,
                "end_index": 82,
                "dilatect_content": "IIF(`bool` = 'neg', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 59,
                "dilatect_content": "CASE WHEN \"bool\" = 'pos' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 77,
                "end_index": 120,
                "dilatect_content": "CASE WHEN \"bool\" = 'neg' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `no_payment_due`\nColumns:\n(`name`, text, primary key)\n(`bool`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"no_payment_due\"\nColumns:\n(\"name\", STRING, primary key)\n(\"bool\", STRING)\n"
        ]
    },
    {
        "sql_id": 298,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT IIF(T2.name IS NULL, 'female', 'male') AS gen , T1.school FROM enrolled AS T1 LEFT JOIN male AS T2 ON T2.name = T1.name WHERE T1.name = 'student995'",
        "target_query": "SELECT CASE WHEN T2.\"name\" IS NULL THEN 'female' ELSE 'male' END AS \"gen\", T1.\"school\" FROM \"enrolled\" AS T1 LEFT JOIN \"male\" AS T2 ON T2.\"name\" = T1.\"name\" WHERE T1.\"name\" = 'student995';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 44,
                "dilatect_content": "IIF(T2.name IS NULL, 'female', 'male')",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 65,
                "dilatect_content": "CASE WHEN T2.\"name\" IS NULL THEN 'female' ELSE 'male' END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `enrolled`\nColumns:\n(`name`, text, primary key)\n(`school`, text, primary key)\n(`month`, integer)\n",
            "Table: `male`\nColumns:\n(`name`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"enrolled\"\nColumns:\n(\"name\", STRING, primary key)\n(\"school\", STRING, primary key)\n(\"_month\", BIGINT)\n",
            "Table: \"male\"\nColumns:\n(\"name\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 299,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.name IS NULL, 1, 0)) AS REAL) * 100 / COUNT(T1.name) FROM person AS T1 LEFT JOIN male AS T2 ON T2.name = T1.name",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"name\" IS NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"name\") FROM \"person\" AS \"T1\" LEFT JOIN \"male\" AS \"T2\" ON \"T2\".\"name\" = \"T1\".\"name\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 41,
                "dilatect_content": "IIF(T2.name IS NULL, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 66,
                "dilatect_content": "CASE WHEN \"T2\".\"name\" IS NULL THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `person`\nColumns:\n(`name`, text, primary key)\n",
            "Table: `male`\nColumns:\n(`name`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"person\"\nColumns:\n(\"name\", STRING, primary key)\n",
            "Table: \"male\"\nColumns:\n(\"name\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 300,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT IIF(T2.name IS NULL, 'female', 'male') AS gender FROM enlist AS T1 LEFT JOIN male AS T2 ON T2.name = T1.name GROUP BY T1.organ",
        "target_query": "SELECT CASE WHEN T2.\"name\" IS NULL THEN 'female' ELSE 'male' END AS \"gender\" FROM \"enlist\" AS T1 LEFT JOIN \"male\" AS T2 ON T2.\"name\" = T1.\"name\" GROUP BY T1.\"organ\", T2.\"name\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 44,
                "dilatect_content": "IIF(T2.name IS NULL, 'female', 'male')",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 65,
                "dilatect_content": "CASE WHEN T2.\"name\" IS NULL THEN 'female' ELSE 'male' END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `enlist`\nColumns:\n(`name`, text)\n(`organ`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `male`\nColumns:\n(`name`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"enlist\"\nColumns:\n(\"name\", STRING)\n(\"organ\", STRING)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"male\"\nColumns:\n(\"name\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 301,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(((SUM(IIF(month = 0, 1, 0)) - SUM(IIF(month = 9, 1, 0)))) AS REAL) * 100 / SUM(IIF(month = 0, 1, 0)) FROM longest_absense_from_school",
        "target_query": "SELECT CAST((SUM(CASE WHEN \"_month\" = 0 THEN 1 ELSE 0 END) - SUM(CASE WHEN \"_month\" = 9 THEN 1 ELSE 0 END)) AS REAL) * 100 / SUM(CASE WHEN \"_month\" = 0 THEN 1 ELSE 0 END) FROM \"longest_absense_from_school\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 18,
                "end_index": 37,
                "dilatect_content": "IIF(month = 0, 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 46,
                "end_index": 65,
                "dilatect_content": "IIF(month = 9, 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 91,
                "end_index": 110,
                "dilatect_content": "IIF(month = 0, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 17,
                "end_index": 58,
                "dilatect_content": "CASE WHEN \"_month\" = 0 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 67,
                "end_index": 108,
                "dilatect_content": "CASE WHEN \"_month\" = 9 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 133,
                "end_index": 174,
                "dilatect_content": "CASE WHEN \"_month\" = 0 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `longest_absense_from_school`\nColumns:\n(`name`, text, primary key)\n(`month`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"longest_absense_from_school\"\nColumns:\n(\"name\", STRING, primary key)\n(\"_month\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 302,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T2.name) - SUM(IIF(T2.name IS NULL, 1, 0)) AS num FROM filed_for_bankrupcy AS T1 LEFT JOIN male AS T2 ON T2.name = T1.name",
        "target_query": "SELECT COUNT(\"T2\".\"name\") - SUM(CASE WHEN \"T2\".\"name\" IS NULL THEN 1 ELSE 0 END) AS \"num\" FROM \"filed_for_bankrupcy\" AS \"T1\" LEFT JOIN \"male\" AS \"T2\" ON \"T2\".\"name\" = \"T1\".\"name\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 28,
                "end_index": 53,
                "dilatect_content": "IIF(T2.name IS NULL, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 36,
                "end_index": 86,
                "dilatect_content": "CASE WHEN \"T2\".\"name\" IS NULL THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `filed_for_bankrupcy`\nColumns:\n(`name`, text, primary key)\n",
            "Table: `male`\nColumns:\n(`name`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"filed_for_bankrupcy\"\nColumns:\n(\"name\", STRING, primary key)\n",
            "Table: \"male\"\nColumns:\n(\"name\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 303,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST((SUM(IIF(T2.name IS NOT NULL AND T1.month = 0, 1, 0)) - SUM(IIF(T2.name IS NULL AND T1.month = 0, 1, 0))) AS REAL) * 100 / COUNT(T1.name), IIF(SUM(IIF(T2.name IS NOT NULL AND T1.month = 0, 1, 0)) - SUM(IIF(T2.name IS NULL AND T1.month = 0, 1, 0)) > 0, 'YES', 'NO') AS isHigh FROM longest_absense_from_school AS T1 LEFT JOIN disabled AS T2 ON T2.name = T1.name",
        "target_query": "SELECT CAST((SUM(CASE WHEN T2.\"name\" IS NOT NULL AND T1.\"_month\" = 0 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.\"name\" IS NULL AND T1.\"_month\" = 0 THEN 1 ELSE 0 END)) AS REAL) * 100 / COUNT(T1.\"name\"), CASE WHEN SUM(CASE WHEN T2.\"name\" IS NOT NULL AND T1.\"_month\" = 0 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.\"name\" IS NULL AND T1.\"_month\" = 0 THEN 1 ELSE 0 END) > 0 THEN 'YES' ELSE 'NO' END AS \"isHigh\" FROM \"longest_absense_from_school\" AS T1 LEFT JOIN \"disabled\" AS T2 ON T2.\"name\" = T1.\"name\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 17,
                "end_index": 63,
                "dilatect_content": "IIF(T2.name IS NOT NULL AND T1.month = 0, 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 72,
                "end_index": 114,
                "dilatect_content": "IIF(T2.name IS NULL AND T1.month = 0, 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 151,
                "end_index": 275,
                "dilatect_content": "IIF(SUM(IIF(T2.name IS NOT NULL AND T1.month = 0, 1, 0)) - SUM(IIF(T2.name IS NULL AND T1.month = 0, 1, 0)) > 0, 'YES', 'NO')",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 159,
                "end_index": 205,
                "dilatect_content": "IIF(T2.name IS NOT NULL AND T1.month = 0, 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 214,
                "end_index": 256,
                "dilatect_content": "IIF(T2.name IS NULL AND T1.month = 0, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 17,
                "end_index": 89,
                "dilatect_content": "CASE WHEN T2.\"name\" IS NOT NULL AND T1.\"_month\" = 0 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 98,
                "end_index": 166,
                "dilatect_content": "CASE WHEN T2.\"name\" IS NULL AND T1.\"_month\" = 0 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 207,
                "end_index": 400,
                "dilatect_content": "CASE WHEN SUM(CASE WHEN T2.\"name\" IS NOT NULL AND T1.\"_month\" = 0 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.\"name\" IS NULL AND T1.\"_month\" = 0 THEN 1 ELSE 0 END) > 0 THEN 'YES' ELSE 'NO' END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 221,
                "end_index": 293,
                "dilatect_content": "CASE WHEN T2.\"name\" IS NOT NULL AND T1.\"_month\" = 0 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 302,
                "end_index": 370,
                "dilatect_content": "CASE WHEN T2.\"name\" IS NULL AND T1.\"_month\" = 0 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `longest_absense_from_school`\nColumns:\n(`name`, text, primary key)\n(`month`, integer)\n",
            "Table: `disabled`\nColumns:\n(`name`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"longest_absense_from_school\"\nColumns:\n(\"name\", STRING, primary key)\n(\"_month\", BIGINT)\n",
            "Table: \"disabled\"\nColumns:\n(\"name\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 304,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.month = 0, 1, 0)) AS REAL) * 100 / COUNT(T1.name) FROM unemployed AS T1 INNER JOIN longest_absense_from_school AS T2 ON T2.name = T1.name",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"_month\" = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"name\") FROM \"unemployed\" AS \"T1\" INNER JOIN \"longest_absense_from_school\" AS \"T2\" ON \"T2\".\"name\" = \"T1\".\"name\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 38,
                "dilatect_content": "IIF(T2.month = 0, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 64,
                "dilatect_content": "CASE WHEN \"T2\".\"_month\" = 0 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `unemployed`\nColumns:\n(`name`, text, primary key)\n",
            "Table: `longest_absense_from_school`\nColumns:\n(`name`, text, primary key)\n(`month`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"unemployed\"\nColumns:\n(\"name\", STRING, primary key)\n",
            "Table: \"longest_absense_from_school\"\nColumns:\n(\"name\", STRING, primary key)\n(\"_month\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 305,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT 100 * SUM(IIF(T2.month = 0, 1, 0)) AS num FROM disabled AS T1 INNER JOIN longest_absense_from_school AS T2 ON T1.name = T2.name",
        "target_query": "SELECT 100 * SUM(CASE WHEN T2.\"_month\" = 0 THEN 1 ELSE 0 END) AS \"num\" FROM \"disabled\" AS T1 INNER JOIN \"longest_absense_from_school\" AS T2 ON T1.\"name\" = T2.\"name\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 17,
                "end_index": 39,
                "dilatect_content": "IIF(T2.month = 0, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 17,
                "end_index": 61,
                "dilatect_content": "CASE WHEN T2.\"_month\" = 0 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `disabled`\nColumns:\n(`name`, text, primary key)\n",
            "Table: `longest_absense_from_school`\nColumns:\n(`name`, text, primary key)\n(`month`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"disabled\"\nColumns:\n(\"name\", STRING, primary key)\n",
            "Table: \"longest_absense_from_school\"\nColumns:\n(\"name\", STRING, primary key)\n(\"_month\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 306,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.school , IIF(T3.name IS NULL, 'female', 'male') AS gender FROM enrolled AS T1 INNER JOIN person AS T2 ON T1.name = T2.name LEFT JOIN male AS T3 ON T2.name = T3.name WHERE T2.name = 'student34'",
        "target_query": "SELECT \"T1\".\"school\", CASE WHEN \"T3\".\"name\" IS NULL THEN 'female' ELSE 'male' END AS \"gender\" FROM \"enrolled\" AS \"T1\" INNER JOIN \"person\" AS \"T2\" ON \"T1\".\"name\" = \"T2\".\"name\" LEFT JOIN \"male\" AS \"T3\" ON \"T2\".\"name\" = \"T3\".\"name\" WHERE \"T2\".\"name\" = 'student34';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 19,
                "end_index": 56,
                "dilatect_content": "IIF(T3.name IS NULL, 'female', 'male')",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 26,
                "end_index": 88,
                "dilatect_content": "CASE WHEN \"T3\".\"name\" IS NULL THEN 'female' ELSE 'male' END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `enrolled`\nColumns:\n(`name`, text, primary key)\n(`school`, text, primary key)\n(`month`, integer)\n",
            "Table: `person`\nColumns:\n(`name`, text, primary key)\n",
            "Table: `male`\nColumns:\n(`name`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"enrolled\"\nColumns:\n(\"name\", STRING, primary key)\n(\"school\", STRING, primary key)\n(\"_month\", BIGINT)\n",
            "Table: \"person\"\nColumns:\n(\"name\", STRING, primary key)\n",
            "Table: \"male\"\nColumns:\n(\"name\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 308,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(T3.name IS NULL, 1, 0)) AS \"result\" FROM enlist AS T1 INNER JOIN person AS T2 ON T1.name = T2.name LEFT JOIN male AS T3 ON T2.name = T3.name WHERE T1.organ = 'army'",
        "target_query": "SELECT SUM(CASE WHEN \"T3\".\"name\" IS NULL THEN 1 ELSE 0 END) AS \"result\" FROM \"enlist\" AS \"T1\" INNER JOIN \"person\" AS \"T2\" ON \"T1\".\"name\" = \"T2\".\"name\" LEFT JOIN \"male\" AS \"T3\" ON \"T2\".\"name\" = \"T3\".\"name\" WHERE \"T1\".\"organ\" = 'army';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 36,
                "dilatect_content": "IIF(T3.name IS NULL, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 61,
                "dilatect_content": "CASE WHEN \"T3\".\"name\" IS NULL THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `enlist`\nColumns:\n(`name`, text)\n(`organ`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `person`\nColumns:\n(`name`, text, primary key)\n",
            "Table: `male`\nColumns:\n(`name`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"enlist\"\nColumns:\n(\"name\", STRING)\n(\"organ\", STRING)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"person\"\nColumns:\n(\"name\", STRING, primary key)\n",
            "Table: \"male\"\nColumns:\n(\"name\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 309,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(movie_title) FROM characters AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE SUBSTR(release_date, INSTR(release_date, '-') + 1, 3) = 'Dec' AND T2.director = 'Wolfgang Reitherman'",
        "target_query": "SELECT COUNT(\"movie_title\") FROM \"characters\" AS \"T1\" INNER JOIN \"director\" AS \"T2\" ON \"T1\".\"movie_title\" = \"T2\".\"name\" WHERE substring(\"release_date\" from POSITION('-' IN \"release_date\") + 1 for 3) = 'Dec' AND \"T2\".\"director\" = 'Wolfgang Reitherman';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 108,
                "end_index": 160,
                "dilatect_content": "SUBSTR(release_date, INSTR(release_date, '-') + 1, 3)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 129,
                "end_index": 152,
                "dilatect_content": "INSTR(release_date, '-')",
                "feature": "instr(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 144,
                "end_index": 219,
                "dilatect_content": "substring(\"release_date\" from POSITION('-' IN \"release_date\") + 1 for 3)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 176,
                "end_index": 208,
                "dilatect_content": "POSITION('-' IN \"release_date\")",
                "feature": "POSITION(Y IN X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "instr(X,Y)",
                "explanation": "The instr(X,Y) function finds the first occurrence of string Y within \n  string X and returns the number of prior characters plus 1, or 0 if\n  Y is nowhere found within X.\n  Or, if X and Y are both BLOBs, then instr(X,Y) returns one\n  more than the number bytes prior to the first occurrence of Y, or 0 if\n  Y does not occur anywhere within X.\n  If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs\n  then both are interpreted as strings.\n  If either X or Y are NULL in instr(X,Y) then the result is NULL.\n",
                "examples": [
                    "SELECT instr('Hello World', 'World'); -- Returns 7",
                    "SELECT instr('abcdefg', 'x'); -- Returns 0 (not found)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            },
            {
                "feature": "POSITION(Y IN X)",
                "explanation": "In MonetDB, the POSITION function is used to find the first occurrence of string Y within string X and returns the number of characters from the beginning of X to the start of Y. If Y is not found within X, it returns 0.",
                "examples": [
                    "SELECT POSITION('World' IN 'Hello World'); -- Returns 7",
                    "SELECT POSITION('x' IN 'abcdefg'); -- Returns 0 (not found)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `characters`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text)\n(`hero`, text)\n(`villian`, text)\n(`song`, text)\n",
            "Table: `director`\nColumns:\n(`name`, text, primary key)\n(`director`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"characters\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING)\n(\"hero\", STRING)\n(\"villian\", STRING)\n(\"song\", STRING)\n",
            "Table: \"director\"\nColumns:\n(\"name\", STRING, primary key)\n(\"director\", STRING)\n"
        ]
    },
    {
        "sql_id": 311,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.song FROM movies_total_gross AS T1 INNER JOIN characters AS T2 ON T1.movie_title = T2.movie_title WHERE CAST(SUBSTR(T1.release_date, INSTR(T1.release_date, ', ') + 1) AS int) BETWEEN 1970 AND 1979 ORDER BY CAST(REPLACE(SUBSTR(T1.total_gross, 2), ',', '') AS float) DESC LIMIT 1",
        "target_query": "SELECT \"T2\".\"song\" FROM \"movies_total_gross\" AS \"T1\" INNER JOIN \"characters\" AS \"T2\" ON \"T1\".\"movie_title\" = \"T2\".\"movie_title\" WHERE CAST(substring(\"T1\".\"release_date\" from POSITION(', ' IN \"T1\".\"release_date\") + 2 for 4) AS int) BETWEEN 1970 AND 1979 ORDER BY CAST(REPLACE(substring(\"T1\".\"total_gross\" from 2 for char_length(\"T1\".\"total_gross\") - 1), ',', '') AS float) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 119,
                "end_index": 175,
                "dilatect_content": "SUBSTR(T1.release_date, INSTR(T1.release_date, ', ') + 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 143,
                "end_index": 170,
                "dilatect_content": "INSTR(T1.release_date, ', ')",
                "feature": "instr(X,Y)"
            },
            {
                "start_index": 229,
                "end_index": 253,
                "dilatect_content": "SUBSTR(T1.total_gross, 2)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 159,
                "end_index": 249,
                "dilatect_content": "substring(\"T1\".\"release_date\" from POSITION(', ' IN \"T1\".\"release_date\") + 2 for 4)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 198,
                "end_index": 238,
                "dilatect_content": "POSITION(', ' IN \"T1\".\"release_date\")",
                "feature": "POSITION(Y IN X)"
            },
            {
                "start_index": 306,
                "end_index": 384,
                "dilatect_content": "substring(\"T1\".\"total_gross\" from 2 for char_length(\"T1\".\"total_gross\")",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "instr(X,Y)",
                "explanation": "The instr(X,Y) function finds the first occurrence of string Y within \n  string X and returns the number of prior characters plus 1, or 0 if\n  Y is nowhere found within X.\n  Or, if X and Y are both BLOBs, then instr(X,Y) returns one\n  more than the number bytes prior to the first occurrence of Y, or 0 if\n  Y does not occur anywhere within X.\n  If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs\n  then both are interpreted as strings.\n  If either X or Y are NULL in instr(X,Y) then the result is NULL.\n",
                "examples": [
                    "SELECT instr('Hello World', 'World'); -- Returns 7",
                    "SELECT instr('abcdefg', 'x'); -- Returns 0 (not found)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            },
            {
                "feature": "POSITION(Y IN X)",
                "explanation": "In MonetDB, the POSITION function is used to find the first occurrence of string Y within string X and returns the number of characters from the beginning of X to the start of Y. If Y is not found within X, it returns 0.",
                "examples": [
                    "SELECT POSITION('World' IN 'Hello World'); -- Returns 7",
                    "SELECT POSITION('x' IN 'abcdefg'); -- Returns 0 (not found)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n",
            "Table: `characters`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text)\n(`hero`, text)\n(`villian`, text)\n(`song`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"movies_total_gross\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING, primary key)\n(\"genre\", STRING)\n(\"MPAA_rating\", STRING)\n(\"total_gross\", STRING)\n(\"inflation_adjusted_gross\", STRING)\n",
            "Table: \"characters\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING)\n(\"hero\", STRING)\n(\"villian\", STRING)\n(\"song\", STRING)\n"
        ]
    },
    {
        "sql_id": 312,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.movie_title FROM movies_total_gross AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE T2.director = 'Wolfgang Reitherman' ORDER BY CAST(REPLACE(SUBSTR(inflation_adjusted_gross, 2), ',', '') AS REAL) DESC LIMIT 1",
        "target_query": "SELECT \"T1\".\"movie_title\" FROM \"movies_total_gross\" AS \"T1\" INNER JOIN \"director\" AS \"T2\" ON \"T1\".\"movie_title\" = \"T2\".\"name\" WHERE \"T2\".\"director\" = 'Wolfgang Reitherman' ORDER BY CAST(REPLACE(substring(\"inflation_adjusted_gross\" from 2 for char_length(\"inflation_adjusted_gross\") - 1), ',', '') AS REAL) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 170,
                "end_index": 204,
                "dilatect_content": "SUBSTR(inflation_adjusted_gross, 2)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 218,
                "end_index": 313,
                "dilatect_content": "substring(\"inflation_adjusted_gross\" from 2 for char_length(\"inflation_adjusted_gross\") - 1)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n",
            "Table: `director`\nColumns:\n(`name`, text, primary key)\n(`director`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"movies_total_gross\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING, primary key)\n(\"genre\", STRING)\n(\"MPAA_rating\", STRING)\n(\"total_gross\", STRING)\n(\"inflation_adjusted_gross\", STRING)\n",
            "Table: \"director\"\nColumns:\n(\"name\", STRING, primary key)\n(\"director\", STRING)\n"
        ]
    },
    {
        "sql_id": 313,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.movie_title FROM movies_total_gross AS T1 INNER JOIN characters AS T2 ON T1.movie_title = T2.movie_title WHERE T2.hero = 'Donald Duck' ORDER BY CAST(REPLACE(SUBSTR(total_gross, 2), ',', '') AS REAL) DESC LIMIT 1",
        "target_query": "SELECT \"T1\".\"movie_title\" FROM \"movies_total_gross\" AS \"T1\" INNER JOIN \"characters\" AS \"T2\" ON \"T1\".\"movie_title\" = \"T2\".\"movie_title\" WHERE \"T2\".\"hero\" = 'Donald Duck' ORDER BY CAST(REPLACE(substring(\"T1\".\"total_gross\" from 2 for char_length(\"T1\".\"total_gross\") - 1), ',', '') AS REAL) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 167,
                "end_index": 188,
                "dilatect_content": "SUBSTR(total_gross, 2)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 215,
                "end_index": 298,
                "dilatect_content": "substring(\"T1\".\"total_gross\" from 2 for char_length(\"T1\".\"total_gross\") - 1)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n",
            "Table: `characters`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text)\n(`hero`, text)\n(`villian`, text)\n(`song`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"movies_total_gross\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING, primary key)\n(\"genre\", STRING)\n(\"MPAA_rating\", STRING)\n(\"total_gross\", STRING)\n(\"inflation_adjusted_gross\", STRING)\n",
            "Table: \"characters\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING)\n(\"hero\", STRING)\n(\"villian\", STRING)\n(\"song\", STRING)\n"
        ]
    },
    {
        "sql_id": 314,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(movie_title) FROM movies_total_gross WHERE MPAA_rating = 'R' AND genre = 'Horror' AND CAST(SUBSTR(release_date, INSTR(release_date, ', ') + 1) AS int) BETWEEN 1990 AND 2015",
        "target_query": "SELECT COUNT(\"movie_title\") FROM \"movies_total_gross\" WHERE \"MPAA_rating\" = 'R' AND \"genre\" = 'Horror' AND CAST(substring(\"release_date\" from POSITION(', ' IN \"release_date\") + 1) AS int) BETWEEN 1990 AND 2015;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 104,
                "end_index": 154,
                "dilatect_content": "SUBSTR(release_date, INSTR(release_date, ', ') + 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 125,
                "end_index": 149,
                "dilatect_content": "INSTR(release_date, ', ')",
                "feature": "instr(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 120,
                "end_index": 190,
                "dilatect_content": "substring(\"release_date\" from POSITION(', ' IN \"release_date\") + 1)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 152,
                "end_index": 176,
                "dilatect_content": "INSTR(release_date, ', ')",
                "feature": "POSITION(Y IN X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "instr(X,Y)",
                "explanation": "The instr(X,Y) function finds the first occurrence of string Y within \n  string X and returns the number of prior characters plus 1, or 0 if\n  Y is nowhere found within X.\n  Or, if X and Y are both BLOBs, then instr(X,Y) returns one\n  more than the number bytes prior to the first occurrence of Y, or 0 if\n  Y does not occur anywhere within X.\n  If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs\n  then both are interpreted as strings.\n  If either X or Y are NULL in instr(X,Y) then the result is NULL.\n",
                "examples": [
                    "SELECT instr('Hello World', 'World'); -- Returns 7",
                    "SELECT instr('abcdefg', 'x'); -- Returns 0 (not found)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            },
            {
                "feature": "POSITION(Y IN X)",
                "explanation": "In MonetDB, the POSITION function is used to find the first occurrence of string Y within string X and returns the number of characters from the beginning of X to the start of Y. If Y is not found within X, it returns 0.",
                "examples": [
                    "SELECT POSITION('World' IN 'Hello World'); -- Returns 7",
                    "SELECT POSITION('x' IN 'abcdefg'); -- Returns 0 (not found)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"movies_total_gross\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING, primary key)\n(\"genre\", STRING)\n(\"MPAA_rating\", STRING)\n(\"total_gross\", STRING)\n(\"inflation_adjusted_gross\", STRING)\n"
        ]
    },
    {
        "sql_id": 315,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.name FROM movies_total_gross AS T1 INNER JOIN director AS T2 ON T2.name = T1.movie_title WHERE T2.director = 'Ron Clements' ORDER BY CAST(REPLACE(SUBSTR(total_gross, 2), ',', '') AS int) DESC LIMIT 1",
        "target_query": "SELECT \"T2\".\"name\" FROM \"movies_total_gross\" AS \"T1\" INNER JOIN \"director\" AS \"T2\" ON \"T2\".\"name\" = \"T1\".\"movie_title\" WHERE \"T2\".\"director\" = 'Ron Clements' ORDER BY CAST(REPLACE(substring(\"T1\".\"total_gross\" from 2 for char_length(\"T1\".\"total_gross\") - 1), ',', '') AS int) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 156,
                "end_index": 177,
                "dilatect_content": "SUBSTR(total_gross, 2)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 204,
                "end_index": 287,
                "dilatect_content": "substring(\"T1\".\"total_gross\" from 2 for char_length(\"T1\".\"total_gross\") - 1)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n",
            "Table: `director`\nColumns:\n(`name`, text, primary key)\n(`director`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"movies_total_gross\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING, primary key)\n(\"genre\", STRING)\n(\"MPAA_rating\", STRING)\n(\"total_gross\", STRING)\n(\"inflation_adjusted_gross\", STRING)\n",
            "Table: \"director\"\nColumns:\n(\"name\", STRING, primary key)\n(\"director\", STRING)\n"
        ]
    },
    {
        "sql_id": 316,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.director FROM movies_total_gross AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name AND CAST(SUBSTR(release_date, INSTR(release_date, ', ') + 1) AS int) BETWEEN 1990 AND 2000 GROUP BY T2.director",
        "target_query": "SELECT \"T2\".\"director\" FROM \"movies_total_gross\" AS \"T1\" INNER JOIN \"director\" AS \"T2\" ON \"T1\".\"movie_title\" = \"T2\".\"name\" AND CAST(substring(\"T1\".\"release_date\" from POSITION(', ' IN \"T1\".\"release_date\") + 2 for 4) AS INTEGER) BETWEEN 1990 AND 2000 GROUP BY \"T2\".\"director\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 112,
                "end_index": 162,
                "dilatect_content": "SUBSTR(release_date, INSTR(release_date, ', ') + 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 133,
                "end_index": 157,
                "dilatect_content": "INSTR(release_date, ', ')",
                "feature": "instr(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 152,
                "end_index": 241,
                "dilatect_content": "substring(\"T1\".\"release_date\" from POSITION(', ' IN \"T1\".\"release_date\") + 2 for 4",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 191,
                "end_index": 231,
                "dilatect_content": "POSITION(', ' IN \"T1\".\"release_date\")",
                "feature": "POSITION(Y IN X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "instr(X,Y)",
                "explanation": "The instr(X,Y) function finds the first occurrence of string Y within \n  string X and returns the number of prior characters plus 1, or 0 if\n  Y is nowhere found within X.\n  Or, if X and Y are both BLOBs, then instr(X,Y) returns one\n  more than the number bytes prior to the first occurrence of Y, or 0 if\n  Y does not occur anywhere within X.\n  If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs\n  then both are interpreted as strings.\n  If either X or Y are NULL in instr(X,Y) then the result is NULL.\n",
                "examples": [
                    "SELECT instr('Hello World', 'World'); -- Returns 7",
                    "SELECT instr('abcdefg', 'x'); -- Returns 0 (not found)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            },
            {
                "feature": "POSITION(Y IN X)",
                "explanation": "In MonetDB, the POSITION function is used to find the first occurrence of string Y within string X and returns the number of characters from the beginning of X to the start of Y. If Y is not found within X, it returns 0.",
                "examples": [
                    "SELECT POSITION('World' IN 'Hello World'); -- Returns 7",
                    "SELECT POSITION('x' IN 'abcdefg'); -- Returns 0 (not found)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n",
            "Table: `director`\nColumns:\n(`name`, text, primary key)\n(`director`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"movies_total_gross\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING, primary key)\n(\"genre\", STRING)\n(\"MPAA_rating\", STRING)\n(\"total_gross\", STRING)\n(\"inflation_adjusted_gross\", STRING)\n",
            "Table: \"director\"\nColumns:\n(\"name\", STRING, primary key)\n(\"director\", STRING)\n"
        ]
    },
    {
        "sql_id": 317,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.movie_title FROM movies_total_gross AS T1 INNER JOIN characters AS T2 ON T2.movie_title = T1.movie_title WHERE T2.song IS NULL ORDER BY CAST(REPLACE(trim(T1.total_gross, '$'), ',', '') AS REAL) DESC LIMIT 1",
        "target_query": "SELECT \"T1\".\"movie_title\" FROM \"movies_total_gross\" AS \"T1\" INNER JOIN \"characters\" AS \"T2\" ON \"T2\".\"movie_title\" = \"T1\".\"movie_title\" WHERE \"T2\".\"song\" IS NULL ORDER BY CAST(REPLACE(REPLACE(\"T1\".\"total_gross\", '$', ''), ',', '') AS REAL) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 159,
                "end_index": 183,
                "dilatect_content": "trim(T1.total_gross, '$')",
                "feature": "trim(X)trim(X,Y)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "trim(X)trim(X,Y)",
                "explanation": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "trim(X) trim(X, Y)",
                "explanation": "The trim(X, Y) function returns a string formed by removing any and all characters that appear in Y from both ends of X. If the Y argument is omitted, trim(X) removes spaces from both ends of X.",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n",
            "Table: `characters`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text)\n(`hero`, text)\n(`villian`, text)\n(`song`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"movies_total_gross\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING, primary key)\n(\"genre\", STRING)\n(\"MPAA_rating\", STRING)\n(\"total_gross\", STRING)\n(\"inflation_adjusted_gross\", STRING)\n",
            "Table: \"characters\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING)\n(\"hero\", STRING)\n(\"villian\", STRING)\n(\"song\", STRING)\n"
        ]
    },
    {
        "sql_id": 318,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.movie_title FROM `voice-actors` AS T1 INNER JOIN movies_total_gross AS T2 ON T2.movie_title = T1.movie WHERE T1.`voice-actor` = 'Jim Cummings' ORDER BY CAST(REPLACE(trim(T2.total_gross, '$'), ',', '') AS REAL) DESC LIMIT 1",
        "target_query": "SELECT T2.\"movie_title\" FROM \"voice_actors\" AS T1 INNER JOIN \"movies_total_gross\" AS T2 ON T2.\"movie_title\" = T1.\"movie\" WHERE T1.\"voice_actor\" = 'Jim Cummings' ORDER BY CAST(REPLACE(trim(REPLACE(trim(T2.\"total_gross\", '$'), ',', '')), ',', '') AS REAL) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 175,
                "end_index": 199,
                "dilatect_content": "trim(T2.total_gross, '$')",
                "feature": "trim(X)trim(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 208,
                "end_index": 236,
                "dilatect_content": "trim(T2.\"total_gross\", '$')",
                "feature": "trim(X) trim(X, Y)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "trim(X)trim(X,Y)",
                "explanation": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "trim(X) trim(X, Y)",
                "explanation": "The trim(X, Y) function returns a string formed by removing any and all characters that appear in Y from both ends of X. If the Y argument is omitted, trim(X) removes spaces from both ends of X.",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `voice-actors`\nColumns:\n(`character`, text, primary key)\n(`voice-actor`, text)\n(`movie`, text)\n",
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"voice_actors\"\nColumns:\n(\"character\", STRING, primary key)\n(\"voice_actor\", STRING)\n(\"movie\", STRING)\n",
            "Table: \"movies_total_gross\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING, primary key)\n(\"genre\", STRING)\n(\"MPAA_rating\", STRING)\n(\"total_gross\", STRING)\n(\"inflation_adjusted_gross\", STRING)\n"
        ]
    },
    {
        "sql_id": 319,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.movie_title FROM director AS T1 INNER JOIN movies_total_gross AS T2 ON T1.name = T2.movie_title WHERE T1.director = 'Ron Clements' ORDER BY CAST(REPLACE(trim(T2.total_gross, '$'), ',', '') AS REAL) DESC LIMIT 1",
        "target_query": "SELECT \"T2\".\"movie_title\" FROM \"director\" AS \"T1\" INNER JOIN \"movies_total_gross\" AS \"T2\" ON \"T1\".\"name\" = \"T2\".\"movie_title\" WHERE \"T1\".\"director\" = 'Ron Clements' ORDER BY CAST(REPLACE(REPLACE(trim(\"T2\".\"total_gross\"), '$', ''), ',', '') AS REAL) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 163,
                "end_index": 187,
                "dilatect_content": "trim(T2.total_gross, '$')",
                "feature": "trim(X)trim(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 219,
                "end_index": 246,
                "dilatect_content": "trim(\"T2\".\"total_gross\")",
                "feature": "trim(X) trim(X, Y)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "trim(X)trim(X,Y)",
                "explanation": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "trim(X) trim(X, Y)",
                "explanation": "The trim(X, Y) function returns a string formed by removing any and all characters that appear in Y from both ends of X. If the Y argument is omitted, trim(X) removes spaces from both ends of X.",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `director`\nColumns:\n(`name`, text, primary key)\n(`director`, text)\n",
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"director\"\nColumns:\n(\"name\", STRING, primary key)\n(\"director\", STRING)\n",
            "Table: \"movies_total_gross\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING, primary key)\n(\"genre\", STRING)\n(\"MPAA_rating\", STRING)\n(\"total_gross\", STRING)\n(\"inflation_adjusted_gross\", STRING)\n"
        ]
    },
    {
        "sql_id": 321,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT movie_title, genre FROM movies_total_gross WHERE SUBSTR(release_date, LENGTH(release_date) - 3, LENGTH(release_date)) = '2016'",
        "target_query": "SELECT \"movie_title\", \"genre\" FROM \"movies_total_gross\" WHERE substring(\"release_date\" from LENGTH(\"release_date\") - 3 for 4) = '2016';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 56,
                "end_index": 123,
                "dilatect_content": "SUBSTR(release_date, LENGTH(release_date) - 3, LENGTH(release_date))",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 77,
                "end_index": 96,
                "dilatect_content": "LENGTH(release_date)",
                "feature": "length(X)"
            },
            {
                "start_index": 103,
                "end_index": 122,
                "dilatect_content": "LENGTH(release_date)",
                "feature": "length(X)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 68,
                "end_index": 134,
                "dilatect_content": "substring(\"release_date\" from LENGTH(\"release_date\") - 3 for 4)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 100,
                "end_index": 123,
                "dilatect_content": "LENGTH(\"release_date\")",
                "feature": "length(X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "MonetDB supports the length() function for both string and BLOB values. For a string value X, the function returns the number of characters (code points) in the string. For a BLOB value, it returns the byte-length of the BLOB.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"movies_total_gross\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING, primary key)\n(\"genre\", STRING)\n(\"MPAA_rating\", STRING)\n(\"total_gross\", STRING)\n(\"inflation_adjusted_gross\", STRING)\n"
        ]
    },
    {
        "sql_id": 323,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.movie_title, T2.hero, T2.song FROM movies_total_gross AS T1 INNER JOIN characters AS T2 ON T1.movie_title = T2.movie_title INNER JOIN director AS T3 ON T1.movie_title = T3.name WHERE T3.director = 'Wolfgang Reitherman' AND SUBSTR(T1.release_date, LENGTH(T1.release_date) - 3, LENGTH(T1.release_date)) = '1977'",
        "target_query": "SELECT \"T1\".\"movie_title\", \"T2\".\"hero\", \"T2\".\"song\" FROM \"movies_total_gross\" AS \"T1\" INNER JOIN \"characters\" AS \"T2\" ON \"T1\".\"movie_title\" = \"T2\".\"movie_title\" INNER JOIN \"director\" AS \"T3\" ON \"T1\".\"movie_title\" = \"T3\".\"name\" WHERE \"T3\".\"director\" = 'Wolfgang Reitherman' AND substring(\"T1\".\"release_date\" from length(\"T1\".\"release_date\") - 3 for 4) = '1977';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 233,
                "end_index": 309,
                "dilatect_content": "SUBSTR(T1.release_date, LENGTH(T1.release_date) - 3, LENGTH(T1.release_date))",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 257,
                "end_index": 279,
                "dilatect_content": "LENGTH(T1.release_date)",
                "feature": "length(X)"
            },
            {
                "start_index": 286,
                "end_index": 308,
                "dilatect_content": "LENGTH(T1.release_date)",
                "feature": "length(X)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 321,
                "end_index": 401,
                "dilatect_content": "substring(\"T1\".\"release_date\" from length(\"T1\".\"release_date\") - 3 for 4)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 360,
                "end_index": 390,
                "dilatect_content": "length(\"T1\".\"release_date\")",
                "feature": "length(X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "MonetDB supports the length() function for both string and BLOB values. For a string value X, the function returns the number of characters (code points) in the string. For a BLOB value, it returns the byte-length of the BLOB.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n",
            "Table: `characters`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text)\n(`hero`, text)\n(`villian`, text)\n(`song`, text)\n",
            "Table: `director`\nColumns:\n(`name`, text, primary key)\n(`director`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"movies_total_gross\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING, primary key)\n(\"genre\", STRING)\n(\"MPAA_rating\", STRING)\n(\"total_gross\", STRING)\n(\"inflation_adjusted_gross\", STRING)\n",
            "Table: \"characters\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING)\n(\"hero\", STRING)\n(\"villian\", STRING)\n(\"song\", STRING)\n",
            "Table: \"director\"\nColumns:\n(\"name\", STRING, primary key)\n(\"director\", STRING)\n"
        ]
    },
    {
        "sql_id": 324,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.movie_title, T1.total_gross FROM movies_total_gross AS T1 INNER JOIN `voice-actors` AS T2 ON T1.movie_title = T2.movie WHERE T2.`voice-actor` = 'Frank Welker' AND CAST(REPLACE(trim(T1.inflation_adjusted_gross, '$'), ',', '') AS REAL) * 1.0 / CAST(REPLACE(trim(T1.total_gross, '$'), ',', '') AS REAL) * 1.0 < 2",
        "target_query": "SELECT \"movie_title\", \"total_gross\" FROM \"movies_total_gross\" AS T1 INNER JOIN \"voice_actors\" AS T2 ON T1.\"movie_title\" = T2.\"movie\" WHERE T2.\"voice_actor\" = 'Frank Welker' AND CAST(REPLACE(trim(REPLACE(trim(T1.\"inflation_adjusted_gross\", '$'), ',', ''), ' '), ',', '') AS REAL) * 1.0 / CAST(REPLACE(trim(REPLACE(trim(T1.\"total_gross\", '$'), ',', ''), ' '), ',', '') AS REAL) * 1.0 < 2;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 186,
                "end_index": 223,
                "dilatect_content": "trim(T1.inflation_adjusted_gross, '$')",
                "feature": "trim(X)trim(X,Y)"
            },
            {
                "start_index": 265,
                "end_index": 289,
                "dilatect_content": "trim(T1.total_gross, '$')",
                "feature": "trim(X)trim(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 217,
                "end_index": 258,
                "dilatect_content": "trim(T1.\"inflation_adjusted_gross\", '$')",
                "feature": "trim(X) trim(X, Y)"
            },
            {
                "start_index": 329,
                "end_index": 357,
                "dilatect_content": "trim(T1.\"total_gross\", '$')",
                "feature": "trim(X) trim(X, Y)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "trim(X)trim(X,Y)",
                "explanation": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "trim(X) trim(X, Y)",
                "explanation": "The trim(X, Y) function returns a string formed by removing any and all characters that appear in Y from both ends of X. If the Y argument is omitted, trim(X) removes spaces from both ends of X.",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n",
            "Table: `voice-actors`\nColumns:\n(`character`, text, primary key)\n(`voice-actor`, text)\n(`movie`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"movies_total_gross\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING, primary key)\n(\"genre\", STRING)\n(\"MPAA_rating\", STRING)\n(\"total_gross\", STRING)\n(\"inflation_adjusted_gross\", STRING)\n",
            "Table: \"voice_actors\"\nColumns:\n(\"character\", STRING, primary key)\n(\"voice_actor\", STRING)\n(\"movie\", STRING)\n"
        ]
    },
    {
        "sql_id": 325,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.director FROM movies_total_gross AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name ORDER BY CAST(REPLACE(trim(T1.total_gross, '$'), ',', '') AS REAL) DESC LIMIT 1",
        "target_query": "SELECT \"T2\".\"director\" FROM \"movies_total_gross\" AS \"T1\" INNER JOIN \"director\" AS \"T2\" ON \"T1\".\"movie_title\" = \"T2\".\"name\" ORDER BY CAST(REPLACE(trim(REPLACE(trim(\"T1\".\"total_gross\", '$'), ',', '')), ',', '') AS REAL) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 125,
                "end_index": 149,
                "dilatect_content": "trim(T1.total_gross, '$')",
                "feature": "trim(X)trim(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 178,
                "end_index": 210,
                "dilatect_content": "trim(\"T1\".\"total_gross\", '$')",
                "feature": "trim(X) trim(X, Y)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "trim(X)trim(X,Y)",
                "explanation": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "trim(X) trim(X, Y)",
                "explanation": "The trim(X, Y) function returns a string formed by removing any and all characters that appear in Y from both ends of X. If the Y argument is omitted, trim(X) removes spaces from both ends of X.",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n",
            "Table: `director`\nColumns:\n(`name`, text, primary key)\n(`director`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"movies_total_gross\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING, primary key)\n(\"genre\", STRING)\n(\"MPAA_rating\", STRING)\n(\"total_gross\", STRING)\n(\"inflation_adjusted_gross\", STRING)\n",
            "Table: \"director\"\nColumns:\n(\"name\", STRING, primary key)\n(\"director\", STRING)\n"
        ]
    },
    {
        "sql_id": 326,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.director, T1.MPAA_rating FROM movies_total_gross AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE T1.genre = 'Musical' AND SUBSTR(T1.release_date, LENGTH(T1.release_date) - 3, LENGTH(T1.release_date)) = '1993'",
        "target_query": "SELECT \"T2\".\"director\", \"T1\".\"MPAA_rating\" FROM \"movies_total_gross\" AS \"T1\" INNER JOIN \"director\" AS \"T2\" ON \"T1\".\"movie_title\" = \"T2\".\"name\" WHERE \"T1\".\"genre\" = 'Musical' AND substring(\"T1\".\"release_date\" from length(\"T1\".\"release_date\") - 3 for 4) = '1993';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 150,
                "end_index": 226,
                "dilatect_content": "SUBSTR(T1.release_date, LENGTH(T1.release_date) - 3, LENGTH(T1.release_date))",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 174,
                "end_index": 196,
                "dilatect_content": "LENGTH(T1.release_date)",
                "feature": "length(X)"
            },
            {
                "start_index": 203,
                "end_index": 225,
                "dilatect_content": "LENGTH(T1.release_date)",
                "feature": "length(X)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 206,
                "end_index": 286,
                "dilatect_content": "substring(\"T1\".\"release_date\" from length(\"T1\".\"release_date\") - 3 for 4)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 245,
                "end_index": 275,
                "dilatect_content": "length(\"T1\".\"release_date\")",
                "feature": "length(X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "MonetDB supports the length() function for both string and BLOB values. For a string value X, the function returns the number of characters (code points) in the string. For a BLOB value, it returns the byte-length of the BLOB.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n",
            "Table: `director`\nColumns:\n(`name`, text, primary key)\n(`director`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"movies_total_gross\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING, primary key)\n(\"genre\", STRING)\n(\"MPAA_rating\", STRING)\n(\"total_gross\", STRING)\n(\"inflation_adjusted_gross\", STRING)\n",
            "Table: \"director\"\nColumns:\n(\"name\", STRING, primary key)\n(\"director\", STRING)\n"
        ]
    },
    {
        "sql_id": 328,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.name, T2.director FROM movies_total_gross AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE SUBSTR(T1.release_date, LENGTH(T1.release_date) - 3, LENGTH(T1.release_date)) BETWEEN '2001' AND '2005' AND CAST(REPLACE(trim(T1.total_gross, '$'), ',', '') AS REAL) / ( SELECT SUM(CAST(REPLACE(trim(T3.total_gross, '$'), ',', '') AS REAL)) / COUNT(T3.movie_title) AS avg_gross FROM movies_total_gross AS T3 INNER JOIN director AS T4 ON T3.movie_title = T4.name WHERE SUBSTR(T3.release_date, LENGTH(T3.release_date) - 3, LENGTH(T3.release_date)) BETWEEN '2001' AND '2005' ) - 1 > 1",
        "target_query": "SELECT \"T2\".\"name\", \"T2\".\"director\" FROM \"movies_total_gross\" AS \"T1\" INNER JOIN \"director\" AS \"T2\" ON \"T1\".\"movie_title\" = \"T2\".\"name\" WHERE substring(\"T1\".\"release_date\" from length(\"T1\".\"release_date\") - 3 for 4) BETWEEN '2001' AND '2005' AND CAST(REPLACE(trim(\"T1\".\"total_gross\", '$'), ',', '') AS REAL) / ( SELECT SUM(CAST(REPLACE(trim(\"T3\".\"total_gross\", '$'), ',', '') AS REAL)) / COUNT(\"T3\".\"movie_title\") AS avg_gross FROM \"movies_total_gross\" AS \"T3\" INNER JOIN \"director\" AS \"T4\" ON \"T3\".\"movie_title\" = \"T4\".\"name\" WHERE substring(\"T3\".\"release_date\" from length(\"T3\".\"release_date\") - 3 for 4) BETWEEN '2001' AND '2005' ) - 1 > 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 118,
                "end_index": 194,
                "dilatect_content": "SUBSTR(T1.release_date, LENGTH(T1.release_date) - 3, LENGTH(T1.release_date))",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 142,
                "end_index": 164,
                "dilatect_content": "LENGTH(T1.release_date)",
                "feature": "length(X)"
            },
            {
                "start_index": 171,
                "end_index": 193,
                "dilatect_content": "LENGTH(T1.release_date)",
                "feature": "length(X)"
            },
            {
                "start_index": 239,
                "end_index": 263,
                "dilatect_content": "trim(T1.total_gross, '$')",
                "feature": "trim(X)trim(X,Y)"
            },
            {
                "start_index": 312,
                "end_index": 336,
                "dilatect_content": "trim(T3.total_gross, '$')",
                "feature": "trim(X)trim(X,Y)"
            },
            {
                "start_index": 485,
                "end_index": 561,
                "dilatect_content": "SUBSTR(T3.release_date, LENGTH(T3.release_date) - 3, LENGTH(T3.release_date))",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 509,
                "end_index": 531,
                "dilatect_content": "LENGTH(T3.release_date)",
                "feature": "length(X)"
            },
            {
                "start_index": 538,
                "end_index": 560,
                "dilatect_content": "LENGTH(T3.release_date)",
                "feature": "length(X)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 166,
                "end_index": 246,
                "dilatect_content": "substring(\"T1\".\"release_date\" from length(\"T1\".\"release_date\") - 3 for 4)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 205,
                "end_index": 235,
                "dilatect_content": "length(\"T1\".\"release_date\")",
                "feature": "length(X)"
            },
            {
                "start_index": 291,
                "end_index": 323,
                "dilatect_content": "trim(\"T1\".\"total_gross\", '$')",
                "feature": "trim(X) trim(X, Y)"
            },
            {
                "start_index": 372,
                "end_index": 404,
                "dilatect_content": "trim(\"T3\".\"total_gross\", '$')",
                "feature": "trim(X) trim(X, Y)"
            },
            {
                "start_index": 593,
                "end_index": 673,
                "dilatect_content": "substring(\"T3\".\"release_date\" from length(\"T3\".\"release_date\") - 3 for 4)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 632,
                "end_index": 662,
                "dilatect_content": "length(\"T3\".\"release_date\")",
                "feature": "length(X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            },
            {
                "feature": "trim(X)trim(X,Y)",
                "explanation": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "MonetDB supports the length() function for both string and BLOB values. For a string value X, the function returns the number of characters (code points) in the string. For a BLOB value, it returns the byte-length of the BLOB.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            },
            {
                "feature": "trim(X) trim(X, Y)",
                "explanation": "The trim(X, Y) function returns a string formed by removing any and all characters that appear in Y from both ends of X. If the Y argument is omitted, trim(X) removes spaces from both ends of X.",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n",
            "Table: `director`\nColumns:\n(`name`, text, primary key)\n(`director`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"movies_total_gross\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING, primary key)\n(\"genre\", STRING)\n(\"MPAA_rating\", STRING)\n(\"total_gross\", STRING)\n(\"inflation_adjusted_gross\", STRING)\n",
            "Table: \"director\"\nColumns:\n(\"name\", STRING, primary key)\n(\"director\", STRING)\n"
        ]
    },
    {
        "sql_id": 329,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(movie_title) FROM characters WHERE SUBSTR(release_date, LENGTH(release_date) - 1, LENGTH(release_date)) BETWEEN '37' AND '50'",
        "target_query": "SELECT COUNT(\"movie_title\") FROM \"characters\" WHERE substring(\"release_date\" from length(\"release_date\") - 1 for length(\"release_date\")) BETWEEN '37' AND '50';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 48,
                "end_index": 115,
                "dilatect_content": "SUBSTR(release_date, LENGTH(release_date) - 1, LENGTH(release_date))",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 69,
                "end_index": 88,
                "dilatect_content": "LENGTH(release_date)",
                "feature": "length(X)"
            },
            {
                "start_index": 95,
                "end_index": 114,
                "dilatect_content": "LENGTH(release_date)",
                "feature": "length(X)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 56,
                "end_index": 145,
                "dilatect_content": "substring(\"release_date\" from length(\"release_date\") - 1 for length(\"release_date\"))",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 88,
                "end_index": 111,
                "dilatect_content": "length(\"release_date\")",
                "feature": "length(X)"
            },
            {
                "start_index": 121,
                "end_index": 144,
                "dilatect_content": "length(\"release_date\")",
                "feature": "length(X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "MonetDB supports the length() function for both string and BLOB values. For a string value X, the function returns the number of characters (code points) in the string. For a BLOB value, it returns the byte-length of the BLOB.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `characters`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text)\n(`hero`, text)\n(`villian`, text)\n(`song`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"characters\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING)\n(\"hero\", STRING)\n(\"villian\", STRING)\n(\"song\", STRING)\n"
        ]
    },
    {
        "sql_id": 330,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.movie_title FROM characters AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE T2.director = 'Jack Kinney' AND SUBSTR(T1.release_date, LENGTH(T1.release_date) - 1, LENGTH(T1.release_date)) < '47'",
        "target_query": "SELECT \"T1\".\"movie_title\" FROM \"characters\" AS \"T1\" INNER JOIN \"director\" AS \"T2\" ON \"T1\".\"movie_title\" = \"T2\".\"name\" WHERE \"T2\".\"director\" = 'Jack Kinney' AND substring(\"T1\".\"release_date\" from length(\"T1\".\"release_date\") - 1 for 2) < '47';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 136,
                "end_index": 212,
                "dilatect_content": "SUBSTR(T1.release_date, LENGTH(T1.release_date) - 1, LENGTH(T1.release_date))",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 160,
                "end_index": 182,
                "dilatect_content": "LENGTH(T1.release_date)",
                "feature": "length(X)"
            },
            {
                "start_index": 189,
                "end_index": 211,
                "dilatect_content": "LENGTH(T1.release_date)",
                "feature": "length(X)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 184,
                "end_index": 264,
                "dilatect_content": "substring(\"T1\".\"release_date\" from length(\"T1\".\"release_date\") - 1 for 2)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 223,
                "end_index": 253,
                "dilatect_content": "length(\"T1\".\"release_date\")",
                "feature": "length(X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "MonetDB supports the length() function for both string and BLOB values. For a string value X, the function returns the number of characters (code points) in the string. For a BLOB value, it returns the byte-length of the BLOB.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `characters`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text)\n(`hero`, text)\n(`villian`, text)\n(`song`, text)\n",
            "Table: `director`\nColumns:\n(`name`, text, primary key)\n(`director`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"characters\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING)\n(\"hero\", STRING)\n(\"villian\", STRING)\n(\"song\", STRING)\n",
            "Table: \"director\"\nColumns:\n(\"name\", STRING, primary key)\n(\"director\", STRING)\n"
        ]
    },
    {
        "sql_id": 331,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT T2.director FROM characters AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name INNER JOIN movies_total_gross AS T3 ON T1.movie_title = T3.movie_title WHERE CAST(REPLACE(trim(T3.total_gross, '$'), ',', '') AS REAL) > 100000000",
        "target_query": "SELECT DISTINCT \"T2\".\"director\" FROM \"characters\" AS \"T1\" INNER JOIN \"director\" AS \"T2\" ON \"T1\".\"movie_title\" = \"T2\".\"name\" INNER JOIN \"movies_total_gross\" AS \"T3\" ON \"T1\".\"movie_title\" = \"T3\".\"movie_title\" WHERE CAST(REPLACE(trim(TRIM(\"T3\".\"total_gross\", '$')), ',', '') AS REAL) > 100000000;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 194,
                "end_index": 218,
                "dilatect_content": "trim(T3.total_gross, '$')",
                "feature": "trim(X)trim(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 263,
                "end_index": 295,
                "dilatect_content": "TRIM(\"T3\".\"total_gross\", '$')",
                "feature": "trim(X) trim(X, Y)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "trim(X)trim(X,Y)",
                "explanation": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "trim(X) trim(X, Y)",
                "explanation": "The trim(X, Y) function returns a string formed by removing any and all characters that appear in Y from both ends of X. If the Y argument is omitted, trim(X) removes spaces from both ends of X.",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `characters`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text)\n(`hero`, text)\n(`villian`, text)\n(`song`, text)\n",
            "Table: `director`\nColumns:\n(`name`, text, primary key)\n(`director`, text)\n",
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"characters\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING)\n(\"hero\", STRING)\n(\"villian\", STRING)\n(\"song\", STRING)\n",
            "Table: \"director\"\nColumns:\n(\"name\", STRING, primary key)\n(\"director\", STRING)\n",
            "Table: \"movies_total_gross\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING, primary key)\n(\"genre\", STRING)\n(\"MPAA_rating\", STRING)\n(\"total_gross\", STRING)\n(\"inflation_adjusted_gross\", STRING)\n"
        ]
    },
    {
        "sql_id": 332,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.song FROM movies_total_gross AS T1 INNER JOIN characters AS T2 ON T1.movie_title = T2.movie_title ORDER BY CAST(REPLACE(trim(T1.total_gross, '$'), ',', '') AS REAL) DESC LIMIT 1",
        "target_query": "SELECT \"T2\".\"song\" FROM \"movies_total_gross\" AS \"T1\" INNER JOIN \"characters\" AS \"T2\" ON \"T1\".\"movie_title\" = \"T2\".\"movie_title\" ORDER BY CAST(REPLACE(trim(REPLACE(trim(\"T1\".\"total_gross\", '$'), ',', '')), ',', '') AS REAL) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 130,
                "end_index": 154,
                "dilatect_content": "trim(T1.total_gross, '$')",
                "feature": "trim(X)trim(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 183,
                "end_index": 215,
                "dilatect_content": "trim(\"T1\".\"total_gross\", '$')",
                "feature": "trim(X) trim(X, Y)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "trim(X)trim(X,Y)",
                "explanation": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "trim(X) trim(X, Y)",
                "explanation": "The trim(X, Y) function returns a string formed by removing any and all characters that appear in Y from both ends of X. If the Y argument is omitted, trim(X) removes spaces from both ends of X.",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n",
            "Table: `characters`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text)\n(`hero`, text)\n(`villian`, text)\n(`song`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"movies_total_gross\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING, primary key)\n(\"genre\", STRING)\n(\"MPAA_rating\", STRING)\n(\"total_gross\", STRING)\n(\"inflation_adjusted_gross\", STRING)\n",
            "Table: \"characters\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING)\n(\"hero\", STRING)\n(\"villian\", STRING)\n(\"song\", STRING)\n"
        ]
    },
    {
        "sql_id": 333,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.director FROM characters AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name INNER JOIN movies_total_gross AS T3 ON T3.movie_title = T1.movie_title WHERE SUBSTR(T3.release_date, LENGTH(T3.release_date) - 3, LENGTH(T3.release_date)) BETWEEN '1937' AND '1990' ORDER BY CAST(REPLACE(trim(T3.total_gross, '$'), ',', '') AS REAL) DESC LIMIT 1",
        "target_query": "SELECT \"T2\".\"director\" FROM \"characters\" AS \"T1\" INNER JOIN \"director\" AS \"T2\" ON \"T1\".\"movie_title\" = \"T2\".\"name\" INNER JOIN \"movies_total_gross\" AS \"T3\" ON \"T3\".\"movie_title\" = \"T1\".\"movie_title\" WHERE substring(\"T3\".\"release_date\" from length(\"T3\".\"release_date\") - 3 for 4) BETWEEN '1937' AND '1990' ORDER BY CAST(REPLACE(trim(\"T3\".\"total_gross\", '$'), ',', '') AS REAL) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 172,
                "end_index": 248,
                "dilatect_content": "SUBSTR(T3.release_date, LENGTH(T3.release_date) - 3, LENGTH(T3.release_date))",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 196,
                "end_index": 218,
                "dilatect_content": "LENGTH(T3.release_date)",
                "feature": "length(X)"
            },
            {
                "start_index": 225,
                "end_index": 247,
                "dilatect_content": "LENGTH(T3.release_date)",
                "feature": "length(X)"
            },
            {
                "start_index": 298,
                "end_index": 322,
                "dilatect_content": "trim(T3.total_gross, '$')",
                "feature": "trim(X)trim(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 236,
                "end_index": 316,
                "dilatect_content": "substring(\"T3\".\"release_date\" from length(\"T3\".\"release_date\") - 3 for 4)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 275,
                "end_index": 305,
                "dilatect_content": "length(\"T3\".\"release_date\")",
                "feature": "length(X)"
            },
            {
                "start_index": 366,
                "end_index": 398,
                "dilatect_content": "trim(\"T3\".\"total_gross\", '$')",
                "feature": "trim(X) trim(X, Y)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            },
            {
                "feature": "trim(X)trim(X,Y)",
                "explanation": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "MonetDB supports the length() function for both string and BLOB values. For a string value X, the function returns the number of characters (code points) in the string. For a BLOB value, it returns the byte-length of the BLOB.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            },
            {
                "feature": "trim(X) trim(X, Y)",
                "explanation": "The trim(X, Y) function returns a string formed by removing any and all characters that appear in Y from both ends of X. If the Y argument is omitted, trim(X) removes spaces from both ends of X.",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `characters`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text)\n(`hero`, text)\n(`villian`, text)\n(`song`, text)\n",
            "Table: `director`\nColumns:\n(`name`, text, primary key)\n(`director`, text)\n",
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"characters\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING)\n(\"hero\", STRING)\n(\"villian\", STRING)\n(\"song\", STRING)\n",
            "Table: \"director\"\nColumns:\n(\"name\", STRING, primary key)\n(\"director\", STRING)\n",
            "Table: \"movies_total_gross\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING, primary key)\n(\"genre\", STRING)\n(\"MPAA_rating\", STRING)\n(\"total_gross\", STRING)\n(\"inflation_adjusted_gross\", STRING)\n"
        ]
    },
    {
        "sql_id": 334,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(COUNT(DISTINCT CASE WHEN CAST(REPLACE(trim(T1.total_gross, '$'), ',', '') AS REAL) > 100000000 THEN T3.director ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T3.director) FROM movies_total_gross AS T1 INNER JOIN characters AS T2 ON T1.movie_title = T2.movie_title INNER JOIN director AS T3 ON T1.movie_title = T3.name",
        "target_query": "SELECT CAST(COUNT(DISTINCT CASE WHEN CAST(REPLACE(trim(\"T1\".\"total_gross\", '$'), ',', '') AS REAL) > 100000000 THEN \"T3\".\"director\" ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT \"T3\".\"director\") FROM \"movies_total_gross\" AS \"T1\" INNER JOIN \"characters\" AS \"T2\" ON \"T1\".\"movie_title\" = \"T2\".\"movie_title\" INNER JOIN \"director\" AS \"T3\" ON \"T1\".\"movie_title\" = \"T3\".\"name\"",
        "semantic_equivalent_type": "approximate_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 50,
                "end_index": 74,
                "dilatect_content": "trim(T1.total_gross, '$')",
                "feature": "trim(X)trim(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 50,
                "end_index": 82,
                "dilatect_content": "trim(\"T1\".\"total_gross\", '$')",
                "feature": "trim(X) trim(X, Y)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "trim(X)trim(X,Y)",
                "explanation": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "trim(X) trim(X, Y)",
                "explanation": "The trim(X, Y) function returns a string formed by removing any and all characters that appear in Y from both ends of X. If the Y argument is omitted, trim(X) removes spaces from both ends of X.",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n",
            "Table: `characters`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text)\n(`hero`, text)\n(`villian`, text)\n(`song`, text)\n",
            "Table: `director`\nColumns:\n(`name`, text, primary key)\n(`director`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"movies_total_gross\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING, primary key)\n(\"genre\", STRING)\n(\"MPAA_rating\", STRING)\n(\"total_gross\", STRING)\n(\"inflation_adjusted_gross\", STRING)\n",
            "Table: \"characters\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING)\n(\"hero\", STRING)\n(\"villian\", STRING)\n(\"song\", STRING)\n",
            "Table: \"director\"\nColumns:\n(\"name\", STRING, primary key)\n(\"director\", STRING)\n"
        ]
    },
    {
        "sql_id": 335,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT movie_title FROM characters ORDER BY SUBSTR(release_date, LENGTH(release_date) - 1, LENGTH(release_date)) ASC LIMIT 1",
        "target_query": "SELECT \"movie_title\" FROM \"characters\" ORDER BY substring(\"release_date\" from length(\"release_date\") - 1 for length(\"release_date\")) ASC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 44,
                "end_index": 111,
                "dilatect_content": "SUBSTR(release_date, LENGTH(release_date) - 1, LENGTH(release_date))",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 65,
                "end_index": 84,
                "dilatect_content": "LENGTH(release_date)",
                "feature": "length(X)"
            },
            {
                "start_index": 91,
                "end_index": 110,
                "dilatect_content": "LENGTH(release_date)",
                "feature": "length(X)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 52,
                "end_index": 111,
                "dilatect_content": "substring(\"release_date\" from length(\"release_date\") - 1 for length(\"release_date\"))",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 84,
                "end_index": 107,
                "dilatect_content": "length(\"release_date\")",
                "feature": "length(X)"
            },
            {
                "start_index": 117,
                "end_index": 140,
                "dilatect_content": "length(\"release_date\")",
                "feature": "length(X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "MonetDB supports the length() function for both string and BLOB values. For a string value X, the function returns the number of characters (code points) in the string. For a BLOB value, it returns the byte-length of the BLOB.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `characters`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text)\n(`hero`, text)\n(`villian`, text)\n(`song`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"characters\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING)\n(\"hero\", STRING)\n(\"villian\", STRING)\n(\"song\", STRING)\n"
        ]
    },
    {
        "sql_id": 336,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(movie_title) FROM characters WHERE SUBSTR(release_date, LENGTH(release_date) - 1, LENGTH(release_date)) BETWEEN '10' AND '16'",
        "target_query": "SELECT COUNT(\"movie_title\") FROM \"characters\" WHERE substring(\"release_date\" from length(\"release_date\") - 1 for length(\"release_date\")) BETWEEN '10' AND '16';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 48,
                "end_index": 115,
                "dilatect_content": "SUBSTR(release_date, LENGTH(release_date) - 1, LENGTH(release_date))",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 69,
                "end_index": 88,
                "dilatect_content": "LENGTH(release_date)",
                "feature": "length(X)"
            },
            {
                "start_index": 95,
                "end_index": 114,
                "dilatect_content": "LENGTH(release_date)",
                "feature": "length(X)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 56,
                "end_index": 145,
                "dilatect_content": "substring(\"release_date\" from length(\"release_date\") - 1 for length(\"release_date\"))",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 88,
                "end_index": 111,
                "dilatect_content": "length(\"release_date\")",
                "feature": "length(X)"
            },
            {
                "start_index": 121,
                "end_index": 144,
                "dilatect_content": "length(\"release_date\")",
                "feature": "length(X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "MonetDB supports the length() function for both string and BLOB values. For a string value X, the function returns the number of characters (code points) in the string. For a BLOB value, it returns the byte-length of the BLOB.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `characters`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text)\n(`hero`, text)\n(`villian`, text)\n(`song`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"characters\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING)\n(\"hero\", STRING)\n(\"villian\", STRING)\n(\"song\", STRING)\n"
        ]
    },
    {
        "sql_id": 337,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT villian FROM characters ORDER BY SUBSTR(release_date, LENGTH(release_date) - 1, LENGTH(release_date)) DESC LIMIT 1",
        "target_query": "SELECT \"villian\" FROM \"characters\" ORDER BY substring(\"release_date\" from length(\"release_date\") - 1 for length(\"release_date\")) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 40,
                "end_index": 107,
                "dilatect_content": "SUBSTR(release_date, LENGTH(release_date) - 1, LENGTH(release_date))",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 61,
                "end_index": 80,
                "dilatect_content": "LENGTH(release_date)",
                "feature": "length(X)"
            },
            {
                "start_index": 87,
                "end_index": 106,
                "dilatect_content": "LENGTH(release_date)",
                "feature": "length(X)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 48,
                "end_index": 137,
                "dilatect_content": "substring(\"release_date\" from length(\"release_date\") - 1 for length(\"release_date\"))",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 80,
                "end_index": 103,
                "dilatect_content": "length(\"release_date\")",
                "feature": "length(X)"
            },
            {
                "start_index": 113,
                "end_index": 136,
                "dilatect_content": "length(\"release_date\")",
                "feature": "length(X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "MonetDB supports the length() function for both string and BLOB values. For a string value X, the function returns the number of characters (code points) in the string. For a BLOB value, it returns the byte-length of the BLOB.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `characters`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text)\n(`hero`, text)\n(`villian`, text)\n(`song`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"characters\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING)\n(\"hero\", STRING)\n(\"villian\", STRING)\n(\"song\", STRING)\n"
        ]
    },
    {
        "sql_id": 338,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT movie_title FROM movies_total_gross WHERE genre = 'Action' ORDER BY CAST(REPLACE(trim(total_gross, '$'), ',', '') AS REAL) DESC LIMIT 1",
        "target_query": "SELECT \"movie_title\" FROM \"movies_total_gross\" WHERE \"genre\" = 'Action' ORDER BY CAST(REPLACE(REPLACE(\"total_gross\", '$', ''), ',', '') AS REAL) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 88,
                "end_index": 109,
                "dilatect_content": "trim(total_gross, '$')",
                "feature": "trim(X)trim(X,Y)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "trim(X)trim(X,Y)",
                "explanation": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "trim(X) trim(X, Y)",
                "explanation": "The trim(X, Y) function returns a string formed by removing any and all characters that appear in Y from both ends of X. If the Y argument is omitted, trim(X) removes spaces from both ends of X.",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"movies_total_gross\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING, primary key)\n(\"genre\", STRING)\n(\"MPAA_rating\", STRING)\n(\"total_gross\", STRING)\n(\"inflation_adjusted_gross\", STRING)\n"
        ]
    },
    {
        "sql_id": 339,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.hero FROM movies_total_gross AS T1 INNER JOIN characters AS T2 ON T1.movie_title = T2.movie_title WHERE T1.genre = 'Adventure' ORDER BY CAST(REPLACE(trim(T1.inflation_adjusted_gross, '$'), ',', '') AS REAL) DESC LIMIT 1",
        "target_query": "SELECT \"T2\".\"hero\" FROM \"movies_total_gross\" AS \"T1\" INNER JOIN \"characters\" AS \"T2\" ON \"T1\".\"movie_title\" = \"T2\".\"movie_title\" WHERE \"T1\".\"genre\" = 'Adventure' ORDER BY CAST(trim(REPLACE(REPLACE(\"T1\".\"inflation_adjusted_gross\", '$', ''), ',', '')) AS REAL) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 159,
                "end_index": 196,
                "dilatect_content": "trim(T1.inflation_adjusted_gross, '$')",
                "feature": "trim(X)trim(X,Y)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "trim(X)trim(X,Y)",
                "explanation": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "trim(X) trim(X, Y)",
                "explanation": "The trim(X, Y) function returns a string formed by removing any and all characters that appear in Y from both ends of X. If the Y argument is omitted, trim(X) removes spaces from both ends of X.",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n",
            "Table: `characters`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text)\n(`hero`, text)\n(`villian`, text)\n(`song`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"movies_total_gross\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING, primary key)\n(\"genre\", STRING)\n(\"MPAA_rating\", STRING)\n(\"total_gross\", STRING)\n(\"inflation_adjusted_gross\", STRING)\n",
            "Table: \"characters\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING)\n(\"hero\", STRING)\n(\"villian\", STRING)\n(\"song\", STRING)\n"
        ]
    },
    {
        "sql_id": 340,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.director FROM movies_total_gross AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name ORDER BY CAST(REPLACE(trim(T1.total_gross, '$'), ',', '') AS REAL) ASC LIMIT 1",
        "target_query": "SELECT \"T2\".\"director\" FROM \"movies_total_gross\" AS \"T1\" INNER JOIN \"director\" AS \"T2\" ON \"T1\".\"movie_title\" = \"T2\".\"name\" ORDER BY CAST(REPLACE(trim(\"T1\".\"total_gross\", '$'), ',', '') AS REAL) ASC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 125,
                "end_index": 149,
                "dilatect_content": "trim(T1.total_gross, '$')",
                "feature": "trim(X)trim(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 165,
                "end_index": 197,
                "dilatect_content": "trim(\"T1\".\"total_gross\", '$')",
                "feature": "trim(X) trim(X, Y)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "trim(X)trim(X,Y)",
                "explanation": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "trim(X) trim(X, Y)",
                "explanation": "The trim(X, Y) function returns a string formed by removing any and all characters that appear in Y from both ends of X. If the Y argument is omitted, trim(X) removes spaces from both ends of X.",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n",
            "Table: `director`\nColumns:\n(`name`, text, primary key)\n(`director`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"movies_total_gross\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING, primary key)\n(\"genre\", STRING)\n(\"MPAA_rating\", STRING)\n(\"total_gross\", STRING)\n(\"inflation_adjusted_gross\", STRING)\n",
            "Table: \"director\"\nColumns:\n(\"name\", STRING, primary key)\n(\"director\", STRING)\n"
        ]
    },
    {
        "sql_id": 342,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(CAST(REPLACE(trim(inflation_adjusted_gross, '$'), ',', '') AS REAL)) / SUM(CAST(REPLACE(trim(total_gross, '$'), ',', '') AS REAL)) FROM movies_total_gross WHERE SUBSTR(release_date, LENGTH(release_date) - 3, LENGTH(release_date)) = '1995' GROUP BY SUBSTR(release_date, LENGTH(release_date) - 3, LENGTH(release_date)) = '1995'",
        "target_query": "SELECT SUM(CAST(REPLACE(trim(\"inflation_adjusted_gross\", '$'), ',', '') AS REAL)) / SUM(CAST(REPLACE(trim(\"total_gross\", '$'), ',', '') AS REAL)) FROM \"movies_total_gross\" WHERE substring(\"release_date\" from length(\"release_date\") - 3 for length(\"release_date\")) = '1995' GROUP BY substring(\"release_date\" from length(\"release_date\") - 3 for length(\"release_date\"));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 24,
                "end_index": -1,
                "dilatect_content": "",
                "feature": "trim(X)trim(X,Y)"
            },
            {
                "start_index": 99,
                "end_index": -1,
                "dilatect_content": "",
                "feature": "trim(X)trim(X,Y)"
            },
            {
                "start_index": 172,
                "end_index": -1,
                "dilatect_content": "",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 193,
                "end_index": -1,
                "dilatect_content": "",
                "feature": "length(X)"
            },
            {
                "start_index": 219,
                "end_index": -1,
                "dilatect_content": "",
                "feature": "length(X)"
            },
            {
                "start_index": 259,
                "end_index": -1,
                "dilatect_content": "",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 280,
                "end_index": -1,
                "dilatect_content": "",
                "feature": "length(X)"
            },
            {
                "start_index": 306,
                "end_index": -1,
                "dilatect_content": "",
                "feature": "length(X)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            },
            {
                "feature": "trim(X)trim(X,Y)",
                "explanation": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "MonetDB supports the length() function for both string and BLOB values. For a string value X, the function returns the number of characters (code points) in the string. For a BLOB value, it returns the byte-length of the BLOB.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            },
            {
                "feature": "trim(X) trim(X, Y)",
                "explanation": "The trim(X, Y) function returns a string formed by removing any and all characters that appear in Y from both ends of X. If the Y argument is omitted, trim(X) removes spaces from both ends of X.",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"movies_total_gross\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING, primary key)\n(\"genre\", STRING)\n(\"MPAA_rating\", STRING)\n(\"total_gross\", STRING)\n(\"inflation_adjusted_gross\", STRING)\n"
        ]
    },
    {
        "sql_id": 344,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(CASE WHEN CAST(REPLACE(trim(inflation_adjusted_gross, '$'), ',', '') AS REAL) > 1236035515 THEN CAST(REPLACE(trim(inflation_adjusted_gross, '$'), ',', '') AS REAL) ELSE 0 END) * 100 / SUM(CAST(REPLACE(trim(inflation_adjusted_gross, '$'), ',', '') AS REAL)) FROM movies_total_gross",
        "target_query": "SELECT SUM(CASE WHEN CAST(REPLACE(trim(\"inflation_adjusted_gross\", '$'), ',', '') AS REAL) > 1236035515 THEN CAST(REPLACE(trim(\"inflation_adjusted_gross\", '$'), ',', '') AS REAL) ELSE 0 END) * 100 / SUM(CAST(REPLACE(trim(\"inflation_adjusted_gross\", '$'), ',', '') AS REAL)) FROM \"movies_total_gross\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 34,
                "end_index": 68,
                "dilatect_content": "trim(inflation_adjusted_gross, '$')",
                "feature": "trim(X)trim(X,Y)"
            },
            {
                "start_index": 120,
                "end_index": 154,
                "dilatect_content": "trim(inflation_adjusted_gross, '$')",
                "feature": "trim(X)trim(X,Y)"
            },
            {
                "start_index": 212,
                "end_index": 246,
                "dilatect_content": "trim(inflation_adjusted_gross, '$')",
                "feature": "trim(X)trim(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 34,
                "end_index": 72,
                "dilatect_content": "trim(\"inflation_adjusted_gross\", '$')",
                "feature": "trim(X) trim(X, Y)"
            },
            {
                "start_index": 124,
                "end_index": 162,
                "dilatect_content": "trim(\"inflation_adjusted_gross\", '$')",
                "feature": "trim(X) trim(X, Y)"
            },
            {
                "start_index": 220,
                "end_index": 258,
                "dilatect_content": "trim(\"inflation_adjusted_gross\", '$')",
                "feature": "trim(X) trim(X, Y)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "trim(X)trim(X,Y)",
                "explanation": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "trim(X) trim(X, Y)",
                "explanation": "The trim(X, Y) function returns a string formed by removing any and all characters that appear in Y from both ends of X. If the Y argument is omitted, trim(X) removes spaces from both ends of X.",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"movies_total_gross\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING, primary key)\n(\"genre\", STRING)\n(\"MPAA_rating\", STRING)\n(\"total_gross\", STRING)\n(\"inflation_adjusted_gross\", STRING)\n"
        ]
    },
    {
        "sql_id": 345,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(COUNT(CASE WHEN CAST(REPLACE(trim(T1.total_gross, '$'), ',', '') AS REAL) > 100000000 THEN T1.movie_title ELSE NULL END) AS REAL) * 100 / COUNT(T1.movie_title) FROM movies_total_gross AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE T2.director = 'Gary Trousdale'",
        "target_query": "SELECT CAST(COUNT(CASE WHEN CAST(REPLACE(trim(\"T1\".\"total_gross\", '$'), ',', '') AS REAL) > 100000000 THEN \"T1\".\"movie_title\" ELSE NULL END) AS REAL) * 100 / COUNT(\"T1\".\"movie_title\") FROM \"movies_total_gross\" AS \"T1\" INNER JOIN \"director\" AS \"T2\" ON \"T1\".\"movie_title\" = \"T2\".\"name\" WHERE \"T2\".\"director\" = 'Gary Trousdale'",
        "semantic_equivalent_type": "approximate_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 41,
                "end_index": 65,
                "dilatect_content": "trim(T1.total_gross, '$')",
                "feature": "trim(X)trim(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 41,
                "end_index": 73,
                "dilatect_content": "trim(\"T1\".\"total_gross\", '$')",
                "feature": "trim(X) trim(X, Y)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "trim(X)trim(X,Y)",
                "explanation": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "trim(X) trim(X, Y)",
                "explanation": "The trim(X, Y) function returns a string formed by removing any and all characters that appear in Y from both ends of X. If the Y argument is omitted, trim(X) removes spaces from both ends of X.",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n",
            "Table: `director`\nColumns:\n(`name`, text, primary key)\n(`director`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"movies_total_gross\"\nColumns:\n(\"movie_title\", STRING, primary key)\n(\"release_date\", STRING, primary key)\n(\"genre\", STRING)\n(\"MPAA_rating\", STRING)\n(\"total_gross\", STRING)\n(\"inflation_adjusted_gross\", STRING)\n",
            "Table: \"director\"\nColumns:\n(\"name\", STRING, primary key)\n(\"director\", STRING)\n"
        ]
    },
    {
        "sql_id": 346,
        "database_name": "legislator",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.first_name, T1.last_name FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T2.party = 'Republican' AND T1.gender_bio = 'F' AND T2.END > DATE() GROUP BY T1.bioguide_id",
        "target_query": "SELECT MIN(T1.\"first_name\") AS \"first_name\", MIN(T1.\"last_name\") AS \"last_name\" FROM \"current\" AS T1 INNER JOIN \"current_terms\" AS T2 ON T1.\"bioguide_id\" = T2.\"bioguide\" WHERE T2.\"party\" = 'Republican' AND T1.\"gender_bio\" = 'F' AND T2.\"_end\" > sys.timestamp_to_str(CURRENT_DATE, '%Y-%m-%d') GROUP BY T1.\"bioguide_id\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 186,
                "end_index": 191,
                "dilatect_content": "DATE()",
                "feature": "date(time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 266,
                "end_index": 311,
                "dilatect_content": "sys.timestamp_to_str(CURRENT_DATE, '%Y-%m-%d')",
                "feature": "sys.timestamp_to_str(date-value, '%Y-%m-%d')"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "date(time-value, modifier, modifier, ...)",
                "explanation": "The date(time-value, modifier, modifier, ...) function returns the date as text in the format: YYYY-MM-DD. The function accepts a time-value and zero or more modifiers to alter the date.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day', 'start of month').\nReturns: A string in the format YYYY-MM-DD.",
                "examples": [
                    "SELECT date(); -- Returns the current date.",
                    "SELECT date('now', '+1 day'); -- Returns the date one day after the current date.",
                    "SELECT date('2024-08-21'); -- Returns '2024-08-21'."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(date-value, '%Y-%m-%d')",
                "explanation": "In MonetDB, the DATE function from SQLite can be emulated using sys.timestamp_to_str to convert a DATE or TIMESTAMP value into a string in the format YYYY-MM-DD. Date arithmetic (e.g., +1 day) can be performed using sql_add with INTERVAL expressions.",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_DATE, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_DATE, interval '1' day), '%Y-%m-%d'); -- Returns the date one day after the current date.",
                    "SELECT sys.timestamp_to_str(date '2024-08-21', '%Y-%m-%d'); -- Returns '2024-08-21'."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `current`\nColumns:\n(`ballotpedia_id`, text)\n(`bioguide_id`, text, primary key)\n(`birthday_bio`, date)\n(`cspan_id`, real, primary key)\n(`fec_id`, text)\n(`first_name`, text)\n(`gender_bio`, text)\n(`google_entity_id_id`, text)\n(`govtrack_id`, integer)\n(`house_history_id`, real)\n(`icpsr_id`, real)\n(`last_name`, text)\n(`lis_id`, text)\n(`maplight_id`, real)\n(`middle_name`, text)\n(`nickname_name`, text)\n(`official_full_name`, text)\n(`opensecrets_id`, text)\n(`religion_bio`, text)\n(`suffix_name`, text)\n(`thomas_id`, integer)\n(`votesmart_id`, real)\n(`wikidata_id`, text)\n(`wikipedia_id`, text)\n",
            "Table: `current-terms`\nColumns:\n(`address`, text)\n(`bioguide`, text, primary key)\n(`caucus`, text)\n(`chamber`, text)\n(`class`, real)\n(`contact_form`, text)\n(`district`, real)\n(`end`, text, primary key)\n(`fax`, text)\n(`last`, text)\n(`name`, text)\n(`office`, text)\n(`party`, text)\n(`party_affiliations`, text)\n(`phone`, text)\n(`relation`, text)\n(`rss_url`, text)\n(`start`, text)\n(`state`, text)\n(`state_rank`, text)\n(`title`, text)\n(`type`, text)\n(`url`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"current\"\nColumns:\n(\"ballotpedia_id\", STRING)\n(\"bioguide_id\", STRING, primary key)\n(\"birthday_bio\", DATE)\n(\"cspan_id\", DOUBLE PRECISION, primary key)\n(\"fec_id\", STRING)\n(\"first_name\", STRING)\n(\"gender_bio\", STRING)\n(\"google_entity_id_id\", STRING)\n(\"govtrack_id\", BIGINT)\n(\"house_history_id\", DOUBLE PRECISION)\n(\"icpsr_id\", DOUBLE PRECISION)\n(\"last_name\", STRING)\n(\"lis_id\", STRING)\n(\"maplight_id\", DOUBLE PRECISION)\n(\"middle_name\", STRING)\n(\"nickname_name\", STRING)\n(\"official_full_name\", STRING)\n(\"opensecrets_id\", STRING)\n(\"religion_bio\", STRING)\n(\"suffix_name\", STRING)\n(\"thomas_id\", BIGINT)\n(\"votesmart_id\", DOUBLE PRECISION)\n(\"wikidata_id\", STRING)\n(\"wikipedia_id\", STRING)\n",
            "Table: \"current_terms\"\nColumns:\n(\"address\", STRING)\n(\"bioguide\", STRING, primary key)\n(\"caucus\", STRING)\n(\"chamber\", STRING)\n(\"class\", DOUBLE PRECISION)\n(\"contact_form\", STRING)\n(\"district\", DOUBLE PRECISION)\n(\"_end\", STRING, primary key)\n(\"fax\", STRING)\n(\"_last\", STRING)\n(\"name\", STRING)\n(\"office\", STRING)\n(\"party\", STRING)\n(\"party_affiliations\", STRING)\n(\"phone\", STRING)\n(\"relation\", STRING)\n(\"rss_url\", STRING)\n(\"start\", STRING)\n(\"state\", STRING)\n(\"state_rank\", STRING)\n(\"title\", STRING)\n(\"type\", STRING)\n(\"url\", STRING)\n"
        ]
    },
    {
        "sql_id": 348,
        "database_name": "legislator",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(CASE WHEN T2.type = 'sen' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.type = 'rep' THEN 1 ELSE 0 END) FROM historical AS T1 INNER JOIN `historical-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.gender_bio = 'F' AND strftime('%Y', T1.birthday_bio) BETWEEN '1930' AND '1970'",
        "target_query": "SELECT SUM(CASE WHEN T2.\"type\" = 'sen' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.\"type\" = 'rep' THEN 1 ELSE 0 END) FROM \"historical\" AS T1 INNER JOIN \"historical_terms\" AS T2 ON T1.\"bioguide_id\" = T2.\"bioguide\" WHERE T1.\"gender_bio\" = 'F' AND sys.timestamp_to_str(T1.\"birthday_bio\", '%Y') BETWEEN '1930' AND '1970';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 227,
                "end_index": 257,
                "dilatect_content": "strftime('%Y', T1.birthday_bio)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 253,
                "end_index": 299,
                "dilatect_content": "sys.timestamp_to_str(T1.\"birthday_bio\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `historical`\nColumns:\n(`ballotpedia_id`, text)\n(`bioguide_id`, text, primary key)\n(`bioguide_previous_id`, text)\n(`birthday_bio`, text)\n(`cspan_id`, text)\n(`fec_id`, text)\n(`first_name`, text)\n(`gender_bio`, text)\n(`google_entity_id_id`, text)\n(`govtrack_id`, integer)\n(`house_history_alternate_id`, text)\n(`house_history_id`, real)\n(`icpsr_id`, real)\n(`last_name`, text)\n(`lis_id`, text)\n(`maplight_id`, text)\n(`middle_name`, text)\n(`nickname_name`, text)\n(`official_full_name`, text)\n(`opensecrets_id`, text)\n(`religion_bio`, text)\n(`suffix_name`, text)\n(`thomas_id`, text)\n(`votesmart_id`, text)\n(`wikidata_id`, text)\n(`wikipedia_id`, text)\n",
            "Table: `historical-terms`\nColumns:\n(`address`, text)\n(`bioguide`, text, primary key)\n(`chamber`, text)\n(`class`, real)\n(`contact_form`, text)\n(`district`, real)\n(`end`, text)\n(`fax`, text)\n(`last`, text)\n(`middle`, text)\n(`name`, text)\n(`office`, text)\n(`party`, text)\n(`party_affiliations`, text)\n(`phone`, text)\n(`relation`, text)\n(`rss_url`, text)\n(`start`, text)\n(`state`, text)\n(`state_rank`, text)\n(`title`, text)\n(`type`, text)\n(`url`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"historical\"\nColumns:\n(\"ballotpedia_id\", STRING)\n(\"bioguide_id\", STRING, primary key)\n(\"bioguide_previous_id\", STRING)\n(\"birthday_bio\", STRING)\n(\"cspan_id\", STRING)\n(\"fec_id\", STRING)\n(\"first_name\", STRING)\n(\"gender_bio\", STRING)\n(\"google_entity_id_id\", STRING)\n(\"govtrack_id\", BIGINT)\n(\"house_history_alternate_id\", STRING)\n(\"house_history_id\", DOUBLE PRECISION)\n(\"icpsr_id\", DOUBLE PRECISION)\n(\"last_name\", STRING)\n(\"lis_id\", STRING)\n(\"maplight_id\", STRING)\n(\"middle_name\", STRING)\n(\"nickname_name\", STRING)\n(\"official_full_name\", STRING)\n(\"opensecrets_id\", STRING)\n(\"religion_bio\", STRING)\n(\"suffix_name\", STRING)\n(\"thomas_id\", STRING)\n(\"votesmart_id\", STRING)\n(\"wikidata_id\", STRING)\n(\"wikipedia_id\", STRING)\n",
            "Table: \"historical_terms\"\nColumns:\n(\"address\", STRING)\n(\"bioguide\", STRING, primary key)\n(\"chamber\", STRING)\n(\"class\", DOUBLE PRECISION)\n(\"contact_form\", STRING)\n(\"district\", DOUBLE PRECISION)\n(\"_end\", STRING)\n(\"fax\", STRING)\n(\"_last\", STRING)\n(\"middle\", STRING)\n(\"name\", STRING)\n(\"office\", STRING)\n(\"party\", STRING)\n(\"party_affiliations\", STRING)\n(\"phone\", STRING)\n(\"relation\", STRING)\n(\"rss_url\", STRING)\n(\"start\", STRING)\n(\"state\", STRING)\n(\"state_rank\", STRING)\n(\"title\", STRING)\n(\"type\", STRING)\n(\"url\", STRING)\n"
        ]
    },
    {
        "sql_id": 349,
        "database_name": "legislator",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(CASE WHEN T2.party = 'Independent' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.party) FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.gender_bio = 'M' AND strftime('%Y', T1.birthday_bio) BETWEEN '1955' AND '1965'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"party\" = 'Independent' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T2\".\"party\") FROM \"current\" AS \"T1\" INNER JOIN \"current_terms\" AS \"T2\" ON \"T1\".\"bioguide_id\" = \"T2\".\"bioguide\" WHERE \"T1\".\"gender_bio\" = 'M' AND sys.timestamp_to_str(\"T1\".\"birthday_bio\", '%Y') BETWEEN '1955' AND '1965';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 217,
                "end_index": 247,
                "dilatect_content": "strftime('%Y', T1.birthday_bio)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 271,
                "end_index": 321,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"birthday_bio\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `current`\nColumns:\n(`ballotpedia_id`, text)\n(`bioguide_id`, text, primary key)\n(`birthday_bio`, date)\n(`cspan_id`, real, primary key)\n(`fec_id`, text)\n(`first_name`, text)\n(`gender_bio`, text)\n(`google_entity_id_id`, text)\n(`govtrack_id`, integer)\n(`house_history_id`, real)\n(`icpsr_id`, real)\n(`last_name`, text)\n(`lis_id`, text)\n(`maplight_id`, real)\n(`middle_name`, text)\n(`nickname_name`, text)\n(`official_full_name`, text)\n(`opensecrets_id`, text)\n(`religion_bio`, text)\n(`suffix_name`, text)\n(`thomas_id`, integer)\n(`votesmart_id`, real)\n(`wikidata_id`, text)\n(`wikipedia_id`, text)\n",
            "Table: `current-terms`\nColumns:\n(`address`, text)\n(`bioguide`, text, primary key)\n(`caucus`, text)\n(`chamber`, text)\n(`class`, real)\n(`contact_form`, text)\n(`district`, real)\n(`end`, text, primary key)\n(`fax`, text)\n(`last`, text)\n(`name`, text)\n(`office`, text)\n(`party`, text)\n(`party_affiliations`, text)\n(`phone`, text)\n(`relation`, text)\n(`rss_url`, text)\n(`start`, text)\n(`state`, text)\n(`state_rank`, text)\n(`title`, text)\n(`type`, text)\n(`url`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"current\"\nColumns:\n(\"ballotpedia_id\", STRING)\n(\"bioguide_id\", STRING, primary key)\n(\"birthday_bio\", DATE)\n(\"cspan_id\", DOUBLE PRECISION, primary key)\n(\"fec_id\", STRING)\n(\"first_name\", STRING)\n(\"gender_bio\", STRING)\n(\"google_entity_id_id\", STRING)\n(\"govtrack_id\", BIGINT)\n(\"house_history_id\", DOUBLE PRECISION)\n(\"icpsr_id\", DOUBLE PRECISION)\n(\"last_name\", STRING)\n(\"lis_id\", STRING)\n(\"maplight_id\", DOUBLE PRECISION)\n(\"middle_name\", STRING)\n(\"nickname_name\", STRING)\n(\"official_full_name\", STRING)\n(\"opensecrets_id\", STRING)\n(\"religion_bio\", STRING)\n(\"suffix_name\", STRING)\n(\"thomas_id\", BIGINT)\n(\"votesmart_id\", DOUBLE PRECISION)\n(\"wikidata_id\", STRING)\n(\"wikipedia_id\", STRING)\n",
            "Table: \"current_terms\"\nColumns:\n(\"address\", STRING)\n(\"bioguide\", STRING, primary key)\n(\"caucus\", STRING)\n(\"chamber\", STRING)\n(\"class\", DOUBLE PRECISION)\n(\"contact_form\", STRING)\n(\"district\", DOUBLE PRECISION)\n(\"_end\", STRING, primary key)\n(\"fax\", STRING)\n(\"_last\", STRING)\n(\"name\", STRING)\n(\"office\", STRING)\n(\"party\", STRING)\n(\"party_affiliations\", STRING)\n(\"phone\", STRING)\n(\"relation\", STRING)\n(\"rss_url\", STRING)\n(\"start\", STRING)\n(\"state\", STRING)\n(\"state_rank\", STRING)\n(\"title\", STRING)\n(\"type\", STRING)\n(\"url\", STRING)\n"
        ]
    },
    {
        "sql_id": 350,
        "database_name": "legislator",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(*) FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE STRFTIME('%Y', T2.start) = '2015' AND T2.state = 'CA' AND T1.gender_bio = 'F'",
        "target_query": "SELECT COUNT(*) FROM \"current\" AS T1 INNER JOIN \"current_terms\" AS T2 ON T1.\"bioguide_id\" = T2.\"bioguide\" WHERE sys.timestamp_to_str(T2.\"start\", '%Y') = '2015' AND T2.\"state\" = 'CA' AND T1.\"gender_bio\" = 'F';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 106,
                "end_index": 129,
                "dilatect_content": "STRFTIME('%Y', T2.start)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 120,
                "end_index": 159,
                "dilatect_content": "sys.timestamp_to_str(T2.\"start\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `current`\nColumns:\n(`ballotpedia_id`, text)\n(`bioguide_id`, text, primary key)\n(`birthday_bio`, date)\n(`cspan_id`, real, primary key)\n(`fec_id`, text)\n(`first_name`, text)\n(`gender_bio`, text)\n(`google_entity_id_id`, text)\n(`govtrack_id`, integer)\n(`house_history_id`, real)\n(`icpsr_id`, real)\n(`last_name`, text)\n(`lis_id`, text)\n(`maplight_id`, real)\n(`middle_name`, text)\n(`nickname_name`, text)\n(`official_full_name`, text)\n(`opensecrets_id`, text)\n(`religion_bio`, text)\n(`suffix_name`, text)\n(`thomas_id`, integer)\n(`votesmart_id`, real)\n(`wikidata_id`, text)\n(`wikipedia_id`, text)\n",
            "Table: `current-terms`\nColumns:\n(`address`, text)\n(`bioguide`, text, primary key)\n(`caucus`, text)\n(`chamber`, text)\n(`class`, real)\n(`contact_form`, text)\n(`district`, real)\n(`end`, text, primary key)\n(`fax`, text)\n(`last`, text)\n(`name`, text)\n(`office`, text)\n(`party`, text)\n(`party_affiliations`, text)\n(`phone`, text)\n(`relation`, text)\n(`rss_url`, text)\n(`start`, text)\n(`state`, text)\n(`state_rank`, text)\n(`title`, text)\n(`type`, text)\n(`url`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"current\"\nColumns:\n(\"ballotpedia_id\", STRING)\n(\"bioguide_id\", STRING, primary key)\n(\"birthday_bio\", DATE)\n(\"cspan_id\", DOUBLE PRECISION, primary key)\n(\"fec_id\", STRING)\n(\"first_name\", STRING)\n(\"gender_bio\", STRING)\n(\"google_entity_id_id\", STRING)\n(\"govtrack_id\", BIGINT)\n(\"house_history_id\", DOUBLE PRECISION)\n(\"icpsr_id\", DOUBLE PRECISION)\n(\"last_name\", STRING)\n(\"lis_id\", STRING)\n(\"maplight_id\", DOUBLE PRECISION)\n(\"middle_name\", STRING)\n(\"nickname_name\", STRING)\n(\"official_full_name\", STRING)\n(\"opensecrets_id\", STRING)\n(\"religion_bio\", STRING)\n(\"suffix_name\", STRING)\n(\"thomas_id\", BIGINT)\n(\"votesmart_id\", DOUBLE PRECISION)\n(\"wikidata_id\", STRING)\n(\"wikipedia_id\", STRING)\n",
            "Table: \"current_terms\"\nColumns:\n(\"address\", STRING)\n(\"bioguide\", STRING, primary key)\n(\"caucus\", STRING)\n(\"chamber\", STRING)\n(\"class\", DOUBLE PRECISION)\n(\"contact_form\", STRING)\n(\"district\", DOUBLE PRECISION)\n(\"_end\", STRING, primary key)\n(\"fax\", STRING)\n(\"_last\", STRING)\n(\"name\", STRING)\n(\"office\", STRING)\n(\"party\", STRING)\n(\"party_affiliations\", STRING)\n(\"phone\", STRING)\n(\"relation\", STRING)\n(\"rss_url\", STRING)\n(\"start\", STRING)\n(\"state\", STRING)\n(\"state_rank\", STRING)\n(\"title\", STRING)\n(\"type\", STRING)\n(\"url\", STRING)\n"
        ]
    },
    {
        "sql_id": 351,
        "database_name": "legislator",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(CASE WHEN strftime('%Y', T2.start) BETWEEN '2000' AND '2017' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.bioguide_id) FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide",
        "target_query": "SELECT CAST(SUM(CASE WHEN sys.timestamp_to_str(T2.start, '%Y') BETWEEN '2000' AND '2017' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.\"bioguide_id\") FROM \"current\" AS T1 INNER JOIN \"current_terms\" AS T2 ON T1.\"bioguide_id\" = T2.\"bioguide\"",
        "semantic_equivalent_type": "approximate_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 26,
                "end_index": 49,
                "dilatect_content": "strftime('%Y', T2.start)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 26,
                "end_index": 61,
                "dilatect_content": "sys.timestamp_to_str(T2.start, '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `current`\nColumns:\n(`ballotpedia_id`, text)\n(`bioguide_id`, text, primary key)\n(`birthday_bio`, date)\n(`cspan_id`, real, primary key)\n(`fec_id`, text)\n(`first_name`, text)\n(`gender_bio`, text)\n(`google_entity_id_id`, text)\n(`govtrack_id`, integer)\n(`house_history_id`, real)\n(`icpsr_id`, real)\n(`last_name`, text)\n(`lis_id`, text)\n(`maplight_id`, real)\n(`middle_name`, text)\n(`nickname_name`, text)\n(`official_full_name`, text)\n(`opensecrets_id`, text)\n(`religion_bio`, text)\n(`suffix_name`, text)\n(`thomas_id`, integer)\n(`votesmart_id`, real)\n(`wikidata_id`, text)\n(`wikipedia_id`, text)\n",
            "Table: `current-terms`\nColumns:\n(`address`, text)\n(`bioguide`, text, primary key)\n(`caucus`, text)\n(`chamber`, text)\n(`class`, real)\n(`contact_form`, text)\n(`district`, real)\n(`end`, text, primary key)\n(`fax`, text)\n(`last`, text)\n(`name`, text)\n(`office`, text)\n(`party`, text)\n(`party_affiliations`, text)\n(`phone`, text)\n(`relation`, text)\n(`rss_url`, text)\n(`start`, text)\n(`state`, text)\n(`state_rank`, text)\n(`title`, text)\n(`type`, text)\n(`url`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"current\"\nColumns:\n(\"ballotpedia_id\", STRING)\n(\"bioguide_id\", STRING, primary key)\n(\"birthday_bio\", DATE)\n(\"cspan_id\", DOUBLE PRECISION, primary key)\n(\"fec_id\", STRING)\n(\"first_name\", STRING)\n(\"gender_bio\", STRING)\n(\"google_entity_id_id\", STRING)\n(\"govtrack_id\", BIGINT)\n(\"house_history_id\", DOUBLE PRECISION)\n(\"icpsr_id\", DOUBLE PRECISION)\n(\"last_name\", STRING)\n(\"lis_id\", STRING)\n(\"maplight_id\", DOUBLE PRECISION)\n(\"middle_name\", STRING)\n(\"nickname_name\", STRING)\n(\"official_full_name\", STRING)\n(\"opensecrets_id\", STRING)\n(\"religion_bio\", STRING)\n(\"suffix_name\", STRING)\n(\"thomas_id\", BIGINT)\n(\"votesmart_id\", DOUBLE PRECISION)\n(\"wikidata_id\", STRING)\n(\"wikipedia_id\", STRING)\n",
            "Table: \"current_terms\"\nColumns:\n(\"address\", STRING)\n(\"bioguide\", STRING, primary key)\n(\"caucus\", STRING)\n(\"chamber\", STRING)\n(\"class\", DOUBLE PRECISION)\n(\"contact_form\", STRING)\n(\"district\", DOUBLE PRECISION)\n(\"_end\", STRING, primary key)\n(\"fax\", STRING)\n(\"_last\", STRING)\n(\"name\", STRING)\n(\"office\", STRING)\n(\"party\", STRING)\n(\"party_affiliations\", STRING)\n(\"phone\", STRING)\n(\"relation\", STRING)\n(\"rss_url\", STRING)\n(\"start\", STRING)\n(\"state\", STRING)\n(\"state_rank\", STRING)\n(\"title\", STRING)\n(\"type\", STRING)\n(\"url\", STRING)\n"
        ]
    },
    {
        "sql_id": 352,
        "database_name": "legislator",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.official_full_name FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T2.party = 'Independent' AND strftime('%Y', T2.start) >= '2011' AND T2.type = 'sen' AND T2.caucus = 'Democrat'",
        "target_query": "SELECT \"T1\".\"official_full_name\" FROM \"current\" AS \"T1\" INNER JOIN \"current_terms\" AS \"T2\" ON \"T1\".\"bioguide_id\" = \"T2\".\"bioguide\" WHERE \"T2\".\"party\" = 'Independent' AND \"T2\".\"start\" >= '2011' AND \"T2\".\"type\" = 'sen' AND \"T2\".\"caucus\" = 'Democrat';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 148,
                "end_index": 171,
                "dilatect_content": "strftime('%Y', T2.start)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `current`\nColumns:\n(`ballotpedia_id`, text)\n(`bioguide_id`, text, primary key)\n(`birthday_bio`, date)\n(`cspan_id`, real, primary key)\n(`fec_id`, text)\n(`first_name`, text)\n(`gender_bio`, text)\n(`google_entity_id_id`, text)\n(`govtrack_id`, integer)\n(`house_history_id`, real)\n(`icpsr_id`, real)\n(`last_name`, text)\n(`lis_id`, text)\n(`maplight_id`, real)\n(`middle_name`, text)\n(`nickname_name`, text)\n(`official_full_name`, text)\n(`opensecrets_id`, text)\n(`religion_bio`, text)\n(`suffix_name`, text)\n(`thomas_id`, integer)\n(`votesmart_id`, real)\n(`wikidata_id`, text)\n(`wikipedia_id`, text)\n",
            "Table: `current-terms`\nColumns:\n(`address`, text)\n(`bioguide`, text, primary key)\n(`caucus`, text)\n(`chamber`, text)\n(`class`, real)\n(`contact_form`, text)\n(`district`, real)\n(`end`, text, primary key)\n(`fax`, text)\n(`last`, text)\n(`name`, text)\n(`office`, text)\n(`party`, text)\n(`party_affiliations`, text)\n(`phone`, text)\n(`relation`, text)\n(`rss_url`, text)\n(`start`, text)\n(`state`, text)\n(`state_rank`, text)\n(`title`, text)\n(`type`, text)\n(`url`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"current\"\nColumns:\n(\"ballotpedia_id\", STRING)\n(\"bioguide_id\", STRING, primary key)\n(\"birthday_bio\", DATE)\n(\"cspan_id\", DOUBLE PRECISION, primary key)\n(\"fec_id\", STRING)\n(\"first_name\", STRING)\n(\"gender_bio\", STRING)\n(\"google_entity_id_id\", STRING)\n(\"govtrack_id\", BIGINT)\n(\"house_history_id\", DOUBLE PRECISION)\n(\"icpsr_id\", DOUBLE PRECISION)\n(\"last_name\", STRING)\n(\"lis_id\", STRING)\n(\"maplight_id\", DOUBLE PRECISION)\n(\"middle_name\", STRING)\n(\"nickname_name\", STRING)\n(\"official_full_name\", STRING)\n(\"opensecrets_id\", STRING)\n(\"religion_bio\", STRING)\n(\"suffix_name\", STRING)\n(\"thomas_id\", BIGINT)\n(\"votesmart_id\", DOUBLE PRECISION)\n(\"wikidata_id\", STRING)\n(\"wikipedia_id\", STRING)\n",
            "Table: \"current_terms\"\nColumns:\n(\"address\", STRING)\n(\"bioguide\", STRING, primary key)\n(\"caucus\", STRING)\n(\"chamber\", STRING)\n(\"class\", DOUBLE PRECISION)\n(\"contact_form\", STRING)\n(\"district\", DOUBLE PRECISION)\n(\"_end\", STRING, primary key)\n(\"fax\", STRING)\n(\"_last\", STRING)\n(\"name\", STRING)\n(\"office\", STRING)\n(\"party\", STRING)\n(\"party_affiliations\", STRING)\n(\"phone\", STRING)\n(\"relation\", STRING)\n(\"rss_url\", STRING)\n(\"start\", STRING)\n(\"state\", STRING)\n(\"state_rank\", STRING)\n(\"title\", STRING)\n(\"type\", STRING)\n(\"url\", STRING)\n"
        ]
    },
    {
        "sql_id": 353,
        "database_name": "legislator",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT CASE WHEN SUM(CAST(strftime('%Y', T2.end) AS int) - CAST(strftime('%Y', T2.start) AS int)) = 26 THEN T1.official_full_name END FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide GROUP BY T1.official_full_name, T2.district HAVING COUNT(T1.official_full_name) = 13",
        "target_query": "SELECT DISTINCT CASE WHEN SUM(CAST(sys.timestamp_to_str(T2.\"_end\", '%Y') AS int) - CAST(sys.timestamp_to_str(T2.\"start\", '%Y') AS int)) = 26 THEN T1.\"official_full_name\" END FROM \"current\" AS T1 INNER JOIN \"current_terms\" AS T2 ON T1.\"bioguide_id\" = T2.\"bioguide\" GROUP BY T1.\"official_full_name\", T2.\"district\" HAVING COUNT(T1.\"official_full_name\") = 13;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 35,
                "end_index": 56,
                "dilatect_content": "strftime('%Y', T2.end)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 73,
                "end_index": 96,
                "dilatect_content": "strftime('%Y', T2.start)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 35,
                "end_index": 73,
                "dilatect_content": "sys.timestamp_to_str(T2.\"_end\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 90,
                "end_index": 129,
                "dilatect_content": "sys.timestamp_to_str(T2.\"start\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `current`\nColumns:\n(`ballotpedia_id`, text)\n(`bioguide_id`, text, primary key)\n(`birthday_bio`, date)\n(`cspan_id`, real, primary key)\n(`fec_id`, text)\n(`first_name`, text)\n(`gender_bio`, text)\n(`google_entity_id_id`, text)\n(`govtrack_id`, integer)\n(`house_history_id`, real)\n(`icpsr_id`, real)\n(`last_name`, text)\n(`lis_id`, text)\n(`maplight_id`, real)\n(`middle_name`, text)\n(`nickname_name`, text)\n(`official_full_name`, text)\n(`opensecrets_id`, text)\n(`religion_bio`, text)\n(`suffix_name`, text)\n(`thomas_id`, integer)\n(`votesmart_id`, real)\n(`wikidata_id`, text)\n(`wikipedia_id`, text)\n",
            "Table: `current-terms`\nColumns:\n(`address`, text)\n(`bioguide`, text, primary key)\n(`caucus`, text)\n(`chamber`, text)\n(`class`, real)\n(`contact_form`, text)\n(`district`, real)\n(`end`, text, primary key)\n(`fax`, text)\n(`last`, text)\n(`name`, text)\n(`office`, text)\n(`party`, text)\n(`party_affiliations`, text)\n(`phone`, text)\n(`relation`, text)\n(`rss_url`, text)\n(`start`, text)\n(`state`, text)\n(`state_rank`, text)\n(`title`, text)\n(`type`, text)\n(`url`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"current\"\nColumns:\n(\"ballotpedia_id\", STRING)\n(\"bioguide_id\", STRING, primary key)\n(\"birthday_bio\", DATE)\n(\"cspan_id\", DOUBLE PRECISION, primary key)\n(\"fec_id\", STRING)\n(\"first_name\", STRING)\n(\"gender_bio\", STRING)\n(\"google_entity_id_id\", STRING)\n(\"govtrack_id\", BIGINT)\n(\"house_history_id\", DOUBLE PRECISION)\n(\"icpsr_id\", DOUBLE PRECISION)\n(\"last_name\", STRING)\n(\"lis_id\", STRING)\n(\"maplight_id\", DOUBLE PRECISION)\n(\"middle_name\", STRING)\n(\"nickname_name\", STRING)\n(\"official_full_name\", STRING)\n(\"opensecrets_id\", STRING)\n(\"religion_bio\", STRING)\n(\"suffix_name\", STRING)\n(\"thomas_id\", BIGINT)\n(\"votesmart_id\", DOUBLE PRECISION)\n(\"wikidata_id\", STRING)\n(\"wikipedia_id\", STRING)\n",
            "Table: \"current_terms\"\nColumns:\n(\"address\", STRING)\n(\"bioguide\", STRING, primary key)\n(\"caucus\", STRING)\n(\"chamber\", STRING)\n(\"class\", DOUBLE PRECISION)\n(\"contact_form\", STRING)\n(\"district\", DOUBLE PRECISION)\n(\"_end\", STRING, primary key)\n(\"fax\", STRING)\n(\"_last\", STRING)\n(\"name\", STRING)\n(\"office\", STRING)\n(\"party\", STRING)\n(\"party_affiliations\", STRING)\n(\"phone\", STRING)\n(\"relation\", STRING)\n(\"rss_url\", STRING)\n(\"start\", STRING)\n(\"state\", STRING)\n(\"state_rank\", STRING)\n(\"title\", STRING)\n(\"type\", STRING)\n(\"url\", STRING)\n"
        ]
    },
    {
        "sql_id": 354,
        "database_name": "legislator",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(T3.result) FROM ( SELECT CASE WHEN SUM(CAST(strftime('%Y', T2.`end`) AS int) - CAST(strftime('%Y', T2.start) AS int)) > 10 THEN 1 ELSE 0 END AS result FROM current AS T1 INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.gender_bio = 'F' AND T2.state = 'CA' AND T2.type = 'rep' ) AS T3",
        "target_query": "SELECT SUM(T3.result) FROM ( SELECT CASE WHEN SUM(CAST(sys.timestamp_to_str(CAST(T2.\"_end\" AS TIMESTAMP), '%Y') AS INT) - CAST(sys.timestamp_to_str(CAST(T2.start AS TIMESTAMP), '%Y') AS INT)) > 10 THEN 1 ELSE 0 END AS result FROM \"current\" AS T1 INNER JOIN \"current_terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.gender_bio = 'F' AND T2.state = 'CA' AND T2.type = 'rep' ) AS T3;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 55,
                "end_index": 78,
                "dilatect_content": "strftime('%Y', T2.`end`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 95,
                "end_index": 118,
                "dilatect_content": "strftime('%Y', T2.start)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 55,
                "end_index": 112,
                "dilatect_content": "sys.timestamp_to_str(CAST(T2.\"_end\" AS TIMESTAMP), '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 129,
                "end_index": 183,
                "dilatect_content": "sys.timestamp_to_str(CAST(T2.start AS TIMESTAMP), '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `current`\nColumns:\n(`ballotpedia_id`, text)\n(`bioguide_id`, text, primary key)\n(`birthday_bio`, date)\n(`cspan_id`, real, primary key)\n(`fec_id`, text)\n(`first_name`, text)\n(`gender_bio`, text)\n(`google_entity_id_id`, text)\n(`govtrack_id`, integer)\n(`house_history_id`, real)\n(`icpsr_id`, real)\n(`last_name`, text)\n(`lis_id`, text)\n(`maplight_id`, real)\n(`middle_name`, text)\n(`nickname_name`, text)\n(`official_full_name`, text)\n(`opensecrets_id`, text)\n(`religion_bio`, text)\n(`suffix_name`, text)\n(`thomas_id`, integer)\n(`votesmart_id`, real)\n(`wikidata_id`, text)\n(`wikipedia_id`, text)\n",
            "Table: `current-terms`\nColumns:\n(`address`, text)\n(`bioguide`, text, primary key)\n(`caucus`, text)\n(`chamber`, text)\n(`class`, real)\n(`contact_form`, text)\n(`district`, real)\n(`end`, text, primary key)\n(`fax`, text)\n(`last`, text)\n(`name`, text)\n(`office`, text)\n(`party`, text)\n(`party_affiliations`, text)\n(`phone`, text)\n(`relation`, text)\n(`rss_url`, text)\n(`start`, text)\n(`state`, text)\n(`state_rank`, text)\n(`title`, text)\n(`type`, text)\n(`url`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"current\"\nColumns:\n(\"ballotpedia_id\", STRING)\n(\"bioguide_id\", STRING, primary key)\n(\"birthday_bio\", DATE)\n(\"cspan_id\", DOUBLE PRECISION, primary key)\n(\"fec_id\", STRING)\n(\"first_name\", STRING)\n(\"gender_bio\", STRING)\n(\"google_entity_id_id\", STRING)\n(\"govtrack_id\", BIGINT)\n(\"house_history_id\", DOUBLE PRECISION)\n(\"icpsr_id\", DOUBLE PRECISION)\n(\"last_name\", STRING)\n(\"lis_id\", STRING)\n(\"maplight_id\", DOUBLE PRECISION)\n(\"middle_name\", STRING)\n(\"nickname_name\", STRING)\n(\"official_full_name\", STRING)\n(\"opensecrets_id\", STRING)\n(\"religion_bio\", STRING)\n(\"suffix_name\", STRING)\n(\"thomas_id\", BIGINT)\n(\"votesmart_id\", DOUBLE PRECISION)\n(\"wikidata_id\", STRING)\n(\"wikipedia_id\", STRING)\n",
            "Table: \"current_terms\"\nColumns:\n(\"address\", STRING)\n(\"bioguide\", STRING, primary key)\n(\"caucus\", STRING)\n(\"chamber\", STRING)\n(\"class\", DOUBLE PRECISION)\n(\"contact_form\", STRING)\n(\"district\", DOUBLE PRECISION)\n(\"_end\", STRING, primary key)\n(\"fax\", STRING)\n(\"_last\", STRING)\n(\"name\", STRING)\n(\"office\", STRING)\n(\"party\", STRING)\n(\"party_affiliations\", STRING)\n(\"phone\", STRING)\n(\"relation\", STRING)\n(\"rss_url\", STRING)\n(\"start\", STRING)\n(\"state\", STRING)\n(\"state_rank\", STRING)\n(\"title\", STRING)\n(\"type\", STRING)\n(\"url\", STRING)\n"
        ]
    },
    {
        "sql_id": 355,
        "database_name": "legislator",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CASE WHEN SUM(CAST(strftime('%Y', T2.end) AS int) - CAST(strftime('%Y', T2.start) AS int)) = 14 THEN official_full_name END FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.religion_bio = 'Lutheran' AND T2.state = 'OH' AND T2.type = 'rep'",
        "target_query": "SELECT \"T1\".\"official_full_name\" FROM \"current\" AS \"T1\" INNER JOIN \"current_terms\" AS \"T2\" ON \"T1\".\"bioguide_id\" = \"T2\".\"bioguide\" WHERE \"T1\".\"religion_bio\" = 'Lutheran' AND \"T2\".\"state\" = 'OH' AND \"T2\".\"type\" = 'rep' GROUP BY \"T1\".\"official_full_name\" HAVING SUM(CAST(sys.timestamp_to_str(CAST(\"T2\".\"_end\" AS TIMESTAMP), '%Y') AS INT) - CAST(sys.timestamp_to_str(CAST(\"T2\".\"start\" AS TIMESTAMP), '%Y') AS INT)) = 14;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 26,
                "end_index": 47,
                "dilatect_content": "strftime('%Y', T2.end)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 64,
                "end_index": 87,
                "dilatect_content": "strftime('%Y', T2.start)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 305,
                "end_index": 366,
                "dilatect_content": "sys.timestamp_to_str(CAST(\"T2\".\"_end\" AS TIMESTAMP), '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 383,
                "end_index": 445,
                "dilatect_content": "sys.timestamp_to_str(CAST(\"T2\".\"start\" AS TIMESTAMP), '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `current`\nColumns:\n(`ballotpedia_id`, text)\n(`bioguide_id`, text, primary key)\n(`birthday_bio`, date)\n(`cspan_id`, real, primary key)\n(`fec_id`, text)\n(`first_name`, text)\n(`gender_bio`, text)\n(`google_entity_id_id`, text)\n(`govtrack_id`, integer)\n(`house_history_id`, real)\n(`icpsr_id`, real)\n(`last_name`, text)\n(`lis_id`, text)\n(`maplight_id`, real)\n(`middle_name`, text)\n(`nickname_name`, text)\n(`official_full_name`, text)\n(`opensecrets_id`, text)\n(`religion_bio`, text)\n(`suffix_name`, text)\n(`thomas_id`, integer)\n(`votesmart_id`, real)\n(`wikidata_id`, text)\n(`wikipedia_id`, text)\n",
            "Table: `current-terms`\nColumns:\n(`address`, text)\n(`bioguide`, text, primary key)\n(`caucus`, text)\n(`chamber`, text)\n(`class`, real)\n(`contact_form`, text)\n(`district`, real)\n(`end`, text, primary key)\n(`fax`, text)\n(`last`, text)\n(`name`, text)\n(`office`, text)\n(`party`, text)\n(`party_affiliations`, text)\n(`phone`, text)\n(`relation`, text)\n(`rss_url`, text)\n(`start`, text)\n(`state`, text)\n(`state_rank`, text)\n(`title`, text)\n(`type`, text)\n(`url`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"current\"\nColumns:\n(\"ballotpedia_id\", STRING)\n(\"bioguide_id\", STRING, primary key)\n(\"birthday_bio\", DATE)\n(\"cspan_id\", DOUBLE PRECISION, primary key)\n(\"fec_id\", STRING)\n(\"first_name\", STRING)\n(\"gender_bio\", STRING)\n(\"google_entity_id_id\", STRING)\n(\"govtrack_id\", BIGINT)\n(\"house_history_id\", DOUBLE PRECISION)\n(\"icpsr_id\", DOUBLE PRECISION)\n(\"last_name\", STRING)\n(\"lis_id\", STRING)\n(\"maplight_id\", DOUBLE PRECISION)\n(\"middle_name\", STRING)\n(\"nickname_name\", STRING)\n(\"official_full_name\", STRING)\n(\"opensecrets_id\", STRING)\n(\"religion_bio\", STRING)\n(\"suffix_name\", STRING)\n(\"thomas_id\", BIGINT)\n(\"votesmart_id\", DOUBLE PRECISION)\n(\"wikidata_id\", STRING)\n(\"wikipedia_id\", STRING)\n",
            "Table: \"current_terms\"\nColumns:\n(\"address\", STRING)\n(\"bioguide\", STRING, primary key)\n(\"caucus\", STRING)\n(\"chamber\", STRING)\n(\"class\", DOUBLE PRECISION)\n(\"contact_form\", STRING)\n(\"district\", DOUBLE PRECISION)\n(\"_end\", STRING, primary key)\n(\"fax\", STRING)\n(\"_last\", STRING)\n(\"name\", STRING)\n(\"office\", STRING)\n(\"party\", STRING)\n(\"party_affiliations\", STRING)\n(\"phone\", STRING)\n(\"relation\", STRING)\n(\"rss_url\", STRING)\n(\"start\", STRING)\n(\"state\", STRING)\n(\"state_rank\", STRING)\n(\"title\", STRING)\n(\"type\", STRING)\n(\"url\", STRING)\n"
        ]
    },
    {
        "sql_id": 356,
        "database_name": "legislator",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(*) FROM current WHERE strftime('%Y', birthday_bio) > '1960' AND google_entity_id_id IS NULL",
        "target_query": "SELECT COUNT(*) FROM \"current\" WHERE sys.timestamp_to_str(\"birthday_bio\", '%Y') > '1960' AND \"google_entity_id_id\" IS NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 35,
                "end_index": 62,
                "dilatect_content": "strftime('%Y', birthday_bio)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 39,
                "end_index": 82,
                "dilatect_content": "sys.timestamp_to_str(\"birthday_bio\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `current`\nColumns:\n(`ballotpedia_id`, text)\n(`bioguide_id`, text, primary key)\n(`birthday_bio`, date)\n(`cspan_id`, real, primary key)\n(`fec_id`, text)\n(`first_name`, text)\n(`gender_bio`, text)\n(`google_entity_id_id`, text)\n(`govtrack_id`, integer)\n(`house_history_id`, real)\n(`icpsr_id`, real)\n(`last_name`, text)\n(`lis_id`, text)\n(`maplight_id`, real)\n(`middle_name`, text)\n(`nickname_name`, text)\n(`official_full_name`, text)\n(`opensecrets_id`, text)\n(`religion_bio`, text)\n(`suffix_name`, text)\n(`thomas_id`, integer)\n(`votesmart_id`, real)\n(`wikidata_id`, text)\n(`wikipedia_id`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"current\"\nColumns:\n(\"ballotpedia_id\", STRING)\n(\"bioguide_id\", STRING, primary key)\n(\"birthday_bio\", DATE)\n(\"cspan_id\", DOUBLE PRECISION, primary key)\n(\"fec_id\", STRING)\n(\"first_name\", STRING)\n(\"gender_bio\", STRING)\n(\"google_entity_id_id\", STRING)\n(\"govtrack_id\", BIGINT)\n(\"house_history_id\", DOUBLE PRECISION)\n(\"icpsr_id\", DOUBLE PRECISION)\n(\"last_name\", STRING)\n(\"lis_id\", STRING)\n(\"maplight_id\", DOUBLE PRECISION)\n(\"middle_name\", STRING)\n(\"nickname_name\", STRING)\n(\"official_full_name\", STRING)\n(\"opensecrets_id\", STRING)\n(\"religion_bio\", STRING)\n(\"suffix_name\", STRING)\n(\"thomas_id\", BIGINT)\n(\"votesmart_id\", DOUBLE PRECISION)\n(\"wikidata_id\", STRING)\n(\"wikipedia_id\", STRING)\n"
        ]
    },
    {
        "sql_id": 357,
        "database_name": "beer_factory",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN `transaction` AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.First = 'Frank-Paul' AND T1.Last = 'Santangelo' AND STRFTIME('%Y-%m', T2.TransactionDate) = '2014-07'",
        "target_query": "SELECT COUNT(\"T1\".\"CustomerID\") FROM \"customers\" AS \"T1\" INNER JOIN \"_transaction\" AS \"T2\" ON \"T1\".\"CustomerID\" = \"T2\".\"CustomerID\" WHERE \"T1\".\"_First\" = 'Frank-Paul' AND \"T1\".\"_Last\" = 'Santangelo' AND sys.timestamp_to_str(\"T2\".\"TransactionDate\", '%Y-%m') = '2014-07';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 174,
                "end_index": 210,
                "dilatect_content": "STRFTIME('%Y-%m', T2.TransactionDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 231,
                "end_index": 287,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"TransactionDate\", '%Y-%m')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customers`\nColumns:\n(`CustomerID`, integer, primary key)\n(`First`, text)\n(`Last`, text)\n(`StreetAddress`, text)\n(`City`, text)\n(`State`, text)\n(`ZipCode`, integer)\n(`Email`, text)\n(`PhoneNumber`, text)\n(`FirstPurchaseDate`, date)\n(`SubscribedToEmailList`, text)\n(`Gender`, text)\n",
            "Table: `transaction`\nColumns:\n(`TransactionID`, integer, primary key)\n(`CreditCardNumber`, integer)\n(`CustomerID`, integer)\n(`TransactionDate`, date)\n(`CreditCardType`, text)\n(`LocationID`, integer)\n(`RootBeerID`, integer)\n(`PurchasePrice`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"customers\"\nColumns:\n(\"CustomerID\", BIGINT, primary key)\n(\"_First\", STRING)\n(\"_Last\", STRING)\n(\"StreetAddress\", STRING)\n(\"City\", STRING)\n(\"State\", STRING)\n(\"ZipCode\", BIGINT)\n(\"Email\", STRING)\n(\"PhoneNumber\", STRING)\n(\"FirstPurchaseDate\", DATE)\n(\"SubscribedToEmailList\", STRING)\n(\"Gender\", STRING)\n",
            "Table: \"_transaction\"\nColumns:\n(\"TransactionID\", BIGINT, primary key)\n(\"CreditCardNumber\", BIGINT)\n(\"CustomerID\", BIGINT)\n(\"TransactionDate\", DATE)\n(\"CreditCardType\", STRING)\n(\"LocationID\", BIGINT)\n(\"RootBeerID\", BIGINT)\n(\"PurchasePrice\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 358,
        "database_name": "beer_factory",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN `transaction` AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Gender = 'M' AND STRFTIME('%Y-%m', T2.TransactionDate) = '2014-07'",
        "target_query": "SELECT COUNT(\"T1\".\"CustomerID\") FROM \"customers\" AS \"T1\" INNER JOIN \"_transaction\" AS \"T2\" ON \"T1\".\"CustomerID\" = \"T2\".\"CustomerID\" WHERE \"T1\".\"Gender\" = 'M' AND sys.timestamp_to_str(\"T2\".\"TransactionDate\", '%Y-%m') = '2014-07';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 139,
                "end_index": 175,
                "dilatect_content": "STRFTIME('%Y-%m', T2.TransactionDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 186,
                "end_index": 242,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"TransactionDate\", '%Y-%m')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customers`\nColumns:\n(`CustomerID`, integer, primary key)\n(`First`, text)\n(`Last`, text)\n(`StreetAddress`, text)\n(`City`, text)\n(`State`, text)\n(`ZipCode`, integer)\n(`Email`, text)\n(`PhoneNumber`, text)\n(`FirstPurchaseDate`, date)\n(`SubscribedToEmailList`, text)\n(`Gender`, text)\n",
            "Table: `transaction`\nColumns:\n(`TransactionID`, integer, primary key)\n(`CreditCardNumber`, integer)\n(`CustomerID`, integer)\n(`TransactionDate`, date)\n(`CreditCardType`, text)\n(`LocationID`, integer)\n(`RootBeerID`, integer)\n(`PurchasePrice`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"customers\"\nColumns:\n(\"CustomerID\", BIGINT, primary key)\n(\"_First\", STRING)\n(\"_Last\", STRING)\n(\"StreetAddress\", STRING)\n(\"City\", STRING)\n(\"State\", STRING)\n(\"ZipCode\", BIGINT)\n(\"Email\", STRING)\n(\"PhoneNumber\", STRING)\n(\"FirstPurchaseDate\", DATE)\n(\"SubscribedToEmailList\", STRING)\n(\"Gender\", STRING)\n",
            "Table: \"_transaction\"\nColumns:\n(\"TransactionID\", BIGINT, primary key)\n(\"CreditCardNumber\", BIGINT)\n(\"CustomerID\", BIGINT)\n(\"TransactionDate\", DATE)\n(\"CreditCardType\", STRING)\n(\"LocationID\", BIGINT)\n(\"RootBeerID\", BIGINT)\n(\"PurchasePrice\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 359,
        "database_name": "beer_factory",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN `transaction` AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.SubscribedToEmailList = 'TRUE' AND T2.CreditCardType = 'Visa' AND STRFTIME('%Y-%m', T2.TransactionDate) = '2014-07'",
        "target_query": "SELECT COUNT(T1.\"CustomerID\") FROM \"customers\" AS T1 INNER JOIN \"_transaction\" AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\" WHERE T1.\"SubscribedToEmailList\" = 'TRUE' AND T2.\"CreditCardType\" = 'Visa' AND sys.timestamp_to_str(T2.\"TransactionDate\", '%Y-%m') = '2014-07';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 188,
                "end_index": 224,
                "dilatect_content": "STRFTIME('%Y-%m', T2.TransactionDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 215,
                "end_index": 267,
                "dilatect_content": "sys.timestamp_to_str(T2.\"TransactionDate\", '%Y-%m')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customers`\nColumns:\n(`CustomerID`, integer, primary key)\n(`First`, text)\n(`Last`, text)\n(`StreetAddress`, text)\n(`City`, text)\n(`State`, text)\n(`ZipCode`, integer)\n(`Email`, text)\n(`PhoneNumber`, text)\n(`FirstPurchaseDate`, date)\n(`SubscribedToEmailList`, text)\n(`Gender`, text)\n",
            "Table: `transaction`\nColumns:\n(`TransactionID`, integer, primary key)\n(`CreditCardNumber`, integer)\n(`CustomerID`, integer)\n(`TransactionDate`, date)\n(`CreditCardType`, text)\n(`LocationID`, integer)\n(`RootBeerID`, integer)\n(`PurchasePrice`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"customers\"\nColumns:\n(\"CustomerID\", BIGINT, primary key)\n(\"_First\", STRING)\n(\"_Last\", STRING)\n(\"StreetAddress\", STRING)\n(\"City\", STRING)\n(\"State\", STRING)\n(\"ZipCode\", BIGINT)\n(\"Email\", STRING)\n(\"PhoneNumber\", STRING)\n(\"FirstPurchaseDate\", DATE)\n(\"SubscribedToEmailList\", STRING)\n(\"Gender\", STRING)\n",
            "Table: \"_transaction\"\nColumns:\n(\"TransactionID\", BIGINT, primary key)\n(\"CreditCardNumber\", BIGINT)\n(\"CustomerID\", BIGINT)\n(\"TransactionDate\", DATE)\n(\"CreditCardType\", STRING)\n(\"LocationID\", BIGINT)\n(\"RootBeerID\", BIGINT)\n(\"PurchasePrice\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 360,
        "database_name": "beer_factory",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.First, T1.Last FROM customers AS T1 INNER JOIN `transaction` AS T2 ON T1.CustomerID = T2.CustomerID WHERE STRFTIME('%Y-%m', T2.TransactionDate) = '2014-08' GROUP BY T1.CustomerID ORDER BY COUNT(T2.CustomerID) DESC LIMIT 1",
        "target_query": "SELECT T1.\"_First\", T1.\"_Last\" FROM \"customers\" AS T1 INNER JOIN \"_transaction\" AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\" WHERE sys.timestamp_to_str(T2.\"TransactionDate\", '%Y-%m') = '2014-08' GROUP BY T1.\"CustomerID\", T1.\"_First\", T1.\"_Last\" ORDER BY COUNT(T2.\"CustomerID\") DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 116,
                "end_index": 152,
                "dilatect_content": "STRFTIME('%Y-%m', T2.TransactionDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 141,
                "end_index": 193,
                "dilatect_content": "sys.timestamp_to_str(T2.\"TransactionDate\", '%Y-%m')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customers`\nColumns:\n(`CustomerID`, integer, primary key)\n(`First`, text)\n(`Last`, text)\n(`StreetAddress`, text)\n(`City`, text)\n(`State`, text)\n(`ZipCode`, integer)\n(`Email`, text)\n(`PhoneNumber`, text)\n(`FirstPurchaseDate`, date)\n(`SubscribedToEmailList`, text)\n(`Gender`, text)\n",
            "Table: `transaction`\nColumns:\n(`TransactionID`, integer, primary key)\n(`CreditCardNumber`, integer)\n(`CustomerID`, integer)\n(`TransactionDate`, date)\n(`CreditCardType`, text)\n(`LocationID`, integer)\n(`RootBeerID`, integer)\n(`PurchasePrice`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"customers\"\nColumns:\n(\"CustomerID\", BIGINT, primary key)\n(\"_First\", STRING)\n(\"_Last\", STRING)\n(\"StreetAddress\", STRING)\n(\"City\", STRING)\n(\"State\", STRING)\n(\"ZipCode\", BIGINT)\n(\"Email\", STRING)\n(\"PhoneNumber\", STRING)\n(\"FirstPurchaseDate\", DATE)\n(\"SubscribedToEmailList\", STRING)\n(\"Gender\", STRING)\n",
            "Table: \"_transaction\"\nColumns:\n(\"TransactionID\", BIGINT, primary key)\n(\"CreditCardNumber\", BIGINT)\n(\"CustomerID\", BIGINT)\n(\"TransactionDate\", DATE)\n(\"CreditCardType\", STRING)\n(\"LocationID\", BIGINT)\n(\"RootBeerID\", BIGINT)\n(\"PurchasePrice\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 361,
        "database_name": "beer_factory",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T3.BrandName FROM rootbeer AS T1 INNER JOIN rootbeerreview AS T2 ON T1.BrandID = T2.BrandID INNER JOIN rootbeerbrand AS T3 ON T1.BrandID = T3.BrandID WHERE T2.StarRating = 5 AND strftime('%Y', T2.ReviewDate) = '2012' GROUP BY T1.BrandID ORDER BY COUNT(T2.BrandID) DESC LIMIT 1",
        "target_query": "SELECT MAX(T3.\"BrandName\") FROM \"rootbeer\" AS T1 INNER JOIN \"rootbeerreview\" AS T2 ON T1.\"BrandID\" = T2.\"BrandID\" INNER JOIN \"rootbeerbrand\" AS T3 ON T1.\"BrandID\" = T3.\"BrandID\" WHERE T2.\"StarRating\" = 5 AND sys.timestamp_to_str(T2.\"ReviewDate\", '%Y') = '2012' GROUP BY T1.\"BrandID\" ORDER BY COUNT(T2.\"BrandID\") DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 185,
                "end_index": 213,
                "dilatect_content": "strftime('%Y', T2.ReviewDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 226,
                "end_index": 270,
                "dilatect_content": "sys.timestamp_to_str(T2.\"ReviewDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `rootbeer`\nColumns:\n(`RootBeerID`, integer, primary key)\n(`BrandID`, integer)\n(`ContainerType`, text)\n(`LocationID`, integer)\n(`PurchaseDate`, date)\n",
            "Table: `rootbeerreview`\nColumns:\n(`CustomerID`, integer, primary key)\n(`BrandID`, integer, primary key)\n(`StarRating`, integer)\n(`ReviewDate`, date)\n(`Review`, text)\n",
            "Table: `rootbeerbrand`\nColumns:\n(`BrandID`, integer, primary key)\n(`BrandName`, text)\n(`FirstBrewedYear`, integer)\n(`BreweryName`, text)\n(`City`, text)\n(`State`, text)\n(`Country`, text)\n(`Description`, text)\n(`CaneSugar`, text)\n(`CornSyrup`, text)\n(`Honey`, text)\n(`ArtificialSweetener`, text)\n(`Caffeinated`, text)\n(`Alcoholic`, text)\n(`AvailableInCans`, text)\n(`AvailableInBottles`, text)\n(`AvailableInKegs`, text)\n(`Website`, text)\n(`FacebookPage`, text)\n(`Twitter`, text)\n(`WholesaleCost`, real)\n(`CurrentRetailPrice`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"rootbeer\"\nColumns:\n(\"RootBeerID\", BIGINT, primary key)\n(\"BrandID\", BIGINT)\n(\"ContainerType\", STRING)\n(\"LocationID\", BIGINT)\n(\"PurchaseDate\", DATE)\n",
            "Table: \"rootbeerreview\"\nColumns:\n(\"CustomerID\", BIGINT, primary key)\n(\"BrandID\", BIGINT, primary key)\n(\"StarRating\", BIGINT)\n(\"ReviewDate\", DATE)\n(\"Review\", STRING)\n",
            "Table: \"rootbeerbrand\"\nColumns:\n(\"BrandID\", BIGINT, primary key)\n(\"BrandName\", STRING)\n(\"FirstBrewedYear\", BIGINT)\n(\"BreweryName\", STRING)\n(\"City\", STRING)\n(\"State\", STRING)\n(\"Country\", STRING)\n(\"Description\", STRING)\n(\"CaneSugar\", STRING)\n(\"CornSyrup\", STRING)\n(\"Honey\", STRING)\n(\"ArtificialSweetener\", STRING)\n(\"Caffeinated\", STRING)\n(\"Alcoholic\", STRING)\n(\"AvailableInCans\", STRING)\n(\"AvailableInBottles\", STRING)\n(\"AvailableInKegs\", STRING)\n(\"Website\", STRING)\n(\"FacebookPage\", STRING)\n(\"Twitter\", STRING)\n(\"WholesaleCost\", DOUBLE PRECISION)\n(\"CurrentRetailPrice\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 363,
        "database_name": "sales",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.SalesID FROM Sales AS T1 INNER JOIN Employees AS T2 ON T1.SalesPersonID = T2.EmployeeID WHERE SUBSTR(T2.FirstName, 1, 1) = 's'",
        "target_query": "SELECT \"T1\".\"SalesID\" FROM \"Sales\" AS \"T1\" INNER JOIN \"Employees\" AS \"T2\" ON \"T1\".\"SalesPersonID\" = \"T2\".\"EmployeeID\" WHERE substring(\"T2\".\"FirstName\" from 1 for 1) = 's';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 104,
                "end_index": 129,
                "dilatect_content": "SUBSTR(T2.FirstName, 1, 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 144,
                "end_index": 187,
                "dilatect_content": "substring(\"T2\".\"FirstName\" from 1 for 1)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales`\nColumns:\n(`SalesID`, integer, primary key)\n(`SalesPersonID`, integer)\n(`CustomerID`, integer)\n(`ProductID`, integer)\n(`Quantity`, integer)\n",
            "Table: `Employees`\nColumns:\n(`EmployeeID`, integer, primary key)\n(`FirstName`, text)\n(`MiddleInitial`, text)\n(`LastName`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Sales\"\nColumns:\n(\"SalesID\", BIGINT, primary key)\n(\"SalesPersonID\", BIGINT)\n(\"CustomerID\", BIGINT)\n(\"ProductID\", BIGINT)\n(\"Quantity\", BIGINT)\n",
            "Table: \"Employees\"\nColumns:\n(\"EmployeeID\", BIGINT, primary key)\n(\"FirstName\", STRING)\n(\"MiddleInitial\", STRING)\n(\"LastName\", STRING)\n"
        ]
    },
    {
        "sql_id": 364,
        "database_name": "sales",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(T2.FirstName = 'Morningstar', 1, 0)) + SUM(IIF(T2.FirstName = 'Heather', 1, 0)) + SUM(IIF(T2.FirstName = 'Dean', 1, 0)) AS num FROM Sales AS T1 INNER JOIN Employees AS T2 ON T1.SalesPersonID = T2.EmployeeID",
        "target_query": "SELECT SUM(CASE WHEN \"T2\".\"FirstName\" = 'Morningstar' THEN 1 ELSE 0 END) + SUM(CASE WHEN \"T2\".\"FirstName\" = 'Heather' THEN 1 ELSE 0 END) + SUM(CASE WHEN \"T2\".\"FirstName\" = 'Dean' THEN 1 ELSE 0 END) AS \"num\" FROM \"Sales\" AS \"T1\" INNER JOIN \"Employees\" AS \"T2\" ON \"T1\".\"SalesPersonID\" = \"T2\".\"EmployeeID\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 49,
                "dilatect_content": "IIF(T2.FirstName = 'Morningstar', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 58,
                "end_index": 92,
                "dilatect_content": "IIF(T2.FirstName = 'Heather', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 101,
                "end_index": 132,
                "dilatect_content": "IIF(T2.FirstName = 'Dean', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 74,
                "dilatect_content": "CASE WHEN \"T2\".\"FirstName\" = 'Morningstar' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 83,
                "end_index": 142,
                "dilatect_content": "CASE WHEN \"T2\".\"FirstName\" = 'Heather' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 151,
                "end_index": 207,
                "dilatect_content": "CASE WHEN \"T2\".\"FirstName\" = 'Dean' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales`\nColumns:\n(`SalesID`, integer, primary key)\n(`SalesPersonID`, integer)\n(`CustomerID`, integer)\n(`ProductID`, integer)\n(`Quantity`, integer)\n",
            "Table: `Employees`\nColumns:\n(`EmployeeID`, integer, primary key)\n(`FirstName`, text)\n(`MiddleInitial`, text)\n(`LastName`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Sales\"\nColumns:\n(\"SalesID\", BIGINT, primary key)\n(\"SalesPersonID\", BIGINT)\n(\"CustomerID\", BIGINT)\n(\"ProductID\", BIGINT)\n(\"Quantity\", BIGINT)\n",
            "Table: \"Employees\"\nColumns:\n(\"EmployeeID\", BIGINT, primary key)\n(\"FirstName\", STRING)\n(\"MiddleInitial\", STRING)\n(\"LastName\", STRING)\n"
        ]
    },
    {
        "sql_id": 365,
        "database_name": "sales",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT IIF(T1.ProductID = 498, 'YES', 'NO') FROM Sales AS T1 INNER JOIN Customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.FirstName = 'Alex'",
        "target_query": "SELECT CASE WHEN \"T1\".\"ProductID\" = 498 THEN 'YES' ELSE 'NO' END FROM \"Sales\" AS \"T1\" INNER JOIN \"Customers\" AS \"T2\" ON \"T1\".\"CustomerID\" = \"T2\".\"CustomerID\" WHERE \"T2\".\"FirstName\" = 'Alex';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 42,
                "dilatect_content": "IIF(T1.ProductID = 498, 'YES', 'NO')",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 67,
                "dilatect_content": "CASE WHEN \"T1\".\"ProductID\" = 498 THEN 'YES' ELSE 'NO' END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales`\nColumns:\n(`SalesID`, integer, primary key)\n(`SalesPersonID`, integer)\n(`CustomerID`, integer)\n(`ProductID`, integer)\n(`Quantity`, integer)\n",
            "Table: `Customers`\nColumns:\n(`CustomerID`, integer, primary key)\n(`FirstName`, text)\n(`MiddleInitial`, text)\n(`LastName`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Sales\"\nColumns:\n(\"SalesID\", BIGINT, primary key)\n(\"SalesPersonID\", BIGINT)\n(\"CustomerID\", BIGINT)\n(\"ProductID\", BIGINT)\n(\"Quantity\", BIGINT)\n",
            "Table: \"Customers\"\nColumns:\n(\"CustomerID\", BIGINT, primary key)\n(\"FirstName\", STRING)\n(\"MiddleInitial\", STRING)\n(\"LastName\", STRING)\n"
        ]
    },
    {
        "sql_id": 366,
        "database_name": "sales",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(T2.Quantity) FROM Products AS T1 INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID WHERE SUBSTR(T1.Name, 1, 1) = 'C'",
        "target_query": "SELECT SUM(\"T2\".\"Quantity\") FROM \"Products\" AS \"T1\" INNER JOIN \"Sales\" AS \"T2\" ON \"T1\".\"ProductID\" = \"T2\".\"ProductID\" WHERE substring(\"T1\".\"Name\" from 1 for 1) = 'C';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 104,
                "end_index": 124,
                "dilatect_content": "SUBSTR(T1.Name, 1, 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 144,
                "end_index": 182,
                "dilatect_content": "substring(\"T1\".\"Name\" from 1 for 1)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Products`\nColumns:\n(`ProductID`, integer, primary key)\n(`Name`, text)\n(`Price`, real)\n",
            "Table: `Sales`\nColumns:\n(`SalesID`, integer, primary key)\n(`SalesPersonID`, integer)\n(`CustomerID`, integer)\n(`ProductID`, integer)\n(`Quantity`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"Products\"\nColumns:\n(\"ProductID\", BIGINT, primary key)\n(\"Name\", STRING)\n(\"Price\", DOUBLE PRECISION)\n",
            "Table: \"Sales\"\nColumns:\n(\"SalesID\", BIGINT, primary key)\n(\"SalesPersonID\", BIGINT)\n(\"CustomerID\", BIGINT)\n(\"ProductID\", BIGINT)\n(\"Quantity\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 367,
        "database_name": "sales",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT IIF(SUM(IIF(T1.Name = 'HL Mountain Frame - Silver, 42', T2.SalesID, 0)) - SUM(IIF(T1.Name = 'HL Mountain Frame - Black, 42', T2.SalesID, 0)) > 0, 'Silver', 'Black') FROM Products AS T1 INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID",
        "target_query": "SELECT CASE WHEN SUM(CASE WHEN \"T1\".\"Name\" = 'HL Mountain Frame - Silver, 42' THEN \"T2\".\"SalesID\" ELSE 0 END) - SUM(CASE WHEN \"T1\".\"Name\" = 'HL Mountain Frame - Black, 42' THEN \"T2\".\"SalesID\" ELSE 0 END) > 0 THEN 'Silver' ELSE 'Black' END FROM \"Products\" AS \"T1\" INNER JOIN \"Sales\" AS \"T2\" ON \"T1\".\"ProductID\" = \"T2\".\"ProductID\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 170,
                "dilatect_content": "IIF(SUM(IIF(T1.Name = 'HL Mountain Frame - Silver, 42', T2.SalesID, 0)) - SUM(IIF(T1.Name = 'HL Mountain Frame - Black, 42', T2.SalesID, 0)) > 0, 'Silver', 'Black')",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 15,
                "end_index": 76,
                "dilatect_content": "IIF(T1.Name = 'HL Mountain Frame - Silver, 42', T2.SalesID, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 85,
                "end_index": 145,
                "dilatect_content": "IIF(T1.Name = 'HL Mountain Frame - Black, 42', T2.SalesID, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 253,
                "dilatect_content": "CASE WHEN SUM(CASE WHEN \"T1\".\"Name\" = 'HL Mountain Frame - Silver, 42' THEN \"T2\".\"SalesID\" ELSE 0 END) - SUM(CASE WHEN \"T1\".\"Name\" = 'HL Mountain Frame - Black, 42' THEN \"T2\".\"SalesID\" ELSE 0 END) > 0 THEN 'Silver' ELSE 'Black' END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 21,
                "end_index": 115,
                "dilatect_content": "CASE WHEN \"T1\".\"Name\" = 'HL Mountain Frame - Silver, 42' THEN \"T2\".\"SalesID\" ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 124,
                "end_index": 217,
                "dilatect_content": "CASE WHEN \"T1\".\"Name\" = 'HL Mountain Frame - Black, 42' THEN \"T2\".\"SalesID\" ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Products`\nColumns:\n(`ProductID`, integer, primary key)\n(`Name`, text)\n(`Price`, real)\n",
            "Table: `Sales`\nColumns:\n(`SalesID`, integer, primary key)\n(`SalesPersonID`, integer)\n(`CustomerID`, integer)\n(`ProductID`, integer)\n(`Quantity`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"Products\"\nColumns:\n(\"ProductID\", BIGINT, primary key)\n(\"Name\", STRING)\n(\"Price\", DOUBLE PRECISION)\n",
            "Table: \"Sales\"\nColumns:\n(\"SalesID\", BIGINT, primary key)\n(\"SalesPersonID\", BIGINT)\n(\"CustomerID\", BIGINT)\n(\"ProductID\", BIGINT)\n(\"Quantity\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 368,
        "database_name": "sales",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T3.FirstName = 'Albert' AND T3.MiddleInitial = 'I' AND T3.LastName = 'Ringer', 1, 0)) AS REAL) * 100 / COUNT(T2.CustomerID) FROM Products AS T1 INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID INNER JOIN Employees AS T3 ON T2.SalesPersonID = T3.EmployeeID WHERE T1.Name = 'ML Bottom Bracket'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T3\".\"FirstName\" = 'Albert' AND \"T3\".\"MiddleInitial\" = 'I' AND \"T3\".\"LastName\" = 'Ringer' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T2\".\"CustomerID\") FROM \"Products\" AS \"T1\" INNER JOIN \"Sales\" AS \"T2\" ON \"T1\".\"ProductID\" = \"T2\".\"ProductID\" INNER JOIN \"Employees\" AS \"T3\" ON \"T2\".\"SalesPersonID\" = \"T3\".\"EmployeeID\" WHERE \"T1\".\"Name\" = 'ML Bottom Bracket';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 103,
                "dilatect_content": "IIF(T3.FirstName = 'Albert' AND T3.MiddleInitial = 'I' AND T3.LastName = 'Ringer', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 144,
                "dilatect_content": "CASE WHEN \"T3\".\"FirstName\" = 'Albert' AND \"T3\".\"MiddleInitial\" = 'I' AND \"T3\".\"LastName\" = 'Ringer' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Products`\nColumns:\n(`ProductID`, integer, primary key)\n(`Name`, text)\n(`Price`, real)\n",
            "Table: `Sales`\nColumns:\n(`SalesID`, integer, primary key)\n(`SalesPersonID`, integer)\n(`CustomerID`, integer)\n(`ProductID`, integer)\n(`Quantity`, integer)\n",
            "Table: `Employees`\nColumns:\n(`EmployeeID`, integer, primary key)\n(`FirstName`, text)\n(`MiddleInitial`, text)\n(`LastName`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Products\"\nColumns:\n(\"ProductID\", BIGINT, primary key)\n(\"Name\", STRING)\n(\"Price\", DOUBLE PRECISION)\n",
            "Table: \"Sales\"\nColumns:\n(\"SalesID\", BIGINT, primary key)\n(\"SalesPersonID\", BIGINT)\n(\"CustomerID\", BIGINT)\n(\"ProductID\", BIGINT)\n(\"Quantity\", BIGINT)\n",
            "Table: \"Employees\"\nColumns:\n(\"EmployeeID\", BIGINT, primary key)\n(\"FirstName\", STRING)\n(\"MiddleInitial\", STRING)\n(\"LastName\", STRING)\n"
        ]
    },
    {
        "sql_id": 369,
        "database_name": "sales",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T1.Price = 0, T2.Quantity, 0)) AS REAL) * 100 / SUM(T2.Quantity)FROM Products AS T1 INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T1\".\"Price\" = 0 THEN \"T2\".\"Quantity\" ELSE 0 END) AS REAL) * 100 / SUM(\"T2\".\"Quantity\") FROM \"Products\" AS \"T1\" INNER JOIN \"Sales\" AS \"T2\" ON \"T1\".\"ProductID\" = \"T2\".\"ProductID\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 48,
                "dilatect_content": "IIF(T1.Price = 0, T2.Quantity, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 81,
                "dilatect_content": "CASE WHEN \"T1\".\"Price\" = 0 THEN \"T2\".\"Quantity\" ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Products`\nColumns:\n(`ProductID`, integer, primary key)\n(`Name`, text)\n(`Price`, real)\n",
            "Table: `Sales`\nColumns:\n(`SalesID`, integer, primary key)\n(`SalesPersonID`, integer)\n(`CustomerID`, integer)\n(`ProductID`, integer)\n(`Quantity`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"Products\"\nColumns:\n(\"ProductID\", BIGINT, primary key)\n(\"Name\", STRING)\n(\"Price\", DOUBLE PRECISION)\n",
            "Table: \"Sales\"\nColumns:\n(\"SalesID\", BIGINT, primary key)\n(\"SalesPersonID\", BIGINT)\n(\"CustomerID\", BIGINT)\n(\"ProductID\", BIGINT)\n(\"Quantity\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 370,
        "database_name": "sales",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T1.Name = 'Blade', T2.Quantity, 0)) AS REAL) * 100 / SUM(T2.Quantity) FROM Products AS T1 INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T1\".\"Name\" = 'Blade' THEN \"T2\".\"Quantity\" ELSE 0 END) AS REAL) * 100 / SUM(\"T2\".\"Quantity\") FROM \"Products\" AS \"T1\" INNER JOIN \"Sales\" AS \"T2\" ON \"T1\".\"ProductID\" = \"T2\".\"ProductID\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 53,
                "dilatect_content": "IIF(T1.Name = 'Blade', T2.Quantity, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 86,
                "dilatect_content": "CASE WHEN \"T1\".\"Name\" = 'Blade' THEN \"T2\".\"Quantity\" ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Products`\nColumns:\n(`ProductID`, integer, primary key)\n(`Name`, text)\n(`Price`, real)\n",
            "Table: `Sales`\nColumns:\n(`SalesID`, integer, primary key)\n(`SalesPersonID`, integer)\n(`CustomerID`, integer)\n(`ProductID`, integer)\n(`Quantity`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"Products\"\nColumns:\n(\"ProductID\", BIGINT, primary key)\n(\"Name\", STRING)\n(\"Price\", DOUBLE PRECISION)\n",
            "Table: \"Sales\"\nColumns:\n(\"SalesID\", BIGINT, primary key)\n(\"SalesPersonID\", BIGINT)\n(\"CustomerID\", BIGINT)\n(\"ProductID\", BIGINT)\n(\"Quantity\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 371,
        "database_name": "sales",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.Price BETWEEN 200 AND 300, 1, 0)) AS REAL) * 100 / COUNT(T2.Price) FROM Sales AS T1 INNER JOIN Products AS T2 ON T1.ProductID = T2.ProductID WHERE T1.SalesID BETWEEN 1 AND 200",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"Price\" BETWEEN 200 AND 300 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T2\".\"Price\") FROM \"Sales\" AS \"T1\" INNER JOIN \"Products\" AS \"T2\" ON \"T1\".\"ProductID\" = \"T2\".\"ProductID\" WHERE \"T1\".\"SalesID\" BETWEEN 1 AND 200;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 54,
                "dilatect_content": "IIF(T2.Price BETWEEN 200 AND 300, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 79,
                "dilatect_content": "CASE WHEN \"T2\".\"Price\" BETWEEN 200 AND 300 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales`\nColumns:\n(`SalesID`, integer, primary key)\n(`SalesPersonID`, integer)\n(`CustomerID`, integer)\n(`ProductID`, integer)\n(`Quantity`, integer)\n",
            "Table: `Products`\nColumns:\n(`ProductID`, integer, primary key)\n(`Name`, text)\n(`Price`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"Sales\"\nColumns:\n(\"SalesID\", BIGINT, primary key)\n(\"SalesPersonID\", BIGINT)\n(\"CustomerID\", BIGINT)\n(\"ProductID\", BIGINT)\n(\"Quantity\", BIGINT)\n",
            "Table: \"Products\"\nColumns:\n(\"ProductID\", BIGINT, primary key)\n(\"Name\", STRING)\n(\"Price\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 372,
        "database_name": "menu",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.name FROM MenuItem AS T1 INNER JOIN Dish AS T2 ON T2.id = T1.dish_id WHERE SUBSTR(T1.created_at, 7, 1) = '4'",
        "target_query": "SELECT \"T2\".\"name\" FROM \"MenuItem\" AS \"T1\" INNER JOIN \"Dish\" AS \"T2\" ON \"T2\".\"id\" = \"T1\".\"dish_id\" WHERE substring(\"T1\".\"created_at\" from 7 for 1) = '4';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 85,
                "end_index": 111,
                "dilatect_content": "SUBSTR(T1.created_at, 7, 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 125,
                "end_index": 169,
                "dilatect_content": "substring(\"T1\".\"created_at\" from 7 for 1)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `MenuItem`\nColumns:\n(`id`, integer, primary key)\n(`menu_page_id`, integer)\n(`price`, real)\n(`high_price`, real)\n(`dish_id`, integer)\n(`created_at`, text)\n(`updated_at`, text)\n(`xpos`, real)\n(`ypos`, real)\n",
            "Table: `Dish`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`description`, text)\n(`menus_appeared`, integer)\n(`times_appeared`, integer)\n(`first_appeared`, integer)\n(`last_appeared`, integer)\n(`lowest_price`, real)\n(`highest_price`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"MenuItem\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"menu_page_id\", BIGINT)\n(\"price\", DOUBLE PRECISION)\n(\"high_price\", DOUBLE PRECISION)\n(\"dish_id\", BIGINT)\n(\"created_at\", STRING)\n(\"updated_at\", STRING)\n(\"xpos\", DOUBLE PRECISION)\n(\"ypos\", DOUBLE PRECISION)\n",
            "Table: \"Dish\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"description\", STRING)\n(\"menus_appeared\", BIGINT)\n(\"times_appeared\", BIGINT)\n(\"first_appeared\", BIGINT)\n(\"last_appeared\", BIGINT)\n(\"lowest_price\", DOUBLE PRECISION)\n(\"highest_price\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 373,
        "database_name": "menu",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.name FROM Dish AS T1 INNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id WHERE SUBSTR(T2.created_at, 1, 4) = '2011' AND SUBSTR(T2.created_at, 7, 1) = '4' AND T1.highest_price IS NULL",
        "target_query": "SELECT \"T1\".\"name\" FROM \"Dish\" AS \"T1\" INNER JOIN \"MenuItem\" AS \"T2\" ON \"T1\".\"id\" = \"T2\".\"dish_id\" WHERE substring(\"T2\".\"created_at\" from 1 for 4) = '2011' AND substring(\"T2\".\"created_at\" from 7 for 1) = '4' AND \"T1\".\"highest_price\" IS NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 85,
                "end_index": 111,
                "dilatect_content": "SUBSTR(T2.created_at, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 126,
                "end_index": 152,
                "dilatect_content": "SUBSTR(T2.created_at, 7, 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 125,
                "end_index": 169,
                "dilatect_content": "substring(\"T2\".\"created_at\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 184,
                "end_index": 228,
                "dilatect_content": "substring(\"T2\".\"created_at\" from 7 for 1)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Dish`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`description`, text)\n(`menus_appeared`, integer)\n(`times_appeared`, integer)\n(`first_appeared`, integer)\n(`last_appeared`, integer)\n(`lowest_price`, real)\n(`highest_price`, real)\n",
            "Table: `MenuItem`\nColumns:\n(`id`, integer, primary key)\n(`menu_page_id`, integer)\n(`price`, real)\n(`high_price`, real)\n(`dish_id`, integer)\n(`created_at`, text)\n(`updated_at`, text)\n(`xpos`, real)\n(`ypos`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"Dish\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"description\", STRING)\n(\"menus_appeared\", BIGINT)\n(\"times_appeared\", BIGINT)\n(\"first_appeared\", BIGINT)\n(\"last_appeared\", BIGINT)\n(\"lowest_price\", DOUBLE PRECISION)\n(\"highest_price\", DOUBLE PRECISION)\n",
            "Table: \"MenuItem\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"menu_page_id\", BIGINT)\n(\"price\", DOUBLE PRECISION)\n(\"high_price\", DOUBLE PRECISION)\n(\"dish_id\", BIGINT)\n(\"created_at\", STRING)\n(\"updated_at\", STRING)\n(\"xpos\", DOUBLE PRECISION)\n(\"ypos\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 374,
        "database_name": "menu",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(*) FROM Menu WHERE call_number IS NULL AND strftime('%Y', date) < '1950'",
        "target_query": "SELECT COUNT(*) FROM \"Menu\" WHERE \"call_number\" IS NULL AND sys.timestamp_to_str(\"_date\", '%Y') < '1950';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 56,
                "end_index": 75,
                "dilatect_content": "strftime('%Y', date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 64,
                "end_index": 100,
                "dilatect_content": "sys.timestamp_to_str(\"_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Menu`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`sponsor`, text)\n(`event`, text)\n(`venue`, text)\n(`place`, text)\n(`physical_description`, text)\n(`occasion`, text)\n(`notes`, text)\n(`call_number`, text)\n(`keywords`, text)\n(`language`, text)\n(`date`, date)\n(`location`, text)\n(`location_type`, text)\n(`currency`, text)\n(`currency_symbol`, text)\n(`status`, text)\n(`page_count`, integer)\n(`dish_count`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"Menu\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"sponsor\", STRING)\n(\"event\", STRING)\n(\"venue\", STRING)\n(\"place\", STRING)\n(\"physical_description\", STRING)\n(\"occasion\", STRING)\n(\"notes\", STRING)\n(\"call_number\", STRING)\n(\"keywords\", STRING)\n(\"language\", STRING)\n(\"_date\", DATE)\n(\"location\", STRING)\n(\"location_type\", STRING)\n(\"currency\", STRING)\n(\"currency_symbol\", STRING)\n(\"_status\", STRING)\n(\"page_count\", BIGINT)\n(\"dish_count\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 375,
        "database_name": "shipping",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T2.ship_id) FROM customer AS T1 INNER JOIN shipment AS T2 ON T1.cust_id = T2.cust_id WHERE T1.cust_name = 'S K L Enterprises Inc' AND STRFTIME('%Y', T2.ship_date) = '2017'",
        "target_query": "SELECT COUNT(\"T2\".\"ship_id\") FROM \"customer\" AS \"T1\" INNER JOIN \"shipment\" AS \"T2\" ON \"T1\".\"cust_id\" = \"T2\".\"cust_id\" WHERE \"T1\".\"cust_name\" = 'S K L Enterprises Inc' AND sys.timestamp_to_str(\"T2\".\"ship_date\", '%Y') = '2017';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 147,
                "end_index": 174,
                "dilatect_content": "STRFTIME('%Y', T2.ship_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 195,
                "end_index": 242,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"ship_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`cust_id`, integer, primary key)\n(`cust_name`, text)\n(`annual_revenue`, integer)\n(`cust_type`, text)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, real)\n(`phone`, text)\n",
            "Table: `shipment`\nColumns:\n(`ship_id`, integer, primary key)\n(`cust_id`, integer)\n(`weight`, real)\n(`truck_id`, integer)\n(`driver_id`, integer)\n(`city_id`, integer)\n(`ship_date`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"customer\"\nColumns:\n(\"cust_id\", BIGINT, primary key)\n(\"cust_name\", STRING)\n(\"annual_revenue\", BIGINT)\n(\"cust_type\", STRING)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", DOUBLE PRECISION)\n(\"phone\", STRING)\n",
            "Table: \"shipment\"\nColumns:\n(\"ship_id\", BIGINT, primary key)\n(\"cust_id\", BIGINT)\n(\"weight\", DOUBLE PRECISION)\n(\"truck_id\", BIGINT)\n(\"driver_id\", BIGINT)\n(\"city_id\", BIGINT)\n(\"ship_date\", STRING)\n"
        ]
    },
    {
        "sql_id": 376,
        "database_name": "shipping",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(COUNTCUSID) FROM ( SELECT COUNT(T1.cust_id) AS COUNTCUSID FROM customer AS T1 INNER JOIN shipment AS T2 ON T1.cust_id = T2.cust_id WHERE STRFTIME('%Y', T2.ship_date) = '2017' AND T1.annual_revenue > 30000000 GROUP BY T1.cust_id HAVING COUNT(T2.ship_id) >= 1 ) T3",
        "target_query": "SELECT COUNT(\"COUNTCUSID\") FROM ( SELECT COUNT(\"T1\".\"cust_id\") AS \"COUNTCUSID\" FROM \"customer\" AS \"T1\" INNER JOIN \"shipment\" AS \"T2\" ON \"T1\".\"cust_id\" = \"T2\".\"cust_id\" WHERE sys.timestamp_to_str(\"T2\".\"ship_date\", '%Y') = '2017' AND \"T1\".\"annual_revenue\" > 30000000 GROUP BY \"T1\".\"cust_id\" HAVING COUNT(\"T2\".\"ship_id\") >= 1 ) AS \"T3\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 150,
                "end_index": 177,
                "dilatect_content": "STRFTIME('%Y', T2.ship_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 198,
                "end_index": 245,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"ship_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`cust_id`, integer, primary key)\n(`cust_name`, text)\n(`annual_revenue`, integer)\n(`cust_type`, text)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, real)\n(`phone`, text)\n",
            "Table: `shipment`\nColumns:\n(`ship_id`, integer, primary key)\n(`cust_id`, integer)\n(`weight`, real)\n(`truck_id`, integer)\n(`driver_id`, integer)\n(`city_id`, integer)\n(`ship_date`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"customer\"\nColumns:\n(\"cust_id\", BIGINT, primary key)\n(\"cust_name\", STRING)\n(\"annual_revenue\", BIGINT)\n(\"cust_type\", STRING)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", DOUBLE PRECISION)\n(\"phone\", STRING)\n",
            "Table: \"shipment\"\nColumns:\n(\"ship_id\", BIGINT, primary key)\n(\"cust_id\", BIGINT)\n(\"weight\", DOUBLE PRECISION)\n(\"truck_id\", BIGINT)\n(\"driver_id\", BIGINT)\n(\"city_id\", BIGINT)\n(\"ship_date\", STRING)\n"
        ]
    },
    {
        "sql_id": 377,
        "database_name": "shipping",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(*) FROM shipment AS T1 INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE STRFTIME('%Y', T1.ship_date) = '2017' AND T2.first_name = 'Sue' AND T2.last_name = 'Newell'",
        "target_query": "SELECT COUNT(*) FROM \"shipment\" AS \"T1\" INNER JOIN \"driver\" AS \"T2\" ON \"T1\".\"driver_id\" = \"T2\".\"driver_id\" WHERE \"T1\".\"ship_date\" LIKE '2017%' AND \"T2\".\"first_name\" = 'Sue' AND \"T2\".\"last_name\" = 'Newell';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 97,
                "end_index": 124,
                "dilatect_content": "STRFTIME('%Y', T1.ship_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `shipment`\nColumns:\n(`ship_id`, integer, primary key)\n(`cust_id`, integer)\n(`weight`, real)\n(`truck_id`, integer)\n(`driver_id`, integer)\n(`city_id`, integer)\n(`ship_date`, text)\n",
            "Table: `driver`\nColumns:\n(`driver_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip_code`, integer)\n(`phone`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"shipment\"\nColumns:\n(\"ship_id\", BIGINT, primary key)\n(\"cust_id\", BIGINT)\n(\"weight\", DOUBLE PRECISION)\n(\"truck_id\", BIGINT)\n(\"driver_id\", BIGINT)\n(\"city_id\", BIGINT)\n(\"ship_date\", STRING)\n",
            "Table: \"driver\"\nColumns:\n(\"driver_id\", BIGINT, primary key)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip_code\", BIGINT)\n(\"phone\", STRING)\n"
        ]
    },
    {
        "sql_id": 379,
        "database_name": "shipping",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(*) FROM shipment AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.city_id WHERE STRFTIME('%Y', T1.ship_date) = '2017' AND T2.state = 'New Jersey'",
        "target_query": "SELECT COUNT(*) FROM \"shipment\" AS \"T1\" INNER JOIN \"city\" AS \"T2\" ON \"T1\".\"city_id\" = \"T2\".\"city_id\" WHERE sys.timestamp_to_str(\"T1\".\"ship_date\", '%Y') = '2017' AND \"T2\".\"state\" = 'New Jersey';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 91,
                "end_index": 118,
                "dilatect_content": "STRFTIME('%Y', T1.ship_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 123,
                "end_index": 170,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"ship_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `shipment`\nColumns:\n(`ship_id`, integer, primary key)\n(`cust_id`, integer)\n(`weight`, real)\n(`truck_id`, integer)\n(`driver_id`, integer)\n(`city_id`, integer)\n(`ship_date`, text)\n",
            "Table: `city`\nColumns:\n(`city_id`, integer, primary key)\n(`city_name`, text)\n(`state`, text)\n(`population`, integer)\n(`area`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"shipment\"\nColumns:\n(\"ship_id\", BIGINT, primary key)\n(\"cust_id\", BIGINT)\n(\"weight\", DOUBLE PRECISION)\n(\"truck_id\", BIGINT)\n(\"driver_id\", BIGINT)\n(\"city_id\", BIGINT)\n(\"ship_date\", STRING)\n",
            "Table: \"city\"\nColumns:\n(\"city_id\", BIGINT, primary key)\n(\"city_name\", STRING)\n(\"state\", STRING)\n(\"population\", BIGINT)\n(\"area\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 380,
        "database_name": "shipping",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(*) FROM shipment AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.city_id INNER JOIN customer AS T3 ON T3.cust_id = T1.cust_id WHERE T2.city_name = 'Downey' AND STRFTIME('%Y', T1.ship_date) = '2016' AND T3.state = 'CA'",
        "target_query": "SELECT COUNT(*) FROM \"shipment\" AS \"T1\" INNER JOIN \"city\" AS \"T2\" ON \"T1\".\"city_id\" = \"T2\".\"city_id\" INNER JOIN \"customer\" AS \"T3\" ON \"T3\".\"cust_id\" = \"T1\".\"cust_id\" WHERE \"T2\".\"city_name\" = 'Downey' AND sys.timestamp_to_str(CAST(\"T1\".\"ship_date\" AS TIMESTAMP), '%Y') = '2016' AND \"T3\".\"state\" = 'CA';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 172,
                "end_index": 199,
                "dilatect_content": "STRFTIME('%Y', T1.ship_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 236,
                "end_index": 302,
                "dilatect_content": "sys.timestamp_to_str(CAST(\"T1\".\"ship_date\" AS TIMESTAMP), '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `shipment`\nColumns:\n(`ship_id`, integer, primary key)\n(`cust_id`, integer)\n(`weight`, real)\n(`truck_id`, integer)\n(`driver_id`, integer)\n(`city_id`, integer)\n(`ship_date`, text)\n",
            "Table: `city`\nColumns:\n(`city_id`, integer, primary key)\n(`city_name`, text)\n(`state`, text)\n(`population`, integer)\n(`area`, real)\n",
            "Table: `customer`\nColumns:\n(`cust_id`, integer, primary key)\n(`cust_name`, text)\n(`annual_revenue`, integer)\n(`cust_type`, text)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, real)\n(`phone`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"shipment\"\nColumns:\n(\"ship_id\", BIGINT, primary key)\n(\"cust_id\", BIGINT)\n(\"weight\", DOUBLE PRECISION)\n(\"truck_id\", BIGINT)\n(\"driver_id\", BIGINT)\n(\"city_id\", BIGINT)\n(\"ship_date\", STRING)\n",
            "Table: \"city\"\nColumns:\n(\"city_id\", BIGINT, primary key)\n(\"city_name\", STRING)\n(\"state\", STRING)\n(\"population\", BIGINT)\n(\"area\", DOUBLE PRECISION)\n",
            "Table: \"customer\"\nColumns:\n(\"cust_id\", BIGINT, primary key)\n(\"cust_name\", STRING)\n(\"annual_revenue\", BIGINT)\n(\"cust_type\", STRING)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", DOUBLE PRECISION)\n(\"phone\", STRING)\n"
        ]
    },
    {
        "sql_id": 381,
        "database_name": "shipping",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(T1.weight) FROM shipment AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.city_id WHERE T2.city_name = 'San Mateo' AND STRFTIME('%Y', T1.ship_date) = '2016'",
        "target_query": "SELECT SUM(\"T1\".\"weight\") FROM \"shipment\" AS \"T1\" INNER JOIN \"city\" AS \"T2\" ON \"T1\".\"city_id\" = \"T2\".\"city_id\" WHERE \"T2\".\"city_name\" = 'San Mateo' AND SUBSTR(\"T1\".\"ship_date\", 1, 4) = '2016';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 128,
                "end_index": 155,
                "dilatect_content": "STRFTIME('%Y', T1.ship_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `shipment`\nColumns:\n(`ship_id`, integer, primary key)\n(`cust_id`, integer)\n(`weight`, real)\n(`truck_id`, integer)\n(`driver_id`, integer)\n(`city_id`, integer)\n(`ship_date`, text)\n",
            "Table: `city`\nColumns:\n(`city_id`, integer, primary key)\n(`city_name`, text)\n(`state`, text)\n(`population`, integer)\n(`area`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"shipment\"\nColumns:\n(\"ship_id\", BIGINT, primary key)\n(\"cust_id\", BIGINT)\n(\"weight\", DOUBLE PRECISION)\n(\"truck_id\", BIGINT)\n(\"driver_id\", BIGINT)\n(\"city_id\", BIGINT)\n(\"ship_date\", STRING)\n",
            "Table: \"city\"\nColumns:\n(\"city_id\", BIGINT, primary key)\n(\"city_name\", STRING)\n(\"state\", STRING)\n(\"population\", BIGINT)\n(\"area\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 383,
        "database_name": "shipping",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(*) FROM shipment AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.city_id INNER JOIN driver AS T3 ON T3.driver_id = T1.driver_id WHERE T3.first_name = 'Andrea' AND T3.last_name = 'Simons' AND T2.city_name = 'Huntsville' AND STRFTIME('%Y', T1.ship_date) = '2016'",
        "target_query": "SELECT COUNT(*) FROM \"shipment\" AS \"T1\" INNER JOIN \"city\" AS \"T2\" ON \"T1\".\"city_id\" = \"T2\".\"city_id\" INNER JOIN \"driver\" AS \"T3\" ON \"T3\".\"driver_id\" = \"T1\".\"driver_id\" WHERE \"T3\".\"first_name\" = 'Andrea' AND \"T3\".\"last_name\" = 'Simons' AND \"T2\".\"city_name\" = 'Huntsville' AND SUBSTRING(\"T1\".\"ship_date\", 1, 4) = '2016';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 235,
                "end_index": 262,
                "dilatect_content": "STRFTIME('%Y', T1.ship_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `shipment`\nColumns:\n(`ship_id`, integer, primary key)\n(`cust_id`, integer)\n(`weight`, real)\n(`truck_id`, integer)\n(`driver_id`, integer)\n(`city_id`, integer)\n(`ship_date`, text)\n",
            "Table: `city`\nColumns:\n(`city_id`, integer, primary key)\n(`city_name`, text)\n(`state`, text)\n(`population`, integer)\n(`area`, real)\n",
            "Table: `driver`\nColumns:\n(`driver_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip_code`, integer)\n(`phone`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"shipment\"\nColumns:\n(\"ship_id\", BIGINT, primary key)\n(\"cust_id\", BIGINT)\n(\"weight\", DOUBLE PRECISION)\n(\"truck_id\", BIGINT)\n(\"driver_id\", BIGINT)\n(\"city_id\", BIGINT)\n(\"ship_date\", STRING)\n",
            "Table: \"city\"\nColumns:\n(\"city_id\", BIGINT, primary key)\n(\"city_name\", STRING)\n(\"state\", STRING)\n(\"population\", BIGINT)\n(\"area\", DOUBLE PRECISION)\n",
            "Table: \"driver\"\nColumns:\n(\"driver_id\", BIGINT, primary key)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip_code\", BIGINT)\n(\"phone\", STRING)\n"
        ]
    },
    {
        "sql_id": 384,
        "database_name": "shipping",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(CASE WHEN T1.weight >= 10000 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM shipment AS T1 INNER JOIN customer AS T2 ON T1.cust_id = T2.cust_id WHERE T2.cust_name = 'Sunguard Window Tinting & Truck Accessories' AND STRFTIME('%Y', T1.ship_date) = '2017'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T1\".\"weight\" >= 10000 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM \"shipment\" AS \"T1\" INNER JOIN \"customer\" AS \"T2\" ON \"T1\".\"cust_id\" = \"T2\".\"cust_id\" WHERE \"T2\".\"cust_name\" = 'Sunguard Window Tinting & Truck Accessories' AND SUBSTRING(\"T1\".\"ship_date\", 1, 4) = '2017';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 234,
                "end_index": 261,
                "dilatect_content": "STRFTIME('%Y', T1.ship_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `shipment`\nColumns:\n(`ship_id`, integer, primary key)\n(`cust_id`, integer)\n(`weight`, real)\n(`truck_id`, integer)\n(`driver_id`, integer)\n(`city_id`, integer)\n(`ship_date`, text)\n",
            "Table: `customer`\nColumns:\n(`cust_id`, integer, primary key)\n(`cust_name`, text)\n(`annual_revenue`, integer)\n(`cust_type`, text)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, real)\n(`phone`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"shipment\"\nColumns:\n(\"ship_id\", BIGINT, primary key)\n(\"cust_id\", BIGINT)\n(\"weight\", DOUBLE PRECISION)\n(\"truck_id\", BIGINT)\n(\"driver_id\", BIGINT)\n(\"city_id\", BIGINT)\n(\"ship_date\", STRING)\n",
            "Table: \"customer\"\nColumns:\n(\"cust_id\", BIGINT, primary key)\n(\"cust_name\", STRING)\n(\"annual_revenue\", BIGINT)\n(\"cust_type\", STRING)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", DOUBLE PRECISION)\n(\"phone\", STRING)\n"
        ]
    },
    {
        "sql_id": 385,
        "database_name": "shipping",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(*) FROM city AS T1 INNER JOIN shipment AS T2 ON T1.city_id = T2.city_id WHERE T1.population > 50000 AND STRFTIME('%Y', T2.ship_date) = '2017'",
        "target_query": "SELECT COUNT(*) FROM \"city\" AS \"T1\" INNER JOIN \"shipment\" AS \"T2\" ON \"T1\".\"city_id\" = \"T2\".\"city_id\" WHERE \"T1\".\"population\" > 50000 AND sys.timestamp_to_str(\"T2\".\"ship_date\", '%Y') = '2017';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 117,
                "end_index": 144,
                "dilatect_content": "STRFTIME('%Y', T2.ship_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 157,
                "end_index": 204,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"ship_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `city`\nColumns:\n(`city_id`, integer, primary key)\n(`city_name`, text)\n(`state`, text)\n(`population`, integer)\n(`area`, real)\n",
            "Table: `shipment`\nColumns:\n(`ship_id`, integer, primary key)\n(`cust_id`, integer)\n(`weight`, real)\n(`truck_id`, integer)\n(`driver_id`, integer)\n(`city_id`, integer)\n(`ship_date`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"city\"\nColumns:\n(\"city_id\", BIGINT, primary key)\n(\"city_name\", STRING)\n(\"state\", STRING)\n(\"population\", BIGINT)\n(\"area\", DOUBLE PRECISION)\n",
            "Table: \"shipment\"\nColumns:\n(\"ship_id\", BIGINT, primary key)\n(\"cust_id\", BIGINT)\n(\"weight\", DOUBLE PRECISION)\n(\"truck_id\", BIGINT)\n(\"driver_id\", BIGINT)\n(\"city_id\", BIGINT)\n(\"ship_date\", STRING)\n"
        ]
    },
    {
        "sql_id": 386,
        "database_name": "shipping",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(*) AS per FROM customer AS T1 INNER JOIN shipment AS T2 ON T1.cust_id = T2.cust_id WHERE STRFTIME('%Y', T2.ship_date) = '2016' AND T1.state = 'CA'",
        "target_query": "SELECT COUNT(*) AS \"per\" FROM \"customer\" AS \"T1\" INNER JOIN \"shipment\" AS \"T2\" ON \"T1\".\"cust_id\" = \"T2\".\"cust_id\" WHERE sys.timestamp_to_str(\"T2\".\"ship_date\", '%Y') = '2016' AND \"T1\".\"state\" = 'CA';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 102,
                "end_index": 129,
                "dilatect_content": "STRFTIME('%Y', T2.ship_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 138,
                "end_index": 185,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"ship_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`cust_id`, integer, primary key)\n(`cust_name`, text)\n(`annual_revenue`, integer)\n(`cust_type`, text)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, real)\n(`phone`, text)\n",
            "Table: `shipment`\nColumns:\n(`ship_id`, integer, primary key)\n(`cust_id`, integer)\n(`weight`, real)\n(`truck_id`, integer)\n(`driver_id`, integer)\n(`city_id`, integer)\n(`ship_date`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"customer\"\nColumns:\n(\"cust_id\", BIGINT, primary key)\n(\"cust_name\", STRING)\n(\"annual_revenue\", BIGINT)\n(\"cust_type\", STRING)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", DOUBLE PRECISION)\n(\"phone\", STRING)\n",
            "Table: \"shipment\"\nColumns:\n(\"ship_id\", BIGINT, primary key)\n(\"cust_id\", BIGINT)\n(\"weight\", DOUBLE PRECISION)\n(\"truck_id\", BIGINT)\n(\"driver_id\", BIGINT)\n(\"city_id\", BIGINT)\n(\"ship_date\", STRING)\n"
        ]
    },
    {
        "sql_id": 387,
        "database_name": "shipping",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(*) FROM city AS T1 INNER JOIN shipment AS T2 ON T1.city_id = T2.city_id INNER JOIN driver AS T3 ON T3.driver_id = T2.driver_id WHERE T3.first_name = 'Zachery' AND T3.last_name = 'Hicks' AND T1.city_name = 'New York' AND STRFTIME('%Y', T2.ship_date) = '2016'",
        "target_query": "SELECT COUNT(*) FROM \"city\" AS \"T1\" INNER JOIN \"shipment\" AS \"T2\" ON \"T1\".\"city_id\" = \"T2\".\"city_id\" INNER JOIN \"driver\" AS \"T3\" ON \"T3\".\"driver_id\" = \"T2\".\"driver_id\" WHERE \"T3\".\"first_name\" = 'Zachery' AND \"T3\".\"last_name\" = 'Hicks' AND \"T1\".\"city_name\" = 'New York' AND sys.timestamp_to_str(\"T2\".\"ship_date\", '%Y') = '2016';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 233,
                "end_index": 260,
                "dilatect_content": "STRFTIME('%Y', T2.ship_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 313,
                "end_index": 360,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"ship_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `city`\nColumns:\n(`city_id`, integer, primary key)\n(`city_name`, text)\n(`state`, text)\n(`population`, integer)\n(`area`, real)\n",
            "Table: `shipment`\nColumns:\n(`ship_id`, integer, primary key)\n(`cust_id`, integer)\n(`weight`, real)\n(`truck_id`, integer)\n(`driver_id`, integer)\n(`city_id`, integer)\n(`ship_date`, text)\n",
            "Table: `driver`\nColumns:\n(`driver_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip_code`, integer)\n(`phone`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"city\"\nColumns:\n(\"city_id\", BIGINT, primary key)\n(\"city_name\", STRING)\n(\"state\", STRING)\n(\"population\", BIGINT)\n(\"area\", DOUBLE PRECISION)\n",
            "Table: \"shipment\"\nColumns:\n(\"ship_id\", BIGINT, primary key)\n(\"cust_id\", BIGINT)\n(\"weight\", DOUBLE PRECISION)\n(\"truck_id\", BIGINT)\n(\"driver_id\", BIGINT)\n(\"city_id\", BIGINT)\n(\"ship_date\", STRING)\n",
            "Table: \"driver\"\nColumns:\n(\"driver_id\", BIGINT, primary key)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip_code\", BIGINT)\n(\"phone\", STRING)\n"
        ]
    },
    {
        "sql_id": 389,
        "database_name": "shipping",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(CASE WHEN T2.first_name = 'Zachery' AND T2.last_name = 'Hicks' THEN T1.weight ELSE 0 END) AS REAL) * 100 / SUM(T1.weight) FROM shipment AS T1 INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE STRFTIME('%Y', T1.ship_date) = '2016'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"first_name\" = 'Zachery' AND \"T2\".\"last_name\" = 'Hicks' THEN \"T1\".\"weight\" ELSE 0 END) AS DOUBLE PRECISION) * 100 / SUM(\"T1\".\"weight\") FROM \"shipment\" AS \"T1\" INNER JOIN \"driver\" AS \"T2\" ON \"T1\".\"driver_id\" = \"T2\".\"driver_id\" WHERE sys.timestamp_to_str(\"T1\".\"ship_date\", '%Y') = '2016';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 219,
                "end_index": 246,
                "dilatect_content": "STRFTIME('%Y', T1.ship_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 295,
                "end_index": 342,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"ship_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `shipment`\nColumns:\n(`ship_id`, integer, primary key)\n(`cust_id`, integer)\n(`weight`, real)\n(`truck_id`, integer)\n(`driver_id`, integer)\n(`city_id`, integer)\n(`ship_date`, text)\n",
            "Table: `driver`\nColumns:\n(`driver_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip_code`, integer)\n(`phone`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"shipment\"\nColumns:\n(\"ship_id\", BIGINT, primary key)\n(\"cust_id\", BIGINT)\n(\"weight\", DOUBLE PRECISION)\n(\"truck_id\", BIGINT)\n(\"driver_id\", BIGINT)\n(\"city_id\", BIGINT)\n(\"ship_date\", STRING)\n",
            "Table: \"driver\"\nColumns:\n(\"driver_id\", BIGINT, primary key)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip_code\", BIGINT)\n(\"phone\", STRING)\n"
        ]
    },
    {
        "sql_id": 390,
        "database_name": "shipping",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(*) FROM shipment AS T1 INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE T2.first_name = 'Maria' AND T2.last_name = 'Craft' AND STRFTIME('%Y', T1.ship_date) = '2017'",
        "target_query": "SELECT COUNT(*) FROM \"shipment\" AS \"T1\" INNER JOIN \"driver\" AS \"T2\" ON \"T1\".\"driver_id\" = \"T2\".\"driver_id\" WHERE \"T2\".\"first_name\" = 'Maria' AND \"T2\".\"last_name\" = 'Craft' AND sys.timestamp_to_str(\"T1\".\"ship_date\", '%Y') = '2017';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 152,
                "end_index": 177,
                "dilatect_content": "STRFTIME('%Y', T1.ship_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 200,
                "end_index": 247,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"ship_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `shipment`\nColumns:\n(`ship_id`, integer, primary key)\n(`cust_id`, integer)\n(`weight`, real)\n(`truck_id`, integer)\n(`driver_id`, integer)\n(`city_id`, integer)\n(`ship_date`, text)\n",
            "Table: `driver`\nColumns:\n(`driver_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip_code`, integer)\n(`phone`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"shipment\"\nColumns:\n(\"ship_id\", BIGINT, primary key)\n(\"cust_id\", BIGINT)\n(\"weight\", DOUBLE PRECISION)\n(\"truck_id\", BIGINT)\n(\"driver_id\", BIGINT)\n(\"city_id\", BIGINT)\n(\"ship_date\", STRING)\n",
            "Table: \"driver\"\nColumns:\n(\"driver_id\", BIGINT, primary key)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip_code\", BIGINT)\n(\"phone\", STRING)\n"
        ]
    },
    {
        "sql_id": 391,
        "database_name": "shipping",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(CASE WHEN STRFTIME('%Y', T1.ship_date) = '2017' THEN 1 ELSE 0 END) AS REAL ) * 100 / COUNT(*) FROM shipment AS T1 INNER JOIN customer AS T2 ON T1.cust_id = T2.cust_id WHERE T2.state = 'TX'",
        "target_query": "SELECT CAST(SUM(CASE WHEN sys.timestamp_to_str(T1.\"ship_date\", '%Y') = '2017' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM \"shipment\" AS T1 INNER JOIN \"customer\" AS T2 ON T1.\"cust_id\" = T2.\"cust_id\" WHERE T2.\"state\" = 'TX'",
        "semantic_equivalent_type": "approximate_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 26,
                "end_index": 53,
                "dilatect_content": "STRFTIME('%Y', T1.ship_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 26,
                "end_index": 69,
                "dilatect_content": "sys.timestamp_to_str(T1.\"ship_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `shipment`\nColumns:\n(`ship_id`, integer, primary key)\n(`cust_id`, integer)\n(`weight`, real)\n(`truck_id`, integer)\n(`driver_id`, integer)\n(`city_id`, integer)\n(`ship_date`, text)\n",
            "Table: `customer`\nColumns:\n(`cust_id`, integer, primary key)\n(`cust_name`, text)\n(`annual_revenue`, integer)\n(`cust_type`, text)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, real)\n(`phone`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"shipment\"\nColumns:\n(\"ship_id\", BIGINT, primary key)\n(\"cust_id\", BIGINT)\n(\"weight\", DOUBLE PRECISION)\n(\"truck_id\", BIGINT)\n(\"driver_id\", BIGINT)\n(\"city_id\", BIGINT)\n(\"ship_date\", STRING)\n",
            "Table: \"customer\"\nColumns:\n(\"cust_id\", BIGINT, primary key)\n(\"cust_name\", STRING)\n(\"annual_revenue\", BIGINT)\n(\"cust_type\", STRING)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", DOUBLE PRECISION)\n(\"phone\", STRING)\n"
        ]
    },
    {
        "sql_id": 392,
        "database_name": "language_corpus",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT title, words FROM pages WHERE title = ( SELECT MAX(LENGTH(title)) FROM pages )",
        "target_query": "SELECT \"title\", \"words\" FROM \"pages\" WHERE \"title\" = ( SELECT MAX(length(\"title\")) FROM \"pages\" );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 58,
                "end_index": 70,
                "dilatect_content": "LENGTH(title)",
                "feature": "length(X)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 74,
                "end_index": 90,
                "dilatect_content": "length(\"title\")",
                "feature": "length(X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "length(X)",
                "explanation": "MonetDB supports the length() function for both string and BLOB values. For a string value X, the function returns the number of characters (code points) in the string. For a BLOB value, it returns the byte-length of the BLOB.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `pages`\nColumns:\n(`pid`, integer, primary key)\n(`lid`, integer)\n(`page`, integer)\n(`revision`, integer)\n(`title`, text)\n(`words`, integer)\n",
            "Table: `pages`\nColumns:\n(`pid`, integer, primary key)\n(`lid`, integer)\n(`page`, integer)\n(`revision`, integer)\n(`title`, text)\n(`words`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"pages\"\nColumns:\n(\"pid\", BIGINT, primary key)\n(\"lid\", BIGINT)\n(\"page\", BIGINT)\n(\"revision\", BIGINT)\n(\"title\", STRING)\n(\"words\", BIGINT)\n",
            "Table: \"pages\"\nColumns:\n(\"pid\", BIGINT, primary key)\n(\"lid\", BIGINT)\n(\"page\", BIGINT)\n(\"revision\", BIGINT)\n(\"title\", STRING)\n(\"words\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 393,
        "database_name": "language_corpus",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(occurrences) FROM words WHERE LENGTH(word) = 3",
        "target_query": "SELECT SUM(\"occurrences\") FROM \"words\" WHERE length(\"word\") = 3;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 41,
                "end_index": 52,
                "dilatect_content": "LENGTH(word)",
                "feature": "length(X)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 49,
                "end_index": 64,
                "dilatect_content": "length(\"word\")",
                "feature": "length(X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "length(X)",
                "explanation": "MonetDB supports the length() function for both string and BLOB values. For a string value X, the function returns the number of characters (code points) in the string. For a BLOB value, it returns the byte-length of the BLOB.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `words`\nColumns:\n(`wid`, integer, primary key)\n(`word`, text)\n(`occurrences`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"words\"\nColumns:\n(\"wid\", BIGINT, primary key)\n(\"word\", STRING)\n(\"occurrences\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 394,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT title FROM book WHERE STRFTIME('%Y', publication_date) = '1900' ORDER BY publication_date LIMIT 1",
        "target_query": "SELECT \"title\" FROM \"book\" WHERE sys.timestamp_to_str(\"publication_date\", '%Y') = '1900' ORDER BY \"publication_date\" LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 29,
                "end_index": 60,
                "dilatect_content": "STRFTIME('%Y', publication_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 37,
                "end_index": 84,
                "dilatect_content": "sys.timestamp_to_str(\"publication_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, integer, primary key)\n(`title`, text)\n(`isbn13`, text)\n(`language_id`, integer)\n(`num_pages`, integer)\n(`publication_date`, date)\n(`publisher_id`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"book\"\nColumns:\n(\"book_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"isbn13\", STRING)\n(\"language_id\", BIGINT)\n(\"num_pages\", BIGINT)\n(\"publication_date\", DATE)\n(\"publisher_id\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 395,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(*) FROM country AS T1 INNER JOIN address AS T2 ON T1.country_id = T2.country_id INNER JOIN cust_order AS T3 ON T3.dest_address_id = T2.address_id WHERE T1.country_name = 'Iran' AND STRFTIME('%Y', T3.order_date) = '2022'",
        "target_query": "SELECT COUNT(*) FROM \"country\" AS \"T1\" INNER JOIN \"address\" AS \"T2\" ON \"T1\".\"country_id\" = \"T2\".\"country_id\" INNER JOIN \"cust_order\" AS \"T3\" ON \"T3\".\"dest_address_id\" = \"T2\".\"address_id\" WHERE \"T1\".\"country_name\" = 'Iran' AND sys.timestamp_to_str(\"T3\".\"order_date\", '%Y') = '2022';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 194,
                "end_index": 222,
                "dilatect_content": "STRFTIME('%Y', T3.order_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 258,
                "end_index": 306,
                "dilatect_content": "sys.timestamp_to_str(\"T3\".\"order_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `country`\nColumns:\n(`country_id`, integer, primary key)\n(`country_name`, text)\n",
            "Table: `address`\nColumns:\n(`address_id`, integer, primary key)\n(`street_number`, text)\n(`street_name`, text)\n(`city`, text)\n(`country_id`, integer)\n",
            "Table: `cust_order`\nColumns:\n(`order_id`, integer, primary key)\n(`order_date`, datetime)\n(`customer_id`, integer)\n(`shipping_method_id`, integer)\n(`dest_address_id`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"country\"\nColumns:\n(\"country_id\", BIGINT, primary key)\n(\"country_name\", STRING)\n",
            "Table: \"address\"\nColumns:\n(\"address_id\", BIGINT, primary key)\n(\"street_number\", STRING)\n(\"street_name\", STRING)\n(\"city\", STRING)\n(\"country_id\", BIGINT)\n",
            "Table: \"cust_order\"\nColumns:\n(\"order_id\", BIGINT, primary key)\n(\"order_date\", TIMESTAMP)\n(\"customer_id\", BIGINT)\n(\"shipping_method_id\", BIGINT)\n(\"dest_address_id\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 396,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(*) FROM order_status AS T1 INNER JOIN order_history AS T2 ON T1.status_id = T2.status_id WHERE T1.status_value = 'Delivered' AND STRFTIME('%Y', T2.status_date) = '2021'",
        "target_query": "SELECT COUNT(*) FROM \"order_status\" AS \"T1\" INNER JOIN \"order_history\" AS \"T2\" ON \"T1\".\"status_id\" = \"T2\".\"status_id\" WHERE \"T1\".\"status_value\" = 'Delivered' AND sys.timestamp_to_str(\"T2\".\"status_date\", '%Y') = '2021';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 142,
                "end_index": 171,
                "dilatect_content": "STRFTIME('%Y', T2.status_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 182,
                "end_index": 231,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"status_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `order_status`\nColumns:\n(`status_id`, integer, primary key)\n(`status_value`, text)\n",
            "Table: `order_history`\nColumns:\n(`history_id`, integer, primary key)\n(`order_id`, integer)\n(`status_id`, integer)\n(`status_date`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"order_status\"\nColumns:\n(\"status_id\", BIGINT, primary key)\n(\"status_value\", STRING)\n",
            "Table: \"order_history\"\nColumns:\n(\"history_id\", BIGINT, primary key)\n(\"order_id\", BIGINT)\n(\"status_id\", BIGINT)\n(\"status_date\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 397,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(T3.cost) FROM customer AS T1 INNER JOIN cust_order AS T2 ON T1.customer_id = T2.customer_id INNER JOIN shipping_method AS T3 ON T3.method_id = T2.shipping_method_id WHERE T1.first_name = 'Page' AND T1.last_name = 'Holsey' AND STRFTIME('%Y', T2.order_date) = '2022'",
        "target_query": "SELECT SUM(\"T3\".\"cost\") FROM \"customer\" AS \"T1\" INNER JOIN \"cust_order\" AS \"T2\" ON \"T1\".\"customer_id\" = \"T2\".\"customer_id\" INNER JOIN \"shipping_method\" AS \"T3\" ON \"T3\".\"method_id\" = \"T2\".\"shipping_method_id\" WHERE \"T1\".\"first_name\" = 'Page' AND \"T1\".\"last_name\" = 'Holsey' AND sys.timestamp_to_str(\"T2\".\"order_date\", '%Y') = '2022';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 237,
                "end_index": 265,
                "dilatect_content": "STRFTIME('%Y', T2.order_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 317,
                "end_index": 365,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"order_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n",
            "Table: `cust_order`\nColumns:\n(`order_id`, integer, primary key)\n(`order_date`, datetime)\n(`customer_id`, integer)\n(`shipping_method_id`, integer)\n(`dest_address_id`, integer)\n",
            "Table: `shipping_method`\nColumns:\n(`method_id`, integer, primary key)\n(`method_name`, text)\n(`cost`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"customer\"\nColumns:\n(\"customer_id\", BIGINT, primary key)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"email\", STRING)\n",
            "Table: \"cust_order\"\nColumns:\n(\"order_id\", BIGINT, primary key)\n(\"order_date\", TIMESTAMP)\n(\"customer_id\", BIGINT)\n(\"shipping_method_id\", BIGINT)\n(\"dest_address_id\", BIGINT)\n",
            "Table: \"shipping_method\"\nColumns:\n(\"method_id\", BIGINT, primary key)\n(\"method_name\", STRING)\n(\"cost\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 398,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(CASE WHEN STRFTIME('%Y', T1.publication_date) = '1992' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM book AS T1 INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE T3.author_name = 'Abraham Lincoln'",
        "target_query": "SELECT CAST(SUM(CASE WHEN sys.timestamp_to_str(T1.publication_date, '%Y') = '1992' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM \"book\" AS T1 INNER JOIN \"book_author\" AS T2 ON T1.\"book_id\" = T2.\"book_id\" INNER JOIN \"author\" AS T3 ON T3.\"author_id\" = T2.\"author_id\" WHERE T3.\"author_name\" = 'Abraham Lincoln';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 26,
                "end_index": 60,
                "dilatect_content": "STRFTIME('%Y', T1.publication_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 26,
                "end_index": 72,
                "dilatect_content": "sys.timestamp_to_str(T1.publication_date, '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, integer, primary key)\n(`title`, text)\n(`isbn13`, text)\n(`language_id`, integer)\n(`num_pages`, integer)\n(`publication_date`, date)\n(`publisher_id`, integer)\n",
            "Table: `book_author`\nColumns:\n(`book_id`, integer, primary key)\n(`author_id`, integer, primary key)\n",
            "Table: `author`\nColumns:\n(`author_id`, integer, primary key)\n(`author_name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"book\"\nColumns:\n(\"book_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"isbn13\", STRING)\n(\"language_id\", BIGINT)\n(\"num_pages\", BIGINT)\n(\"publication_date\", DATE)\n(\"publisher_id\", BIGINT)\n",
            "Table: \"book_author\"\nColumns:\n(\"book_id\", BIGINT, primary key)\n(\"author_id\", BIGINT, primary key)\n",
            "Table: \"author\"\nColumns:\n(\"author_id\", BIGINT, primary key)\n(\"author_name\", STRING)\n"
        ]
    },
    {
        "sql_id": 399,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.title, T2.publisher_name FROM book AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE STRFTIME('%Y', T1.publication_date) = '2004' AND T1.num_pages * 100 > ( SELECT AVG(num_pages) FROM book ) * 70",
        "target_query": "SELECT \"T1\".\"title\", \"T2\".\"publisher_name\" FROM \"book\" AS \"T1\" INNER JOIN \"publisher\" AS \"T2\" ON \"T1\".\"publisher_id\" = \"T2\".\"publisher_id\" WHERE sys.timestamp_to_str(\"T1\".\"publication_date\", '%Y') = '2004' AND \"T1\".\"num_pages\" * 100 > ( SELECT AVG(\"num_pages\") FROM \"book\" ) * 70;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 121,
                "end_index": 155,
                "dilatect_content": "STRFTIME('%Y', T1.publication_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 169,
                "end_index": 223,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"publication_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, integer, primary key)\n(`title`, text)\n(`isbn13`, text)\n(`language_id`, integer)\n(`num_pages`, integer)\n(`publication_date`, date)\n(`publisher_id`, integer)\n",
            "Table: `publisher`\nColumns:\n(`publisher_id`, integer, primary key)\n(`publisher_name`, text)\n",
            "Table: `book`\nColumns:\n(`book_id`, integer, primary key)\n(`title`, text)\n(`isbn13`, text)\n(`language_id`, integer)\n(`num_pages`, integer)\n(`publication_date`, date)\n(`publisher_id`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"book\"\nColumns:\n(\"book_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"isbn13\", STRING)\n(\"language_id\", BIGINT)\n(\"num_pages\", BIGINT)\n(\"publication_date\", DATE)\n(\"publisher_id\", BIGINT)\n",
            "Table: \"publisher\"\nColumns:\n(\"publisher_id\", BIGINT, primary key)\n(\"publisher_name\", STRING)\n",
            "Table: \"book\"\nColumns:\n(\"book_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"isbn13\", STRING)\n(\"language_id\", BIGINT)\n(\"num_pages\", BIGINT)\n(\"publication_date\", DATE)\n(\"publisher_id\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 400,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.title FROM book AS T1 INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE T3.author_name = 'Orson Scott Card' AND STRFTIME('%Y', T1.publication_date) = '2001'",
        "target_query": "SELECT \"T1\".\"title\" FROM \"book\" AS \"T1\" INNER JOIN \"book_author\" AS \"T2\" ON \"T1\".\"book_id\" = \"T2\".\"book_id\" INNER JOIN \"author\" AS \"T3\" ON \"T3\".\"author_id\" = \"T2\".\"author_id\" WHERE \"T3\".\"author_name\" = 'Orson Scott Card' AND sys.timestamp_to_str(\"T1\".\"publication_date\", '%Y') = '2001';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 189,
                "end_index": 223,
                "dilatect_content": "STRFTIME('%Y', T1.publication_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 261,
                "end_index": 315,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"publication_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, integer, primary key)\n(`title`, text)\n(`isbn13`, text)\n(`language_id`, integer)\n(`num_pages`, integer)\n(`publication_date`, date)\n(`publisher_id`, integer)\n",
            "Table: `book_author`\nColumns:\n(`book_id`, integer, primary key)\n(`author_id`, integer, primary key)\n",
            "Table: `author`\nColumns:\n(`author_id`, integer, primary key)\n(`author_name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"book\"\nColumns:\n(\"book_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"isbn13\", STRING)\n(\"language_id\", BIGINT)\n(\"num_pages\", BIGINT)\n(\"publication_date\", DATE)\n(\"publisher_id\", BIGINT)\n",
            "Table: \"book_author\"\nColumns:\n(\"book_id\", BIGINT, primary key)\n(\"author_id\", BIGINT, primary key)\n",
            "Table: \"author\"\nColumns:\n(\"author_id\", BIGINT, primary key)\n(\"author_name\", STRING)\n"
        ]
    },
    {
        "sql_id": 401,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(*) FROM cust_order AS T1 INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id WHERE T2.first_name = 'Daisey' AND T2.last_name = 'Lamball' AND STRFTIME('%Y', T1.order_date) = '2021'",
        "target_query": "SELECT COUNT(*) FROM \"cust_order\" AS T1 INNER JOIN \"customer\" AS T2 ON T1.\"customer_id\" = T2.\"customer_id\" WHERE T2.\"first_name\" = 'Daisey' AND T2.\"last_name\" = 'Lamball' AND sys.timestamp_to_str(T1.\"order_date\", '%Y') = '2021';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 163,
                "end_index": 191,
                "dilatect_content": "STRFTIME('%Y', T1.order_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 187,
                "end_index": 231,
                "dilatect_content": "sys.timestamp_to_str(T1.\"order_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `cust_order`\nColumns:\n(`order_id`, integer, primary key)\n(`order_date`, datetime)\n(`customer_id`, integer)\n(`shipping_method_id`, integer)\n(`dest_address_id`, integer)\n",
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"cust_order\"\nColumns:\n(\"order_id\", BIGINT, primary key)\n(\"order_date\", TIMESTAMP)\n(\"customer_id\", BIGINT)\n(\"shipping_method_id\", BIGINT)\n(\"dest_address_id\", BIGINT)\n",
            "Table: \"customer\"\nColumns:\n(\"customer_id\", BIGINT, primary key)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"email\", STRING)\n"
        ]
    },
    {
        "sql_id": 402,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(*) FROM order_status AS T1 INNER JOIN order_history AS T2 ON T1.status_id = T2.status_id WHERE T1.status_value = 'Delivered' AND STRFTIME('%Y', T2.status_date) = '2019'",
        "target_query": "SELECT COUNT(*) FROM \"order_status\" AS T1 INNER JOIN \"order_history\" AS T2 ON T1.\"status_id\" = T2.\"status_id\" WHERE T1.\"status_value\" = 'Delivered' AND sys.timestamp_to_str(T2.\"status_date\", '%Y') = '2019';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 142,
                "end_index": 171,
                "dilatect_content": "STRFTIME('%Y', T2.status_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 162,
                "end_index": 207,
                "dilatect_content": "sys.timestamp_to_str(T2.\"status_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `order_status`\nColumns:\n(`status_id`, integer, primary key)\n(`status_value`, text)\n",
            "Table: `order_history`\nColumns:\n(`history_id`, integer, primary key)\n(`order_id`, integer)\n(`status_id`, integer)\n(`status_date`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"order_status\"\nColumns:\n(\"status_id\", BIGINT, primary key)\n(\"status_value\", STRING)\n",
            "Table: \"order_history\"\nColumns:\n(\"history_id\", BIGINT, primary key)\n(\"order_id\", BIGINT)\n(\"status_id\", BIGINT)\n(\"status_date\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 403,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(CASE WHEN T2.method_name = 'International' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM cust_order AS T1 INNER JOIN shipping_method AS T2 ON T1.shipping_method_id = T2.method_id WHERE STRFTIME('%Y', T1.order_date) = '2020'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"method_name\" = 'International' THEN 1 ELSE 0 END) AS DOUBLE PRECISION) * 100 / COUNT(*) FROM \"cust_order\" AS \"T1\" INNER JOIN \"shipping_method\" AS \"T2\" ON \"T1\".\"shipping_method_id\" = \"T2\".\"method_id\" WHERE sys.timestamp_to_str(\"T1\".\"order_date\", '%Y') = '2020';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 205,
                "end_index": 233,
                "dilatect_content": "STRFTIME('%Y', T1.order_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 257,
                "end_index": 305,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"order_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `cust_order`\nColumns:\n(`order_id`, integer, primary key)\n(`order_date`, datetime)\n(`customer_id`, integer)\n(`shipping_method_id`, integer)\n(`dest_address_id`, integer)\n",
            "Table: `shipping_method`\nColumns:\n(`method_id`, integer, primary key)\n(`method_name`, text)\n(`cost`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"cust_order\"\nColumns:\n(\"order_id\", BIGINT, primary key)\n(\"order_date\", TIMESTAMP)\n(\"customer_id\", BIGINT)\n(\"shipping_method_id\", BIGINT)\n(\"dest_address_id\", BIGINT)\n",
            "Table: \"shipping_method\"\nColumns:\n(\"method_id\", BIGINT, primary key)\n(\"method_name\", STRING)\n(\"cost\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 404,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT strftime('%Y', order_date) FROM cust_order GROUP BY strftime('%Y', order_date) ORDER BY COUNT(strftime('%Y', order_date)) DESC LIMIT 1",
        "target_query": "SELECT sys.timestamp_to_str(\"order_date\", '%Y') FROM \"cust_order\" GROUP BY sys.timestamp_to_str(\"order_date\", '%Y') ORDER BY COUNT(sys.timestamp_to_str(\"order_date\", '%Y')) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 32,
                "dilatect_content": "strftime('%Y', order_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 59,
                "end_index": 84,
                "dilatect_content": "strftime('%Y', order_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 101,
                "end_index": 126,
                "dilatect_content": "strftime('%Y', order_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 48,
                "dilatect_content": "sys.timestamp_to_str(\"order_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 79,
                "end_index": 120,
                "dilatect_content": "sys.timestamp_to_str(\"order_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 137,
                "end_index": 178,
                "dilatect_content": "sys.timestamp_to_str(\"order_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `cust_order`\nColumns:\n(`order_id`, integer, primary key)\n(`order_date`, datetime)\n(`customer_id`, integer)\n(`shipping_method_id`, integer)\n(`dest_address_id`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"cust_order\"\nColumns:\n(\"order_id\", BIGINT, primary key)\n(\"order_date\", TIMESTAMP)\n(\"customer_id\", BIGINT)\n(\"shipping_method_id\", BIGINT)\n(\"dest_address_id\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 405,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT title FROM book WHERE STRFTIME('%Y', publication_date) = '1995'",
        "target_query": "SELECT \"title\" FROM \"book\" WHERE sys.timestamp_to_str(\"publication_date\", '%Y') = '1995';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 29,
                "end_index": 60,
                "dilatect_content": "STRFTIME('%Y', publication_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 37,
                "end_index": 84,
                "dilatect_content": "sys.timestamp_to_str(\"publication_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, integer, primary key)\n(`title`, text)\n(`isbn13`, text)\n(`language_id`, integer)\n(`num_pages`, integer)\n(`publication_date`, date)\n(`publisher_id`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"book\"\nColumns:\n(\"book_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"isbn13\", STRING)\n(\"language_id\", BIGINT)\n(\"num_pages\", BIGINT)\n(\"publication_date\", DATE)\n(\"publisher_id\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 406,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUBSTR(email, INSTR(email, '@') + 1, LENGTH(email) - INSTR(email, '@')) AS ym FROM customer GROUP BY SUBSTR(email, INSTR(email, '@') + 1, LENGTH(email) - INSTR(email, '@')) ORDER BY COUNT(*) DESC LIMIT 1",
        "target_query": "SELECT substring(\"email\" from POSITION('@' IN \"email\") + 1 for length(\"email\") - POSITION('@' IN \"email\")) AS ym \nFROM \"customer\" \nGROUP BY substring(\"email\" from POSITION('@' IN \"email\") + 1 for length(\"email\") - POSITION('@' IN \"email\")) \nORDER BY COUNT(*) DESC \nLIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 77,
                "dilatect_content": "SUBSTR(email, INSTR(email, '@') + 1, LENGTH(email) - INSTR(email, '@'))",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 21,
                "end_index": 37,
                "dilatect_content": "INSTR(email, '@')",
                "feature": "instr(X,Y)"
            },
            {
                "start_index": 44,
                "end_index": 56,
                "dilatect_content": "LENGTH(email)",
                "feature": "length(X)"
            },
            {
                "start_index": 60,
                "end_index": 76,
                "dilatect_content": "INSTR(email, '@')",
                "feature": "instr(X,Y)"
            },
            {
                "start_index": 108,
                "end_index": 178,
                "dilatect_content": "SUBSTR(email, INSTR(email, '@') + 1, LENGTH(email) - INSTR(email, '@'))",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 122,
                "end_index": 138,
                "dilatect_content": "INSTR(email, '@')",
                "feature": "instr(X,Y)"
            },
            {
                "start_index": 145,
                "end_index": 157,
                "dilatect_content": "LENGTH(email)",
                "feature": "length(X)"
            },
            {
                "start_index": 161,
                "end_index": 177,
                "dilatect_content": "INSTR(email, '@')",
                "feature": "instr(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 113,
                "dilatect_content": "substring(\"email\" from POSITION('@' IN \"email\") + 1 for length(\"email\") - POSITION('@' IN \"email\"))",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 32,
                "end_index": 57,
                "dilatect_content": "POSITION('@' IN \"email\")",
                "feature": "POSITION(Y IN X)"
            },
            {
                "start_index": 67,
                "end_index": 83,
                "dilatect_content": "length(\"email\")",
                "feature": "length(X)"
            },
            {
                "start_index": 87,
                "end_index": 112,
                "dilatect_content": "POSITION('@' IN \"email\")",
                "feature": "POSITION(Y IN X)"
            },
            {
                "start_index": 152,
                "end_index": 258,
                "dilatect_content": "substring(\"email\" from POSITION('@' IN \"email\") + 1 for length(\"email\") - POSITION('@' IN \"email\"))",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 177,
                "end_index": 202,
                "dilatect_content": "POSITION('@' IN \"email\")",
                "feature": "POSITION(Y IN X)"
            },
            {
                "start_index": 212,
                "end_index": 228,
                "dilatect_content": "length(\"email\")",
                "feature": "length(X)"
            },
            {
                "start_index": 232,
                "end_index": 257,
                "dilatect_content": "POSITION('@' IN \"email\")",
                "feature": "POSITION(Y IN X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            },
            {
                "feature": "instr(X,Y)",
                "explanation": "The instr(X,Y) function finds the first occurrence of string Y within \n  string X and returns the number of prior characters plus 1, or 0 if\n  Y is nowhere found within X.\n  Or, if X and Y are both BLOBs, then instr(X,Y) returns one\n  more than the number bytes prior to the first occurrence of Y, or 0 if\n  Y does not occur anywhere within X.\n  If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs\n  then both are interpreted as strings.\n  If either X or Y are NULL in instr(X,Y) then the result is NULL.\n",
                "examples": [
                    "SELECT instr('Hello World', 'World'); -- Returns 7",
                    "SELECT instr('abcdefg', 'x'); -- Returns 0 (not found)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "MonetDB supports the length() function for both string and BLOB values. For a string value X, the function returns the number of characters (code points) in the string. For a BLOB value, it returns the byte-length of the BLOB.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            },
            {
                "feature": "POSITION(Y IN X)",
                "explanation": "In MonetDB, the POSITION function is used to find the first occurrence of string Y within string X and returns the number of characters from the beginning of X to the start of Y. If Y is not found within X, it returns 0.",
                "examples": [
                    "SELECT POSITION('World' IN 'Hello World'); -- Returns 7",
                    "SELECT POSITION('x' IN 'abcdefg'); -- Returns 0 (not found)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"customer\"\nColumns:\n(\"customer_id\", BIGINT, primary key)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"email\", STRING)\n"
        ]
    },
    {
        "sql_id": 407,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(*) FROM order_status AS T1 INNER JOIN order_history AS T2 ON T1.status_id = T2.status_id WHERE T1.status_value = 'Returned' AND STRFTIME('%Y', T2.status_date) = '2020'",
        "target_query": "SELECT COUNT(*) FROM \"order_status\" AS T1 INNER JOIN \"order_history\" AS T2 ON T1.\"status_id\" = T2.\"status_id\" WHERE T1.\"status_value\" = 'Returned' AND sys.timestamp_to_str(T2.\"status_date\", '%Y') = '2020';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 141,
                "end_index": 170,
                "dilatect_content": "STRFTIME('%Y', T2.status_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 161,
                "end_index": 206,
                "dilatect_content": "sys.timestamp_to_str(T2.\"status_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `order_status`\nColumns:\n(`status_id`, integer, primary key)\n(`status_value`, text)\n",
            "Table: `order_history`\nColumns:\n(`history_id`, integer, primary key)\n(`order_id`, integer)\n(`status_id`, integer)\n(`status_date`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"order_status\"\nColumns:\n(\"status_id\", BIGINT, primary key)\n(\"status_value\", STRING)\n",
            "Table: \"order_history\"\nColumns:\n(\"history_id\", BIGINT, primary key)\n(\"order_id\", BIGINT)\n(\"status_id\", BIGINT)\n(\"status_date\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 408,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT strftime('%J', T2.status_date) - strftime('%J', T1.order_date) FROM cust_order AS T1 INNER JOIN order_history AS T2 ON T1.order_id = T2.order_id WHERE T1.order_id = 2398",
        "target_query": "SELECT (T2.\"status_date\" - T1.\"order_date\") AS \"date_difference\" FROM \"cust_order\" AS T1 INNER JOIN \"order_history\" AS T2 ON T1.\"order_id\" = T2.\"order_id\" WHERE T1.\"order_id\" = 2398;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 36,
                "dilatect_content": "strftime('%J', T2.status_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 40,
                "end_index": 68,
                "dilatect_content": "strftime('%J', T1.order_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `cust_order`\nColumns:\n(`order_id`, integer, primary key)\n(`order_date`, datetime)\n(`customer_id`, integer)\n(`shipping_method_id`, integer)\n(`dest_address_id`, integer)\n",
            "Table: `order_history`\nColumns:\n(`history_id`, integer, primary key)\n(`order_id`, integer)\n(`status_id`, integer)\n(`status_date`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"cust_order\"\nColumns:\n(\"order_id\", BIGINT, primary key)\n(\"order_date\", TIMESTAMP)\n(\"customer_id\", BIGINT)\n(\"shipping_method_id\", BIGINT)\n(\"dest_address_id\", BIGINT)\n",
            "Table: \"order_history\"\nColumns:\n(\"history_id\", BIGINT, primary key)\n(\"order_id\", BIGINT)\n(\"status_id\", BIGINT)\n(\"status_date\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 409,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(*) FROM customer AS T1 INNER JOIN cust_order AS T2 ON T1.customer_id = T2.customer_id INNER JOIN shipping_method AS T3 ON T3.method_id = T2.shipping_method_id WHERE T1.first_name = 'Marcelia' AND T1.last_name = 'Goering' AND STRFTIME('%Y', T2.order_date) = '2021' AND T3.method_name = 'Priority'",
        "target_query": "SELECT COUNT(*) FROM \"customer\" AS \"T1\" INNER JOIN \"cust_order\" AS \"T2\" ON \"T1\".\"customer_id\" = \"T2\".\"customer_id\" INNER JOIN \"shipping_method\" AS \"T3\" ON \"T3\".\"method_id\" = \"T2\".\"shipping_method_id\" WHERE \"T1\".\"first_name\" = 'Marcelia' AND \"T1\".\"last_name\" = 'Goering' AND sys.timestamp_to_str(\"T2\".\"order_date\", '%Y') = '2021' AND \"T3\".\"method_name\" = 'Priority';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 238,
                "end_index": 264,
                "dilatect_content": "STRFTIME('%Y', T2.order_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 310,
                "end_index": 358,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"order_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n",
            "Table: `cust_order`\nColumns:\n(`order_id`, integer, primary key)\n(`order_date`, datetime)\n(`customer_id`, integer)\n(`shipping_method_id`, integer)\n(`dest_address_id`, integer)\n",
            "Table: `shipping_method`\nColumns:\n(`method_id`, integer, primary key)\n(`method_name`, text)\n(`cost`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"customer\"\nColumns:\n(\"customer_id\", BIGINT, primary key)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"email\", STRING)\n",
            "Table: \"cust_order\"\nColumns:\n(\"order_id\", BIGINT, primary key)\n(\"order_date\", TIMESTAMP)\n(\"customer_id\", BIGINT)\n(\"shipping_method_id\", BIGINT)\n(\"dest_address_id\", BIGINT)\n",
            "Table: \"shipping_method\"\nColumns:\n(\"method_id\", BIGINT, primary key)\n(\"method_name\", STRING)\n(\"cost\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 410,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(*) FROM order_status AS T1 INNER JOIN order_history AS T2 ON T1.status_id = T2.status_id WHERE T1.status_value = 'Cancelled' AND STRFTIME('%Y', T2.status_date) = '2022'",
        "target_query": "SELECT COUNT(*) FROM \"order_status\" AS \"T1\" INNER JOIN \"order_history\" AS \"T2\" ON \"T1\".\"status_id\" = \"T2\".\"status_id\" WHERE \"T1\".\"status_value\" = 'Cancelled' AND sys.timestamp_to_str(\"T2\".\"status_date\", '%Y') = '2022';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 142,
                "end_index": 171,
                "dilatect_content": "STRFTIME('%Y', T2.status_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 182,
                "end_index": 231,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"status_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `order_status`\nColumns:\n(`status_id`, integer, primary key)\n(`status_value`, text)\n",
            "Table: `order_history`\nColumns:\n(`history_id`, integer, primary key)\n(`order_id`, integer)\n(`status_id`, integer)\n(`status_date`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"order_status\"\nColumns:\n(\"status_id\", BIGINT, primary key)\n(\"status_value\", STRING)\n",
            "Table: \"order_history\"\nColumns:\n(\"history_id\", BIGINT, primary key)\n(\"order_id\", BIGINT)\n(\"status_id\", BIGINT)\n(\"status_date\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 411,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(*) FROM book WHERE STRFTIME('%Y', publication_date) = '2017'",
        "target_query": "SELECT COUNT(*) FROM \"book\" WHERE sys.timestamp_to_str(\"publication_date\", '%Y') = '2017';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 32,
                "end_index": 63,
                "dilatect_content": "STRFTIME('%Y', publication_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 36,
                "end_index": 83,
                "dilatect_content": "sys.timestamp_to_str(\"publication_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, integer, primary key)\n(`title`, text)\n(`isbn13`, text)\n(`language_id`, integer)\n(`num_pages`, integer)\n(`publication_date`, date)\n(`publisher_id`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"book\"\nColumns:\n(\"book_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"isbn13\", STRING)\n(\"language_id\", BIGINT)\n(\"num_pages\", BIGINT)\n(\"publication_date\", DATE)\n(\"publisher_id\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 412,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(CASE WHEN T1.status_value = 'Returned' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM order_status AS T1 INNER JOIN order_history AS T2 ON T1.status_id = T2.status_id WHERE STRFTIME('%Y', T2.status_date) = '2022'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T1\".\"status_value\" = 'Returned' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM \"order_status\" AS \"T1\" INNER JOIN \"order_history\" AS \"T2\" ON \"T1\".\"status_id\" = \"T2\".\"status_id\" WHERE sys.timestamp_to_str(\"T2\".\"status_date\", '%Y') = '2022';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 192,
                "end_index": 221,
                "dilatect_content": "STRFTIME('%Y', T2.status_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 232,
                "end_index": 281,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"status_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `order_status`\nColumns:\n(`status_id`, integer, primary key)\n(`status_value`, text)\n",
            "Table: `order_history`\nColumns:\n(`history_id`, integer, primary key)\n(`order_id`, integer)\n(`status_id`, integer)\n(`status_date`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"order_status\"\nColumns:\n(\"status_id\", BIGINT, primary key)\n(\"status_value\", STRING)\n",
            "Table: \"order_history\"\nColumns:\n(\"history_id\", BIGINT, primary key)\n(\"order_id\", BIGINT)\n(\"status_id\", BIGINT)\n(\"status_date\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 413,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.title FROM book AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE T2.publisher_name = 'Free Press' AND STRFTIME('%Y', T1.publication_date) BETWEEN '1990' AND '2000' ORDER BY T1.num_pages DESC LIMIT 1",
        "target_query": "SELECT \"T1\".\"title\" FROM \"book\" AS \"T1\" INNER JOIN \"publisher\" AS \"T2\" ON \"T1\".\"publisher_id\" = \"T2\".\"publisher_id\" WHERE \"T2\".\"publisher_name\" = 'Free Press' AND sys.timestamp_to_str(\"T1\".\"publication_date\", '%Y') BETWEEN '1990' AND '2000' ORDER BY \"T1\".\"num_pages\" DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 139,
                "end_index": 173,
                "dilatect_content": "STRFTIME('%Y', T1.publication_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 187,
                "end_index": 241,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"publication_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, integer, primary key)\n(`title`, text)\n(`isbn13`, text)\n(`language_id`, integer)\n(`num_pages`, integer)\n(`publication_date`, date)\n(`publisher_id`, integer)\n",
            "Table: `publisher`\nColumns:\n(`publisher_id`, integer, primary key)\n(`publisher_name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"book\"\nColumns:\n(\"book_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"isbn13\", STRING)\n(\"language_id\", BIGINT)\n(\"num_pages\", BIGINT)\n(\"publication_date\", DATE)\n(\"publisher_id\", BIGINT)\n",
            "Table: \"publisher\"\nColumns:\n(\"publisher_id\", BIGINT, primary key)\n(\"publisher_name\", STRING)\n"
        ]
    },
    {
        "sql_id": 414,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.price FROM book AS T1 INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id WHERE T1.title = 'The Servant Leader' AND STRFTIME('%Y', T1.publication_date) = '2003'",
        "target_query": "SELECT \"T2\".\"price\" FROM \"book\" AS \"T1\" INNER JOIN \"order_line\" AS \"T2\" ON \"T1\".\"book_id\" = \"T2\".\"book_id\" WHERE \"T1\".\"title\" = 'The Servant Leader' AND sys.timestamp_to_str(\"T1\".\"publication_date\", '%Y') = '2003';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 129,
                "end_index": 163,
                "dilatect_content": "STRFTIME('%Y', T1.publication_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 177,
                "end_index": 231,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"publication_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, integer, primary key)\n(`title`, text)\n(`isbn13`, text)\n(`language_id`, integer)\n(`num_pages`, integer)\n(`publication_date`, date)\n(`publisher_id`, integer)\n",
            "Table: `order_line`\nColumns:\n(`line_id`, integer, primary key)\n(`order_id`, integer)\n(`book_id`, integer)\n(`price`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"book\"\nColumns:\n(\"book_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"isbn13\", STRING)\n(\"language_id\", BIGINT)\n(\"num_pages\", BIGINT)\n(\"publication_date\", DATE)\n(\"publisher_id\", BIGINT)\n",
            "Table: \"order_line\"\nColumns:\n(\"line_id\", BIGINT, primary key)\n(\"order_id\", BIGINT)\n(\"book_id\", BIGINT)\n(\"price\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 415,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(*) FROM order_status AS T1 INNER JOIN order_history AS T2 ON T1.status_id = T2.status_id WHERE T1.status_value = 'Returned' AND STRFTIME('%Y', T2.status_date) = '2022'",
        "target_query": "SELECT COUNT(*) FROM \"order_status\" AS T1 INNER JOIN \"order_history\" AS T2 ON T1.\"status_id\" = T2.\"status_id\" WHERE T1.\"status_value\" = 'Returned' AND sys.timestamp_to_str(T2.\"status_date\", '%Y') = '2022';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 141,
                "end_index": 170,
                "dilatect_content": "STRFTIME('%Y', T2.status_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 161,
                "end_index": 206,
                "dilatect_content": "sys.timestamp_to_str(T2.\"status_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `order_status`\nColumns:\n(`status_id`, integer, primary key)\n(`status_value`, text)\n",
            "Table: `order_history`\nColumns:\n(`history_id`, integer, primary key)\n(`order_id`, integer)\n(`status_id`, integer)\n(`status_date`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"order_status\"\nColumns:\n(\"status_id\", BIGINT, primary key)\n(\"status_value\", STRING)\n",
            "Table: \"order_history\"\nColumns:\n(\"history_id\", BIGINT, primary key)\n(\"order_id\", BIGINT)\n(\"status_id\", BIGINT)\n(\"status_date\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 416,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(*) FROM book AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE T2.publisher_name = 'Birlinn' AND STRFTIME('%Y', T1.publication_date) = '2008' AND T1.num_pages BETWEEN 600 AND 700",
        "target_query": "SELECT COUNT(*) FROM \"book\" AS \"T1\" INNER JOIN \"publisher\" AS \"T2\" ON \"T1\".\"publisher_id\" = \"T2\".\"publisher_id\" WHERE \"T2\".\"publisher_name\" = 'Birlinn' AND sys.timestamp_to_str(\"T1\".\"publication_date\", '%Y') = '2008' AND \"T1\".\"num_pages\" BETWEEN 600 AND 700;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 136,
                "end_index": 170,
                "dilatect_content": "STRFTIME('%Y', T1.publication_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 176,
                "end_index": 230,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"publication_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, integer, primary key)\n(`title`, text)\n(`isbn13`, text)\n(`language_id`, integer)\n(`num_pages`, integer)\n(`publication_date`, date)\n(`publisher_id`, integer)\n",
            "Table: `publisher`\nColumns:\n(`publisher_id`, integer, primary key)\n(`publisher_name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"book\"\nColumns:\n(\"book_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"isbn13\", STRING)\n(\"language_id\", BIGINT)\n(\"num_pages\", BIGINT)\n(\"publication_date\", DATE)\n(\"publisher_id\", BIGINT)\n",
            "Table: \"publisher\"\nColumns:\n(\"publisher_id\", BIGINT, primary key)\n(\"publisher_name\", STRING)\n"
        ]
    },
    {
        "sql_id": 417,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(*) FROM book AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE T2.publisher_name = 'Brava' AND STRFTIME('%Y', T1.publication_date) = '2006'",
        "target_query": "SELECT COUNT(*) FROM \"book\" AS T1 INNER JOIN \"publisher\" AS T2 ON T1.\"publisher_id\" = T2.\"publisher_id\" WHERE T2.\"publisher_name\" = 'Brava' AND sys.timestamp_to_str(T1.\"publication_date\", '%Y') = '2006';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 134,
                "end_index": 168,
                "dilatect_content": "STRFTIME('%Y', T1.publication_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 154,
                "end_index": 204,
                "dilatect_content": "sys.timestamp_to_str(T1.\"publication_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, integer, primary key)\n(`title`, text)\n(`isbn13`, text)\n(`language_id`, integer)\n(`num_pages`, integer)\n(`publication_date`, date)\n(`publisher_id`, integer)\n",
            "Table: `publisher`\nColumns:\n(`publisher_id`, integer, primary key)\n(`publisher_name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"book\"\nColumns:\n(\"book_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"isbn13\", STRING)\n(\"language_id\", BIGINT)\n(\"num_pages\", BIGINT)\n(\"publication_date\", DATE)\n(\"publisher_id\", BIGINT)\n",
            "Table: \"publisher\"\nColumns:\n(\"publisher_id\", BIGINT, primary key)\n(\"publisher_name\", STRING)\n"
        ]
    },
    {
        "sql_id": 418,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT T1.first_name, T1.last_name FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE strftime('%Y-%m', T2.inspection_date) = '2010-05' AND T1.title = 'Sanitarian'",
        "target_query": "SELECT DISTINCT \"T1\".\"first_name\", \"T1\".\"last_name\" FROM \"employee\" AS \"T1\" INNER JOIN \"inspection\" AS \"T2\" ON \"T1\".\"employee_id\" = \"T2\".\"employee_id\" WHERE sys.timestamp_to_str(\"T2\".\"inspection_date\", '%Y-%m-%d') LIKE '2010-05%' AND \"T1\".\"title\" = 'Sanitarian';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 133,
                "end_index": 169,
                "dilatect_content": "strftime('%Y-%m', T2.inspection_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 181,
                "end_index": 240,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"inspection_date\", '%Y-%m-%d')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`employee_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`phone`, text)\n(`title`, text)\n(`salary`, integer)\n(`supervisor`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"employee\"\nColumns:\n(\"employee_id\", BIGINT, primary key)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", BIGINT)\n(\"phone\", STRING)\n(\"title\", STRING)\n(\"salary\", BIGINT)\n(\"supervisor\", BIGINT)\n",
            "Table: \"inspection\"\nColumns:\n(\"inspection_id\", BIGINT, primary key)\n(\"inspection_date\", DATE)\n(\"inspection_type\", STRING)\n(\"results\", STRING)\n(\"employee_id\", BIGINT)\n(\"license_no\", BIGINT)\n(\"followup_to\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 419,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T2.inspection_id) FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE strftime('%Y', T2.inspection_date) = '2010' AND T1.first_name = 'Joshua' AND T1.last_name = 'Rosa'",
        "target_query": "SELECT COUNT(\"T2\".\"inspection_id\") FROM \"employee\" AS \"T1\" INNER JOIN \"inspection\" AS \"T2\" ON \"T1\".\"employee_id\" = \"T2\".\"employee_id\" WHERE sys.timestamp_to_str(\"T2\".\"inspection_date\", '%Y') = '2010' AND \"T1\".\"first_name\" = 'Joshua' AND \"T1\".\"last_name\" = 'Rosa';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 120,
                "end_index": 153,
                "dilatect_content": "strftime('%Y', T2.inspection_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 160,
                "end_index": 213,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"inspection_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`employee_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`phone`, text)\n(`title`, text)\n(`salary`, integer)\n(`supervisor`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"employee\"\nColumns:\n(\"employee_id\", BIGINT, primary key)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", BIGINT)\n(\"phone\", STRING)\n(\"title\", STRING)\n(\"salary\", BIGINT)\n(\"supervisor\", BIGINT)\n",
            "Table: \"inspection\"\nColumns:\n(\"inspection_id\", BIGINT, primary key)\n(\"inspection_date\", DATE)\n(\"inspection_type\", STRING)\n(\"results\", STRING)\n(\"employee_id\", BIGINT)\n(\"license_no\", BIGINT)\n(\"followup_to\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 420,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(DISTINCT T1.license_no) FROM inspection AS T1 INNER JOIN establishment AS T2 ON T1.license_no = T2.license_no WHERE strftime('%Y', T1.inspection_date) = '2010' AND T2.facility_type = 'Restaurant'",
        "target_query": "SELECT COUNT(DISTINCT \"T1\".\"license_no\") FROM \"inspection\" AS \"T1\" INNER JOIN \"establishment\" AS \"T2\" ON \"T1\".\"license_no\" = \"T2\".\"license_no\" WHERE sys.timestamp_to_str(\"T1\".\"inspection_date\", '%Y') = '2010' AND \"T2\".\"facility_type\" = 'Restaurant';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 129,
                "end_index": 162,
                "dilatect_content": "strftime('%Y', T1.inspection_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 169,
                "end_index": 222,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"inspection_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n",
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"inspection\"\nColumns:\n(\"inspection_id\", BIGINT, primary key)\n(\"inspection_date\", DATE)\n(\"inspection_type\", STRING)\n(\"results\", STRING)\n(\"employee_id\", BIGINT)\n(\"license_no\", BIGINT)\n(\"followup_to\", BIGINT)\n",
            "Table: \"establishment\"\nColumns:\n(\"license_no\", BIGINT, primary key)\n(\"dba_name\", STRING)\n(\"aka_name\", STRING)\n(\"facility_type\", STRING)\n(\"risk_level\", BIGINT)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", BIGINT)\n(\"latitude\", DOUBLE PRECISION)\n(\"longitude\", DOUBLE PRECISION)\n(\"ward\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 421,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(DISTINCT T1.license_no) FROM inspection AS T1 INNER JOIN establishment AS T2 ON T1.license_no = T2.license_no WHERE strftime('%Y', T1.inspection_date) = '2010' AND T2.ward = 42",
        "target_query": "SELECT COUNT(DISTINCT \"T1\".\"license_no\") FROM \"inspection\" AS \"T1\" INNER JOIN \"establishment\" AS \"T2\" ON \"T1\".\"license_no\" = \"T2\".\"license_no\" WHERE EXTRACT(YEAR FROM \"T1\".\"inspection_date\") = 2010 AND \"T2\".\"ward\" = 42;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 129,
                "end_index": 162,
                "dilatect_content": "strftime('%Y', T1.inspection_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 177,
                "end_index": 212,
                "dilatect_content": "YEAR FROM \"T1\".\"inspection_date\"",
                "feature": ""
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n",
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"inspection\"\nColumns:\n(\"inspection_id\", BIGINT, primary key)\n(\"inspection_date\", DATE)\n(\"inspection_type\", STRING)\n(\"results\", STRING)\n(\"employee_id\", BIGINT)\n(\"license_no\", BIGINT)\n(\"followup_to\", BIGINT)\n",
            "Table: \"establishment\"\nColumns:\n(\"license_no\", BIGINT, primary key)\n(\"dba_name\", STRING)\n(\"aka_name\", STRING)\n(\"facility_type\", STRING)\n(\"risk_level\", BIGINT)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", BIGINT)\n(\"latitude\", DOUBLE PRECISION)\n(\"longitude\", DOUBLE PRECISION)\n(\"ward\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 422,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT T2.dba_name FROM inspection AS T1 INNER JOIN establishment AS T2 ON T1.license_no = T2.license_no WHERE T1.results = 'Fail' AND strftime('%Y', T1.inspection_date) = '2010'",
        "target_query": "SELECT DISTINCT \"T2\".\"dba_name\" FROM \"inspection\" AS \"T1\" INNER JOIN \"establishment\" AS \"T2\" ON \"T1\".\"license_no\" = \"T2\".\"license_no\" WHERE \"T1\".\"results\" = 'Fail' AND sys.timestamp_to_str(\"T1\".\"inspection_date\", '%Y') = '2010';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 144,
                "end_index": 177,
                "dilatect_content": "strftime('%Y', T1.inspection_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 192,
                "end_index": 245,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"inspection_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n",
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"inspection\"\nColumns:\n(\"inspection_id\", BIGINT, primary key)\n(\"inspection_date\", DATE)\n(\"inspection_type\", STRING)\n(\"results\", STRING)\n(\"employee_id\", BIGINT)\n(\"license_no\", BIGINT)\n(\"followup_to\", BIGINT)\n",
            "Table: \"establishment\"\nColumns:\n(\"license_no\", BIGINT, primary key)\n(\"dba_name\", STRING)\n(\"aka_name\", STRING)\n(\"facility_type\", STRING)\n(\"risk_level\", BIGINT)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", BIGINT)\n(\"latitude\", DOUBLE PRECISION)\n(\"longitude\", DOUBLE PRECISION)\n(\"ward\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 423,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(DISTINCT T2.license_no) FROM inspection AS T1 INNER JOIN establishment AS T2 ON T1.license_no = T2.license_no WHERE strftime('%Y', T1.inspection_date) = '2010' AND T2.risk_level = 3",
        "target_query": "SELECT COUNT(DISTINCT \"T2\".\"license_no\") FROM \"inspection\" AS \"T1\" INNER JOIN \"establishment\" AS \"T2\" ON \"T1\".\"license_no\" = \"T2\".\"license_no\" WHERE sys.timestamp_to_str(\"T1\".\"inspection_date\", '%Y') = '2010' AND \"T2\".\"risk_level\" = 3;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 129,
                "end_index": 162,
                "dilatect_content": "strftime('%Y', T1.inspection_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 169,
                "end_index": 222,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"inspection_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n",
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"inspection\"\nColumns:\n(\"inspection_id\", BIGINT, primary key)\n(\"inspection_date\", DATE)\n(\"inspection_type\", STRING)\n(\"results\", STRING)\n(\"employee_id\", BIGINT)\n(\"license_no\", BIGINT)\n(\"followup_to\", BIGINT)\n",
            "Table: \"establishment\"\nColumns:\n(\"license_no\", BIGINT, primary key)\n(\"dba_name\", STRING)\n(\"aka_name\", STRING)\n(\"facility_type\", STRING)\n(\"risk_level\", BIGINT)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", BIGINT)\n(\"latitude\", DOUBLE PRECISION)\n(\"longitude\", DOUBLE PRECISION)\n(\"ward\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 424,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T1.inspection_id) FROM inspection AS T1 INNER JOIN employee AS T2 ON T1.employee_id = T2.employee_id WHERE T2.address = '5000 N Wolcott Ave' AND T2.title = 'Sanitarian' AND strftime('%Y-%m', T1.inspection_date) = '2011-05'",
        "target_query": "SELECT COUNT(\"T1\".\"inspection_id\") FROM \"inspection\" AS \"T1\" INNER JOIN \"employee\" AS \"T2\" ON \"T1\".\"employee_id\" = \"T2\".\"employee_id\" WHERE \"T2\".\"address\" = '5000 N Wolcott Ave' AND \"T2\".\"title\" = 'Sanitarian' AND sys.timestamp_to_str(\"T1\".\"inspection_date\", '%Y-%m') = '2011-05';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 186,
                "end_index": 222,
                "dilatect_content": "strftime('%Y-%m', T1.inspection_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 242,
                "end_index": 298,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"inspection_date\", '%Y-%m')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n",
            "Table: `employee`\nColumns:\n(`employee_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`phone`, text)\n(`title`, text)\n(`salary`, integer)\n(`supervisor`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"inspection\"\nColumns:\n(\"inspection_id\", BIGINT, primary key)\n(\"inspection_date\", DATE)\n(\"inspection_type\", STRING)\n(\"results\", STRING)\n(\"employee_id\", BIGINT)\n(\"license_no\", BIGINT)\n(\"followup_to\", BIGINT)\n",
            "Table: \"employee\"\nColumns:\n(\"employee_id\", BIGINT, primary key)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", BIGINT)\n(\"phone\", STRING)\n(\"title\", STRING)\n(\"salary\", BIGINT)\n(\"supervisor\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 425,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T3.first_name, T3.last_name FROM ( SELECT T1.employee_id, COUNT(T1.inspection_id) FROM inspection AS T1 WHERE strftime('%Y-%m', T1.inspection_date) = '2016-03' GROUP BY T1.employee_id ORDER BY COUNT(T1.inspection_id) DESC LIMIT 1 ) AS T2 INNER JOIN employee AS T3 ON T2.employee_id = T3.employee_id",
        "target_query": "SELECT \"T3\".\"first_name\", \"T3\".\"last_name\" \nFROM ( \n    SELECT \"T1\".\"employee_id\", COUNT(\"T1\".\"inspection_id\") \n    FROM \"inspection\" AS \"T1\" \n    WHERE \"T1\".\"inspection_date\" >= DATE '2016-03-01' AND \"T1\".\"inspection_date\" < DATE '2016-04-01' \n    GROUP BY \"T1\".\"employee_id\" \n    ORDER BY COUNT(\"T1\".\"inspection_id\") DESC \n    LIMIT 1 \n) AS \"T2\" \nINNER JOIN \"employee\" AS \"T3\" ON \"T2\".\"employee_id\" = \"T3\".\"employee_id\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 117,
                "end_index": 153,
                "dilatect_content": "strftime('%Y-%m', T1.inspection_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`employee_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`phone`, text)\n(`title`, text)\n(`salary`, integer)\n(`supervisor`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"employee\"\nColumns:\n(\"employee_id\", BIGINT, primary key)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", BIGINT)\n(\"phone\", STRING)\n(\"title\", STRING)\n(\"salary\", BIGINT)\n(\"supervisor\", BIGINT)\n",
            "Table: \"inspection\"\nColumns:\n(\"inspection_id\", BIGINT, primary key)\n(\"inspection_date\", DATE)\n(\"inspection_type\", STRING)\n(\"results\", STRING)\n(\"employee_id\", BIGINT)\n(\"license_no\", BIGINT)\n(\"followup_to\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 426,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT T2.dba_name FROM inspection AS T1 INNER JOIN establishment AS T2 ON T1.license_no = T2.license_no WHERE strftime('%Y-%m', T1.inspection_date) = '2012-05' AND T1.results = 'Pass w/ Conditions'",
        "target_query": "SELECT DISTINCT \"T2\".\"dba_name\" FROM \"inspection\" AS \"T1\" INNER JOIN \"establishment\" AS \"T2\" ON \"T1\".\"license_no\" = \"T2\".\"license_no\" WHERE sys.timestamp_to_str(\"T1\".\"inspection_date\", '%Y-%m') = '2012-05' AND \"T1\".\"results\" = 'Pass w/ Conditions';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 120,
                "end_index": 156,
                "dilatect_content": "strftime('%Y-%m', T1.inspection_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 160,
                "end_index": 216,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"inspection_date\", '%Y-%m')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n",
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"inspection\"\nColumns:\n(\"inspection_id\", BIGINT, primary key)\n(\"inspection_date\", DATE)\n(\"inspection_type\", STRING)\n(\"results\", STRING)\n(\"employee_id\", BIGINT)\n(\"license_no\", BIGINT)\n(\"followup_to\", BIGINT)\n",
            "Table: \"establishment\"\nColumns:\n(\"license_no\", BIGINT, primary key)\n(\"dba_name\", STRING)\n(\"aka_name\", STRING)\n(\"facility_type\", STRING)\n(\"risk_level\", BIGINT)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", BIGINT)\n(\"latitude\", DOUBLE PRECISION)\n(\"longitude\", DOUBLE PRECISION)\n(\"ward\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 427,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T.dba_name FROM ( SELECT T1.dba_name, SUM(T3.fine) FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no INNER JOIN violation AS T3 ON T2.inspection_id = T3.inspection_id WHERE strftime('%Y', T2.inspection_date) = '2014' GROUP BY T1.dba_name ORDER BY SUM(T3.fine) DESC LIMIT 1 ) AS T",
        "target_query": "SELECT \"T\".\"dba_name\" FROM ( SELECT \"T1\".\"dba_name\", SUM(\"T3\".\"fine\") FROM \"establishment\" AS \"T1\" INNER JOIN \"inspection\" AS \"T2\" ON \"T1\".\"license_no\" = \"T2\".\"license_no\" INNER JOIN \"violation\" AS \"T3\" ON \"T2\".\"inspection_id\" = \"T3\".\"inspection_id\" WHERE sys.timestamp_to_str(\"T2\".\"inspection_date\", '%Y') = '2014' GROUP BY \"T1\".\"dba_name\" ORDER BY SUM(\"T3\".\"fine\") DESC LIMIT 1 ) AS \"T\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 216,
                "end_index": 249,
                "dilatect_content": "strftime('%Y', T2.inspection_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 296,
                "end_index": 349,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"inspection_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n",
            "Table: `violation`\nColumns:\n(`inspection_id`, integer, primary key)\n(`point_id`, integer, primary key)\n(`fine`, integer)\n(`inspector_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"establishment\"\nColumns:\n(\"license_no\", BIGINT, primary key)\n(\"dba_name\", STRING)\n(\"aka_name\", STRING)\n(\"facility_type\", STRING)\n(\"risk_level\", BIGINT)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", BIGINT)\n(\"latitude\", DOUBLE PRECISION)\n(\"longitude\", DOUBLE PRECISION)\n(\"ward\", BIGINT)\n",
            "Table: \"inspection\"\nColumns:\n(\"inspection_id\", BIGINT, primary key)\n(\"inspection_date\", DATE)\n(\"inspection_type\", STRING)\n(\"results\", STRING)\n(\"employee_id\", BIGINT)\n(\"license_no\", BIGINT)\n(\"followup_to\", BIGINT)\n",
            "Table: \"violation\"\nColumns:\n(\"inspection_id\", BIGINT, primary key)\n(\"point_id\", BIGINT, primary key)\n(\"fine\", BIGINT)\n(\"inspector_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 428,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(T3.fine) FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no INNER JOIN violation AS T3 ON T2.inspection_id = T3.inspection_id WHERE strftime('%Y-%m', T2.inspection_date) = '2014-02' AND T1.dba_name = 'RON OF JAPAN INC'",
        "target_query": "SELECT SUM(\"T3\".\"fine\") FROM \"establishment\" AS \"T1\" INNER JOIN \"inspection\" AS \"T2\" ON \"T1\".\"license_no\" = \"T2\".\"license_no\" INNER JOIN \"violation\" AS \"T3\" ON \"T2\".\"inspection_id\" = \"T3\".\"inspection_id\" WHERE sys.timestamp_to_str(\"T2\".\"inspection_date\", '%Y-%m') = '2014-02' AND \"T1\".\"dba_name\" = 'RON OF JAPAN INC';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 178,
                "end_index": 214,
                "dilatect_content": "strftime('%Y-%m', T2.inspection_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 242,
                "end_index": 298,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"inspection_date\", '%Y-%m')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n",
            "Table: `violation`\nColumns:\n(`inspection_id`, integer, primary key)\n(`point_id`, integer, primary key)\n(`fine`, integer)\n(`inspector_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"establishment\"\nColumns:\n(\"license_no\", BIGINT, primary key)\n(\"dba_name\", STRING)\n(\"aka_name\", STRING)\n(\"facility_type\", STRING)\n(\"risk_level\", BIGINT)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", BIGINT)\n(\"latitude\", DOUBLE PRECISION)\n(\"longitude\", DOUBLE PRECISION)\n(\"ward\", BIGINT)\n",
            "Table: \"inspection\"\nColumns:\n(\"inspection_id\", BIGINT, primary key)\n(\"inspection_date\", DATE)\n(\"inspection_type\", STRING)\n(\"results\", STRING)\n(\"employee_id\", BIGINT)\n(\"license_no\", BIGINT)\n(\"followup_to\", BIGINT)\n",
            "Table: \"violation\"\nColumns:\n(\"inspection_id\", BIGINT, primary key)\n(\"point_id\", BIGINT, primary key)\n(\"fine\", BIGINT)\n(\"inspector_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 429,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT T1.address FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE strftime('%Y-%m', T2.inspection_date) = '2010-03' AND T2.results = 'Pass' AND T1.facility_type = 'School'",
        "target_query": "SELECT DISTINCT \"establishment\".\"address\" FROM \"establishment\" INNER JOIN \"inspection\" ON \"establishment\".\"license_no\" = \"inspection\".\"license_no\" WHERE sys.timestamp_to_str(\"inspection\".\"inspection_date\", '%Y-%m') = '2010-03' AND \"inspection\".\"results\" = 'Pass' AND \"establishment\".\"facility_type\" = 'School';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 119,
                "end_index": 155,
                "dilatect_content": "strftime('%Y-%m', T2.inspection_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 169,
                "end_index": 233,
                "dilatect_content": "sys.timestamp_to_str(\"inspection\".\"inspection_date\", '%Y-%m')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"establishment\"\nColumns:\n(\"license_no\", BIGINT, primary key)\n(\"dba_name\", STRING)\n(\"aka_name\", STRING)\n(\"facility_type\", STRING)\n(\"risk_level\", BIGINT)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", BIGINT)\n(\"latitude\", DOUBLE PRECISION)\n(\"longitude\", DOUBLE PRECISION)\n(\"ward\", BIGINT)\n",
            "Table: \"inspection\"\nColumns:\n(\"inspection_id\", BIGINT, primary key)\n(\"inspection_date\", DATE)\n(\"inspection_type\", STRING)\n(\"results\", STRING)\n(\"employee_id\", BIGINT)\n(\"license_no\", BIGINT)\n(\"followup_to\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 430,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(inspection_id) FROM inspection WHERE strftime('%Y-%m', inspection_date) = '2011-01'",
        "target_query": "SELECT COUNT(\"inspection_id\") FROM \"inspection\" WHERE sys.timestamp_to_str(\"inspection_date\", '%Y-%m') = '2011-01';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 50,
                "end_index": 83,
                "dilatect_content": "strftime('%Y-%m', inspection_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 58,
                "end_index": 107,
                "dilatect_content": "sys.timestamp_to_str(\"inspection_date\", '%Y-%m')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"inspection\"\nColumns:\n(\"inspection_id\", BIGINT, primary key)\n(\"inspection_date\", DATE)\n(\"inspection_type\", STRING)\n(\"results\", STRING)\n(\"employee_id\", BIGINT)\n(\"license_no\", BIGINT)\n(\"followup_to\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 431,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(inspection_id) FROM inspection WHERE strftime('%Y', inspection_date) = '2014' AND results = 'Fail'",
        "target_query": "SELECT COUNT(\"inspection_id\") FROM \"inspection\" WHERE sys.timestamp_to_str(\"inspection_date\", '%Y') = '2014' AND \"results\" = 'Fail';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 50,
                "end_index": 80,
                "dilatect_content": "strftime('%Y', inspection_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 58,
                "end_index": 104,
                "dilatect_content": "sys.timestamp_to_str(\"inspection_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"inspection\"\nColumns:\n(\"inspection_id\", BIGINT, primary key)\n(\"inspection_date\", DATE)\n(\"inspection_type\", STRING)\n(\"results\", STRING)\n(\"employee_id\", BIGINT)\n(\"license_no\", BIGINT)\n(\"followup_to\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 433,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(COUNT(CASE WHEN T1.first_name = 'Jessica' AND T1.last_name = 'Anthony' THEN T2.inspection_id ELSE 0 END) AS REAL) / 8 FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE strftime('%Y', T2.inspection_date) BETWEEN '2010' AND '2017'",
        "target_query": "SELECT CAST(COUNT(CASE WHEN \"T1\".\"first_name\" = 'Jessica' AND \"T1\".\"last_name\" = 'Anthony' THEN \"T2\".\"inspection_id\" ELSE 0 END) AS REAL) / 8 FROM \"employee\" AS \"T1\" INNER JOIN \"inspection\" AS \"T2\" ON \"T1\".\"employee_id\" = \"T2\".\"employee_id\" WHERE sys.timestamp_to_str(\"T2\".\"inspection_date\", '%Y') BETWEEN '2010' AND '2017';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 219,
                "end_index": 252,
                "dilatect_content": "strftime('%Y', T2.inspection_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 275,
                "end_index": 328,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"inspection_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`employee_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`phone`, text)\n(`title`, text)\n(`salary`, integer)\n(`supervisor`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"employee\"\nColumns:\n(\"employee_id\", BIGINT, primary key)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", BIGINT)\n(\"phone\", STRING)\n(\"title\", STRING)\n(\"salary\", BIGINT)\n(\"supervisor\", BIGINT)\n",
            "Table: \"inspection\"\nColumns:\n(\"inspection_id\", BIGINT, primary key)\n(\"inspection_date\", DATE)\n(\"inspection_type\", STRING)\n(\"results\", STRING)\n(\"employee_id\", BIGINT)\n(\"license_no\", BIGINT)\n(\"followup_to\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 434,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T2.inspection_id) FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE strftime('%Y', T2.inspection_date) = '2010' AND T1.risk_level = 3",
        "target_query": "SELECT COUNT(\"T2\".\"inspection_id\") FROM \"establishment\" AS \"T1\" INNER JOIN \"inspection\" AS \"T2\" ON \"T1\".\"license_no\" = \"T2\".\"license_no\" WHERE sys.timestamp_to_str(\"T2\".\"inspection_date\", '%Y') = '2010' AND \"T1\".\"risk_level\" = 3;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 123,
                "end_index": 156,
                "dilatect_content": "strftime('%Y', T2.inspection_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 163,
                "end_index": 216,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"inspection_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"establishment\"\nColumns:\n(\"license_no\", BIGINT, primary key)\n(\"dba_name\", STRING)\n(\"aka_name\", STRING)\n(\"facility_type\", STRING)\n(\"risk_level\", BIGINT)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", BIGINT)\n(\"latitude\", DOUBLE PRECISION)\n(\"longitude\", DOUBLE PRECISION)\n(\"ward\", BIGINT)\n",
            "Table: \"inspection\"\nColumns:\n(\"inspection_id\", BIGINT, primary key)\n(\"inspection_date\", DATE)\n(\"inspection_type\", STRING)\n(\"results\", STRING)\n(\"employee_id\", BIGINT)\n(\"license_no\", BIGINT)\n(\"followup_to\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 435,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT MIN(T2.inspection_date) FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE T1.dba_name = 'JOHN SCHALLER' AND strftime('%Y', T2.inspection_date) = '2010'",
        "target_query": "SELECT MIN(\"T2\".\"inspection_date\") FROM \"establishment\" AS \"T1\" INNER JOIN \"inspection\" AS \"T2\" ON \"T1\".\"license_no\" = \"T2\".\"license_no\" WHERE \"T1\".\"dba_name\" = 'JOHN SCHALLER' AND sys.timestamp_to_str(\"T2\".\"inspection_date\", '%Y') = '2010';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 157,
                "end_index": 190,
                "dilatect_content": "strftime('%Y', T2.inspection_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 205,
                "end_index": 258,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"inspection_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"establishment\"\nColumns:\n(\"license_no\", BIGINT, primary key)\n(\"dba_name\", STRING)\n(\"aka_name\", STRING)\n(\"facility_type\", STRING)\n(\"risk_level\", BIGINT)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", BIGINT)\n(\"latitude\", DOUBLE PRECISION)\n(\"longitude\", DOUBLE PRECISION)\n(\"ward\", BIGINT)\n",
            "Table: \"inspection\"\nColumns:\n(\"inspection_id\", BIGINT, primary key)\n(\"inspection_date\", DATE)\n(\"inspection_type\", STRING)\n(\"results\", STRING)\n(\"employee_id\", BIGINT)\n(\"license_no\", BIGINT)\n(\"followup_to\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 436,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT T1.dba_name FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE strftime('%Y', T2.inspection_date) = '2010' AND T2.results = 'Pass' AND T1.facility_type = 'Liquor'",
        "target_query": "SELECT DISTINCT \"T1\".\"dba_name\" FROM \"establishment\" AS \"T1\" INNER JOIN \"inspection\" AS \"T2\" ON \"T1\".\"license_no\" = \"T2\".\"license_no\" WHERE sys.timestamp_to_str(\"T2\".\"inspection_date\", '%Y') = '2010' AND \"T2\".\"results\" = 'Pass' AND \"T1\".\"facility_type\" = 'Liquor';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 120,
                "end_index": 153,
                "dilatect_content": "strftime('%Y', T2.inspection_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 160,
                "end_index": 213,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"inspection_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"establishment\"\nColumns:\n(\"license_no\", BIGINT, primary key)\n(\"dba_name\", STRING)\n(\"aka_name\", STRING)\n(\"facility_type\", STRING)\n(\"risk_level\", BIGINT)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", BIGINT)\n(\"latitude\", DOUBLE PRECISION)\n(\"longitude\", DOUBLE PRECISION)\n(\"ward\", BIGINT)\n",
            "Table: \"inspection\"\nColumns:\n(\"inspection_id\", BIGINT, primary key)\n(\"inspection_date\", DATE)\n(\"inspection_type\", STRING)\n(\"results\", STRING)\n(\"employee_id\", BIGINT)\n(\"license_no\", BIGINT)\n(\"followup_to\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 437,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(DISTINCT T1.license_no) FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE strftime('%Y-%m', T2.inspection_date) = '2010-07' AND T2.results = 'Fail' AND T1.facility_type = 'Restaurant'",
        "target_query": "SELECT COUNT(DISTINCT \"T1\".\"license_no\") FROM \"establishment\" AS \"T1\" INNER JOIN \"inspection\" AS \"T2\" ON \"T1\".\"license_no\" = \"T2\".\"license_no\" WHERE sys.timestamp_to_str(\"T2\".\"inspection_date\", '%Y-%m') = '2010-07' AND \"T2\".\"results\" = 'Fail' AND \"T1\".\"facility_type\" = 'Restaurant';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 129,
                "end_index": 165,
                "dilatect_content": "strftime('%Y-%m', T2.inspection_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 169,
                "end_index": 225,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"inspection_date\", '%Y-%m')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"establishment\"\nColumns:\n(\"license_no\", BIGINT, primary key)\n(\"dba_name\", STRING)\n(\"aka_name\", STRING)\n(\"facility_type\", STRING)\n(\"risk_level\", BIGINT)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", BIGINT)\n(\"latitude\", DOUBLE PRECISION)\n(\"longitude\", DOUBLE PRECISION)\n(\"ward\", BIGINT)\n",
            "Table: \"inspection\"\nColumns:\n(\"inspection_id\", BIGINT, primary key)\n(\"inspection_date\", DATE)\n(\"inspection_type\", STRING)\n(\"results\", STRING)\n(\"employee_id\", BIGINT)\n(\"license_no\", BIGINT)\n(\"followup_to\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 438,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT T3.dba_name, T2.results FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id INNER JOIN establishment AS T3 ON T2.license_no = T3.license_no WHERE T1.first_name = 'Bob' AND T1.last_name = 'Benson' AND strftime('%Y', T2.inspection_date) = '2010'",
        "target_query": "SELECT DISTINCT \"T3\".\"dba_name\", \"T2\".\"results\" FROM \"employee\" AS \"T1\" INNER JOIN \"inspection\" AS \"T2\" ON \"T1\".\"employee_id\" = \"T2\".\"employee_id\" INNER JOIN \"establishment\" AS \"T3\" ON \"T2\".\"license_no\" = \"T3\".\"license_no\" WHERE \"T1\".\"first_name\" = 'Bob' AND \"T1\".\"last_name\" = 'Benson' AND sys.timestamp_to_str(\"T2\".\"inspection_date\", '%Y') = '2010';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 247,
                "end_index": 280,
                "dilatect_content": "strftime('%Y', T2.inspection_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 335,
                "end_index": 388,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"inspection_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`employee_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`phone`, text)\n(`title`, text)\n(`salary`, integer)\n(`supervisor`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n",
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"employee\"\nColumns:\n(\"employee_id\", BIGINT, primary key)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", BIGINT)\n(\"phone\", STRING)\n(\"title\", STRING)\n(\"salary\", BIGINT)\n(\"supervisor\", BIGINT)\n",
            "Table: \"inspection\"\nColumns:\n(\"inspection_id\", BIGINT, primary key)\n(\"inspection_date\", DATE)\n(\"inspection_type\", STRING)\n(\"results\", STRING)\n(\"employee_id\", BIGINT)\n(\"license_no\", BIGINT)\n(\"followup_to\", BIGINT)\n",
            "Table: \"establishment\"\nColumns:\n(\"license_no\", BIGINT, primary key)\n(\"dba_name\", STRING)\n(\"aka_name\", STRING)\n(\"facility_type\", STRING)\n(\"risk_level\", BIGINT)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", BIGINT)\n(\"latitude\", DOUBLE PRECISION)\n(\"longitude\", DOUBLE PRECISION)\n(\"ward\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 439,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(DISTINCT T1.license_no) FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE strftime('%Y-%m', T2.inspection_date) = '2010-04' AND T1.facility_type = 'Restaurant' AND T2.results = 'Fail'",
        "target_query": "SELECT COUNT(DISTINCT \"T1\".\"license_no\") FROM \"establishment\" AS \"T1\" INNER JOIN \"inspection\" AS \"T2\" ON \"T1\".\"license_no\" = \"T2\".\"license_no\" WHERE sys.timestamp_to_str(\"T2\".\"inspection_date\", '%Y-%m') = '2010-04' AND \"T1\".\"facility_type\" = 'Restaurant' AND \"T2\".\"results\" = 'Fail';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 129,
                "end_index": 165,
                "dilatect_content": "strftime('%Y-%m', T2.inspection_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 169,
                "end_index": 225,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"inspection_date\", '%Y-%m')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"establishment\"\nColumns:\n(\"license_no\", BIGINT, primary key)\n(\"dba_name\", STRING)\n(\"aka_name\", STRING)\n(\"facility_type\", STRING)\n(\"risk_level\", BIGINT)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", BIGINT)\n(\"latitude\", DOUBLE PRECISION)\n(\"longitude\", DOUBLE PRECISION)\n(\"ward\", BIGINT)\n",
            "Table: \"inspection\"\nColumns:\n(\"inspection_id\", BIGINT, primary key)\n(\"inspection_date\", DATE)\n(\"inspection_type\", STRING)\n(\"results\", STRING)\n(\"employee_id\", BIGINT)\n(\"license_no\", BIGINT)\n(\"followup_to\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 440,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT T1.dba_name FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no INNER JOIN violation AS T3 ON T2.inspection_id = T3.inspection_id WHERE strftime('%Y-%m', T2.inspection_date) = '2010-01' AND T2.results = 'Fail' AND T1.facility_type = 'TAVERN'",
        "target_query": "SELECT DISTINCT \"T1\".\"dba_name\" FROM \"establishment\" AS \"T1\" INNER JOIN \"inspection\" AS \"T2\" ON \"T1\".\"license_no\" = \"T2\".\"license_no\" INNER JOIN \"violation\" AS \"T3\" ON \"T2\".\"inspection_id\" = \"T3\".\"inspection_id\" WHERE sys.timestamp_to_str(\"T2\".\"inspection_date\", '%Y-%m') = '2010-01' AND \"T2\".\"results\" = 'Fail' AND \"T1\".\"facility_type\" = 'TAVERN';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 186,
                "end_index": 222,
                "dilatect_content": "strftime('%Y-%m', T2.inspection_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 250,
                "end_index": 306,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"inspection_date\", '%Y-%m')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n",
            "Table: `violation`\nColumns:\n(`inspection_id`, integer, primary key)\n(`point_id`, integer, primary key)\n(`fine`, integer)\n(`inspector_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"establishment\"\nColumns:\n(\"license_no\", BIGINT, primary key)\n(\"dba_name\", STRING)\n(\"aka_name\", STRING)\n(\"facility_type\", STRING)\n(\"risk_level\", BIGINT)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", BIGINT)\n(\"latitude\", DOUBLE PRECISION)\n(\"longitude\", DOUBLE PRECISION)\n(\"ward\", BIGINT)\n",
            "Table: \"inspection\"\nColumns:\n(\"inspection_id\", BIGINT, primary key)\n(\"inspection_date\", DATE)\n(\"inspection_type\", STRING)\n(\"results\", STRING)\n(\"employee_id\", BIGINT)\n(\"license_no\", BIGINT)\n(\"followup_to\", BIGINT)\n",
            "Table: \"violation\"\nColumns:\n(\"inspection_id\", BIGINT, primary key)\n(\"point_id\", BIGINT, primary key)\n(\"fine\", BIGINT)\n(\"inspector_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 441,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT T1.employee_id FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE T2.results = 'Fail' AND strftime('%Y-%m', T2.inspection_date) = '2010-02' AND T1.salary > 0.7 * ( SELECT AVG(salary) FROM employee )",
        "target_query": "SELECT DISTINCT \"T1\".\"employee_id\" \nFROM \"employee\" AS \"T1\" \nINNER JOIN \"inspection\" AS \"T2\" ON \"T1\".\"employee_id\" = \"T2\".\"employee_id\" \nWHERE \"T2\".\"results\" = 'Fail' \nAND sys.timestamp_to_str(\"T2\".\"inspection_date\", '%Y-%m') = '2010-02' \nAND \"T1\".\"salary\" > 0.7 * (SELECT AVG(\"salary\") FROM \"employee\");",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 144,
                "end_index": 180,
                "dilatect_content": "strftime('%Y-%m', T2.inspection_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 200,
                "end_index": 256,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"inspection_date\", '%Y-%m')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`employee_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`phone`, text)\n(`title`, text)\n(`salary`, integer)\n(`supervisor`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n",
            "Table: `employee`\nColumns:\n(`employee_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`phone`, text)\n(`title`, text)\n(`salary`, integer)\n(`supervisor`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"employee\"\nColumns:\n(\"employee_id\", BIGINT, primary key)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", BIGINT)\n(\"phone\", STRING)\n(\"title\", STRING)\n(\"salary\", BIGINT)\n(\"supervisor\", BIGINT)\n",
            "Table: \"inspection\"\nColumns:\n(\"inspection_id\", BIGINT, primary key)\n(\"inspection_date\", DATE)\n(\"inspection_type\", STRING)\n(\"results\", STRING)\n(\"employee_id\", BIGINT)\n(\"license_no\", BIGINT)\n(\"followup_to\", BIGINT)\n",
            "Table: \"employee\"\nColumns:\n(\"employee_id\", BIGINT, primary key)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n(\"zip\", BIGINT)\n(\"phone\", STRING)\n(\"title\", STRING)\n(\"salary\", BIGINT)\n(\"supervisor\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 442,
        "database_name": "coinmarketcap",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.name FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T2.date LIKE '2018%' AND T2.market_cap = ( SELECT MAX(market_cap) FROM historical WHERE STRFTIME('%Y', date) = '2018' )",
        "target_query": "SELECT \"T1\".\"name\" FROM \"coins\" AS \"T1\" INNER JOIN \"historical\" AS \"T2\" ON \"T1\".\"id\" = \"T2\".\"coin_id\" WHERE \"T2\".\"_date\" LIKE '2018%' AND \"T2\".\"market_cap\" = ( SELECT MAX(\"market_cap\") FROM \"historical\" WHERE sys.timestamp_to_str(\"historical\".\"_date\", '%Y') = '2018' );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 176,
                "end_index": 195,
                "dilatect_content": "STRFTIME('%Y', date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 241,
                "end_index": 292,
                "dilatect_content": "sys.timestamp_to_str(\"historical\".\"_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `coins`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`slug`, text)\n(`symbol`, text)\n(`status`, text)\n(`category`, text)\n(`description`, text)\n(`subreddit`, text)\n(`notice`, text)\n(`tags`, text)\n(`tag_names`, text)\n(`website`, text)\n(`platform_id`, integer)\n(`date_added`, text)\n(`date_launched`, text)\n",
            "Table: `historical`\nColumns:\n(`date`, date)\n(`coin_id`, integer)\n(`cmc_rank`, integer)\n(`market_cap`, real)\n(`price`, real)\n(`open`, real)\n(`high`, real)\n(`low`, real)\n(`close`, real)\n(`time_high`, text)\n(`time_low`, text)\n(`volume_24h`, real)\n(`percent_change_1h`, real)\n(`percent_change_24h`, real)\n(`percent_change_7d`, real)\n(`circulating_supply`, real)\n(`total_supply`, real)\n(`max_supply`, real)\n(`num_market_pairs`, integer)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"coins\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"slug\", STRING)\n(\"symbol\", STRING)\n(\"_status\", STRING)\n(\"category\", STRING)\n(\"description\", STRING)\n(\"subreddit\", STRING)\n(\"notice\", STRING)\n(\"tags\", STRING)\n(\"tag_names\", STRING)\n(\"website\", STRING)\n(\"platform_id\", BIGINT)\n(\"date_added\", STRING)\n(\"date_launched\", STRING)\n",
            "Table: \"historical\"\nColumns:\n(\"_date\", DATE)\n(\"coin_id\", BIGINT)\n(\"cmc_rank\", BIGINT)\n(\"market_cap\", DOUBLE PRECISION)\n(\"price\", DOUBLE PRECISION)\n(\"open\", DOUBLE PRECISION)\n(\"high\", DOUBLE PRECISION)\n(\"low\", DOUBLE PRECISION)\n(\"close\", DOUBLE PRECISION)\n(\"time_high\", STRING)\n(\"time_low\", STRING)\n(\"volume_24h\", DOUBLE PRECISION)\n(\"percent_change_1h\", DOUBLE PRECISION)\n(\"percent_change_24h\", DOUBLE PRECISION)\n(\"percent_change_7d\", DOUBLE PRECISION)\n(\"circulating_supply\", DOUBLE PRECISION)\n(\"total_supply\", DOUBLE PRECISION)\n(\"max_supply\", DOUBLE PRECISION)\n(\"num_market_pairs\", BIGINT)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 443,
        "database_name": "coinmarketcap",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.time_high, T2.time_low, T2.date FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T1.name = 'WARP' AND STRFTIME('%Y-%m', T2.date) = '2016-08'",
        "target_query": "SELECT T2.time_high, T2.time_low, T2._date FROM \"coins\" AS T1 INNER JOIN \"historical\" AS T2 ON T1.id = T2.coin_id WHERE T1.name = 'WARP' AND sys.timestamp_to_str(T2._date, '%Y-%m') = '2016-08';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 136,
                "end_index": 161,
                "dilatect_content": "STRFTIME('%Y-%m', T2.date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 145,
                "end_index": 183,
                "dilatect_content": "sys.timestamp_to_str(T2._date, '%Y-%m')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `coins`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`slug`, text)\n(`symbol`, text)\n(`status`, text)\n(`category`, text)\n(`description`, text)\n(`subreddit`, text)\n(`notice`, text)\n(`tags`, text)\n(`tag_names`, text)\n(`website`, text)\n(`platform_id`, integer)\n(`date_added`, text)\n(`date_launched`, text)\n",
            "Table: `historical`\nColumns:\n(`date`, date)\n(`coin_id`, integer)\n(`cmc_rank`, integer)\n(`market_cap`, real)\n(`price`, real)\n(`open`, real)\n(`high`, real)\n(`low`, real)\n(`close`, real)\n(`time_high`, text)\n(`time_low`, text)\n(`volume_24h`, real)\n(`percent_change_1h`, real)\n(`percent_change_24h`, real)\n(`percent_change_7d`, real)\n(`circulating_supply`, real)\n(`total_supply`, real)\n(`max_supply`, real)\n(`num_market_pairs`, integer)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"coins\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"slug\", STRING)\n(\"symbol\", STRING)\n(\"_status\", STRING)\n(\"category\", STRING)\n(\"description\", STRING)\n(\"subreddit\", STRING)\n(\"notice\", STRING)\n(\"tags\", STRING)\n(\"tag_names\", STRING)\n(\"website\", STRING)\n(\"platform_id\", BIGINT)\n(\"date_added\", STRING)\n(\"date_launched\", STRING)\n",
            "Table: \"historical\"\nColumns:\n(\"_date\", DATE)\n(\"coin_id\", BIGINT)\n(\"cmc_rank\", BIGINT)\n(\"market_cap\", DOUBLE PRECISION)\n(\"price\", DOUBLE PRECISION)\n(\"open\", DOUBLE PRECISION)\n(\"high\", DOUBLE PRECISION)\n(\"low\", DOUBLE PRECISION)\n(\"close\", DOUBLE PRECISION)\n(\"time_high\", STRING)\n(\"time_low\", STRING)\n(\"volume_24h\", DOUBLE PRECISION)\n(\"percent_change_1h\", DOUBLE PRECISION)\n(\"percent_change_24h\", DOUBLE PRECISION)\n(\"percent_change_7d\", DOUBLE PRECISION)\n(\"circulating_supply\", DOUBLE PRECISION)\n(\"total_supply\", DOUBLE PRECISION)\n(\"max_supply\", DOUBLE PRECISION)\n(\"num_market_pairs\", BIGINT)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 444,
        "database_name": "coinmarketcap",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(T2.circulating_supply) AS REAL) / 12 FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T1.name = 'Frozen' AND STRFTIME('%Y', T2.date) = '2014'",
        "target_query": "SELECT CAST(SUM(\"T2\".\"circulating_supply\") AS DOUBLE PRECISION) / 12 FROM \"coins\" AS \"T1\" INNER JOIN \"historical\" AS \"T2\" ON \"T1\".\"id\" = \"T2\".\"coin_id\" WHERE \"T1\".\"name\" = 'Frozen' AND EXTRACT(YEAR FROM \"T2\"._date) = 2014;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 149,
                "end_index": 171,
                "dilatect_content": "STRFTIME('%Y', T2.date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 217,
                "end_index": 238,
                "dilatect_content": "YEAR FROM \"T2\"._date",
                "feature": ""
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `coins`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`slug`, text)\n(`symbol`, text)\n(`status`, text)\n(`category`, text)\n(`description`, text)\n(`subreddit`, text)\n(`notice`, text)\n(`tags`, text)\n(`tag_names`, text)\n(`website`, text)\n(`platform_id`, integer)\n(`date_added`, text)\n(`date_launched`, text)\n",
            "Table: `historical`\nColumns:\n(`date`, date)\n(`coin_id`, integer)\n(`cmc_rank`, integer)\n(`market_cap`, real)\n(`price`, real)\n(`open`, real)\n(`high`, real)\n(`low`, real)\n(`close`, real)\n(`time_high`, text)\n(`time_low`, text)\n(`volume_24h`, real)\n(`percent_change_1h`, real)\n(`percent_change_24h`, real)\n(`percent_change_7d`, real)\n(`circulating_supply`, real)\n(`total_supply`, real)\n(`max_supply`, real)\n(`num_market_pairs`, integer)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"coins\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"slug\", STRING)\n(\"symbol\", STRING)\n(\"_status\", STRING)\n(\"category\", STRING)\n(\"description\", STRING)\n(\"subreddit\", STRING)\n(\"notice\", STRING)\n(\"tags\", STRING)\n(\"tag_names\", STRING)\n(\"website\", STRING)\n(\"platform_id\", BIGINT)\n(\"date_added\", STRING)\n(\"date_launched\", STRING)\n",
            "Table: \"historical\"\nColumns:\n(\"_date\", DATE)\n(\"coin_id\", BIGINT)\n(\"cmc_rank\", BIGINT)\n(\"market_cap\", DOUBLE PRECISION)\n(\"price\", DOUBLE PRECISION)\n(\"open\", DOUBLE PRECISION)\n(\"high\", DOUBLE PRECISION)\n(\"low\", DOUBLE PRECISION)\n(\"close\", DOUBLE PRECISION)\n(\"time_high\", STRING)\n(\"time_low\", STRING)\n(\"volume_24h\", DOUBLE PRECISION)\n(\"percent_change_1h\", DOUBLE PRECISION)\n(\"percent_change_24h\", DOUBLE PRECISION)\n(\"percent_change_7d\", DOUBLE PRECISION)\n(\"circulating_supply\", DOUBLE PRECISION)\n(\"total_supply\", DOUBLE PRECISION)\n(\"max_supply\", DOUBLE PRECISION)\n(\"num_market_pairs\", BIGINT)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 445,
        "database_name": "coinmarketcap",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT AVG(T2.price) FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T1.name = 'Bitcoin' AND STRFTIME('%Y', T2.date) = '2016'",
        "target_query": "SELECT AVG(\"T2\".\"price\") FROM \"coins\" AS \"T1\" INNER JOIN \"historical\" AS \"T2\" ON \"T1\".\"id\" = \"T2\".\"coin_id\" WHERE \"T1\".\"name\" = 'Bitcoin' AND sys.timestamp_to_str(\"T2\".\"_date\", '%Y') = '2016';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 118,
                "end_index": 140,
                "dilatect_content": "STRFTIME('%Y', T2.date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 166,
                "end_index": 209,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `coins`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`slug`, text)\n(`symbol`, text)\n(`status`, text)\n(`category`, text)\n(`description`, text)\n(`subreddit`, text)\n(`notice`, text)\n(`tags`, text)\n(`tag_names`, text)\n(`website`, text)\n(`platform_id`, integer)\n(`date_added`, text)\n(`date_launched`, text)\n",
            "Table: `historical`\nColumns:\n(`date`, date)\n(`coin_id`, integer)\n(`cmc_rank`, integer)\n(`market_cap`, real)\n(`price`, real)\n(`open`, real)\n(`high`, real)\n(`low`, real)\n(`close`, real)\n(`time_high`, text)\n(`time_low`, text)\n(`volume_24h`, real)\n(`percent_change_1h`, real)\n(`percent_change_24h`, real)\n(`percent_change_7d`, real)\n(`circulating_supply`, real)\n(`total_supply`, real)\n(`max_supply`, real)\n(`num_market_pairs`, integer)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"coins\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"slug\", STRING)\n(\"symbol\", STRING)\n(\"_status\", STRING)\n(\"category\", STRING)\n(\"description\", STRING)\n(\"subreddit\", STRING)\n(\"notice\", STRING)\n(\"tags\", STRING)\n(\"tag_names\", STRING)\n(\"website\", STRING)\n(\"platform_id\", BIGINT)\n(\"date_added\", STRING)\n(\"date_launched\", STRING)\n",
            "Table: \"historical\"\nColumns:\n(\"_date\", DATE)\n(\"coin_id\", BIGINT)\n(\"cmc_rank\", BIGINT)\n(\"market_cap\", DOUBLE PRECISION)\n(\"price\", DOUBLE PRECISION)\n(\"open\", DOUBLE PRECISION)\n(\"high\", DOUBLE PRECISION)\n(\"low\", DOUBLE PRECISION)\n(\"close\", DOUBLE PRECISION)\n(\"time_high\", STRING)\n(\"time_low\", STRING)\n(\"volume_24h\", DOUBLE PRECISION)\n(\"percent_change_1h\", DOUBLE PRECISION)\n(\"percent_change_24h\", DOUBLE PRECISION)\n(\"percent_change_7d\", DOUBLE PRECISION)\n(\"circulating_supply\", DOUBLE PRECISION)\n(\"total_supply\", DOUBLE PRECISION)\n(\"max_supply\", DOUBLE PRECISION)\n(\"num_market_pairs\", BIGINT)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 446,
        "database_name": "coinmarketcap",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT AVG(T2.price) FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE STRFTIME('%Y', T2.date) = '2013' AND T1.name = 'Bitcoin'",
        "target_query": "SELECT AVG(\"T2\".\"price\") FROM \"coins\" AS \"T1\" INNER JOIN \"historical\" AS \"T2\" ON \"T1\".\"id\" = \"T2\".\"coin_id\" WHERE sys.timestamp_to_str(\"T2\".\"_date\", '%Y') = '2013' AND \"T1\".\"name\" = 'Bitcoin';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 94,
                "end_index": 116,
                "dilatect_content": "STRFTIME('%Y', T2.date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 134,
                "end_index": 177,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `coins`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`slug`, text)\n(`symbol`, text)\n(`status`, text)\n(`category`, text)\n(`description`, text)\n(`subreddit`, text)\n(`notice`, text)\n(`tags`, text)\n(`tag_names`, text)\n(`website`, text)\n(`platform_id`, integer)\n(`date_added`, text)\n(`date_launched`, text)\n",
            "Table: `historical`\nColumns:\n(`date`, date)\n(`coin_id`, integer)\n(`cmc_rank`, integer)\n(`market_cap`, real)\n(`price`, real)\n(`open`, real)\n(`high`, real)\n(`low`, real)\n(`close`, real)\n(`time_high`, text)\n(`time_low`, text)\n(`volume_24h`, real)\n(`percent_change_1h`, real)\n(`percent_change_24h`, real)\n(`percent_change_7d`, real)\n(`circulating_supply`, real)\n(`total_supply`, real)\n(`max_supply`, real)\n(`num_market_pairs`, integer)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"coins\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"slug\", STRING)\n(\"symbol\", STRING)\n(\"_status\", STRING)\n(\"category\", STRING)\n(\"description\", STRING)\n(\"subreddit\", STRING)\n(\"notice\", STRING)\n(\"tags\", STRING)\n(\"tag_names\", STRING)\n(\"website\", STRING)\n(\"platform_id\", BIGINT)\n(\"date_added\", STRING)\n(\"date_launched\", STRING)\n",
            "Table: \"historical\"\nColumns:\n(\"_date\", DATE)\n(\"coin_id\", BIGINT)\n(\"cmc_rank\", BIGINT)\n(\"market_cap\", DOUBLE PRECISION)\n(\"price\", DOUBLE PRECISION)\n(\"open\", DOUBLE PRECISION)\n(\"high\", DOUBLE PRECISION)\n(\"low\", DOUBLE PRECISION)\n(\"close\", DOUBLE PRECISION)\n(\"time_high\", STRING)\n(\"time_low\", STRING)\n(\"volume_24h\", DOUBLE PRECISION)\n(\"percent_change_1h\", DOUBLE PRECISION)\n(\"percent_change_24h\", DOUBLE PRECISION)\n(\"percent_change_7d\", DOUBLE PRECISION)\n(\"circulating_supply\", DOUBLE PRECISION)\n(\"total_supply\", DOUBLE PRECISION)\n(\"max_supply\", DOUBLE PRECISION)\n(\"num_market_pairs\", BIGINT)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 448,
        "database_name": "coinmarketcap",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT name FROM coins WHERE LENGTH(tag_names) - LENGTH(replace(tag_names, ',', '')) = 2",
        "target_query": "SELECT \"name\" FROM \"coins\" WHERE length(\"tag_names\") - length(replace(\"tag_names\", ',', '')) = 2;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 29,
                "end_index": 45,
                "dilatect_content": "LENGTH(tag_names)",
                "feature": "length(X)"
            },
            {
                "start_index": 49,
                "end_index": 83,
                "dilatect_content": "LENGTH(replace(tag_names, ',', ''))",
                "feature": "length(X)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 37,
                "end_index": 57,
                "dilatect_content": "length(\"tag_names\")",
                "feature": "length(X)"
            },
            {
                "start_index": 61,
                "end_index": 99,
                "dilatect_content": "length(replace(\"tag_names\", ',', ''))",
                "feature": "length(X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "length(X)",
                "explanation": "MonetDB supports the length() function for both string and BLOB values. For a string value X, the function returns the number of characters (code points) in the string. For a BLOB value, it returns the byte-length of the BLOB.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `coins`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`slug`, text)\n(`symbol`, text)\n(`status`, text)\n(`category`, text)\n(`description`, text)\n(`subreddit`, text)\n(`notice`, text)\n(`tags`, text)\n(`tag_names`, text)\n(`website`, text)\n(`platform_id`, integer)\n(`date_added`, text)\n(`date_launched`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"coins\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"slug\", STRING)\n(\"symbol\", STRING)\n(\"_status\", STRING)\n(\"category\", STRING)\n(\"description\", STRING)\n(\"subreddit\", STRING)\n(\"notice\", STRING)\n(\"tags\", STRING)\n(\"tag_names\", STRING)\n(\"website\", STRING)\n(\"platform_id\", BIGINT)\n(\"date_added\", STRING)\n(\"date_launched\", STRING)\n"
        ]
    },
    {
        "sql_id": 449,
        "database_name": "coinmarketcap",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.name FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE STRFTIME('%Y-%m', T2.date) = '2013-05' AND T2.open IS NULL",
        "target_query": "SELECT \"T1\".\"name\" FROM \"coins\" AS \"T1\" INNER JOIN \"historical\" AS \"T2\" ON \"T1\".\"id\" = \"T2\".\"coin_id\" WHERE sys.timestamp_to_str(\"T2\".\"_date\", '%Y-%m') = '2013-05' AND \"T2\".\"open\" IS NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 88,
                "end_index": 113,
                "dilatect_content": "STRFTIME('%Y-%m', T2.date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 128,
                "end_index": 174,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"_date\", '%Y-%m')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `coins`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`slug`, text)\n(`symbol`, text)\n(`status`, text)\n(`category`, text)\n(`description`, text)\n(`subreddit`, text)\n(`notice`, text)\n(`tags`, text)\n(`tag_names`, text)\n(`website`, text)\n(`platform_id`, integer)\n(`date_added`, text)\n(`date_launched`, text)\n",
            "Table: `historical`\nColumns:\n(`date`, date)\n(`coin_id`, integer)\n(`cmc_rank`, integer)\n(`market_cap`, real)\n(`price`, real)\n(`open`, real)\n(`high`, real)\n(`low`, real)\n(`close`, real)\n(`time_high`, text)\n(`time_low`, text)\n(`volume_24h`, real)\n(`percent_change_1h`, real)\n(`percent_change_24h`, real)\n(`percent_change_7d`, real)\n(`circulating_supply`, real)\n(`total_supply`, real)\n(`max_supply`, real)\n(`num_market_pairs`, integer)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"coins\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"slug\", STRING)\n(\"symbol\", STRING)\n(\"_status\", STRING)\n(\"category\", STRING)\n(\"description\", STRING)\n(\"subreddit\", STRING)\n(\"notice\", STRING)\n(\"tags\", STRING)\n(\"tag_names\", STRING)\n(\"website\", STRING)\n(\"platform_id\", BIGINT)\n(\"date_added\", STRING)\n(\"date_launched\", STRING)\n",
            "Table: \"historical\"\nColumns:\n(\"_date\", DATE)\n(\"coin_id\", BIGINT)\n(\"cmc_rank\", BIGINT)\n(\"market_cap\", DOUBLE PRECISION)\n(\"price\", DOUBLE PRECISION)\n(\"open\", DOUBLE PRECISION)\n(\"high\", DOUBLE PRECISION)\n(\"low\", DOUBLE PRECISION)\n(\"close\", DOUBLE PRECISION)\n(\"time_high\", STRING)\n(\"time_low\", STRING)\n(\"volume_24h\", DOUBLE PRECISION)\n(\"percent_change_1h\", DOUBLE PRECISION)\n(\"percent_change_24h\", DOUBLE PRECISION)\n(\"percent_change_7d\", DOUBLE PRECISION)\n(\"circulating_supply\", DOUBLE PRECISION)\n(\"total_supply\", DOUBLE PRECISION)\n(\"max_supply\", DOUBLE PRECISION)\n(\"num_market_pairs\", BIGINT)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 450,
        "database_name": "coinmarketcap",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T2.coin_id) FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T1.name = 'Bytecoin' AND STRFTIME('%Y-%m', T2.date) = '2013-06'",
        "target_query": "SELECT COUNT(\"T2\".\"coin_id\") FROM \"coins\" AS \"T1\" INNER JOIN \"historical\" AS \"T2\" ON \"T1\".\"id\" = \"T2\".\"coin_id\" WHERE \"T1\".\"name\" = 'Bytecoin' AND sys.timestamp_to_str(\"T2\".\"_date\", '%Y-%m') = '2013-06';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 123,
                "end_index": 148,
                "dilatect_content": "STRFTIME('%Y-%m', T2.date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 171,
                "end_index": 217,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"_date\", '%Y-%m')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `coins`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`slug`, text)\n(`symbol`, text)\n(`status`, text)\n(`category`, text)\n(`description`, text)\n(`subreddit`, text)\n(`notice`, text)\n(`tags`, text)\n(`tag_names`, text)\n(`website`, text)\n(`platform_id`, integer)\n(`date_added`, text)\n(`date_launched`, text)\n",
            "Table: `historical`\nColumns:\n(`date`, date)\n(`coin_id`, integer)\n(`cmc_rank`, integer)\n(`market_cap`, real)\n(`price`, real)\n(`open`, real)\n(`high`, real)\n(`low`, real)\n(`close`, real)\n(`time_high`, text)\n(`time_low`, text)\n(`volume_24h`, real)\n(`percent_change_1h`, real)\n(`percent_change_24h`, real)\n(`percent_change_7d`, real)\n(`circulating_supply`, real)\n(`total_supply`, real)\n(`max_supply`, real)\n(`num_market_pairs`, integer)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"coins\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"slug\", STRING)\n(\"symbol\", STRING)\n(\"_status\", STRING)\n(\"category\", STRING)\n(\"description\", STRING)\n(\"subreddit\", STRING)\n(\"notice\", STRING)\n(\"tags\", STRING)\n(\"tag_names\", STRING)\n(\"website\", STRING)\n(\"platform_id\", BIGINT)\n(\"date_added\", STRING)\n(\"date_launched\", STRING)\n",
            "Table: \"historical\"\nColumns:\n(\"_date\", DATE)\n(\"coin_id\", BIGINT)\n(\"cmc_rank\", BIGINT)\n(\"market_cap\", DOUBLE PRECISION)\n(\"price\", DOUBLE PRECISION)\n(\"open\", DOUBLE PRECISION)\n(\"high\", DOUBLE PRECISION)\n(\"low\", DOUBLE PRECISION)\n(\"close\", DOUBLE PRECISION)\n(\"time_high\", STRING)\n(\"time_low\", STRING)\n(\"volume_24h\", DOUBLE PRECISION)\n(\"percent_change_1h\", DOUBLE PRECISION)\n(\"percent_change_24h\", DOUBLE PRECISION)\n(\"percent_change_7d\", DOUBLE PRECISION)\n(\"circulating_supply\", DOUBLE PRECISION)\n(\"total_supply\", DOUBLE PRECISION)\n(\"max_supply\", DOUBLE PRECISION)\n(\"num_market_pairs\", BIGINT)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 453,
        "database_name": "retail_world",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T1.CustomerID) FROM Customers AS T1 INNER JOIN Orders AS T2 ON T1.CustomerID = T2.CustomerID WHERE STRFTIME('%Y', T2.OrderDate) = '1996' AND T1.Country = 'UK'",
        "target_query": "SELECT COUNT(\"T1\".\"CustomerID\") FROM \"Customers\" AS \"T1\" INNER JOIN \"Orders\" AS \"T2\" ON \"T1\".\"CustomerID\" = \"T2\".\"CustomerID\" WHERE sys.timestamp_to_str(\"T2\".\"OrderDate\", '%Y') = '1996' AND \"T1\".\"Country\" = 'UK';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 112,
                "end_index": 139,
                "dilatect_content": "STRFTIME('%Y', T2.OrderDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 152,
                "end_index": 199,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"OrderDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Customers`\nColumns:\n(`CustomerID`, integer, primary key)\n(`CustomerName`, text)\n(`ContactName`, text)\n(`Address`, text)\n(`City`, text)\n(`PostalCode`, text)\n(`Country`, text)\n",
            "Table: `Orders`\nColumns:\n(`OrderID`, integer, primary key)\n(`CustomerID`, integer)\n(`EmployeeID`, integer)\n(`OrderDate`, date)\n(`ShipperID`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"Customers\"\nColumns:\n(\"CustomerID\", BIGINT, primary key)\n(\"CustomerName\", STRING)\n(\"ContactName\", STRING)\n(\"Address\", STRING)\n(\"City\", STRING)\n(\"PostalCode\", STRING)\n(\"Country\", STRING)\n",
            "Table: \"Orders\"\nColumns:\n(\"OrderID\", BIGINT, primary key)\n(\"CustomerID\", BIGINT)\n(\"EmployeeID\", BIGINT)\n(\"OrderDate\", DATE)\n(\"ShipperID\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 455,
        "database_name": "retail_world",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T2.CustomerID) FROM Customers AS T1 INNER JOIN Orders AS T2 ON T1.CustomerID = T2.CustomerID WHERE STRFTIME('%Y', T2.OrderDate) = '1996' GROUP BY T1.Country",
        "target_query": "SELECT COUNT(\"T2\".\"CustomerID\") FROM \"Customers\" AS \"T1\" INNER JOIN \"Orders\" AS \"T2\" ON \"T1\".\"CustomerID\" = \"T2\".\"CustomerID\" WHERE sys.timestamp_to_str(\"T2\".\"OrderDate\", '%Y') = '1996' GROUP BY \"T1\".\"Country\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 112,
                "end_index": 139,
                "dilatect_content": "STRFTIME('%Y', T2.OrderDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 152,
                "end_index": 199,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"OrderDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Customers`\nColumns:\n(`CustomerID`, integer, primary key)\n(`CustomerName`, text)\n(`ContactName`, text)\n(`Address`, text)\n(`City`, text)\n(`PostalCode`, text)\n(`Country`, text)\n",
            "Table: `Orders`\nColumns:\n(`OrderID`, integer, primary key)\n(`CustomerID`, integer)\n(`EmployeeID`, integer)\n(`OrderDate`, date)\n(`ShipperID`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"Customers\"\nColumns:\n(\"CustomerID\", BIGINT, primary key)\n(\"CustomerName\", STRING)\n(\"ContactName\", STRING)\n(\"Address\", STRING)\n(\"City\", STRING)\n(\"PostalCode\", STRING)\n(\"Country\", STRING)\n",
            "Table: \"Orders\"\nColumns:\n(\"OrderID\", BIGINT, primary key)\n(\"CustomerID\", BIGINT)\n(\"EmployeeID\", BIGINT)\n(\"OrderDate\", DATE)\n(\"ShipperID\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 463,
        "database_name": "retail_world",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T4.ProductName FROM Customers AS T1 INNER JOIN Orders AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN `OrderDetails` AS T3 ON T2.OrderID = T3.OrderID INNER JOIN Products AS T4 ON T3.ProductID = T4.ProductID WHERE T1.Country = 'Norway' AND STRFTIME('%Y', T2.OrderDate) = '1996'",
        "target_query": "SELECT \"T4\".\"ProductName\" FROM \"Customers\" AS \"T1\" INNER JOIN \"Orders\" AS \"T2\" ON \"T1\".\"CustomerID\" = \"T2\".\"CustomerID\" INNER JOIN \"OrderDetails\" AS \"T3\" ON \"T2\".\"OrderID\" = \"T3\".\"OrderID\" INNER JOIN \"Products\" AS \"T4\" ON \"T3\".\"ProductID\" = \"T4\".\"ProductID\" WHERE \"T1\".\"Country\" = 'Norway' AND sys.timestamp_to_str(\"T2\".\"OrderDate\", '%Y') = '1996';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 249,
                "end_index": 276,
                "dilatect_content": "STRFTIME('%Y', T2.OrderDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 342,
                "end_index": 389,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"OrderDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Customers`\nColumns:\n(`CustomerID`, integer, primary key)\n(`CustomerName`, text)\n(`ContactName`, text)\n(`Address`, text)\n(`City`, text)\n(`PostalCode`, text)\n(`Country`, text)\n",
            "Table: `Orders`\nColumns:\n(`OrderID`, integer, primary key)\n(`CustomerID`, integer)\n(`EmployeeID`, integer)\n(`OrderDate`, date)\n(`ShipperID`, integer)\n",
            "Table: `OrderDetails`\nColumns:\n(`OrderDetailID`, integer, primary key)\n(`OrderID`, integer)\n(`ProductID`, integer)\n(`Quantity`, integer)\n",
            "Table: `Products`\nColumns:\n(`ProductID`, integer, primary key)\n(`ProductName`, text)\n(`SupplierID`, integer)\n(`CategoryID`, integer)\n(`Unit`, text)\n(`Price`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"Customers\"\nColumns:\n(\"CustomerID\", BIGINT, primary key)\n(\"CustomerName\", STRING)\n(\"ContactName\", STRING)\n(\"Address\", STRING)\n(\"City\", STRING)\n(\"PostalCode\", STRING)\n(\"Country\", STRING)\n",
            "Table: \"Orders\"\nColumns:\n(\"OrderID\", BIGINT, primary key)\n(\"CustomerID\", BIGINT)\n(\"EmployeeID\", BIGINT)\n(\"OrderDate\", DATE)\n(\"ShipperID\", BIGINT)\n",
            "Table: \"OrderDetails\"\nColumns:\n(\"OrderDetailID\", BIGINT, primary key)\n(\"OrderID\", BIGINT)\n(\"ProductID\", BIGINT)\n(\"Quantity\", BIGINT)\n",
            "Table: \"Products\"\nColumns:\n(\"ProductID\", BIGINT, primary key)\n(\"ProductName\", STRING)\n(\"SupplierID\", BIGINT)\n(\"CategoryID\", BIGINT)\n(\"Unit\", STRING)\n(\"Price\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 471,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.n_name = 'GERMANY', 1, 0)) AS REAL) * 100 / COUNT(T1.c_custkey) FROM customer AS T1 INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"n_name\" = 'GERMANY' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"c_custkey\") FROM \"customer\" AS \"T1\" INNER JOIN \"nation\" AS \"T2\" ON \"T1\".\"c_nationkey\" = \"T2\".\"n_nationkey\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 47,
                "dilatect_content": "IIF(T2.n_name = 'GERMANY', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 72,
                "dilatect_content": "CASE WHEN \"T2\".\"n_name\" = 'GERMANY' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`c_custkey`, integer, primary key)\n(`c_mktsegment`, text)\n(`c_nationkey`, integer)\n(`c_name`, text)\n(`c_address`, text)\n(`c_phone`, text)\n(`c_acctbal`, real)\n(`c_comment`, text)\n",
            "Table: `nation`\nColumns:\n(`n_nationkey`, integer, primary key)\n(`n_name`, text)\n(`n_regionkey`, integer)\n(`n_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"customer\"\nColumns:\n(\"c_custkey\", BIGINT, primary key)\n(\"c_mktsegment\", STRING)\n(\"c_nationkey\", BIGINT)\n(\"c_name\", STRING)\n(\"c_address\", STRING)\n(\"c_phone\", STRING)\n(\"c_acctbal\", DOUBLE PRECISION)\n(\"c_comment\", STRING)\n",
            "Table: \"nation\"\nColumns:\n(\"n_nationkey\", BIGINT, primary key)\n(\"n_name\", STRING)\n(\"n_regionkey\", BIGINT)\n(\"n_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 473,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.r_name = 'EUROPE', 1, 0)) AS REAL) * 100 / COUNT(T1.n_name) FROM nation AS T1 INNER JOIN region AS T2 ON T1.n_regionkey = T2.r_regionkey",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"r_name\" = 'EUROPE' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"n_name\") FROM \"nation\" AS \"T1\" INNER JOIN \"region\" AS \"T2\" ON \"T1\".\"n_regionkey\" = \"T2\".\"r_regionkey\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 46,
                "dilatect_content": "IIF(T2.r_name = 'EUROPE', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 71,
                "dilatect_content": "CASE WHEN \"T2\".\"r_name\" = 'EUROPE' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `nation`\nColumns:\n(`n_nationkey`, integer, primary key)\n(`n_name`, text)\n(`n_regionkey`, integer)\n(`n_comment`, text)\n",
            "Table: `region`\nColumns:\n(`r_regionkey`, integer, primary key)\n(`r_name`, text)\n(`r_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"nation\"\nColumns:\n(\"n_nationkey\", BIGINT, primary key)\n(\"n_name\", STRING)\n(\"n_regionkey\", BIGINT)\n(\"n_comment\", STRING)\n",
            "Table: \"region\"\nColumns:\n(\"r_regionkey\", BIGINT, primary key)\n(\"r_name\", STRING)\n(\"r_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 474,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.n_name = 'JAPAN', 1, 0)) AS REAL) * 100 / COUNT(T1.s_name) FROM supplier AS T1 INNER JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey WHERE T1.s_acctbal < 0",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"n_name\" = 'JAPAN' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"s_name\") FROM \"supplier\" AS \"T1\" INNER JOIN \"nation\" AS \"T2\" ON \"T1\".\"s_nationkey\" = \"T2\".\"n_nationkey\" WHERE \"T1\".\"s_acctbal\" < 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 45,
                "dilatect_content": "IIF(T2.n_name = 'JAPAN', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 70,
                "dilatect_content": "CASE WHEN \"T2\".\"n_name\" = 'JAPAN' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `supplier`\nColumns:\n(`s_suppkey`, integer, primary key)\n(`s_nationkey`, integer)\n(`s_comment`, text)\n(`s_name`, text)\n(`s_address`, text)\n(`s_phone`, text)\n(`s_acctbal`, real)\n",
            "Table: `nation`\nColumns:\n(`n_nationkey`, integer, primary key)\n(`n_name`, text)\n(`n_regionkey`, integer)\n(`n_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"supplier\"\nColumns:\n(\"s_suppkey\", BIGINT, primary key)\n(\"s_nationkey\", BIGINT)\n(\"s_comment\", STRING)\n(\"s_name\", STRING)\n(\"s_address\", STRING)\n(\"s_phone\", STRING)\n(\"s_acctbal\", DOUBLE PRECISION)\n",
            "Table: \"nation\"\nColumns:\n(\"n_nationkey\", BIGINT, primary key)\n(\"n_name\", STRING)\n(\"n_regionkey\", BIGINT)\n(\"n_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 475,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(l_orderkey) FROM lineitem WHERE STRFTIME('%Y', l_shipdate) = '1998'",
        "target_query": "SELECT COUNT(\"l_orderkey\") FROM \"lineitem\" WHERE sys.timestamp_to_str(\"l_shipdate\", '%Y') = '1998';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 45,
                "end_index": 70,
                "dilatect_content": "STRFTIME('%Y', l_shipdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 53,
                "end_index": 94,
                "dilatect_content": "sys.timestamp_to_str(\"l_shipdate\", '%Y')",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, date)\n(`l_orderkey`, integer, primary key)\n(`l_discount`, real)\n(`l_extendedprice`, real)\n(`l_suppkey`, integer)\n(`l_quantity`, integer)\n(`l_returnflag`, text)\n(`l_partkey`, integer)\n(`l_linestatus`, text)\n(`l_tax`, real)\n(`l_commitdate`, date)\n(`l_receiptdate`, date)\n(`l_shipmode`, text)\n(`l_linenumber`, integer, primary key)\n(`l_shipinstruct`, text)\n(`l_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"lineitem\"\nColumns:\n(\"l_shipdate\", DATE)\n(\"l_orderkey\", BIGINT, primary key)\n(\"l_discount\", DOUBLE PRECISION)\n(\"l_extendedprice\", DOUBLE PRECISION)\n(\"l_suppkey\", BIGINT)\n(\"l_quantity\", BIGINT)\n(\"l_returnflag\", STRING)\n(\"l_partkey\", BIGINT)\n(\"l_linestatus\", STRING)\n(\"l_tax\", DOUBLE PRECISION)\n(\"l_commitdate\", DATE)\n(\"l_receiptdate\", DATE)\n(\"l_shipmode\", STRING)\n(\"l_linenumber\", BIGINT, primary key)\n(\"l_shipinstruct\", STRING)\n(\"l_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 476,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(l_linenumber) FROM lineitem WHERE l_returnflag = 'R' AND l_shipmode = 'AIR' AND STRFTIME('%Y', l_shipdate) = '1994'",
        "target_query": "SELECT COUNT(\"l_linenumber\") FROM \"lineitem\" WHERE \"l_returnflag\" = 'R' AND \"l_shipmode\" = 'AIR' AND sys.timestamp_to_str(\"l_shipdate\", '%Y') = '1994';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 93,
                "end_index": 118,
                "dilatect_content": "STRFTIME('%Y', l_shipdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 109,
                "end_index": 150,
                "dilatect_content": "sys.timestamp_to_str(\"l_shipdate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, date)\n(`l_orderkey`, integer, primary key)\n(`l_discount`, real)\n(`l_extendedprice`, real)\n(`l_suppkey`, integer)\n(`l_quantity`, integer)\n(`l_returnflag`, text)\n(`l_partkey`, integer)\n(`l_linestatus`, text)\n(`l_tax`, real)\n(`l_commitdate`, date)\n(`l_receiptdate`, date)\n(`l_shipmode`, text)\n(`l_linenumber`, integer, primary key)\n(`l_shipinstruct`, text)\n(`l_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"lineitem\"\nColumns:\n(\"l_shipdate\", DATE)\n(\"l_orderkey\", BIGINT, primary key)\n(\"l_discount\", DOUBLE PRECISION)\n(\"l_extendedprice\", DOUBLE PRECISION)\n(\"l_suppkey\", BIGINT)\n(\"l_quantity\", BIGINT)\n(\"l_returnflag\", STRING)\n(\"l_partkey\", BIGINT)\n(\"l_linestatus\", STRING)\n(\"l_tax\", DOUBLE PRECISION)\n(\"l_commitdate\", DATE)\n(\"l_receiptdate\", DATE)\n(\"l_shipmode\", STRING)\n(\"l_linenumber\", BIGINT, primary key)\n(\"l_shipinstruct\", STRING)\n(\"l_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 477,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T2.o_orderkey) FROM lineitem AS T1 INNER JOIN orders AS T2 ON T2.o_orderkey = T1.l_orderkey WHERE JULIANDAY(T1.l_shipdate) - JULIANDAY(T2.o_orderdate) = 1 AND T2.o_orderpriority = '1-URGENT'",
        "target_query": "SELECT COUNT(\"T2\".\"o_orderkey\") FROM \"lineitem\" AS \"T1\" INNER JOIN \"orders\" AS \"T2\" ON \"T2\".\"o_orderkey\" = \"T1\".\"l_orderkey\" WHERE (2440587.5 + EXTRACT(EPOCH FROM \"T1\".\"l_shipdate\") / 86400) - (2440587.5 + EXTRACT(EPOCH FROM \"T2\".\"o_orderdate\") / 86400) = 1 AND \"T2\".\"o_orderpriority\" = '1-URGENT';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 111,
                "end_index": 134,
                "dilatect_content": "JULIANDAY(T1.l_shipdate)",
                "feature": "julianday(time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 138,
                "end_index": 162,
                "dilatect_content": "JULIANDAY(T2.o_orderdate)",
                "feature": "julianday(time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 152,
                "end_index": 212,
                "dilatect_content": "2440587.5 + EXTRACT(EPOCH FROM \"T1\".\"l_shipdate\") / 86400",
                "feature": "2440587.5 + EXTRACT(EPOCH FROM time-value) / 86400"
            },
            {
                "start_index": 218,
                "end_index": 279,
                "dilatect_content": "2440587.5 + EXTRACT(EPOCH FROM \"T2\".\"o_orderdate\") / 86400",
                "feature": "2440587.5 + EXTRACT(EPOCH FROM time-value) / 86400"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "julianday(time-value, modifier, modifier, ...)",
                "explanation": "The julianday(time-value, modifier, modifier, ...) function returns the Julian day number - the fractional number of days since noon in Greenwich on November 24, 4714 B.C. (Proleptic Gregorian calendar). It accepts a time-value and zero or more modifiers.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day').\nReturns: A real number representing the Julian day number.",
                "examples": [
                    "SELECT julianday(); -- Returns the current Julian day number.",
                    "SELECT julianday('2024-08-21'); -- Returns the Julian day number for August 21, 2024.",
                    "SELECT julianday('now', '+1 day'); -- Returns the Julian day number for one day after the current date."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "2440587.5 + EXTRACT(EPOCH FROM time-value) / 86400",
                "explanation": "This expression calculates the Julian day number in MonetDB. It returns the fractional number of days since noon in Greenwich on November 24, 4714 B.C. by converting the input date or timestamp to seconds since the Unix epoch, dividing by 86400 (seconds per day), and adding the Julian base offset 2440587.5.\n\nParameters:\n- time-value: a DATE or TIMESTAMP value.\nReturns: A real number representing the Julian day number.",
                "examples": [
                    "SELECT 2440587.5 + EXTRACT(EPOCH FROM CURRENT_TIMESTAMP) / 86400; -- Returns the current Julian day number.",
                    "SELECT 2440587.5 + EXTRACT(EPOCH FROM DATE '2024-08-21') / 86400; -- Julian day for August 21, 2024.",
                    "SELECT 2440587.5 + EXTRACT(EPOCH FROM TIMESTAMP '2024-08-21 12:00:00') / 86400; -- Julian day with time component."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, date)\n(`l_orderkey`, integer, primary key)\n(`l_discount`, real)\n(`l_extendedprice`, real)\n(`l_suppkey`, integer)\n(`l_quantity`, integer)\n(`l_returnflag`, text)\n(`l_partkey`, integer)\n(`l_linestatus`, text)\n(`l_tax`, real)\n(`l_commitdate`, date)\n(`l_receiptdate`, date)\n(`l_shipmode`, text)\n(`l_linenumber`, integer, primary key)\n(`l_shipinstruct`, text)\n(`l_comment`, text)\n",
            "Table: `orders`\nColumns:\n(`o_orderdate`, date)\n(`o_orderkey`, integer, primary key)\n(`o_custkey`, integer)\n(`o_orderpriority`, text)\n(`o_shippriority`, integer)\n(`o_clerk`, text)\n(`o_orderstatus`, text)\n(`o_totalprice`, real)\n(`o_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"lineitem\"\nColumns:\n(\"l_shipdate\", DATE)\n(\"l_orderkey\", BIGINT, primary key)\n(\"l_discount\", DOUBLE PRECISION)\n(\"l_extendedprice\", DOUBLE PRECISION)\n(\"l_suppkey\", BIGINT)\n(\"l_quantity\", BIGINT)\n(\"l_returnflag\", STRING)\n(\"l_partkey\", BIGINT)\n(\"l_linestatus\", STRING)\n(\"l_tax\", DOUBLE PRECISION)\n(\"l_commitdate\", DATE)\n(\"l_receiptdate\", DATE)\n(\"l_shipmode\", STRING)\n(\"l_linenumber\", BIGINT, primary key)\n(\"l_shipinstruct\", STRING)\n(\"l_comment\", STRING)\n",
            "Table: \"orders\"\nColumns:\n(\"o_orderdate\", DATE)\n(\"o_orderkey\", BIGINT, primary key)\n(\"o_custkey\", BIGINT)\n(\"o_orderpriority\", STRING)\n(\"o_shippriority\", BIGINT)\n(\"o_clerk\", STRING)\n(\"o_orderstatus\", STRING)\n(\"o_totalprice\", DOUBLE PRECISION)\n(\"o_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 478,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(c_acctbal < 0, 1, 0)) AS REAL) * 100 / COUNT(c_custkey) FROM customer",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"c_acctbal\" < 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"c_custkey\") FROM \"customer\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 39,
                "dilatect_content": "IIF(c_acctbal < 0, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 60,
                "dilatect_content": "CASE WHEN \"c_acctbal\" < 0 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`c_custkey`, integer, primary key)\n(`c_mktsegment`, text)\n(`c_nationkey`, integer)\n(`c_name`, text)\n(`c_address`, text)\n(`c_phone`, text)\n(`c_acctbal`, real)\n(`c_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"customer\"\nColumns:\n(\"c_custkey\", BIGINT, primary key)\n(\"c_mktsegment\", STRING)\n(\"c_nationkey\", BIGINT)\n(\"c_name\", STRING)\n(\"c_address\", STRING)\n(\"c_phone\", STRING)\n(\"c_acctbal\", DOUBLE PRECISION)\n(\"c_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 479,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(p_mfgr = 'Manufacturer#3', 1, 0)) AS REAL) * 100 / COUNT(p_partkey) FROM part",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"p_mfgr\" = 'Manufacturer#3' THEN 1 ELSE 0 END) AS DOUBLE PRECISION) * 100 / COUNT(\"p_partkey\") FROM \"part\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 51,
                "dilatect_content": "IIF(p_mfgr = 'Manufacturer#3', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 72,
                "dilatect_content": "CASE WHEN \"p_mfgr\" = 'Manufacturer#3' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `part`\nColumns:\n(`p_partkey`, integer, primary key)\n(`p_type`, text)\n(`p_size`, integer)\n(`p_brand`, text)\n(`p_name`, text)\n(`p_container`, text)\n(`p_mfgr`, text)\n(`p_retailprice`, real)\n(`p_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"part\"\nColumns:\n(\"p_partkey\", BIGINT, primary key)\n(\"p_type\", STRING)\n(\"p_size\", BIGINT)\n(\"p_brand\", STRING)\n(\"p_name\", STRING)\n(\"p_container\", STRING)\n(\"p_mfgr\", STRING)\n(\"p_retailprice\", DOUBLE PRECISION)\n(\"p_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 480,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T1.o_orderkey) FROM orders AS T1 INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey WHERE T2.l_shipmode = 'AIR' AND T1.o_orderpriority = '1-URGENT' AND SUBSTR(T2.l_shipdate, 1, 7) = '1998-11'",
        "target_query": "SELECT COUNT(\"T1\".\"o_orderkey\") FROM \"orders\" AS \"T1\" INNER JOIN \"lineitem\" AS \"T2\" ON \"T1\".\"o_orderkey\" = \"T2\".\"l_orderkey\" WHERE \"T2\".\"l_shipmode\" = 'AIR' AND \"T1\".\"o_orderpriority\" = '1-URGENT' AND substring(\"T2\".\"l_shipdate\" from 1 for 7) = '1998-11';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 173,
                "end_index": 199,
                "dilatect_content": "SUBSTR(T2.l_shipdate, 1, 7)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 229,
                "end_index": 273,
                "dilatect_content": "substring(\"T2\".\"l_shipdate\" from 1 for 7)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `orders`\nColumns:\n(`o_orderdate`, date)\n(`o_orderkey`, integer, primary key)\n(`o_custkey`, integer)\n(`o_orderpriority`, text)\n(`o_shippriority`, integer)\n(`o_clerk`, text)\n(`o_orderstatus`, text)\n(`o_totalprice`, real)\n(`o_comment`, text)\n",
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, date)\n(`l_orderkey`, integer, primary key)\n(`l_discount`, real)\n(`l_extendedprice`, real)\n(`l_suppkey`, integer)\n(`l_quantity`, integer)\n(`l_returnflag`, text)\n(`l_partkey`, integer)\n(`l_linestatus`, text)\n(`l_tax`, real)\n(`l_commitdate`, date)\n(`l_receiptdate`, date)\n(`l_shipmode`, text)\n(`l_linenumber`, integer, primary key)\n(`l_shipinstruct`, text)\n(`l_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"orders\"\nColumns:\n(\"o_orderdate\", DATE)\n(\"o_orderkey\", BIGINT, primary key)\n(\"o_custkey\", BIGINT)\n(\"o_orderpriority\", STRING)\n(\"o_shippriority\", BIGINT)\n(\"o_clerk\", STRING)\n(\"o_orderstatus\", STRING)\n(\"o_totalprice\", DOUBLE PRECISION)\n(\"o_comment\", STRING)\n",
            "Table: \"lineitem\"\nColumns:\n(\"l_shipdate\", DATE)\n(\"l_orderkey\", BIGINT, primary key)\n(\"l_discount\", DOUBLE PRECISION)\n(\"l_extendedprice\", DOUBLE PRECISION)\n(\"l_suppkey\", BIGINT)\n(\"l_quantity\", BIGINT)\n(\"l_returnflag\", STRING)\n(\"l_partkey\", BIGINT)\n(\"l_linestatus\", STRING)\n(\"l_tax\", DOUBLE PRECISION)\n(\"l_commitdate\", DATE)\n(\"l_receiptdate\", DATE)\n(\"l_shipmode\", STRING)\n(\"l_linenumber\", BIGINT, primary key)\n(\"l_shipinstruct\", STRING)\n(\"l_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 481,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.n_name = 'GERMANY', 1, 0)) AS REAL) * 100 / COUNT(T1.s_suppkey) FROM supplier AS T1 INNER JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey WHERE T1.s_acctbal < 0",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"n_name\" = 'GERMANY' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"s_suppkey\") FROM \"supplier\" AS \"T1\" INNER JOIN \"nation\" AS \"T2\" ON \"T1\".\"s_nationkey\" = \"T2\".\"n_nationkey\" WHERE \"T1\".\"s_acctbal\" < 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 47,
                "dilatect_content": "IIF(T2.n_name = 'GERMANY', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 72,
                "dilatect_content": "CASE WHEN \"T2\".\"n_name\" = 'GERMANY' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `supplier`\nColumns:\n(`s_suppkey`, integer, primary key)\n(`s_nationkey`, integer)\n(`s_comment`, text)\n(`s_name`, text)\n(`s_address`, text)\n(`s_phone`, text)\n(`s_acctbal`, real)\n",
            "Table: `nation`\nColumns:\n(`n_nationkey`, integer, primary key)\n(`n_name`, text)\n(`n_regionkey`, integer)\n(`n_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"supplier\"\nColumns:\n(\"s_suppkey\", BIGINT, primary key)\n(\"s_nationkey\", BIGINT)\n(\"s_comment\", STRING)\n(\"s_name\", STRING)\n(\"s_address\", STRING)\n(\"s_phone\", STRING)\n(\"s_acctbal\", DOUBLE PRECISION)\n",
            "Table: \"nation\"\nColumns:\n(\"n_nationkey\", BIGINT, primary key)\n(\"n_name\", STRING)\n(\"n_regionkey\", BIGINT)\n(\"n_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 482,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(l_orderkey) FROM lineitem WHERE STRFTIME('%Y', l_shipdate) = '1994'",
        "target_query": "SELECT COUNT(\"l_orderkey\") FROM \"lineitem\" WHERE sys.timestamp_to_str(\"l_shipdate\", '%Y') = '1994';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 45,
                "end_index": 70,
                "dilatect_content": "STRFTIME('%Y', l_shipdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 53,
                "end_index": 94,
                "dilatect_content": "sys.timestamp_to_str(\"l_shipdate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, date)\n(`l_orderkey`, integer, primary key)\n(`l_discount`, real)\n(`l_extendedprice`, real)\n(`l_suppkey`, integer)\n(`l_quantity`, integer)\n(`l_returnflag`, text)\n(`l_partkey`, integer)\n(`l_linestatus`, text)\n(`l_tax`, real)\n(`l_commitdate`, date)\n(`l_receiptdate`, date)\n(`l_shipmode`, text)\n(`l_linenumber`, integer, primary key)\n(`l_shipinstruct`, text)\n(`l_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"lineitem\"\nColumns:\n(\"l_shipdate\", DATE)\n(\"l_orderkey\", BIGINT, primary key)\n(\"l_discount\", DOUBLE PRECISION)\n(\"l_extendedprice\", DOUBLE PRECISION)\n(\"l_suppkey\", BIGINT)\n(\"l_quantity\", BIGINT)\n(\"l_returnflag\", STRING)\n(\"l_partkey\", BIGINT)\n(\"l_linestatus\", STRING)\n(\"l_tax\", DOUBLE PRECISION)\n(\"l_commitdate\", DATE)\n(\"l_receiptdate\", DATE)\n(\"l_shipmode\", STRING)\n(\"l_linenumber\", BIGINT, primary key)\n(\"l_shipinstruct\", STRING)\n(\"l_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 483,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.n_name = 'United States', 1, 0)) AS REAL) * 100 / COUNT(T1.c_custkey) FROM customer AS T1 INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE T1.c_acctbal < 4000",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"n_name\" = 'United States' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"c_custkey\") FROM \"customer\" AS \"T1\" INNER JOIN \"nation\" AS \"T2\" ON \"T1\".\"c_nationkey\" = \"T2\".\"n_nationkey\" WHERE \"T1\".\"c_acctbal\" < 4000;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 53,
                "dilatect_content": "IIF(T2.n_name = 'United States', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 78,
                "dilatect_content": "CASE WHEN \"T2\".\"n_name\" = 'United States' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`c_custkey`, integer, primary key)\n(`c_mktsegment`, text)\n(`c_nationkey`, integer)\n(`c_name`, text)\n(`c_address`, text)\n(`c_phone`, text)\n(`c_acctbal`, real)\n(`c_comment`, text)\n",
            "Table: `nation`\nColumns:\n(`n_nationkey`, integer, primary key)\n(`n_name`, text)\n(`n_regionkey`, integer)\n(`n_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"customer\"\nColumns:\n(\"c_custkey\", BIGINT, primary key)\n(\"c_mktsegment\", STRING)\n(\"c_nationkey\", BIGINT)\n(\"c_name\", STRING)\n(\"c_address\", STRING)\n(\"c_phone\", STRING)\n(\"c_acctbal\", DOUBLE PRECISION)\n(\"c_comment\", STRING)\n",
            "Table: \"nation\"\nColumns:\n(\"n_nationkey\", BIGINT, primary key)\n(\"n_name\", STRING)\n(\"n_regionkey\", BIGINT)\n(\"n_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 484,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(ps_supplycost > 500, 1, 0)) AS REAL) * 100 / COUNT(ps_suppkey) FROM partsupp",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"ps_supplycost\" > 500 THEN 1 ELSE 0 END) AS DOUBLE PRECISION) * 100 / COUNT(\"ps_suppkey\") FROM \"partsupp\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 45,
                "dilatect_content": "IIF(ps_supplycost > 500, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 66,
                "dilatect_content": "CASE WHEN \"ps_supplycost\" > 500 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `partsupp`\nColumns:\n(`ps_partkey`, integer, primary key)\n(`ps_suppkey`, integer, primary key)\n(`ps_supplycost`, real)\n(`ps_availqty`, integer)\n(`ps_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"partsupp\"\nColumns:\n(\"ps_partkey\", BIGINT, primary key)\n(\"ps_suppkey\", BIGINT, primary key)\n(\"ps_supplycost\", DOUBLE PRECISION)\n(\"ps_availqty\", BIGINT)\n(\"ps_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 485,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T1.c_mktsegment = 'AUTOMOBILE', 1, 0)) AS REAL) * 100 / COUNT(T1.c_name) FROM customer AS T1 INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE T2.n_name = 'FRANCE'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T1\".\"c_mktsegment\" = 'AUTOMOBILE' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"c_name\") FROM \"customer\" AS \"T1\" INNER JOIN \"nation\" AS \"T2\" ON \"T1\".\"c_nationkey\" = \"T2\".\"n_nationkey\" WHERE \"T2\".\"n_name\" = 'FRANCE';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 56,
                "dilatect_content": "IIF(T1.c_mktsegment = 'AUTOMOBILE', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 81,
                "dilatect_content": "CASE WHEN \"T1\".\"c_mktsegment\" = 'AUTOMOBILE' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`c_custkey`, integer, primary key)\n(`c_mktsegment`, text)\n(`c_nationkey`, integer)\n(`c_name`, text)\n(`c_address`, text)\n(`c_phone`, text)\n(`c_acctbal`, real)\n(`c_comment`, text)\n",
            "Table: `nation`\nColumns:\n(`n_nationkey`, integer, primary key)\n(`n_name`, text)\n(`n_regionkey`, integer)\n(`n_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"customer\"\nColumns:\n(\"c_custkey\", BIGINT, primary key)\n(\"c_mktsegment\", STRING)\n(\"c_nationkey\", BIGINT)\n(\"c_name\", STRING)\n(\"c_address\", STRING)\n(\"c_phone\", STRING)\n(\"c_acctbal\", DOUBLE PRECISION)\n(\"c_comment\", STRING)\n",
            "Table: \"nation\"\nColumns:\n(\"n_nationkey\", BIGINT, primary key)\n(\"n_name\", STRING)\n(\"n_regionkey\", BIGINT)\n(\"n_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 486,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.r_name = 'AFRICA', 1, 0)) AS REAL) * 100 / COUNT(T1.n_nationkey) FROM nation AS T1 INNER JOIN region AS T2 ON T1.n_regionkey = T2.r_regionkey INNER JOIN customer AS T3 ON T1.n_nationkey = T3.c_nationkey WHERE T3.c_mktsegment = 'HOUSEHOLD'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"r_name\" = 'AFRICA' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"n_nationkey\") FROM \"nation\" AS \"T1\" INNER JOIN \"region\" AS \"T2\" ON \"T1\".\"n_regionkey\" = \"T2\".\"r_regionkey\" INNER JOIN \"customer\" AS \"T3\" ON \"T1\".\"n_nationkey\" = \"T3\".\"c_nationkey\" WHERE \"T3\".\"c_mktsegment\" = 'HOUSEHOLD';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 46,
                "dilatect_content": "IIF(T2.r_name = 'AFRICA', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 71,
                "dilatect_content": "CASE WHEN \"T2\".\"r_name\" = 'AFRICA' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `nation`\nColumns:\n(`n_nationkey`, integer, primary key)\n(`n_name`, text)\n(`n_regionkey`, integer)\n(`n_comment`, text)\n",
            "Table: `region`\nColumns:\n(`r_regionkey`, integer, primary key)\n(`r_name`, text)\n(`r_comment`, text)\n",
            "Table: `customer`\nColumns:\n(`c_custkey`, integer, primary key)\n(`c_mktsegment`, text)\n(`c_nationkey`, integer)\n(`c_name`, text)\n(`c_address`, text)\n(`c_phone`, text)\n(`c_acctbal`, real)\n(`c_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"nation\"\nColumns:\n(\"n_nationkey\", BIGINT, primary key)\n(\"n_name\", STRING)\n(\"n_regionkey\", BIGINT)\n(\"n_comment\", STRING)\n",
            "Table: \"region\"\nColumns:\n(\"r_regionkey\", BIGINT, primary key)\n(\"r_name\", STRING)\n(\"r_comment\", STRING)\n",
            "Table: \"customer\"\nColumns:\n(\"c_custkey\", BIGINT, primary key)\n(\"c_mktsegment\", STRING)\n(\"c_nationkey\", BIGINT)\n(\"c_name\", STRING)\n(\"c_address\", STRING)\n(\"c_phone\", STRING)\n(\"c_acctbal\", DOUBLE PRECISION)\n(\"c_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 487,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT (CAST(SUM(IIF(T3.l_shipmode = 'SHIP', T1.p_retailprice, 0)) AS REAL) / SUM(IIF(T3.l_shipmode = 'SHIP', 1, 0))) - (CAST(SUM(IIF(T3.l_shipmode = 'AIR', T1.p_retailprice, 0)) AS REAL) / SUM(IIF(T3.l_shipmode = 'AIR', 1, 0))) FROM part AS T1 INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey INNER JOIN lineitem AS T3 ON T2.ps_suppkey = T3.l_suppkey",
        "target_query": "SELECT (SUM(CASE WHEN \"T3\".\"l_shipmode\" = 'SHIP' THEN \"T1\".\"p_retailprice\" ELSE 0 END) / SUM(CASE WHEN \"T3\".\"l_shipmode\" = 'SHIP' THEN 1 ELSE 0 END)) - (SUM(CASE WHEN \"T3\".\"l_shipmode\" = 'AIR' THEN \"T1\".\"p_retailprice\" ELSE 0 END) / SUM(CASE WHEN \"T3\".\"l_shipmode\" = 'AIR' THEN 1 ELSE 0 END)) FROM \"part\" AS \"T1\" INNER JOIN \"partsupp\" AS \"T2\" ON \"T1\".\"p_partkey\" = \"T2\".\"ps_partkey\" INNER JOIN \"lineitem\" AS \"T3\" ON \"T2\".\"ps_suppkey\" = \"T3\".\"l_suppkey\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 17,
                "end_index": 64,
                "dilatect_content": "IIF(T3.l_shipmode = 'SHIP', T1.p_retailprice, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 82,
                "end_index": 114,
                "dilatect_content": "IIF(T3.l_shipmode = 'SHIP', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 130,
                "end_index": 176,
                "dilatect_content": "IIF(T3.l_shipmode = 'AIR', T1.p_retailprice, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 194,
                "end_index": 225,
                "dilatect_content": "IIF(T3.l_shipmode = 'AIR', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 12,
                "end_index": 92,
                "dilatect_content": "CASE WHEN \"T3\".\"l_shipmode\" = 'SHIP' THEN \"T1\".\"p_retailprice\" ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 101,
                "end_index": 158,
                "dilatect_content": "CASE WHEN \"T3\".\"l_shipmode\" = 'SHIP' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 169,
                "end_index": 248,
                "dilatect_content": "CASE WHEN \"T3\".\"l_shipmode\" = 'AIR' THEN \"T1\".\"p_retailprice\" ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 257,
                "end_index": 313,
                "dilatect_content": "CASE WHEN \"T3\".\"l_shipmode\" = 'AIR' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `part`\nColumns:\n(`p_partkey`, integer, primary key)\n(`p_type`, text)\n(`p_size`, integer)\n(`p_brand`, text)\n(`p_name`, text)\n(`p_container`, text)\n(`p_mfgr`, text)\n(`p_retailprice`, real)\n(`p_comment`, text)\n",
            "Table: `partsupp`\nColumns:\n(`ps_partkey`, integer, primary key)\n(`ps_suppkey`, integer, primary key)\n(`ps_supplycost`, real)\n(`ps_availqty`, integer)\n(`ps_comment`, text)\n",
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, date)\n(`l_orderkey`, integer, primary key)\n(`l_discount`, real)\n(`l_extendedprice`, real)\n(`l_suppkey`, integer)\n(`l_quantity`, integer)\n(`l_returnflag`, text)\n(`l_partkey`, integer)\n(`l_linestatus`, text)\n(`l_tax`, real)\n(`l_commitdate`, date)\n(`l_receiptdate`, date)\n(`l_shipmode`, text)\n(`l_linenumber`, integer, primary key)\n(`l_shipinstruct`, text)\n(`l_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"part\"\nColumns:\n(\"p_partkey\", BIGINT, primary key)\n(\"p_type\", STRING)\n(\"p_size\", BIGINT)\n(\"p_brand\", STRING)\n(\"p_name\", STRING)\n(\"p_container\", STRING)\n(\"p_mfgr\", STRING)\n(\"p_retailprice\", DOUBLE PRECISION)\n(\"p_comment\", STRING)\n",
            "Table: \"partsupp\"\nColumns:\n(\"ps_partkey\", BIGINT, primary key)\n(\"ps_suppkey\", BIGINT, primary key)\n(\"ps_supplycost\", DOUBLE PRECISION)\n(\"ps_availqty\", BIGINT)\n(\"ps_comment\", STRING)\n",
            "Table: \"lineitem\"\nColumns:\n(\"l_shipdate\", DATE)\n(\"l_orderkey\", BIGINT, primary key)\n(\"l_discount\", DOUBLE PRECISION)\n(\"l_extendedprice\", DOUBLE PRECISION)\n(\"l_suppkey\", BIGINT)\n(\"l_quantity\", BIGINT)\n(\"l_returnflag\", STRING)\n(\"l_partkey\", BIGINT)\n(\"l_linestatus\", STRING)\n(\"l_tax\", DOUBLE PRECISION)\n(\"l_commitdate\", DATE)\n(\"l_receiptdate\", DATE)\n(\"l_shipmode\", STRING)\n(\"l_linenumber\", BIGINT, primary key)\n(\"l_shipinstruct\", STRING)\n(\"l_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 488,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T3.s_acctbal < ( SELECT AVG(supplier.s_acctbal) FROM supplier ), 1, 0)) AS REAL) * 100 / COUNT(T1.n_nationkey) FROM nation AS T1 INNER JOIN region AS T2 ON T1.n_regionkey = T2.r_regionkey INNER JOIN supplier AS T3 ON T1.n_nationkey = T3.s_nationkey WHERE T2.r_name = 'EUROPE'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T3\".\"s_acctbal\" < (SELECT AVG(\"supplier\".\"s_acctbal\") FROM \"supplier\") THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"n_nationkey\") FROM \"nation\" AS \"T1\" INNER JOIN \"region\" AS \"T2\" ON \"T1\".\"n_regionkey\" = \"T2\".\"r_regionkey\" INNER JOIN \"supplier\" AS \"T3\" ON \"T1\".\"n_nationkey\" = \"T3\".\"s_nationkey\" WHERE \"T2\".\"r_name\" = 'EUROPE'",
        "semantic_equivalent_type": "approximate_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 89,
                "dilatect_content": "IIF(T3.s_acctbal < ( SELECT AVG(supplier.s_acctbal) FROM supplier ), 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 124,
                "dilatect_content": "CASE WHEN \"T3\".\"s_acctbal\" < (SELECT AVG(\"supplier\".\"s_acctbal\") FROM \"supplier\") THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `nation`\nColumns:\n(`n_nationkey`, integer, primary key)\n(`n_name`, text)\n(`n_regionkey`, integer)\n(`n_comment`, text)\n",
            "Table: `region`\nColumns:\n(`r_regionkey`, integer, primary key)\n(`r_name`, text)\n(`r_comment`, text)\n",
            "Table: `supplier`\nColumns:\n(`s_suppkey`, integer, primary key)\n(`s_nationkey`, integer)\n(`s_comment`, text)\n(`s_name`, text)\n(`s_address`, text)\n(`s_phone`, text)\n(`s_acctbal`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"nation\"\nColumns:\n(\"n_nationkey\", BIGINT, primary key)\n(\"n_name\", STRING)\n(\"n_regionkey\", BIGINT)\n(\"n_comment\", STRING)\n",
            "Table: \"region\"\nColumns:\n(\"r_regionkey\", BIGINT, primary key)\n(\"r_name\", STRING)\n(\"r_comment\", STRING)\n",
            "Table: \"supplier\"\nColumns:\n(\"s_suppkey\", BIGINT, primary key)\n(\"s_nationkey\", BIGINT)\n(\"s_comment\", STRING)\n(\"s_name\", STRING)\n(\"s_address\", STRING)\n(\"s_phone\", STRING)\n(\"s_acctbal\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 489,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT (CAST(SUM(IIF(STRFTIME('%Y', T2.l_shipdate) = 1995, 1, 0)) AS REAL) / 12) - (CAST(SUM(IIF(STRFTIME('%Y', T2.l_shipdate) = 1996, 1, 0)) AS REAL) / 12) FROM orders AS T1 INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey WHERE T1.o_orderpriority = '5-LOW' AND T2.l_shipmode = 'TRUCK'",
        "target_query": "SELECT (CAST(SUM(CASE WHEN sys.timestamp_to_str(\"T2\".\"l_shipdate\", '%Y') = '1995' THEN 1 ELSE 0 END) AS REAL) / 12) - (CAST(SUM(CASE WHEN sys.timestamp_to_str(\"T2\".\"l_shipdate\", '%Y') = '1996' THEN 1 ELSE 0 END) AS REAL) / 12) \nFROM \"orders\" AS \"T1\" \nINNER JOIN \"lineitem\" AS \"T2\" ON \"T1\".\"o_orderkey\" = \"T2\".\"l_orderkey\" \nWHERE \"T1\".\"o_orderpriority\" = '5-LOW' AND \"T2\".\"l_shipmode\" = 'TRUCK';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 17,
                "end_index": 63,
                "dilatect_content": "IIF(STRFTIME('%Y', T2.l_shipdate) = 1995, 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 21,
                "end_index": 49,
                "dilatect_content": "STRFTIME('%Y', T2.l_shipdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 93,
                "end_index": 139,
                "dilatect_content": "IIF(STRFTIME('%Y', T2.l_shipdate) = 1996, 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 97,
                "end_index": 125,
                "dilatect_content": "STRFTIME('%Y', T2.l_shipdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 17,
                "end_index": 102,
                "dilatect_content": "CASE WHEN sys.timestamp_to_str(\"T2\".\"l_shipdate\", '%Y') = '1995' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 27,
                "end_index": 75,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"l_shipdate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 132,
                "end_index": 217,
                "dilatect_content": "CASE WHEN sys.timestamp_to_str(\"T2\".\"l_shipdate\", '%Y') = '1996' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 142,
                "end_index": 190,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"l_shipdate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            },
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            },
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `orders`\nColumns:\n(`o_orderdate`, date)\n(`o_orderkey`, integer, primary key)\n(`o_custkey`, integer)\n(`o_orderpriority`, text)\n(`o_shippriority`, integer)\n(`o_clerk`, text)\n(`o_orderstatus`, text)\n(`o_totalprice`, real)\n(`o_comment`, text)\n",
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, date)\n(`l_orderkey`, integer, primary key)\n(`l_discount`, real)\n(`l_extendedprice`, real)\n(`l_suppkey`, integer)\n(`l_quantity`, integer)\n(`l_returnflag`, text)\n(`l_partkey`, integer)\n(`l_linestatus`, text)\n(`l_tax`, real)\n(`l_commitdate`, date)\n(`l_receiptdate`, date)\n(`l_shipmode`, text)\n(`l_linenumber`, integer, primary key)\n(`l_shipinstruct`, text)\n(`l_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"orders\"\nColumns:\n(\"o_orderdate\", DATE)\n(\"o_orderkey\", BIGINT, primary key)\n(\"o_custkey\", BIGINT)\n(\"o_orderpriority\", STRING)\n(\"o_shippriority\", BIGINT)\n(\"o_clerk\", STRING)\n(\"o_orderstatus\", STRING)\n(\"o_totalprice\", DOUBLE PRECISION)\n(\"o_comment\", STRING)\n",
            "Table: \"lineitem\"\nColumns:\n(\"l_shipdate\", DATE)\n(\"l_orderkey\", BIGINT, primary key)\n(\"l_discount\", DOUBLE PRECISION)\n(\"l_extendedprice\", DOUBLE PRECISION)\n(\"l_suppkey\", BIGINT)\n(\"l_quantity\", BIGINT)\n(\"l_returnflag\", STRING)\n(\"l_partkey\", BIGINT)\n(\"l_linestatus\", STRING)\n(\"l_tax\", DOUBLE PRECISION)\n(\"l_commitdate\", DATE)\n(\"l_receiptdate\", DATE)\n(\"l_shipmode\", STRING)\n(\"l_linenumber\", BIGINT, primary key)\n(\"l_shipinstruct\", STRING)\n(\"l_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 490,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.n_name = 'IRAN', 1, 0)) AS REAL) * 100 / COUNT(T2.n_name) FROM customer AS T1 INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE T1.c_mktsegment = 'HOUSEHOLD'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"n_name\" = 'IRAN' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T2\".\"n_name\") FROM \"customer\" AS \"T1\" INNER JOIN \"nation\" AS \"T2\" ON \"T1\".\"c_nationkey\" = \"T2\".\"n_nationkey\" WHERE \"T1\".\"c_mktsegment\" = 'HOUSEHOLD';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 44,
                "dilatect_content": "IIF(T2.n_name = 'IRAN', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 69,
                "dilatect_content": "CASE WHEN \"T2\".\"n_name\" = 'IRAN' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`c_custkey`, integer, primary key)\n(`c_mktsegment`, text)\n(`c_nationkey`, integer)\n(`c_name`, text)\n(`c_address`, text)\n(`c_phone`, text)\n(`c_acctbal`, real)\n(`c_comment`, text)\n",
            "Table: `nation`\nColumns:\n(`n_nationkey`, integer, primary key)\n(`n_name`, text)\n(`n_regionkey`, integer)\n(`n_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"customer\"\nColumns:\n(\"c_custkey\", BIGINT, primary key)\n(\"c_mktsegment\", STRING)\n(\"c_nationkey\", BIGINT)\n(\"c_name\", STRING)\n(\"c_address\", STRING)\n(\"c_phone\", STRING)\n(\"c_acctbal\", DOUBLE PRECISION)\n(\"c_comment\", STRING)\n",
            "Table: \"nation\"\nColumns:\n(\"n_nationkey\", BIGINT, primary key)\n(\"n_name\", STRING)\n(\"n_regionkey\", BIGINT)\n(\"n_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 491,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT IIF(SUM(IIF(l_shipmode = 'RAIL', 1, 0)) - SUM(IIF(l_shipmode = 'MAIL', 1, 0)), 'RAIL', 'MAIL') AS result FROM lineitem WHERE l_shipinstruct = 'DELIVER IN PERSON'",
        "target_query": "SELECT CASE WHEN SUM(CASE WHEN \"l_shipmode\" = 'RAIL' THEN 1 ELSE 0 END) - SUM(CASE WHEN \"l_shipmode\" = 'MAIL' THEN 1 ELSE 0 END) <> 0 THEN 'RAIL' ELSE 'MAIL' END AS result FROM \"lineitem\" WHERE \"l_shipinstruct\" = 'DELIVER IN PERSON';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 100,
                "dilatect_content": "IIF(SUM(IIF(l_shipmode = 'RAIL', 1, 0)) - SUM(IIF(l_shipmode = 'MAIL', 1, 0)), 'RAIL', 'MAIL')",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 15,
                "end_index": 44,
                "dilatect_content": "IIF(l_shipmode = 'RAIL', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 53,
                "end_index": 82,
                "dilatect_content": "IIF(l_shipmode = 'MAIL', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 164,
                "dilatect_content": "CASE WHEN SUM(CASE WHEN \"l_shipmode\" = 'RAIL' THEN 1 ELSE 0 END) - SUM(CASE WHEN \"l_shipmode\" = 'MAIL' THEN 1 ELSE 0 END) <> 0 THEN 'RAIL' ELSE 'MAIL' END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 21,
                "end_index": 71,
                "dilatect_content": "CASE WHEN \"l_shipmode\" = 'RAIL' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 80,
                "end_index": 130,
                "dilatect_content": "CASE WHEN \"l_shipmode\" = 'MAIL' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, date)\n(`l_orderkey`, integer, primary key)\n(`l_discount`, real)\n(`l_extendedprice`, real)\n(`l_suppkey`, integer)\n(`l_quantity`, integer)\n(`l_returnflag`, text)\n(`l_partkey`, integer)\n(`l_linestatus`, text)\n(`l_tax`, real)\n(`l_commitdate`, date)\n(`l_receiptdate`, date)\n(`l_shipmode`, text)\n(`l_linenumber`, integer, primary key)\n(`l_shipinstruct`, text)\n(`l_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"lineitem\"\nColumns:\n(\"l_shipdate\", DATE)\n(\"l_orderkey\", BIGINT, primary key)\n(\"l_discount\", DOUBLE PRECISION)\n(\"l_extendedprice\", DOUBLE PRECISION)\n(\"l_suppkey\", BIGINT)\n(\"l_quantity\", BIGINT)\n(\"l_returnflag\", STRING)\n(\"l_partkey\", BIGINT)\n(\"l_linestatus\", STRING)\n(\"l_tax\", DOUBLE PRECISION)\n(\"l_commitdate\", DATE)\n(\"l_receiptdate\", DATE)\n(\"l_shipmode\", STRING)\n(\"l_linenumber\", BIGINT, primary key)\n(\"l_shipinstruct\", STRING)\n(\"l_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 492,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(o_orderkey) AS countorders FROM orders WHERE STRFTIME('%Y', o_orderdate) = '1998' AND o_totalprice < 950",
        "target_query": "SELECT COUNT(\"o_orderkey\") AS countorders FROM \"orders\" WHERE sys.timestamp_to_str(\"o_orderdate\", '%Y') = '1998' AND \"o_totalprice\" < 950;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 58,
                "end_index": 84,
                "dilatect_content": "STRFTIME('%Y', o_orderdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 66,
                "end_index": 108,
                "dilatect_content": "sys.timestamp_to_str(\"o_orderdate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `orders`\nColumns:\n(`o_orderdate`, date)\n(`o_orderkey`, integer, primary key)\n(`o_custkey`, integer)\n(`o_orderpriority`, text)\n(`o_shippriority`, integer)\n(`o_clerk`, text)\n(`o_orderstatus`, text)\n(`o_totalprice`, real)\n(`o_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"orders\"\nColumns:\n(\"o_orderdate\", DATE)\n(\"o_orderkey\", BIGINT, primary key)\n(\"o_custkey\", BIGINT)\n(\"o_orderpriority\", STRING)\n(\"o_shippriority\", BIGINT)\n(\"o_clerk\", STRING)\n(\"o_orderstatus\", STRING)\n(\"o_totalprice\", DOUBLE PRECISION)\n(\"o_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 493,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(l_returnflag = 'A', 1, 0)) - SUM(IIF(l_returnflag = 'N', 1, 0)) AS diff FROM lineitem WHERE l_extendedprice < 16947.7",
        "target_query": "SELECT SUM(CASE WHEN \"l_returnflag\" = 'A' THEN 1 ELSE 0 END) - SUM(CASE WHEN \"l_returnflag\" = 'N' THEN 1 ELSE 0 END) AS \"diff\" FROM \"lineitem\" WHERE \"l_extendedprice\" < 16947.7;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 39,
                "dilatect_content": "IIF(l_returnflag = 'A', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 48,
                "end_index": 76,
                "dilatect_content": "IIF(l_returnflag = 'N', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 60,
                "dilatect_content": "CASE WHEN \"l_returnflag\" = 'A' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 69,
                "end_index": 118,
                "dilatect_content": "CASE WHEN \"l_returnflag\" = 'N' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, date)\n(`l_orderkey`, integer, primary key)\n(`l_discount`, real)\n(`l_extendedprice`, real)\n(`l_suppkey`, integer)\n(`l_quantity`, integer)\n(`l_returnflag`, text)\n(`l_partkey`, integer)\n(`l_linestatus`, text)\n(`l_tax`, real)\n(`l_commitdate`, date)\n(`l_receiptdate`, date)\n(`l_shipmode`, text)\n(`l_linenumber`, integer, primary key)\n(`l_shipinstruct`, text)\n(`l_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"lineitem\"\nColumns:\n(\"l_shipdate\", DATE)\n(\"l_orderkey\", BIGINT, primary key)\n(\"l_discount\", DOUBLE PRECISION)\n(\"l_extendedprice\", DOUBLE PRECISION)\n(\"l_suppkey\", BIGINT)\n(\"l_quantity\", BIGINT)\n(\"l_returnflag\", STRING)\n(\"l_partkey\", BIGINT)\n(\"l_linestatus\", STRING)\n(\"l_tax\", DOUBLE PRECISION)\n(\"l_commitdate\", DATE)\n(\"l_receiptdate\", DATE)\n(\"l_shipmode\", STRING)\n(\"l_linenumber\", BIGINT, primary key)\n(\"l_shipinstruct\", STRING)\n(\"l_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 494,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT JULIANDAY(T2.l_receiptdate) - JULIANDAY(T2.l_commitdate), T1.o_clerk FROM orders AS T1 INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey WHERE T1.o_orderkey = 6",
        "target_query": "SELECT (2440587.5 + EXTRACT(EPOCH FROM \"T2\".\"l_receiptdate\") / 86400) - (2440587.5 + EXTRACT(EPOCH FROM \"T2\".\"l_commitdate\") / 86400), \"T1\".\"o_clerk\" FROM \"orders\" AS \"T1\" INNER JOIN \"lineitem\" AS \"T2\" ON \"T1\".\"o_orderkey\" = \"T2\".\"l_orderkey\" WHERE \"T1\".\"o_orderkey\" = 6;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 33,
                "dilatect_content": "JULIANDAY(T2.l_receiptdate)",
                "feature": "julianday(time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 37,
                "end_index": 62,
                "dilatect_content": "JULIANDAY(T2.l_commitdate)",
                "feature": "julianday(time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 72,
                "dilatect_content": "(2440587.5 + EXTRACT(EPOCH FROM \"T2\".\"l_receiptdate\") / 86400)",
                "feature": "2440587.5 + EXTRACT(EPOCH FROM time-value) / 86400"
            },
            {
                "start_index": 76,
                "end_index": 140,
                "dilatect_content": "(2440587.5 + EXTRACT(EPOCH FROM \"T2\".\"l_commitdate\") / 86400)",
                "feature": "2440587.5 + EXTRACT(EPOCH FROM time-value) / 86400"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "julianday(time-value, modifier, modifier, ...)",
                "explanation": "The julianday(time-value, modifier, modifier, ...) function returns the Julian day number - the fractional number of days since noon in Greenwich on November 24, 4714 B.C. (Proleptic Gregorian calendar). It accepts a time-value and zero or more modifiers.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day').\nReturns: A real number representing the Julian day number.",
                "examples": [
                    "SELECT julianday(); -- Returns the current Julian day number.",
                    "SELECT julianday('2024-08-21'); -- Returns the Julian day number for August 21, 2024.",
                    "SELECT julianday('now', '+1 day'); -- Returns the Julian day number for one day after the current date."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "2440587.5 + EXTRACT(EPOCH FROM time-value) / 86400",
                "explanation": "This expression calculates the Julian day number in MonetDB. It returns the fractional number of days since noon in Greenwich on November 24, 4714 B.C. by converting the input date or timestamp to seconds since the Unix epoch, dividing by 86400 (seconds per day), and adding the Julian base offset 2440587.5.\n\nParameters:\n- time-value: a DATE or TIMESTAMP value.\nReturns: A real number representing the Julian day number.",
                "examples": [
                    "SELECT 2440587.5 + EXTRACT(EPOCH FROM CURRENT_TIMESTAMP) / 86400; -- Returns the current Julian day number.",
                    "SELECT 2440587.5 + EXTRACT(EPOCH FROM DATE '2024-08-21') / 86400; -- Julian day for August 21, 2024.",
                    "SELECT 2440587.5 + EXTRACT(EPOCH FROM TIMESTAMP '2024-08-21 12:00:00') / 86400; -- Julian day with time component."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `orders`\nColumns:\n(`o_orderdate`, date)\n(`o_orderkey`, integer, primary key)\n(`o_custkey`, integer)\n(`o_orderpriority`, text)\n(`o_shippriority`, integer)\n(`o_clerk`, text)\n(`o_orderstatus`, text)\n(`o_totalprice`, real)\n(`o_comment`, text)\n",
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, date)\n(`l_orderkey`, integer, primary key)\n(`l_discount`, real)\n(`l_extendedprice`, real)\n(`l_suppkey`, integer)\n(`l_quantity`, integer)\n(`l_returnflag`, text)\n(`l_partkey`, integer)\n(`l_linestatus`, text)\n(`l_tax`, real)\n(`l_commitdate`, date)\n(`l_receiptdate`, date)\n(`l_shipmode`, text)\n(`l_linenumber`, integer, primary key)\n(`l_shipinstruct`, text)\n(`l_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"orders\"\nColumns:\n(\"o_orderdate\", DATE)\n(\"o_orderkey\", BIGINT, primary key)\n(\"o_custkey\", BIGINT)\n(\"o_orderpriority\", STRING)\n(\"o_shippriority\", BIGINT)\n(\"o_clerk\", STRING)\n(\"o_orderstatus\", STRING)\n(\"o_totalprice\", DOUBLE PRECISION)\n(\"o_comment\", STRING)\n",
            "Table: \"lineitem\"\nColumns:\n(\"l_shipdate\", DATE)\n(\"l_orderkey\", BIGINT, primary key)\n(\"l_discount\", DOUBLE PRECISION)\n(\"l_extendedprice\", DOUBLE PRECISION)\n(\"l_suppkey\", BIGINT)\n(\"l_quantity\", BIGINT)\n(\"l_returnflag\", STRING)\n(\"l_partkey\", BIGINT)\n(\"l_linestatus\", STRING)\n(\"l_tax\", DOUBLE PRECISION)\n(\"l_commitdate\", DATE)\n(\"l_receiptdate\", DATE)\n(\"l_shipmode\", STRING)\n(\"l_linenumber\", BIGINT, primary key)\n(\"l_shipinstruct\", STRING)\n(\"l_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 495,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T1.r_name = 'ASIA', 1, 0)) AS REAL) * 100 / COUNT(T1.r_regionkey) FROM region AS T1 INNER JOIN nation AS T2 ON T1.r_regionkey = T2.n_regionkey INNER JOIN supplier AS T3 ON T2.n_nationkey = T3.s_nationkey",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T1\".\"r_name\" = 'ASIA' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"r_regionkey\") FROM \"region\" AS \"T1\" INNER JOIN \"nation\" AS \"T2\" ON \"T1\".\"r_regionkey\" = \"T2\".\"n_regionkey\" INNER JOIN \"supplier\" AS \"T3\" ON \"T2\".\"n_nationkey\" = \"T3\".\"s_nationkey\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 44,
                "dilatect_content": "IIF(T1.r_name = 'ASIA', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 69,
                "dilatect_content": "CASE WHEN \"T1\".\"r_name\" = 'ASIA' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `region`\nColumns:\n(`r_regionkey`, integer, primary key)\n(`r_name`, text)\n(`r_comment`, text)\n",
            "Table: `nation`\nColumns:\n(`n_nationkey`, integer, primary key)\n(`n_name`, text)\n(`n_regionkey`, integer)\n(`n_comment`, text)\n",
            "Table: `supplier`\nColumns:\n(`s_suppkey`, integer, primary key)\n(`s_nationkey`, integer)\n(`s_comment`, text)\n(`s_name`, text)\n(`s_address`, text)\n(`s_phone`, text)\n(`s_acctbal`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"region\"\nColumns:\n(\"r_regionkey\", BIGINT, primary key)\n(\"r_name\", STRING)\n(\"r_comment\", STRING)\n",
            "Table: \"nation\"\nColumns:\n(\"n_nationkey\", BIGINT, primary key)\n(\"n_name\", STRING)\n(\"n_regionkey\", BIGINT)\n(\"n_comment\", STRING)\n",
            "Table: \"supplier\"\nColumns:\n(\"s_suppkey\", BIGINT, primary key)\n(\"s_nationkey\", BIGINT)\n(\"s_comment\", STRING)\n(\"s_name\", STRING)\n(\"s_address\", STRING)\n(\"s_phone\", STRING)\n(\"s_acctbal\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 496,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT l_linenumber FROM lineitem WHERE STRFTIME('%Y', l_shipdate) < 1997 AND l_shipmode = 'truck'",
        "target_query": "SELECT \"l_linenumber\" FROM \"lineitem\" WHERE sys.timestamp_to_str(\"l_shipdate\", '%Y') < '1997' AND \"l_shipmode\" = 'truck';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 40,
                "end_index": 65,
                "dilatect_content": "STRFTIME('%Y', l_shipdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 48,
                "end_index": 89,
                "dilatect_content": "sys.timestamp_to_str(\"l_shipdate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, date)\n(`l_orderkey`, integer, primary key)\n(`l_discount`, real)\n(`l_extendedprice`, real)\n(`l_suppkey`, integer)\n(`l_quantity`, integer)\n(`l_returnflag`, text)\n(`l_partkey`, integer)\n(`l_linestatus`, text)\n(`l_tax`, real)\n(`l_commitdate`, date)\n(`l_receiptdate`, date)\n(`l_shipmode`, text)\n(`l_linenumber`, integer, primary key)\n(`l_shipinstruct`, text)\n(`l_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"lineitem\"\nColumns:\n(\"l_shipdate\", DATE)\n(\"l_orderkey\", BIGINT, primary key)\n(\"l_discount\", DOUBLE PRECISION)\n(\"l_extendedprice\", DOUBLE PRECISION)\n(\"l_suppkey\", BIGINT)\n(\"l_quantity\", BIGINT)\n(\"l_returnflag\", STRING)\n(\"l_partkey\", BIGINT)\n(\"l_linestatus\", STRING)\n(\"l_tax\", DOUBLE PRECISION)\n(\"l_commitdate\", DATE)\n(\"l_receiptdate\", DATE)\n(\"l_shipmode\", STRING)\n(\"l_linenumber\", BIGINT, primary key)\n(\"l_shipinstruct\", STRING)\n(\"l_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 497,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT l_linenumber FROM lineitem WHERE STRFTIME('%Y', l_shipdate) < 1997 AND l_shipmode = 'TRUCK'",
        "target_query": "SELECT \"l_linenumber\" FROM \"lineitem\" WHERE sys.timestamp_to_str(\"l_shipdate\", '%Y') < '1997' AND \"l_shipmode\" = 'TRUCK';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 40,
                "end_index": 65,
                "dilatect_content": "STRFTIME('%Y', l_shipdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 48,
                "end_index": 89,
                "dilatect_content": "sys.timestamp_to_str(\"l_shipdate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, date)\n(`l_orderkey`, integer, primary key)\n(`l_discount`, real)\n(`l_extendedprice`, real)\n(`l_suppkey`, integer)\n(`l_quantity`, integer)\n(`l_returnflag`, text)\n(`l_partkey`, integer)\n(`l_linestatus`, text)\n(`l_tax`, real)\n(`l_commitdate`, date)\n(`l_receiptdate`, date)\n(`l_shipmode`, text)\n(`l_linenumber`, integer, primary key)\n(`l_shipinstruct`, text)\n(`l_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"lineitem\"\nColumns:\n(\"l_shipdate\", DATE)\n(\"l_orderkey\", BIGINT, primary key)\n(\"l_discount\", DOUBLE PRECISION)\n(\"l_extendedprice\", DOUBLE PRECISION)\n(\"l_suppkey\", BIGINT)\n(\"l_quantity\", BIGINT)\n(\"l_returnflag\", STRING)\n(\"l_partkey\", BIGINT)\n(\"l_linestatus\", STRING)\n(\"l_tax\", DOUBLE PRECISION)\n(\"l_commitdate\", DATE)\n(\"l_receiptdate\", DATE)\n(\"l_shipmode\", STRING)\n(\"l_linenumber\", BIGINT, primary key)\n(\"l_shipinstruct\", STRING)\n(\"l_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 498,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T3.c_name FROM orders AS T1 INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey INNER JOIN customer AS T3 ON T1.o_custkey = T3.c_custkey WHERE T2.l_discount = 0.1 AND STRFTIME('%Y', T1.o_orderdate) BETWEEN 1994 AND 1995",
        "target_query": "SELECT \"T3\".\"c_name\" FROM \"orders\" AS \"T1\" INNER JOIN \"lineitem\" AS \"T2\" ON \"T1\".\"o_orderkey\" = \"T2\".\"l_orderkey\" INNER JOIN \"customer\" AS \"T3\" ON \"T1\".\"o_custkey\" = \"T3\".\"c_custkey\" WHERE \"T2\".\"l_discount\" = 0.1 AND sys.timestamp_to_str(\"T1\".\"o_orderdate\", '%Y') BETWEEN '1994' AND '1995';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 181,
                "end_index": 210,
                "dilatect_content": "STRFTIME('%Y', T1.o_orderdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 253,
                "end_index": 302,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"o_orderdate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `orders`\nColumns:\n(`o_orderdate`, date)\n(`o_orderkey`, integer, primary key)\n(`o_custkey`, integer)\n(`o_orderpriority`, text)\n(`o_shippriority`, integer)\n(`o_clerk`, text)\n(`o_orderstatus`, text)\n(`o_totalprice`, real)\n(`o_comment`, text)\n",
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, date)\n(`l_orderkey`, integer, primary key)\n(`l_discount`, real)\n(`l_extendedprice`, real)\n(`l_suppkey`, integer)\n(`l_quantity`, integer)\n(`l_returnflag`, text)\n(`l_partkey`, integer)\n(`l_linestatus`, text)\n(`l_tax`, real)\n(`l_commitdate`, date)\n(`l_receiptdate`, date)\n(`l_shipmode`, text)\n(`l_linenumber`, integer, primary key)\n(`l_shipinstruct`, text)\n(`l_comment`, text)\n",
            "Table: `customer`\nColumns:\n(`c_custkey`, integer, primary key)\n(`c_mktsegment`, text)\n(`c_nationkey`, integer)\n(`c_name`, text)\n(`c_address`, text)\n(`c_phone`, text)\n(`c_acctbal`, real)\n(`c_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"orders\"\nColumns:\n(\"o_orderdate\", DATE)\n(\"o_orderkey\", BIGINT, primary key)\n(\"o_custkey\", BIGINT)\n(\"o_orderpriority\", STRING)\n(\"o_shippriority\", BIGINT)\n(\"o_clerk\", STRING)\n(\"o_orderstatus\", STRING)\n(\"o_totalprice\", DOUBLE PRECISION)\n(\"o_comment\", STRING)\n",
            "Table: \"lineitem\"\nColumns:\n(\"l_shipdate\", DATE)\n(\"l_orderkey\", BIGINT, primary key)\n(\"l_discount\", DOUBLE PRECISION)\n(\"l_extendedprice\", DOUBLE PRECISION)\n(\"l_suppkey\", BIGINT)\n(\"l_quantity\", BIGINT)\n(\"l_returnflag\", STRING)\n(\"l_partkey\", BIGINT)\n(\"l_linestatus\", STRING)\n(\"l_tax\", DOUBLE PRECISION)\n(\"l_commitdate\", DATE)\n(\"l_receiptdate\", DATE)\n(\"l_shipmode\", STRING)\n(\"l_linenumber\", BIGINT, primary key)\n(\"l_shipinstruct\", STRING)\n(\"l_comment\", STRING)\n",
            "Table: \"customer\"\nColumns:\n(\"c_custkey\", BIGINT, primary key)\n(\"c_mktsegment\", STRING)\n(\"c_nationkey\", BIGINT)\n(\"c_name\", STRING)\n(\"c_address\", STRING)\n(\"c_phone\", STRING)\n(\"c_acctbal\", DOUBLE PRECISION)\n(\"c_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 499,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T1.r_name = 'America', 1, 0)) AS REAL) * 100 / COUNT(T2.n_name) FROM region AS T1 INNER JOIN nation AS T2 ON T1.r_regionkey = T2.n_regionkey",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T1\".\"r_name\" = 'America' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T2\".\"n_name\") FROM \"region\" AS \"T1\" INNER JOIN \"nation\" AS \"T2\" ON \"T1\".\"r_regionkey\" = \"T2\".\"n_regionkey\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 47,
                "dilatect_content": "IIF(T1.r_name = 'America', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 72,
                "dilatect_content": "CASE WHEN \"T1\".\"r_name\" = 'America' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `region`\nColumns:\n(`r_regionkey`, integer, primary key)\n(`r_name`, text)\n(`r_comment`, text)\n",
            "Table: `nation`\nColumns:\n(`n_nationkey`, integer, primary key)\n(`n_name`, text)\n(`n_regionkey`, integer)\n(`n_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"region\"\nColumns:\n(\"r_regionkey\", BIGINT, primary key)\n(\"r_name\", STRING)\n(\"r_comment\", STRING)\n",
            "Table: \"nation\"\nColumns:\n(\"n_nationkey\", BIGINT, primary key)\n(\"n_name\", STRING)\n(\"n_regionkey\", BIGINT)\n(\"n_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 500,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T1.c_mktsegment = 'HOUSEHOLD', 1, 0)) AS REAL) * 100 / COUNT(T1.c_mktsegment) FROM customer AS T1 INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE T2.n_name = 'INDONESIA'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T1\".\"c_mktsegment\" = 'HOUSEHOLD' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"c_mktsegment\") FROM \"customer\" AS \"T1\" INNER JOIN \"nation\" AS \"T2\" ON \"T1\".\"c_nationkey\" = \"T2\".\"n_nationkey\" WHERE \"T2\".\"n_name\" = 'INDONESIA';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 55,
                "dilatect_content": "IIF(T1.c_mktsegment = 'HOUSEHOLD', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 80,
                "dilatect_content": "CASE WHEN \"T1\".\"c_mktsegment\" = 'HOUSEHOLD' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`c_custkey`, integer, primary key)\n(`c_mktsegment`, text)\n(`c_nationkey`, integer)\n(`c_name`, text)\n(`c_address`, text)\n(`c_phone`, text)\n(`c_acctbal`, real)\n(`c_comment`, text)\n",
            "Table: `nation`\nColumns:\n(`n_nationkey`, integer, primary key)\n(`n_name`, text)\n(`n_regionkey`, integer)\n(`n_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"customer\"\nColumns:\n(\"c_custkey\", BIGINT, primary key)\n(\"c_mktsegment\", STRING)\n(\"c_nationkey\", BIGINT)\n(\"c_name\", STRING)\n(\"c_address\", STRING)\n(\"c_phone\", STRING)\n(\"c_acctbal\", DOUBLE PRECISION)\n(\"c_comment\", STRING)\n",
            "Table: \"nation\"\nColumns:\n(\"n_nationkey\", BIGINT, primary key)\n(\"n_name\", STRING)\n(\"n_regionkey\", BIGINT)\n(\"n_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 501,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(l_orderkey) FROM lineitem WHERE STRFTIME('%Y', l_shipdate) = '1997' AND l_shipmode = 'MAIL'",
        "target_query": "SELECT COUNT(\"l_orderkey\") FROM \"lineitem\" WHERE sys.timestamp_to_str(\"l_shipdate\", '%Y') = '1997' AND \"l_shipmode\" = 'MAIL';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 45,
                "end_index": 70,
                "dilatect_content": "STRFTIME('%Y', l_shipdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 53,
                "end_index": 94,
                "dilatect_content": "sys.timestamp_to_str(\"l_shipdate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, date)\n(`l_orderkey`, integer, primary key)\n(`l_discount`, real)\n(`l_extendedprice`, real)\n(`l_suppkey`, integer)\n(`l_quantity`, integer)\n(`l_returnflag`, text)\n(`l_partkey`, integer)\n(`l_linestatus`, text)\n(`l_tax`, real)\n(`l_commitdate`, date)\n(`l_receiptdate`, date)\n(`l_shipmode`, text)\n(`l_linenumber`, integer, primary key)\n(`l_shipinstruct`, text)\n(`l_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"lineitem\"\nColumns:\n(\"l_shipdate\", DATE)\n(\"l_orderkey\", BIGINT, primary key)\n(\"l_discount\", DOUBLE PRECISION)\n(\"l_extendedprice\", DOUBLE PRECISION)\n(\"l_suppkey\", BIGINT)\n(\"l_quantity\", BIGINT)\n(\"l_returnflag\", STRING)\n(\"l_partkey\", BIGINT)\n(\"l_linestatus\", STRING)\n(\"l_tax\", DOUBLE PRECISION)\n(\"l_commitdate\", DATE)\n(\"l_receiptdate\", DATE)\n(\"l_shipmode\", STRING)\n(\"l_linenumber\", BIGINT, primary key)\n(\"l_shipinstruct\", STRING)\n(\"l_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 502,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(l_orderkey) FROM lineitem WHERE STRFTIME('%Y', l_shipdate) = '1994' AND l_returnflag = 'R' AND l_shipmode = 'TRUCK'",
        "target_query": "SELECT COUNT(\"l_orderkey\") FROM \"lineitem\" WHERE sys.timestamp_to_str(\"l_shipdate\", '%Y') = '1994' AND \"l_returnflag\" = 'R' AND \"l_shipmode\" = 'TRUCK';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 45,
                "end_index": 70,
                "dilatect_content": "STRFTIME('%Y', l_shipdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 53,
                "end_index": 94,
                "dilatect_content": "sys.timestamp_to_str(\"l_shipdate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, date)\n(`l_orderkey`, integer, primary key)\n(`l_discount`, real)\n(`l_extendedprice`, real)\n(`l_suppkey`, integer)\n(`l_quantity`, integer)\n(`l_returnflag`, text)\n(`l_partkey`, integer)\n(`l_linestatus`, text)\n(`l_tax`, real)\n(`l_commitdate`, date)\n(`l_receiptdate`, date)\n(`l_shipmode`, text)\n(`l_linenumber`, integer, primary key)\n(`l_shipinstruct`, text)\n(`l_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"lineitem\"\nColumns:\n(\"l_shipdate\", DATE)\n(\"l_orderkey\", BIGINT, primary key)\n(\"l_discount\", DOUBLE PRECISION)\n(\"l_extendedprice\", DOUBLE PRECISION)\n(\"l_suppkey\", BIGINT)\n(\"l_quantity\", BIGINT)\n(\"l_returnflag\", STRING)\n(\"l_partkey\", BIGINT)\n(\"l_linestatus\", STRING)\n(\"l_tax\", DOUBLE PRECISION)\n(\"l_commitdate\", DATE)\n(\"l_receiptdate\", DATE)\n(\"l_shipmode\", STRING)\n(\"l_linenumber\", BIGINT, primary key)\n(\"l_shipinstruct\", STRING)\n(\"l_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 503,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(o_orderkey) FROM orders WHERE STRFTIME('%Y', o_orderdate) = '1997' AND o_clerk = 'Clerk#000000001' AND o_orderpriority = '1-URGENT'",
        "target_query": "SELECT COUNT(\"o_orderkey\") FROM \"orders\" WHERE sys.timestamp_to_str(\"o_orderdate\", '%Y') = '1997' AND \"o_clerk\" = 'Clerk#000000001' AND \"o_orderpriority\" = '1-URGENT';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 43,
                "end_index": 69,
                "dilatect_content": "STRFTIME('%Y', o_orderdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 51,
                "end_index": 93,
                "dilatect_content": "sys.timestamp_to_str(\"o_orderdate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `orders`\nColumns:\n(`o_orderdate`, date)\n(`o_orderkey`, integer, primary key)\n(`o_custkey`, integer)\n(`o_orderpriority`, text)\n(`o_shippriority`, integer)\n(`o_clerk`, text)\n(`o_orderstatus`, text)\n(`o_totalprice`, real)\n(`o_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"orders\"\nColumns:\n(\"o_orderdate\", DATE)\n(\"o_orderkey\", BIGINT, primary key)\n(\"o_custkey\", BIGINT)\n(\"o_orderpriority\", STRING)\n(\"o_shippriority\", BIGINT)\n(\"o_clerk\", STRING)\n(\"o_orderstatus\", STRING)\n(\"o_totalprice\", DOUBLE PRECISION)\n(\"o_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 504,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T3.c_name FROM orders AS T1 INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey INNER JOIN customer AS T3 ON T1.o_custkey = T3.c_custkey ORDER BY (JULIANDAY(T2.l_receiptdate) - JULIANDAY(T2.l_commitdate)) DESC LIMIT 1",
        "target_query": "SELECT \"T3\".\"c_name\" FROM \"orders\" AS \"T1\" INNER JOIN \"lineitem\" AS \"T2\" ON \"T1\".\"o_orderkey\" = \"T2\".\"l_orderkey\" INNER JOIN \"customer\" AS \"T3\" ON \"T1\".\"o_custkey\" = \"T3\".\"c_custkey\" ORDER BY (2440587.5 + EXTRACT(EPOCH FROM \"T2\".\"l_receiptdate\") / 86400 - 2440587.5 - EXTRACT(EPOCH FROM \"T2\".\"l_commitdate\") / 86400) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 161,
                "end_index": 187,
                "dilatect_content": "JULIANDAY(T2.l_receiptdate)",
                "feature": "julianday(time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 191,
                "end_index": 216,
                "dilatect_content": "JULIANDAY(T2.l_commitdate)",
                "feature": "julianday(time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 224,
                "end_index": 288,
                "dilatect_content": "(2440587.5 + EXTRACT(EPOCH FROM \"T2\".\"l_receiptdate\") / 86400",
                "feature": "2440587.5 + EXTRACT(EPOCH FROM time-value) / 86400"
            },
            {
                "start_index": 292,
                "end_index": 354,
                "dilatect_content": "2440587.5 - EXTRACT(EPOCH FROM \"T2\".\"l_commitdate\") / 86400",
                "feature": "2440587.5 + EXTRACT(EPOCH FROM time-value) / 86400"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "julianday(time-value, modifier, modifier, ...)",
                "explanation": "The julianday(time-value, modifier, modifier, ...) function returns the Julian day number - the fractional number of days since noon in Greenwich on November 24, 4714 B.C. (Proleptic Gregorian calendar). It accepts a time-value and zero or more modifiers.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day').\nReturns: A real number representing the Julian day number.",
                "examples": [
                    "SELECT julianday(); -- Returns the current Julian day number.",
                    "SELECT julianday('2024-08-21'); -- Returns the Julian day number for August 21, 2024.",
                    "SELECT julianday('now', '+1 day'); -- Returns the Julian day number for one day after the current date."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "2440587.5 + EXTRACT(EPOCH FROM time-value) / 86400",
                "explanation": "This expression calculates the Julian day number in MonetDB. It returns the fractional number of days since noon in Greenwich on November 24, 4714 B.C. by converting the input date or timestamp to seconds since the Unix epoch, dividing by 86400 (seconds per day), and adding the Julian base offset 2440587.5.\n\nParameters:\n- time-value: a DATE or TIMESTAMP value.\nReturns: A real number representing the Julian day number.",
                "examples": [
                    "SELECT 2440587.5 + EXTRACT(EPOCH FROM CURRENT_TIMESTAMP) / 86400; -- Returns the current Julian day number.",
                    "SELECT 2440587.5 + EXTRACT(EPOCH FROM DATE '2024-08-21') / 86400; -- Julian day for August 21, 2024.",
                    "SELECT 2440587.5 + EXTRACT(EPOCH FROM TIMESTAMP '2024-08-21 12:00:00') / 86400; -- Julian day with time component."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `orders`\nColumns:\n(`o_orderdate`, date)\n(`o_orderkey`, integer, primary key)\n(`o_custkey`, integer)\n(`o_orderpriority`, text)\n(`o_shippriority`, integer)\n(`o_clerk`, text)\n(`o_orderstatus`, text)\n(`o_totalprice`, real)\n(`o_comment`, text)\n",
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, date)\n(`l_orderkey`, integer, primary key)\n(`l_discount`, real)\n(`l_extendedprice`, real)\n(`l_suppkey`, integer)\n(`l_quantity`, integer)\n(`l_returnflag`, text)\n(`l_partkey`, integer)\n(`l_linestatus`, text)\n(`l_tax`, real)\n(`l_commitdate`, date)\n(`l_receiptdate`, date)\n(`l_shipmode`, text)\n(`l_linenumber`, integer, primary key)\n(`l_shipinstruct`, text)\n(`l_comment`, text)\n",
            "Table: `customer`\nColumns:\n(`c_custkey`, integer, primary key)\n(`c_mktsegment`, text)\n(`c_nationkey`, integer)\n(`c_name`, text)\n(`c_address`, text)\n(`c_phone`, text)\n(`c_acctbal`, real)\n(`c_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"orders\"\nColumns:\n(\"o_orderdate\", DATE)\n(\"o_orderkey\", BIGINT, primary key)\n(\"o_custkey\", BIGINT)\n(\"o_orderpriority\", STRING)\n(\"o_shippriority\", BIGINT)\n(\"o_clerk\", STRING)\n(\"o_orderstatus\", STRING)\n(\"o_totalprice\", DOUBLE PRECISION)\n(\"o_comment\", STRING)\n",
            "Table: \"lineitem\"\nColumns:\n(\"l_shipdate\", DATE)\n(\"l_orderkey\", BIGINT, primary key)\n(\"l_discount\", DOUBLE PRECISION)\n(\"l_extendedprice\", DOUBLE PRECISION)\n(\"l_suppkey\", BIGINT)\n(\"l_quantity\", BIGINT)\n(\"l_returnflag\", STRING)\n(\"l_partkey\", BIGINT)\n(\"l_linestatus\", STRING)\n(\"l_tax\", DOUBLE PRECISION)\n(\"l_commitdate\", DATE)\n(\"l_receiptdate\", DATE)\n(\"l_shipmode\", STRING)\n(\"l_linenumber\", BIGINT, primary key)\n(\"l_shipinstruct\", STRING)\n(\"l_comment\", STRING)\n",
            "Table: \"customer\"\nColumns:\n(\"c_custkey\", BIGINT, primary key)\n(\"c_mktsegment\", STRING)\n(\"c_nationkey\", BIGINT)\n(\"c_name\", STRING)\n(\"c_address\", STRING)\n(\"c_phone\", STRING)\n(\"c_acctbal\", DOUBLE PRECISION)\n(\"c_comment\", STRING)\n"
        ]
    },
    {
        "sql_id": 505,
        "database_name": "ice_hockey_draft",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T2.ELITEID) FROM height_info AS T1 INNER JOIN PlayerInfo AS T2 ON T1.height_id = T2.height WHERE T1.height_in_cm > 182 AND strftime('%Y', T2.birthdate) = '1982'",
        "target_query": "SELECT COUNT(\"T2\".\"ELITEID\") FROM \"height_info\" AS \"T1\" INNER JOIN \"PlayerInfo\" AS \"T2\" ON \"T1\".\"height_id\" = \"T2\".\"height\" WHERE \"T1\".\"height_in_cm\" > 182 AND SUBSTRING(\"T2\".\"birthdate\" FROM 1 FOR 4) = '1982';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 136,
                "end_index": 163,
                "dilatect_content": "strftime('%Y', T2.birthdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `height_info`\nColumns:\n(`height_id`, integer, primary key)\n(`height_in_cm`, integer)\n(`height_in_inch`, text)\n",
            "Table: `PlayerInfo`\nColumns:\n(`ELITEID`, integer, primary key)\n(`PlayerName`, text)\n(`birthdate`, text)\n(`birthyear`, text)\n(`birthmonth`, integer)\n(`birthday`, integer)\n(`birthplace`, text)\n(`nation`, text)\n(`height`, integer)\n(`weight`, integer)\n(`position_info`, text)\n(`shoots`, text)\n(`draftyear`, integer)\n(`draftround`, integer)\n(`overall`, integer)\n(`overallby`, text)\n(`CSS_rank`, integer)\n(`sum_7yr_GP`, integer)\n(`sum_7yr_TOI`, integer)\n(`GP_greater_than_0`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"height_info\"\nColumns:\n(\"height_id\", BIGINT, primary key)\n(\"height_in_cm\", BIGINT)\n(\"height_in_inch\", STRING)\n",
            "Table: \"PlayerInfo\"\nColumns:\n(\"ELITEID\", BIGINT, primary key)\n(\"PlayerName\", STRING)\n(\"birthdate\", STRING)\n(\"birthyear\", STRING)\n(\"birthmonth\", BIGINT)\n(\"birthday\", BIGINT)\n(\"birthplace\", STRING)\n(\"nation\", STRING)\n(\"height\", BIGINT)\n(\"weight\", BIGINT)\n(\"position_info\", STRING)\n(\"shoots\", STRING)\n(\"draftyear\", BIGINT)\n(\"draftround\", BIGINT)\n(\"overall\", BIGINT)\n(\"overallby\", STRING)\n(\"CSS_rank\", BIGINT)\n(\"sum_7yr_GP\", BIGINT)\n(\"sum_7yr_TOI\", BIGINT)\n(\"GP_greater_than_0\", STRING)\n"
        ]
    },
    {
        "sql_id": 506,
        "database_name": "ice_hockey_draft",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T2.ELITEID) FROM weight_info AS T1 INNER JOIN PlayerInfo AS T2 ON T1.weight_id = T2.weight WHERE T1.weight_in_lbs = 185 AND strftime('%Y', T2.birthdate) = '1980'",
        "target_query": "SELECT COUNT(\"T2\".\"ELITEID\") FROM \"weight_info\" AS \"T1\" INNER JOIN \"PlayerInfo\" AS \"T2\" ON \"T1\".\"weight_id\" = \"T2\".\"weight\" WHERE \"T1\".\"weight_in_lbs\" = 185 AND sys.timestamp_to_str(\"T2\".\"birthdate\", '%Y') = '1980';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 137,
                "end_index": 164,
                "dilatect_content": "strftime('%Y', T2.birthdate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 185,
                "end_index": 232,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"birthdate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `weight_info`\nColumns:\n(`weight_id`, integer, primary key)\n(`weight_in_kg`, integer)\n(`weight_in_lbs`, integer)\n",
            "Table: `PlayerInfo`\nColumns:\n(`ELITEID`, integer, primary key)\n(`PlayerName`, text)\n(`birthdate`, text)\n(`birthyear`, text)\n(`birthmonth`, integer)\n(`birthday`, integer)\n(`birthplace`, text)\n(`nation`, text)\n(`height`, integer)\n(`weight`, integer)\n(`position_info`, text)\n(`shoots`, text)\n(`draftyear`, integer)\n(`draftround`, integer)\n(`overall`, integer)\n(`overallby`, text)\n(`CSS_rank`, integer)\n(`sum_7yr_GP`, integer)\n(`sum_7yr_TOI`, integer)\n(`GP_greater_than_0`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"weight_info\"\nColumns:\n(\"weight_id\", BIGINT, primary key)\n(\"weight_in_kg\", BIGINT)\n(\"weight_in_lbs\", BIGINT)\n",
            "Table: \"PlayerInfo\"\nColumns:\n(\"ELITEID\", BIGINT, primary key)\n(\"PlayerName\", STRING)\n(\"birthdate\", STRING)\n(\"birthyear\", STRING)\n(\"birthmonth\", BIGINT)\n(\"birthday\", BIGINT)\n(\"birthplace\", STRING)\n(\"nation\", STRING)\n(\"height\", BIGINT)\n(\"weight\", BIGINT)\n(\"position_info\", STRING)\n(\"shoots\", STRING)\n(\"draftyear\", BIGINT)\n(\"draftround\", BIGINT)\n(\"overall\", BIGINT)\n(\"overallby\", STRING)\n(\"CSS_rank\", BIGINT)\n(\"sum_7yr_GP\", BIGINT)\n(\"sum_7yr_TOI\", BIGINT)\n(\"GP_greater_than_0\", STRING)\n"
        ]
    },
    {
        "sql_id": 507,
        "database_name": "ice_hockey_draft",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT CAST(COUNT(CASE WHEN T1.nation = 'Sweden' THEN T1.ELITEID ELSE NULL END) OVER (PARTITION BY T2.SEASON) AS REAL) * 100 / COUNT(T1.ELITEID) OVER (PARTITION BY T2.SEASON) FROM PlayerInfo AS T1 INNER JOIN SeasonStatus AS T2 ON T1.ELITEID = T2.ELITEID WHERE T2.SEASON IN ('1997-1998', '1998-1999', '1999-2000')",
        "target_query": "SELECT DISTINCT CAST((COUNT(CASE WHEN \"T1\".\"nation\" = 'Sweden' THEN \"T1\".\"ELITEID\" ELSE NULL END) OVER (PARTITION BY \"T2\".\"SEASON\") * 100.0) / COUNT(\"T1\".\"ELITEID\") OVER (PARTITION BY \"T2\".\"SEASON\") AS REAL) FROM \"PlayerInfo\" AS \"T1\" INNER JOIN \"SeasonStatus\" AS \"T2\" ON \"T1\".\"ELITEID\" = \"T2\".\"ELITEID\" WHERE \"T2\".\"SEASON\" IN ('1997-1998', '1998-1999', '1999-2000')",
        "semantic_equivalent_type": "approximate_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 89,
                "end_index": 117,
                "dilatect_content": "OVER (PARTITION BY T2.SEASON)",
                "feature": "OVER ( [PARTITION BY column_list] [ORDER BY column_list] )"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 106,
                "end_index": 142,
                "dilatect_content": "OVER (PARTITION BY \"T2\".\"SEASON\")",
                "feature": "OVER ( [PARTITION BY column_list] [ORDER BY column_list] )"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "OVER ( [PARTITION BY column_list] [ORDER BY column_list] )",
                "explanation": "SQLite supports window functions, and the `OVER` clause is used to define a window. It can include `PARTITION BY` to divide the result set into partitions and `ORDER BY` to specify the order of rows within each partition. Window functions in SQLite are available from version 3.25.0 onward. However, SQLite does not support window frame specifications such as `ROWS BETWEEN`.",
                "examples": [
                    "SELECT id, value, ROW_NUMBER() OVER (PARTITION BY category ORDER BY value DESC) AS rank FROM items;",
                    "SELECT name, department, AVG(salary) OVER (PARTITION BY department) AS avg_salary FROM employees;",
                    "SELECT customer_id, order_date, SUM(total_amount) OVER (PARTITION BY customer_id ORDER BY order_date) AS running_total FROM orders;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "OVER ( [PARTITION BY column_list] [ORDER BY column_list] )",
                "explanation": "MonetDB supports window functions, and the `OVER` clause is used to define a window. It allows `PARTITION BY` and `ORDER BY` to control the scope and order of rows within a window for functions like ROW_NUMBER, RANK, and aggregate functions.",
                "examples": [
                    "SELECT id, value, ROW_NUMBER() OVER (PARTITION BY category ORDER BY value DESC) AS rank FROM items;",
                    "SELECT name, department, AVG(salary) OVER (PARTITION BY department) AS avg_salary FROM employees;",
                    "SELECT customer_id, order_date, SUM(total_amount) OVER (PARTITION BY customer_id ORDER BY order_date) AS running_total FROM orders;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `PlayerInfo`\nColumns:\n(`ELITEID`, integer, primary key)\n(`PlayerName`, text)\n(`birthdate`, text)\n(`birthyear`, text)\n(`birthmonth`, integer)\n(`birthday`, integer)\n(`birthplace`, text)\n(`nation`, text)\n(`height`, integer)\n(`weight`, integer)\n(`position_info`, text)\n(`shoots`, text)\n(`draftyear`, integer)\n(`draftround`, integer)\n(`overall`, integer)\n(`overallby`, text)\n(`CSS_rank`, integer)\n(`sum_7yr_GP`, integer)\n(`sum_7yr_TOI`, integer)\n(`GP_greater_than_0`, text)\n",
            "Table: `SeasonStatus`\nColumns:\n(`ELITEID`, integer)\n(`SEASON`, text)\n(`TEAM`, text)\n(`LEAGUE`, text)\n(`GAMETYPE`, text)\n(`GP`, integer)\n(`G`, integer)\n(`A`, integer)\n(`P`, integer)\n(`PIM`, integer)\n(`PLUSMINUS`, integer)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"PlayerInfo\"\nColumns:\n(\"ELITEID\", BIGINT, primary key)\n(\"PlayerName\", STRING)\n(\"birthdate\", STRING)\n(\"birthyear\", STRING)\n(\"birthmonth\", BIGINT)\n(\"birthday\", BIGINT)\n(\"birthplace\", STRING)\n(\"nation\", STRING)\n(\"height\", BIGINT)\n(\"weight\", BIGINT)\n(\"position_info\", STRING)\n(\"shoots\", STRING)\n(\"draftyear\", BIGINT)\n(\"draftround\", BIGINT)\n(\"overall\", BIGINT)\n(\"overallby\", STRING)\n(\"CSS_rank\", BIGINT)\n(\"sum_7yr_GP\", BIGINT)\n(\"sum_7yr_TOI\", BIGINT)\n(\"GP_greater_than_0\", STRING)\n",
            "Table: \"SeasonStatus\"\nColumns:\n(\"ELITEID\", BIGINT)\n(\"SEASON\", STRING)\n(\"TEAM\", STRING)\n(\"LEAGUE\", STRING)\n(\"GAMETYPE\", STRING)\n(\"GP\", BIGINT)\n(\"G\", BIGINT)\n(\"A\", BIGINT)\n(\"P\", BIGINT)\n(\"PIM\", BIGINT)\n(\"PLUSMINUS\", BIGINT)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 508,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT JULIANDAY(EndDate) - JULIANDAY(StartDate) FROM BillOfMaterials ORDER BY JULIANDAY(EndDate) - JULIANDAY(StartDate) DESC LIMIT 1",
        "target_query": "SELECT CAST((2440587.5 + EXTRACT(EPOCH FROM \"EndDate\") / 86400) - (2440587.5 + EXTRACT(EPOCH FROM \"StartDate\") / 86400) AS DOUBLE PRECISION) FROM \"BillOfMaterials\" ORDER BY CAST((2440587.5 + EXTRACT(EPOCH FROM \"EndDate\") / 86400) - (2440587.5 + EXTRACT(EPOCH FROM \"StartDate\") / 86400) AS DOUBLE PRECISION) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 24,
                "dilatect_content": "JULIANDAY(EndDate)",
                "feature": "julianday(time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 28,
                "end_index": 47,
                "dilatect_content": "JULIANDAY(StartDate)",
                "feature": "julianday(time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 79,
                "end_index": 96,
                "dilatect_content": "JULIANDAY(EndDate)",
                "feature": "julianday(time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 100,
                "end_index": 119,
                "dilatect_content": "JULIANDAY(StartDate)",
                "feature": "julianday(time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 12,
                "end_index": 64,
                "dilatect_content": "(2440587.5 + EXTRACT(EPOCH FROM \"EndDate\") / 86400)",
                "feature": "2440587.5 + EXTRACT(EPOCH FROM time-value) / 86400"
            },
            {
                "start_index": 68,
                "end_index": 122,
                "dilatect_content": "(2440587.5 + EXTRACT(EPOCH FROM \"StartDate\") / 86400)",
                "feature": "2440587.5 + EXTRACT(EPOCH FROM time-value) / 86400"
            },
            {
                "start_index": 184,
                "end_index": 236,
                "dilatect_content": "(2440587.5 + EXTRACT(EPOCH FROM \"EndDate\") / 86400)",
                "feature": "2440587.5 + EXTRACT(EPOCH FROM time-value) / 86400"
            },
            {
                "start_index": 240,
                "end_index": 294,
                "dilatect_content": "(2440587.5 + EXTRACT(EPOCH FROM \"StartDate\") / 86400)",
                "feature": "2440587.5 + EXTRACT(EPOCH FROM time-value) / 86400"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "julianday(time-value, modifier, modifier, ...)",
                "explanation": "The julianday(time-value, modifier, modifier, ...) function returns the Julian day number - the fractional number of days since noon in Greenwich on November 24, 4714 B.C. (Proleptic Gregorian calendar). It accepts a time-value and zero or more modifiers.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day').\nReturns: A real number representing the Julian day number.",
                "examples": [
                    "SELECT julianday(); -- Returns the current Julian day number.",
                    "SELECT julianday('2024-08-21'); -- Returns the Julian day number for August 21, 2024.",
                    "SELECT julianday('now', '+1 day'); -- Returns the Julian day number for one day after the current date."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "2440587.5 + EXTRACT(EPOCH FROM time-value) / 86400",
                "explanation": "This expression calculates the Julian day number in MonetDB. It returns the fractional number of days since noon in Greenwich on November 24, 4714 B.C. by converting the input date or timestamp to seconds since the Unix epoch, dividing by 86400 (seconds per day), and adding the Julian base offset 2440587.5.\n\nParameters:\n- time-value: a DATE or TIMESTAMP value.\nReturns: A real number representing the Julian day number.",
                "examples": [
                    "SELECT 2440587.5 + EXTRACT(EPOCH FROM CURRENT_TIMESTAMP) / 86400; -- Returns the current Julian day number.",
                    "SELECT 2440587.5 + EXTRACT(EPOCH FROM DATE '2024-08-21') / 86400; -- Julian day for August 21, 2024.",
                    "SELECT 2440587.5 + EXTRACT(EPOCH FROM TIMESTAMP '2024-08-21 12:00:00') / 86400; -- Julian day with time component."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `BillOfMaterials`\nColumns:\n(`BillOfMaterialsID`, integer, primary key)\n(`ProductAssemblyID`, integer)\n(`ComponentID`, integer)\n(`StartDate`, datetime)\n(`EndDate`, datetime)\n(`UnitMeasureCode`, text)\n(`BOMLevel`, integer)\n(`PerAssemblyQty`, real)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"BillOfMaterials\"\nColumns:\n(\"BillOfMaterialsID\", BIGINT, primary key)\n(\"ProductAssemblyID\", BIGINT)\n(\"ComponentID\", BIGINT)\n(\"StartDate\", TIMESTAMP)\n(\"EndDate\", TIMESTAMP)\n(\"UnitMeasureCode\", STRING)\n(\"BOMLevel\", BIGINT)\n(\"PerAssemblyQty\", DOUBLE PRECISION)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 510,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(CASE WHEN MaritalStatus = 'M' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(BusinessEntityID) FROM Employee WHERE SUBSTR(HireDate, 1, 4) = '2009' AND Gender = 'M'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"MaritalStatus\" = 'M' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"BusinessEntityID\") FROM \"Employee\" WHERE substring(\"HireDate\" from 1 for 4) = '2009' AND \"Gender\" = 'M';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 126,
                "end_index": 147,
                "dilatect_content": "SUBSTR(HireDate, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 138,
                "end_index": 173,
                "dilatect_content": "substring(\"HireDate\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"Employee\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"NationalIDNumber\", STRING)\n(\"LoginID\", STRING)\n(\"OrganizationNode\", STRING)\n(\"OrganizationLevel\", BIGINT)\n(\"JobTitle\", STRING)\n(\"BirthDate\", DATE)\n(\"MaritalStatus\", STRING)\n(\"Gender\", STRING)\n(\"HireDate\", DATE)\n(\"SalariedFlag\", BIGINT)\n(\"VacationHours\", BIGINT)\n(\"SickLeaveHours\", BIGINT)\n(\"CurrentFlag\", BIGINT)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 511,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.CreditRating FROM ProductVendor AS T1 INNER JOIN Vendor AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.StandardPrice = 18.9900 AND T1.AverageLeadTime = 16 AND STRFTIME('%Y-%m-%d', T1.LastReceiptDate) = '2011-08-27'",
        "target_query": "SELECT \"T2\".\"CreditRating\" FROM \"ProductVendor\" AS \"T1\" INNER JOIN \"Vendor\" AS \"T2\" ON \"T1\".\"BusinessEntityID\" = \"T2\".\"BusinessEntityID\" WHERE \"T1\".\"StandardPrice\" = 18.9900 AND \"T1\".\"AverageLeadTime\" = 16 AND sys.timestamp_to_str(\"T1\".\"LastReceiptDate\", '%Y-%m-%d') = '2011-08-27';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 182,
                "end_index": 221,
                "dilatect_content": "STRFTIME('%Y-%m-%d', T1.LastReceiptDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 238,
                "end_index": 297,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"LastReceiptDate\", '%Y-%m-%d')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `ProductVendor`\nColumns:\n(`ProductID`, integer, primary key)\n(`BusinessEntityID`, integer, primary key)\n(`AverageLeadTime`, integer)\n(`StandardPrice`, real)\n(`LastReceiptCost`, real)\n(`LastReceiptDate`, datetime)\n(`MinOrderQty`, integer)\n(`MaxOrderQty`, integer)\n(`OnOrderQty`, integer)\n(`UnitMeasureCode`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `Vendor`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`AccountNumber`, text)\n(`Name`, text)\n(`CreditRating`, integer)\n(`PreferredVendorStatus`, integer)\n(`ActiveFlag`, integer)\n(`PurchasingWebServiceURL`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"ProductVendor\"\nColumns:\n(\"ProductID\", BIGINT, primary key)\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"AverageLeadTime\", BIGINT)\n(\"StandardPrice\", DOUBLE PRECISION)\n(\"LastReceiptCost\", DOUBLE PRECISION)\n(\"LastReceiptDate\", TIMESTAMP)\n(\"MinOrderQty\", BIGINT)\n(\"MaxOrderQty\", BIGINT)\n(\"OnOrderQty\", BIGINT)\n(\"UnitMeasureCode\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"Vendor\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"AccountNumber\", STRING)\n(\"Name\", STRING)\n(\"CreditRating\", BIGINT)\n(\"PreferredVendorStatus\", BIGINT)\n(\"ActiveFlag\", BIGINT)\n(\"PurchasingWebServiceURL\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 512,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T1.ShipMethodID = 5, T3.OrderQty, 0)) AS REAL) / COUNT(T3.ProductID) FROM ShipMethod AS T1 INNER JOIN PurchaseOrderHeader AS T2 ON T1.ShipMethodID = T2.ShipMethodID INNER JOIN PurchaseOrderDetail AS T3 ON T2.PurchaseOrderID = T3.PurchaseOrderID",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T1\".\"ShipMethodID\" = 5 THEN \"T3\".\"OrderQty\" ELSE 0 END) AS REAL) / COUNT(\"T3\".\"ProductID\") FROM \"ShipMethod\" AS \"T1\" INNER JOIN \"PurchaseOrderHeader\" AS \"T2\" ON \"T1\".\"ShipMethodID\" = \"T2\".\"ShipMethodID\" INNER JOIN \"PurchaseOrderDetail\" AS \"T3\" ON \"T2\".\"PurchaseOrderID\" = \"T3\".\"PurchaseOrderID\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 55,
                "dilatect_content": "IIF(T1.ShipMethodID = 5, T3.OrderQty, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 88,
                "dilatect_content": "CASE WHEN \"T1\".\"ShipMethodID\" = 5 THEN \"T3\".\"OrderQty\" ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `ShipMethod`\nColumns:\n(`ShipMethodID`, integer, primary key)\n(`Name`, text)\n(`ShipBase`, real)\n(`ShipRate`, real)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `PurchaseOrderHeader`\nColumns:\n(`PurchaseOrderID`, integer, primary key)\n(`RevisionNumber`, integer)\n(`Status`, integer)\n(`EmployeeID`, integer)\n(`VendorID`, integer)\n(`ShipMethodID`, integer)\n(`OrderDate`, datetime)\n(`ShipDate`, datetime)\n(`SubTotal`, real)\n(`TaxAmt`, real)\n(`Freight`, real)\n(`TotalDue`, real)\n(`ModifiedDate`, datetime)\n",
            "Table: `PurchaseOrderDetail`\nColumns:\n(`PurchaseOrderID`, integer)\n(`PurchaseOrderDetailID`, integer, primary key)\n(`DueDate`, datetime)\n(`OrderQty`, integer)\n(`ProductID`, integer)\n(`UnitPrice`, real)\n(`LineTotal`, real)\n(`ReceivedQty`, real)\n(`RejectedQty`, real)\n(`StockedQty`, real)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"ShipMethod\"\nColumns:\n(\"ShipMethodID\", BIGINT, primary key)\n(\"Name\", STRING)\n(\"ShipBase\", DOUBLE PRECISION)\n(\"ShipRate\", DOUBLE PRECISION)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"PurchaseOrderHeader\"\nColumns:\n(\"PurchaseOrderID\", BIGINT, primary key)\n(\"RevisionNumber\", BIGINT)\n(\"_Status\", BIGINT)\n(\"EmployeeID\", BIGINT)\n(\"VendorID\", BIGINT)\n(\"ShipMethodID\", BIGINT)\n(\"OrderDate\", TIMESTAMP)\n(\"ShipDate\", TIMESTAMP)\n(\"SubTotal\", DOUBLE PRECISION)\n(\"TaxAmt\", DOUBLE PRECISION)\n(\"Freight\", DOUBLE PRECISION)\n(\"TotalDue\", DOUBLE PRECISION)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"PurchaseOrderDetail\"\nColumns:\n(\"PurchaseOrderID\", BIGINT)\n(\"PurchaseOrderDetailID\", BIGINT, primary key)\n(\"DueDate\", TIMESTAMP)\n(\"OrderQty\", BIGINT)\n(\"ProductID\", BIGINT)\n(\"UnitPrice\", DOUBLE PRECISION)\n(\"LineTotal\", DOUBLE PRECISION)\n(\"ReceivedQty\", DOUBLE PRECISION)\n(\"RejectedQty\", DOUBLE PRECISION)\n(\"StockedQty\", DOUBLE PRECISION)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 513,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(T1.city = 'Bothell', 1, 0)) - SUM(IIF(T1.city = 'Kenmore', 1, 0)) , stateprovincecode FROM Address AS T1 INNER JOIN StateProvince AS T2 ON T1.stateprovinceid = T2.stateprovinceid GROUP BY stateprovincecode",
        "target_query": "SELECT SUM(CASE WHEN \"T1\".\"City\" = 'Bothell' THEN 1 ELSE 0 END) - SUM(CASE WHEN \"T1\".\"City\" = 'Kenmore' THEN 1 ELSE 0 END), \"T2\".\"StateProvinceCode\" FROM \"Address\" AS \"T1\" INNER JOIN \"StateProvince\" AS \"T2\" ON \"T1\".\"StateProvinceID\" = \"T2\".\"StateProvinceID\" GROUP BY \"T2\".\"StateProvinceCode\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 40,
                "dilatect_content": "IIF(T1.city = 'Bothell', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 49,
                "end_index": 78,
                "dilatect_content": "IIF(T1.city = 'Kenmore', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 65,
                "dilatect_content": "CASE WHEN \"T1\".\"City\" = 'Bothell' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 74,
                "end_index": 128,
                "dilatect_content": "CASE WHEN \"T1\".\"City\" = 'Kenmore' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Address`\nColumns:\n(`AddressID`, integer, primary key)\n(`AddressLine1`, text)\n(`AddressLine2`, text)\n(`City`, text)\n(`StateProvinceID`, integer)\n(`PostalCode`, text)\n(`SpatialLocation`, text)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `StateProvince`\nColumns:\n(`StateProvinceID`, integer, primary key)\n(`StateProvinceCode`, text)\n(`CountryRegionCode`, text)\n(`IsOnlyStateProvinceFlag`, integer)\n(`Name`, text)\n(`TerritoryID`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"Address\"\nColumns:\n(\"AddressID\", BIGINT, primary key)\n(\"AddressLine1\", STRING)\n(\"AddressLine2\", STRING)\n(\"City\", STRING)\n(\"StateProvinceID\", BIGINT)\n(\"PostalCode\", STRING)\n(\"SpatialLocation\", STRING)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"StateProvince\"\nColumns:\n(\"StateProvinceID\", BIGINT, primary key)\n(\"StateProvinceCode\", STRING)\n(\"CountryRegionCode\", STRING)\n(\"IsOnlyStateProvinceFlag\", BIGINT)\n(\"Name\", STRING)\n(\"TerritoryID\", BIGINT)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 514,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.ListPrice FROM Product AS T1 INNER JOIN ProductListPriceHistory AS T2 ON T1.ProductID = T2.ProductID WHERE T1.ListPrice - T1.StandardCost > 21.9037 AND STRFTIME('%Y-%m-%d', T2.StartDate) >= '2012-10-01'",
        "target_query": "SELECT \"T1\".\"ListPrice\" FROM \"Product\" AS \"T1\" INNER JOIN \"ProductListPriceHistory\" AS \"T2\" ON \"T1\".\"ProductID\" = \"T2\".\"ProductID\" WHERE \"T1\".\"ListPrice\" - \"T1\".\"StandardCost\" > 21.9037 AND sys.timestamp_to_str(\"T2\".\"StartDate\", '%Y-%m-%d') >= '2012-10-01';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 162,
                "end_index": 195,
                "dilatect_content": "STRFTIME('%Y-%m-%d', T2.StartDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 216,
                "end_index": 269,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"StartDate\", '%Y-%m-%d')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Product`\nColumns:\n(`ProductID`, integer, primary key)\n(`Name`, text)\n(`ProductNumber`, text)\n(`MakeFlag`, integer)\n(`FinishedGoodsFlag`, integer)\n(`Color`, text)\n(`SafetyStockLevel`, integer)\n(`ReorderPoint`, integer)\n(`StandardCost`, real)\n(`ListPrice`, real)\n(`Size`, text)\n(`SizeUnitMeasureCode`, text)\n(`WeightUnitMeasureCode`, text)\n(`Weight`, real)\n(`DaysToManufacture`, integer)\n(`ProductLine`, text)\n(`Class`, text)\n(`Style`, text)\n(`ProductSubcategoryID`, integer)\n(`ProductModelID`, integer)\n(`SellStartDate`, datetime)\n(`SellEndDate`, datetime)\n(`DiscontinuedDate`, datetime)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `ProductListPriceHistory`\nColumns:\n(`ProductID`, integer, primary key)\n(`StartDate`, datetime, primary key)\n(`EndDate`, datetime)\n(`ListPrice`, real)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"Product\"\nColumns:\n(\"ProductID\", BIGINT, primary key)\n(\"Name\", STRING)\n(\"ProductNumber\", STRING)\n(\"MakeFlag\", BIGINT)\n(\"FinishedGoodsFlag\", BIGINT)\n(\"Color\", STRING)\n(\"SafetyStockLevel\", BIGINT)\n(\"ReorderPoint\", BIGINT)\n(\"StandardCost\", DOUBLE PRECISION)\n(\"ListPrice\", DOUBLE PRECISION)\n(\"Size\", STRING)\n(\"SizeUnitMeasureCode\", STRING)\n(\"WeightUnitMeasureCode\", STRING)\n(\"Weight\", DOUBLE PRECISION)\n(\"DaysToManufacture\", BIGINT)\n(\"ProductLine\", STRING)\n(\"Class\", STRING)\n(\"Style\", STRING)\n(\"ProductSubcategoryID\", BIGINT)\n(\"ProductModelID\", BIGINT)\n(\"SellStartDate\", TIMESTAMP)\n(\"SellEndDate\", TIMESTAMP)\n(\"DiscontinuedDate\", TIMESTAMP)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"ProductListPriceHistory\"\nColumns:\n(\"ProductID\", BIGINT, primary key)\n(\"StartDate\", TIMESTAMP, primary key)\n(\"EndDate\", TIMESTAMP)\n(\"ListPrice\", DOUBLE PRECISION)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 515,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT LENGTH(T2.PasswordHash) FROM Person AS T1 INNER JOIN Password AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.FirstName = 'Catherine' AND T1.LastName = 'Ward'",
        "target_query": "SELECT length(\"T2\".\"PasswordHash\") FROM \"Person\" AS \"T1\" INNER JOIN \"Password\" AS \"T2\" ON \"T1\".\"BusinessEntityID\" = \"T2\".\"BusinessEntityID\" WHERE \"T1\".\"FirstName\" = 'Catherine' AND \"T1\".\"LastName\" = 'Ward';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 29,
                "dilatect_content": "LENGTH(T2.PasswordHash)",
                "feature": "length(X)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 37,
                "dilatect_content": "length(\"T2\".\"PasswordHash\")",
                "feature": "length(X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "length(X)",
                "explanation": "MonetDB supports the length() function for both string and BLOB values. For a string value X, the function returns the number of characters (code points) in the string. For a BLOB value, it returns the byte-length of the BLOB.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`PersonType`, text)\n(`NameStyle`, integer)\n(`Title`, text)\n(`FirstName`, text)\n(`MiddleName`, text)\n(`LastName`, text)\n(`Suffix`, text)\n(`EmailPromotion`, integer)\n(`AdditionalContactInfo`, text)\n(`Demographics`, text)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `Password`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`PasswordHash`, text)\n(`PasswordSalt`, text)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"Person\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"PersonType\", STRING)\n(\"NameStyle\", BIGINT)\n(\"Title\", STRING)\n(\"FirstName\", STRING)\n(\"MiddleName\", STRING)\n(\"LastName\", STRING)\n(\"Suffix\", STRING)\n(\"EmailPromotion\", BIGINT)\n(\"AdditionalContactInfo\", STRING)\n(\"Demographics\", STRING)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"Password\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"PasswordHash\", STRING)\n(\"PasswordSalt\", STRING)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 516,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.TransactionType FROM TransactionHistory AS T1 INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE T2.Name = 'HL Road Frame - Black, 48' AND STRFTIME('%Y-%m-%d',T1.TransactionDate) = '2013-07-31'",
        "target_query": "SELECT \"T1\".\"TransactionType\" FROM \"TransactionHistory\" AS \"T1\" INNER JOIN \"Product\" AS \"T2\" ON \"T1\".\"ProductID\" = \"T2\".\"ProductID\" WHERE \"T2\".\"Name\" = 'HL Road Frame - Black, 48' AND sys.timestamp_to_str(\"T1\".\"TransactionDate\", '%Y-%m-%d') = '2013-07-31';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 160,
                "end_index": 198,
                "dilatect_content": "STRFTIME('%Y-%m-%d',T1.TransactionDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 208,
                "end_index": 267,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"TransactionDate\", '%Y-%m-%d')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `TransactionHistory`\nColumns:\n(`TransactionID`, integer, primary key)\n(`ProductID`, integer)\n(`ReferenceOrderID`, integer)\n(`ReferenceOrderLineID`, integer)\n(`TransactionDate`, datetime)\n(`TransactionType`, text)\n(`Quantity`, integer)\n(`ActualCost`, real)\n(`ModifiedDate`, datetime)\n",
            "Table: `Product`\nColumns:\n(`ProductID`, integer, primary key)\n(`Name`, text)\n(`ProductNumber`, text)\n(`MakeFlag`, integer)\n(`FinishedGoodsFlag`, integer)\n(`Color`, text)\n(`SafetyStockLevel`, integer)\n(`ReorderPoint`, integer)\n(`StandardCost`, real)\n(`ListPrice`, real)\n(`Size`, text)\n(`SizeUnitMeasureCode`, text)\n(`WeightUnitMeasureCode`, text)\n(`Weight`, real)\n(`DaysToManufacture`, integer)\n(`ProductLine`, text)\n(`Class`, text)\n(`Style`, text)\n(`ProductSubcategoryID`, integer)\n(`ProductModelID`, integer)\n(`SellStartDate`, datetime)\n(`SellEndDate`, datetime)\n(`DiscontinuedDate`, datetime)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"TransactionHistory\"\nColumns:\n(\"TransactionID\", BIGINT, primary key)\n(\"ProductID\", BIGINT)\n(\"ReferenceOrderID\", BIGINT)\n(\"ReferenceOrderLineID\", BIGINT)\n(\"TransactionDate\", TIMESTAMP)\n(\"TransactionType\", STRING)\n(\"Quantity\", BIGINT)\n(\"ActualCost\", DOUBLE PRECISION)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"Product\"\nColumns:\n(\"ProductID\", BIGINT, primary key)\n(\"Name\", STRING)\n(\"ProductNumber\", STRING)\n(\"MakeFlag\", BIGINT)\n(\"FinishedGoodsFlag\", BIGINT)\n(\"Color\", STRING)\n(\"SafetyStockLevel\", BIGINT)\n(\"ReorderPoint\", BIGINT)\n(\"StandardCost\", DOUBLE PRECISION)\n(\"ListPrice\", DOUBLE PRECISION)\n(\"Size\", STRING)\n(\"SizeUnitMeasureCode\", STRING)\n(\"WeightUnitMeasureCode\", STRING)\n(\"Weight\", DOUBLE PRECISION)\n(\"DaysToManufacture\", BIGINT)\n(\"ProductLine\", STRING)\n(\"Class\", STRING)\n(\"Style\", STRING)\n(\"ProductSubcategoryID\", BIGINT)\n(\"ProductModelID\", BIGINT)\n(\"SellStartDate\", TIMESTAMP)\n(\"SellEndDate\", TIMESTAMP)\n(\"DiscontinuedDate\", TIMESTAMP)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 517,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.TransactionType FROM TransactionHistoryArchive AS T1 INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE T2.Name = 'LL Road Handlebars' AND STRFTIME('%Y-%m-%d',T1.TransactionDate) = '2012-11-03'",
        "target_query": "SELECT \"T1\".\"TransactionType\" FROM \"TransactionHistoryArchive\" AS \"T1\" INNER JOIN \"Product\" AS \"T2\" ON \"T1\".\"ProductID\" = \"T2\".\"ProductID\" WHERE \"T2\".\"Name\" = 'LL Road Handlebars' AND sys.timestamp_to_str(\"T1\".\"TransactionDate\", '%Y-%m-%d') = '2012-11-03';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 160,
                "end_index": 198,
                "dilatect_content": "STRFTIME('%Y-%m-%d',T1.TransactionDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 208,
                "end_index": 267,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"TransactionDate\", '%Y-%m-%d')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `TransactionHistoryArchive`\nColumns:\n(`TransactionID`, integer, primary key)\n(`ProductID`, integer)\n(`ReferenceOrderID`, integer)\n(`ReferenceOrderLineID`, integer)\n(`TransactionDate`, datetime)\n(`TransactionType`, text)\n(`Quantity`, integer)\n(`ActualCost`, real)\n(`ModifiedDate`, datetime)\n",
            "Table: `Product`\nColumns:\n(`ProductID`, integer, primary key)\n(`Name`, text)\n(`ProductNumber`, text)\n(`MakeFlag`, integer)\n(`FinishedGoodsFlag`, integer)\n(`Color`, text)\n(`SafetyStockLevel`, integer)\n(`ReorderPoint`, integer)\n(`StandardCost`, real)\n(`ListPrice`, real)\n(`Size`, text)\n(`SizeUnitMeasureCode`, text)\n(`WeightUnitMeasureCode`, text)\n(`Weight`, real)\n(`DaysToManufacture`, integer)\n(`ProductLine`, text)\n(`Class`, text)\n(`Style`, text)\n(`ProductSubcategoryID`, integer)\n(`ProductModelID`, integer)\n(`SellStartDate`, datetime)\n(`SellEndDate`, datetime)\n(`DiscontinuedDate`, datetime)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"TransactionHistoryArchive\"\nColumns:\n(\"TransactionID\", BIGINT, primary key)\n(\"ProductID\", BIGINT)\n(\"ReferenceOrderID\", BIGINT)\n(\"ReferenceOrderLineID\", BIGINT)\n(\"TransactionDate\", TIMESTAMP)\n(\"TransactionType\", STRING)\n(\"Quantity\", BIGINT)\n(\"ActualCost\", DOUBLE PRECISION)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"Product\"\nColumns:\n(\"ProductID\", BIGINT, primary key)\n(\"Name\", STRING)\n(\"ProductNumber\", STRING)\n(\"MakeFlag\", BIGINT)\n(\"FinishedGoodsFlag\", BIGINT)\n(\"Color\", STRING)\n(\"SafetyStockLevel\", BIGINT)\n(\"ReorderPoint\", BIGINT)\n(\"StandardCost\", DOUBLE PRECISION)\n(\"ListPrice\", DOUBLE PRECISION)\n(\"Size\", STRING)\n(\"SizeUnitMeasureCode\", STRING)\n(\"WeightUnitMeasureCode\", STRING)\n(\"Weight\", DOUBLE PRECISION)\n(\"DaysToManufacture\", BIGINT)\n(\"ProductLine\", STRING)\n(\"Class\", STRING)\n(\"Style\", STRING)\n(\"ProductSubcategoryID\", BIGINT)\n(\"ProductModelID\", BIGINT)\n(\"SellStartDate\", TIMESTAMP)\n(\"SellEndDate\", TIMESTAMP)\n(\"DiscontinuedDate\", TIMESTAMP)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 518,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT BusinessEntityID FROM SalesPerson WHERE BusinessEntityID IN ( SELECT BusinessEntityID FROM SalesPersonQuotaHistory WHERE STRFTIME('%Y', QuotaDate) = '2013' ) ORDER BY CAST(SalesLastYear AS REAL) / SalesQuota DESC LIMIT 1",
        "target_query": "SELECT \"BusinessEntityID\" FROM \"SalesPerson\" WHERE \"BusinessEntityID\" IN ( SELECT \"BusinessEntityID\" FROM \"SalesPersonQuotaHistory\" WHERE sys.timestamp_to_str(\"QuotaDate\", '%Y') = '2013' ) ORDER BY CAST(\"SalesLastYear\" AS REAL) / \"SalesQuota\" DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 128,
                "end_index": 152,
                "dilatect_content": "STRFTIME('%Y', QuotaDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 148,
                "end_index": 188,
                "dilatect_content": "sys.timestamp_to_str(\"QuotaDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `SalesPerson`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`TerritoryID`, integer)\n(`SalesQuota`, real)\n(`Bonus`, real)\n(`CommissionPct`, real)\n(`SalesYTD`, real)\n(`SalesLastYear`, real)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `SalesPersonQuotaHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`QuotaDate`, datetime, primary key)\n(`SalesQuota`, real)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"SalesPerson\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"TerritoryID\", BIGINT)\n(\"SalesQuota\", DOUBLE PRECISION)\n(\"Bonus\", DOUBLE PRECISION)\n(\"CommissionPct\", DOUBLE PRECISION)\n(\"SalesYTD\", DOUBLE PRECISION)\n(\"SalesLastYear\", DOUBLE PRECISION)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"SalesPersonQuotaHistory\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"QuotaDate\", TIMESTAMP, primary key)\n(\"SalesQuota\", DOUBLE PRECISION)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 519,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T1.BusinessEntityID) FROM Employee AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T2.PersonType = 'SP' AND SUBSTR(T1.HireDate, 0, 4) < 2010",
        "target_query": "SELECT COUNT(\"T1\".\"BusinessEntityID\") FROM \"Employee\" AS \"T1\" INNER JOIN \"Person\" AS \"T2\" ON \"T1\".\"BusinessEntityID\" = \"T2\".\"BusinessEntityID\" WHERE \"T2\".\"PersonType\" = 'SP' AND substring(\"T1\".\"HireDate\" from 1 for 4) < '2010';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 154,
                "end_index": 178,
                "dilatect_content": "SUBSTR(T1.HireDate, 0, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 202,
                "end_index": 244,
                "dilatect_content": "substring(\"T1\".\"HireDate\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`PersonType`, text)\n(`NameStyle`, integer)\n(`Title`, text)\n(`FirstName`, text)\n(`MiddleName`, text)\n(`LastName`, text)\n(`Suffix`, text)\n(`EmailPromotion`, integer)\n(`AdditionalContactInfo`, text)\n(`Demographics`, text)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"Employee\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"NationalIDNumber\", STRING)\n(\"LoginID\", STRING)\n(\"OrganizationNode\", STRING)\n(\"OrganizationLevel\", BIGINT)\n(\"JobTitle\", STRING)\n(\"BirthDate\", DATE)\n(\"MaritalStatus\", STRING)\n(\"Gender\", STRING)\n(\"HireDate\", DATE)\n(\"SalariedFlag\", BIGINT)\n(\"VacationHours\", BIGINT)\n(\"SickLeaveHours\", BIGINT)\n(\"CurrentFlag\", BIGINT)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"Person\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"PersonType\", STRING)\n(\"NameStyle\", BIGINT)\n(\"Title\", STRING)\n(\"FirstName\", STRING)\n(\"MiddleName\", STRING)\n(\"LastName\", STRING)\n(\"Suffix\", STRING)\n(\"EmailPromotion\", BIGINT)\n(\"AdditionalContactInfo\", STRING)\n(\"Demographics\", STRING)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 520,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.BusinessEntityID, SUM(T1.SalesQuota) FROM SalesPerson AS T1 INNER JOIN SalesPersonQuotaHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE STRFTIME('%Y', T2.QuotaDate) = '2011' GROUP BY T1.BusinessEntityID ORDER BY SUM(T1.SalesYTD) DESC LIMIT 1",
        "target_query": "SELECT \"T1\".\"BusinessEntityID\", SUM(\"T1\".\"SalesQuota\") FROM \"SalesPerson\" AS \"T1\" INNER JOIN \"SalesPersonQuotaHistory\" AS \"T2\" ON \"T1\".\"BusinessEntityID\" = \"T2\".\"BusinessEntityID\" WHERE sys.timestamp_to_str(\"T2\".\"QuotaDate\", '%Y') = '2011' GROUP BY \"T1\".\"BusinessEntityID\" ORDER BY SUM(\"T1\".\"SalesYTD\") DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 162,
                "end_index": 189,
                "dilatect_content": "STRFTIME('%Y', T2.QuotaDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 210,
                "end_index": 257,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"QuotaDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `SalesPerson`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`TerritoryID`, integer)\n(`SalesQuota`, real)\n(`Bonus`, real)\n(`CommissionPct`, real)\n(`SalesYTD`, real)\n(`SalesLastYear`, real)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `SalesPersonQuotaHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`QuotaDate`, datetime, primary key)\n(`SalesQuota`, real)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"SalesPerson\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"TerritoryID\", BIGINT)\n(\"SalesQuota\", DOUBLE PRECISION)\n(\"Bonus\", DOUBLE PRECISION)\n(\"CommissionPct\", DOUBLE PRECISION)\n(\"SalesYTD\", DOUBLE PRECISION)\n(\"SalesLastYear\", DOUBLE PRECISION)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"SalesPersonQuotaHistory\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"QuotaDate\", TIMESTAMP, primary key)\n(\"SalesQuota\", DOUBLE PRECISION)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 521,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT T1.BusinessEntityID FROM SalesPerson AS T1 INNER JOIN SalesPersonQuotaHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.TerritoryID = 1 AND STRFTIME('%Y', QuotaDate) = '2013'",
        "target_query": "SELECT DISTINCT \"T1\".\"BusinessEntityID\" FROM \"SalesPerson\" AS \"T1\" INNER JOIN \"SalesPersonQuotaHistory\" AS \"T2\" ON \"T1\".\"BusinessEntityID\" = \"T2\".\"BusinessEntityID\" WHERE \"T1\".\"TerritoryID\" = 1 AND sys.timestamp_to_str(\"T2\".\"QuotaDate\", '%Y') = '2013';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 174,
                "end_index": 198,
                "dilatect_content": "STRFTIME('%Y', QuotaDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 222,
                "end_index": 269,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"QuotaDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `SalesPerson`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`TerritoryID`, integer)\n(`SalesQuota`, real)\n(`Bonus`, real)\n(`CommissionPct`, real)\n(`SalesYTD`, real)\n(`SalesLastYear`, real)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `SalesPersonQuotaHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`QuotaDate`, datetime, primary key)\n(`SalesQuota`, real)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"SalesPerson\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"TerritoryID\", BIGINT)\n(\"SalesQuota\", DOUBLE PRECISION)\n(\"Bonus\", DOUBLE PRECISION)\n(\"CommissionPct\", DOUBLE PRECISION)\n(\"SalesYTD\", DOUBLE PRECISION)\n(\"SalesLastYear\", DOUBLE PRECISION)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"SalesPersonQuotaHistory\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"QuotaDate\", TIMESTAMP, primary key)\n(\"SalesQuota\", DOUBLE PRECISION)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 522,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(T1.SalesQuota) FROM SalesPerson AS T1 INNER JOIN SalesPersonQuotaHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.BusinessEntityID = 275 AND STRFTIME('%Y', QuotaDate) = '2013'",
        "target_query": "SELECT SUM(\"T1\".\"SalesQuota\") FROM \"SalesPerson\" AS \"T1\" INNER JOIN \"SalesPersonQuotaHistory\" AS \"T2\" ON \"T1\".\"BusinessEntityID\" = \"T2\".\"BusinessEntityID\" WHERE \"T1\".\"BusinessEntityID\" = 275 AND sys.timestamp_to_str(\"T2\".\"QuotaDate\", '%Y') = '2013';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 171,
                "end_index": 195,
                "dilatect_content": "STRFTIME('%Y', QuotaDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 219,
                "end_index": 257,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"QuotaDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `SalesPerson`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`TerritoryID`, integer)\n(`SalesQuota`, real)\n(`Bonus`, real)\n(`CommissionPct`, real)\n(`SalesYTD`, real)\n(`SalesLastYear`, real)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `SalesPersonQuotaHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`QuotaDate`, datetime, primary key)\n(`SalesQuota`, real)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"SalesPerson\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"TerritoryID\", BIGINT)\n(\"SalesQuota\", DOUBLE PRECISION)\n(\"Bonus\", DOUBLE PRECISION)\n(\"CommissionPct\", DOUBLE PRECISION)\n(\"SalesYTD\", DOUBLE PRECISION)\n(\"SalesLastYear\", DOUBLE PRECISION)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"SalesPersonQuotaHistory\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"QuotaDate\", TIMESTAMP, primary key)\n(\"SalesQuota\", DOUBLE PRECISION)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 523,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT T1.BusinessEntityID FROM SalesPerson AS T1 INNER JOIN SalesPersonQuotaHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE STRFTIME('%Y', T2.QuotaDate) = '2013' AND T1.SalesQuota < T1.SalesLastYear",
        "target_query": "SELECT DISTINCT \"T1\".\"BusinessEntityID\" FROM \"SalesPerson\" AS \"T1\" INNER JOIN \"SalesPersonQuotaHistory\" AS \"T2\" ON \"T1\".\"BusinessEntityID\" = \"T2\".\"BusinessEntityID\" WHERE sys.timestamp_to_str(\"T2\".\"QuotaDate\", '%Y') = '2013' AND \"T1\".\"SalesQuota\" < \"T1\".\"SalesLastYear\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 151,
                "end_index": 178,
                "dilatect_content": "STRFTIME('%Y', T2.QuotaDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 191,
                "end_index": 238,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"QuotaDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `SalesPerson`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`TerritoryID`, integer)\n(`SalesQuota`, real)\n(`Bonus`, real)\n(`CommissionPct`, real)\n(`SalesYTD`, real)\n(`SalesLastYear`, real)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `SalesPersonQuotaHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`QuotaDate`, datetime, primary key)\n(`SalesQuota`, real)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"SalesPerson\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"TerritoryID\", BIGINT)\n(\"SalesQuota\", DOUBLE PRECISION)\n(\"Bonus\", DOUBLE PRECISION)\n(\"CommissionPct\", DOUBLE PRECISION)\n(\"SalesYTD\", DOUBLE PRECISION)\n(\"SalesLastYear\", DOUBLE PRECISION)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"SalesPersonQuotaHistory\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"QuotaDate\", TIMESTAMP, primary key)\n(\"SalesQuota\", DOUBLE PRECISION)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 524,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(T1.Bonus) , CAST(SUM(T1.Bonus) AS REAL) * 100 / SUM(T1.SalesQuota) FROM SalesPerson AS T1 INNER JOIN SalesPersonQuotaHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE STRFTIME('%Y', T2.QuotaDate) = '2013'",
        "target_query": "SELECT SUM(\"T1\".\"Bonus\"), CAST(SUM(\"T1\".\"Bonus\") AS REAL) * 100 / SUM(\"T1\".\"SalesQuota\") FROM \"SalesPerson\" AS \"T1\" INNER JOIN \"SalesPersonQuotaHistory\" AS \"T2\" ON \"T1\".\"BusinessEntityID\" = \"T2\".\"BusinessEntityID\" WHERE sys.timestamp_to_str(\"T2\".\"QuotaDate\", '%Y') = '2013';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 193,
                "end_index": 220,
                "dilatect_content": "STRFTIME('%Y', T2.QuotaDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 248,
                "end_index": 295,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"QuotaDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `SalesPerson`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`TerritoryID`, integer)\n(`SalesQuota`, real)\n(`Bonus`, real)\n(`CommissionPct`, real)\n(`SalesYTD`, real)\n(`SalesLastYear`, real)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `SalesPersonQuotaHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`QuotaDate`, datetime, primary key)\n(`SalesQuota`, real)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"SalesPerson\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"TerritoryID\", BIGINT)\n(\"SalesQuota\", DOUBLE PRECISION)\n(\"Bonus\", DOUBLE PRECISION)\n(\"CommissionPct\", DOUBLE PRECISION)\n(\"SalesYTD\", DOUBLE PRECISION)\n(\"SalesLastYear\", DOUBLE PRECISION)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"SalesPersonQuotaHistory\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"QuotaDate\", TIMESTAMP, primary key)\n(\"SalesQuota\", DOUBLE PRECISION)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 525,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.Rate FROM Employee AS T1 INNER JOIN EmployeePayHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE STRFTIME('%Y', T1.HireDate) - STRFTIME('%Y', T1.BirthDate) = 20",
        "target_query": "SELECT \"T2\".\"Rate\" FROM \"Employee\" AS \"T1\" INNER JOIN \"EmployeePayHistory\" AS \"T2\" ON \"T1\".\"BusinessEntityID\" = \"T2\".\"BusinessEntityID\" WHERE (CAST(sys.timestamp_to_str(\"T1\".\"HireDate\", '%Y') AS INTEGER) - CAST(sys.timestamp_to_str(\"T1\".\"BirthDate\", '%Y') AS INTEGER)) = 20;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 122,
                "end_index": 148,
                "dilatect_content": "STRFTIME('%Y', T1.HireDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 152,
                "end_index": 179,
                "dilatect_content": "STRFTIME('%Y', T1.BirthDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 168,
                "end_index": 214,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"HireDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 235,
                "end_index": 282,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"BirthDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `EmployeePayHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`RateChangeDate`, datetime, primary key)\n(`Rate`, real)\n(`PayFrequency`, integer)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"Employee\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"NationalIDNumber\", STRING)\n(\"LoginID\", STRING)\n(\"OrganizationNode\", STRING)\n(\"OrganizationLevel\", BIGINT)\n(\"JobTitle\", STRING)\n(\"BirthDate\", DATE)\n(\"MaritalStatus\", STRING)\n(\"Gender\", STRING)\n(\"HireDate\", DATE)\n(\"SalariedFlag\", BIGINT)\n(\"VacationHours\", BIGINT)\n(\"SickLeaveHours\", BIGINT)\n(\"CurrentFlag\", BIGINT)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"EmployeePayHistory\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"RateChangeDate\", TIMESTAMP, primary key)\n(\"Rate\", DOUBLE PRECISION)\n(\"PayFrequency\", BIGINT)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 526,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(BusinessEntityID) FROM Employee WHERE MaritalStatus = 'M' AND STRFTIME('%Y', BirthDate) < '1960' AND Gender = 'M'",
        "target_query": "SELECT COUNT(\"BusinessEntityID\") FROM \"Employee\" WHERE \"MaritalStatus\" = 'M' AND sys.timestamp_to_str(\"BirthDate\", '%Y') < '1960' AND \"Gender\" = 'M';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 75,
                "end_index": 99,
                "dilatect_content": "STRFTIME('%Y', BirthDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 87,
                "end_index": 127,
                "dilatect_content": "sys.timestamp_to_str(\"BirthDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"Employee\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"NationalIDNumber\", STRING)\n(\"LoginID\", STRING)\n(\"OrganizationNode\", STRING)\n(\"OrganizationLevel\", BIGINT)\n(\"JobTitle\", STRING)\n(\"BirthDate\", DATE)\n(\"MaritalStatus\", STRING)\n(\"Gender\", STRING)\n(\"HireDate\", DATE)\n(\"SalariedFlag\", BIGINT)\n(\"VacationHours\", BIGINT)\n(\"SickLeaveHours\", BIGINT)\n(\"CurrentFlag\", BIGINT)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 528,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T3.Name) FROM Person AS T1 INNER JOIN EmployeeDepartmentHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Department AS T3 ON T2.DepartmentID = T3.DepartmentID WHERE T1.FirstName = 'Sheela' AND T1.LastName = 'Word' AND STRFTIME('%Y', T3.ModifiedDate) BETWEEN '2011' AND '2012'",
        "target_query": "SELECT COUNT(\"T3\".\"Name\") FROM \"Person\" AS \"T1\" INNER JOIN \"EmployeeDepartmentHistory\" AS \"T2\" ON \"T1\".\"BusinessEntityID\" = \"T2\".\"BusinessEntityID\" INNER JOIN \"Department\" AS \"T3\" ON \"T2\".\"DepartmentID\" = \"T3\".\"DepartmentID\" WHERE \"T1\".\"FirstName\" = 'Sheela' AND \"T1\".\"LastName\" = 'Word' AND sys.timestamp_to_str(\"T3\".\"ModifiedDate\", '%Y') BETWEEN '2011' AND '2012';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 252,
                "end_index": 282,
                "dilatect_content": "STRFTIME('%Y', T3.ModifiedDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 332,
                "end_index": 382,
                "dilatect_content": "sys.timestamp_to_str(\"T3\".\"ModifiedDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`PersonType`, text)\n(`NameStyle`, integer)\n(`Title`, text)\n(`FirstName`, text)\n(`MiddleName`, text)\n(`LastName`, text)\n(`Suffix`, text)\n(`EmailPromotion`, integer)\n(`AdditionalContactInfo`, text)\n(`Demographics`, text)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `EmployeeDepartmentHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`DepartmentID`, integer, primary key)\n(`ShiftID`, integer, primary key)\n(`StartDate`, date, primary key)\n(`EndDate`, date)\n(`ModifiedDate`, datetime)\n",
            "Table: `Department`\nColumns:\n(`DepartmentID`, integer, primary key)\n(`Name`, text)\n(`GroupName`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"Person\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"PersonType\", STRING)\n(\"NameStyle\", BIGINT)\n(\"Title\", STRING)\n(\"FirstName\", STRING)\n(\"MiddleName\", STRING)\n(\"LastName\", STRING)\n(\"Suffix\", STRING)\n(\"EmailPromotion\", BIGINT)\n(\"AdditionalContactInfo\", STRING)\n(\"Demographics\", STRING)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"EmployeeDepartmentHistory\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"DepartmentID\", BIGINT, primary key)\n(\"ShiftID\", BIGINT, primary key)\n(\"StartDate\", DATE, primary key)\n(\"EndDate\", DATE)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"Department\"\nColumns:\n(\"DepartmentID\", BIGINT, primary key)\n(\"Name\", STRING)\n(\"GroupName\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 529,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT AVG(2009 - STRFTIME('%Y', T2.BirthDate)) FROM Person AS T1 INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.PersonType = 'SP'",
        "target_query": "SELECT AVG(2009 - CAST(sys.timestamp_to_str(\"T2\".\"BirthDate\", '%Y') AS INTEGER)) FROM \"Person\" AS \"T1\" INNER JOIN \"Employee\" AS \"T2\" ON \"T1\".\"BusinessEntityID\" = \"T2\".\"BusinessEntityID\" WHERE \"T1\".\"PersonType\" = 'SP';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 18,
                "end_index": 45,
                "dilatect_content": "STRFTIME('%Y', T2.BirthDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 23,
                "end_index": 70,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"BirthDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`PersonType`, text)\n(`NameStyle`, integer)\n(`Title`, text)\n(`FirstName`, text)\n(`MiddleName`, text)\n(`LastName`, text)\n(`Suffix`, text)\n(`EmailPromotion`, integer)\n(`AdditionalContactInfo`, text)\n(`Demographics`, text)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"Person\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"PersonType\", STRING)\n(\"NameStyle\", BIGINT)\n(\"Title\", STRING)\n(\"FirstName\", STRING)\n(\"MiddleName\", STRING)\n(\"LastName\", STRING)\n(\"Suffix\", STRING)\n(\"EmailPromotion\", BIGINT)\n(\"AdditionalContactInfo\", STRING)\n(\"Demographics\", STRING)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"Employee\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"NationalIDNumber\", STRING)\n(\"LoginID\", STRING)\n(\"OrganizationNode\", STRING)\n(\"OrganizationLevel\", BIGINT)\n(\"JobTitle\", STRING)\n(\"BirthDate\", DATE)\n(\"MaritalStatus\", STRING)\n(\"Gender\", STRING)\n(\"HireDate\", DATE)\n(\"SalariedFlag\", BIGINT)\n(\"VacationHours\", BIGINT)\n(\"SickLeaveHours\", BIGINT)\n(\"CurrentFlag\", BIGINT)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 530,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT 2015 - STRFTIME('%Y', T1.BirthDate), T2.Rate FROM Employee AS T1 INNER JOIN EmployeePayHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.JobTitle = 'Marketing Specialist' ORDER BY 2015 - STRFTIME('%Y', T1.BirthDate) DESC LIMIT 1",
        "target_query": "SELECT 2015 - CAST(sys.timestamp_to_str(\"T1\".\"BirthDate\", '%Y') AS INTEGER), \"T2\".\"Rate\" FROM \"Employee\" AS \"T1\" INNER JOIN \"EmployeePayHistory\" AS \"T2\" ON \"T1\".\"BusinessEntityID\" = \"T2\".\"BusinessEntityID\" WHERE \"T1\".\"JobTitle\" = 'Marketing Specialist' ORDER BY 2015 - CAST(sys.timestamp_to_str(\"T1\".\"BirthDate\", '%Y') AS INTEGER) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 14,
                "end_index": 41,
                "dilatect_content": "STRFTIME('%Y', T1.BirthDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 212,
                "end_index": 239,
                "dilatect_content": "STRFTIME('%Y', T1.BirthDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 19,
                "end_index": 66,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"BirthDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 302,
                "end_index": 349,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"BirthDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `EmployeePayHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`RateChangeDate`, datetime, primary key)\n(`Rate`, real)\n(`PayFrequency`, integer)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"Employee\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"NationalIDNumber\", STRING)\n(\"LoginID\", STRING)\n(\"OrganizationNode\", STRING)\n(\"OrganizationLevel\", BIGINT)\n(\"JobTitle\", STRING)\n(\"BirthDate\", DATE)\n(\"MaritalStatus\", STRING)\n(\"Gender\", STRING)\n(\"HireDate\", DATE)\n(\"SalariedFlag\", BIGINT)\n(\"VacationHours\", BIGINT)\n(\"SickLeaveHours\", BIGINT)\n(\"CurrentFlag\", BIGINT)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"EmployeePayHistory\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"RateChangeDate\", TIMESTAMP, primary key)\n(\"Rate\", DOUBLE PRECISION)\n(\"PayFrequency\", BIGINT)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 531,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.BusinessEntityID, STRFTIME('%Y', T2.HireDate) - STRFTIME('%Y', T2.BirthDate) FROM PurchaseOrderHeader AS T1 INNER JOIN Employee AS T2 ON T1.EmployeeID = T2.BusinessEntityID ORDER BY T1.TotalDue DESC LIMIT 1",
        "target_query": "SELECT \"T2\".\"BusinessEntityID\", EXTRACT(YEAR FROM \"T2\".\"HireDate\") - EXTRACT(YEAR FROM \"T2\".\"BirthDate\") FROM \"PurchaseOrderHeader\" AS \"T1\" INNER JOIN \"Employee\" AS \"T2\" ON \"T1\".\"EmployeeID\" = \"T2\".\"BusinessEntityID\" ORDER BY \"T1\".\"TotalDue\" DESC FETCH FIRST 1 ROWS ONLY;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 28,
                "end_index": 54,
                "dilatect_content": "STRFTIME('%Y', T2.HireDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 58,
                "end_index": 85,
                "dilatect_content": "STRFTIME('%Y', T2.BirthDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 44,
                "end_index": 72,
                "dilatect_content": "YEAR FROM \"T2\".\"HireDate\"",
                "feature": ""
            },
            {
                "start_index": 85,
                "end_index": 114,
                "dilatect_content": "YEAR FROM \"T2\".\"BirthDate\"",
                "feature": ""
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `PurchaseOrderHeader`\nColumns:\n(`PurchaseOrderID`, integer, primary key)\n(`RevisionNumber`, integer)\n(`Status`, integer)\n(`EmployeeID`, integer)\n(`VendorID`, integer)\n(`ShipMethodID`, integer)\n(`OrderDate`, datetime)\n(`ShipDate`, datetime)\n(`SubTotal`, real)\n(`TaxAmt`, real)\n(`Freight`, real)\n(`TotalDue`, real)\n(`ModifiedDate`, datetime)\n",
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"PurchaseOrderHeader\"\nColumns:\n(\"PurchaseOrderID\", BIGINT, primary key)\n(\"RevisionNumber\", BIGINT)\n(\"_Status\", BIGINT)\n(\"EmployeeID\", BIGINT)\n(\"VendorID\", BIGINT)\n(\"ShipMethodID\", BIGINT)\n(\"OrderDate\", TIMESTAMP)\n(\"ShipDate\", TIMESTAMP)\n(\"SubTotal\", DOUBLE PRECISION)\n(\"TaxAmt\", DOUBLE PRECISION)\n(\"Freight\", DOUBLE PRECISION)\n(\"TotalDue\", DOUBLE PRECISION)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"Employee\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"NationalIDNumber\", STRING)\n(\"LoginID\", STRING)\n(\"OrganizationNode\", STRING)\n(\"OrganizationLevel\", BIGINT)\n(\"JobTitle\", STRING)\n(\"BirthDate\", DATE)\n(\"MaritalStatus\", STRING)\n(\"Gender\", STRING)\n(\"HireDate\", DATE)\n(\"SalariedFlag\", BIGINT)\n(\"VacationHours\", BIGINT)\n(\"SickLeaveHours\", BIGINT)\n(\"CurrentFlag\", BIGINT)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 532,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT 2011 - STRFTIME('%Y', T2.HireDate) FROM Document AS T1 INNER JOIN Employee AS T2 ON T1.Owner = T2.BusinessEntityID WHERE T1.Status = 1",
        "target_query": "SELECT 2011 - CAST(sys.timestamp_to_str(\"T2\".\"HireDate\", '%Y') AS INTEGER) FROM \"Document\" AS \"T1\" INNER JOIN \"Employee\" AS \"T2\" ON \"T1\".\"Owner\" = \"T2\".\"BusinessEntityID\" WHERE \"T1\".\"_Status\" = 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 14,
                "end_index": 40,
                "dilatect_content": "STRFTIME('%Y', T2.HireDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 19,
                "end_index": 65,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"HireDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Document`\nColumns:\n(`DocumentNode`, text, primary key)\n(`DocumentLevel`, integer)\n(`Title`, text)\n(`Owner`, integer)\n(`FolderFlag`, integer)\n(`FileName`, text)\n(`FileExtension`, text)\n(`Revision`, text)\n(`ChangeNumber`, integer)\n(`Status`, integer)\n(`DocumentSummary`, text)\n(`Document`, blob)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"Document\"\nColumns:\n(\"DocumentNode\", STRING, primary key)\n(\"DocumentLevel\", BIGINT)\n(\"Title\", STRING)\n(\"Owner\", BIGINT)\n(\"FolderFlag\", BIGINT)\n(\"FileName\", STRING)\n(\"FileExtension\", STRING)\n(\"Revision\", STRING)\n(\"ChangeNumber\", BIGINT)\n(\"_Status\", BIGINT)\n(\"DocumentSummary\", STRING)\n(\"Document\", BLOB)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"Employee\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"NationalIDNumber\", STRING)\n(\"LoginID\", STRING)\n(\"OrganizationNode\", STRING)\n(\"OrganizationLevel\", BIGINT)\n(\"JobTitle\", STRING)\n(\"BirthDate\", DATE)\n(\"MaritalStatus\", STRING)\n(\"Gender\", STRING)\n(\"HireDate\", DATE)\n(\"SalariedFlag\", BIGINT)\n(\"VacationHours\", BIGINT)\n(\"SickLeaveHours\", BIGINT)\n(\"CurrentFlag\", BIGINT)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 533,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.FirstName, T2.MiddleName, T2.LastName FROM Employee AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID ORDER BY STRFTIME('%Y', T1.HireDate) - STRFTIME('%Y', T1.BirthDate) DESC LIMIT 1, 1",
        "target_query": "SELECT \"T2\".\"FirstName\", \"T2\".\"MiddleName\", \"T2\".\"LastName\" FROM \"Employee\" AS \"T1\" INNER JOIN \"Person\" AS \"T2\" ON \"T1\".\"BusinessEntityID\" = \"T2\".\"BusinessEntityID\" ORDER BY EXTRACT(YEAR FROM \"T1\".\"HireDate\") - EXTRACT(YEAR FROM \"T1\".\"BirthDate\") DESC LIMIT 1 OFFSET 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 146,
                "end_index": 172,
                "dilatect_content": "STRFTIME('%Y', T1.HireDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 176,
                "end_index": 203,
                "dilatect_content": "STRFTIME('%Y', T1.BirthDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 210,
                "end_index": 238,
                "dilatect_content": "YEAR FROM \"T1\".\"HireDate\"",
                "feature": ""
            },
            {
                "start_index": 251,
                "end_index": 280,
                "dilatect_content": "YEAR FROM \"T1\".\"BirthDate\"",
                "feature": ""
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`PersonType`, text)\n(`NameStyle`, integer)\n(`Title`, text)\n(`FirstName`, text)\n(`MiddleName`, text)\n(`LastName`, text)\n(`Suffix`, text)\n(`EmailPromotion`, integer)\n(`AdditionalContactInfo`, text)\n(`Demographics`, text)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"Employee\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"NationalIDNumber\", STRING)\n(\"LoginID\", STRING)\n(\"OrganizationNode\", STRING)\n(\"OrganizationLevel\", BIGINT)\n(\"JobTitle\", STRING)\n(\"BirthDate\", DATE)\n(\"MaritalStatus\", STRING)\n(\"Gender\", STRING)\n(\"HireDate\", DATE)\n(\"SalariedFlag\", BIGINT)\n(\"VacationHours\", BIGINT)\n(\"SickLeaveHours\", BIGINT)\n(\"CurrentFlag\", BIGINT)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"Person\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"PersonType\", STRING)\n(\"NameStyle\", BIGINT)\n(\"Title\", STRING)\n(\"FirstName\", STRING)\n(\"MiddleName\", STRING)\n(\"LastName\", STRING)\n(\"Suffix\", STRING)\n(\"EmailPromotion\", BIGINT)\n(\"AdditionalContactInfo\", STRING)\n(\"Demographics\", STRING)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 534,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.FirstName, T1.LastName FROM Person AS T1 INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE STRFTIME('%Y', T2.HireDate) >= '2007' AND T2.SalariedFlag = 1",
        "target_query": "SELECT \"T1\".\"FirstName\", \"T1\".\"LastName\" FROM \"Person\" AS \"T1\" INNER JOIN \"Employee\" AS \"T2\" ON \"T1\".\"BusinessEntityID\" = \"T2\".\"BusinessEntityID\" WHERE sys.timestamp_to_str(\"T2\".\"HireDate\", '%Y') >= '2007' AND \"T2\".\"SalariedFlag\" = 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 128,
                "end_index": 154,
                "dilatect_content": "STRFTIME('%Y', T2.HireDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`PersonType`, text)\n(`NameStyle`, integer)\n(`Title`, text)\n(`FirstName`, text)\n(`MiddleName`, text)\n(`LastName`, text)\n(`Suffix`, text)\n(`EmailPromotion`, integer)\n(`AdditionalContactInfo`, text)\n(`Demographics`, text)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"Person\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"PersonType\", STRING)\n(\"NameStyle\", BIGINT)\n(\"Title\", STRING)\n(\"FirstName\", STRING)\n(\"MiddleName\", STRING)\n(\"LastName\", STRING)\n(\"Suffix\", STRING)\n(\"EmailPromotion\", BIGINT)\n(\"AdditionalContactInfo\", STRING)\n(\"Demographics\", STRING)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"Employee\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"NationalIDNumber\", STRING)\n(\"LoginID\", STRING)\n(\"OrganizationNode\", STRING)\n(\"OrganizationLevel\", BIGINT)\n(\"JobTitle\", STRING)\n(\"BirthDate\", DATE)\n(\"MaritalStatus\", STRING)\n(\"Gender\", STRING)\n(\"HireDate\", DATE)\n(\"SalariedFlag\", BIGINT)\n(\"VacationHours\", BIGINT)\n(\"SickLeaveHours\", BIGINT)\n(\"CurrentFlag\", BIGINT)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 535,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.FirstName, T1.LastName , STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', BirthDate) FROM Person AS T1 INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN EmployeeDepartmentHistory AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID WHERE T3.ShiftId = 3 ORDER BY STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', BirthDate) DESC LIMIT 1",
        "target_query": "SELECT \"T1\".\"FirstName\", \"T1\".\"LastName\", \n       EXTRACT(YEAR FROM CURRENT_TIMESTAMP) - EXTRACT(YEAR FROM \"T2\".\"BirthDate\") \nFROM \"Person\" AS \"T1\" \nINNER JOIN \"Employee\" AS \"T2\" ON \"T1\".\"BusinessEntityID\" = \"T2\".\"BusinessEntityID\" \nINNER JOIN \"EmployeeDepartmentHistory\" AS \"T3\" ON \"T2\".\"BusinessEntityID\" = \"T3\".\"BusinessEntityID\" \nWHERE \"T3\".\"ShiftID\" = 3 \nORDER BY EXTRACT(YEAR FROM CURRENT_TIMESTAMP) - EXTRACT(YEAR FROM \"T2\".\"BirthDate\") DESC \nLIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 35,
                "end_index": 67,
                "dilatect_content": "STRFTIME('%Y', CURRENT_TIMESTAMP)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 71,
                "end_index": 95,
                "dilatect_content": "STRFTIME('%Y', BirthDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 304,
                "end_index": 336,
                "dilatect_content": "STRFTIME('%Y', CURRENT_TIMESTAMP)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 340,
                "end_index": 364,
                "dilatect_content": "STRFTIME('%Y', BirthDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 67,
                "end_index": 93,
                "dilatect_content": "YEAR FROM CURRENT_TIMESTAMP",
                "feature": ""
            },
            {
                "start_index": 106,
                "end_index": 135,
                "dilatect_content": "YEAR FROM \"T2\".\"BirthDate\"",
                "feature": ""
            },
            {
                "start_index": 427,
                "end_index": 453,
                "dilatect_content": "YEAR FROM CURRENT_TIMESTAMP",
                "feature": ""
            },
            {
                "start_index": 466,
                "end_index": 495,
                "dilatect_content": "YEAR FROM \"T2\".\"BirthDate\"",
                "feature": ""
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`PersonType`, text)\n(`NameStyle`, integer)\n(`Title`, text)\n(`FirstName`, text)\n(`MiddleName`, text)\n(`LastName`, text)\n(`Suffix`, text)\n(`EmailPromotion`, integer)\n(`AdditionalContactInfo`, text)\n(`Demographics`, text)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `EmployeeDepartmentHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`DepartmentID`, integer, primary key)\n(`ShiftID`, integer, primary key)\n(`StartDate`, date, primary key)\n(`EndDate`, date)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"Person\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"PersonType\", STRING)\n(\"NameStyle\", BIGINT)\n(\"Title\", STRING)\n(\"FirstName\", STRING)\n(\"MiddleName\", STRING)\n(\"LastName\", STRING)\n(\"Suffix\", STRING)\n(\"EmailPromotion\", BIGINT)\n(\"AdditionalContactInfo\", STRING)\n(\"Demographics\", STRING)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"Employee\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"NationalIDNumber\", STRING)\n(\"LoginID\", STRING)\n(\"OrganizationNode\", STRING)\n(\"OrganizationLevel\", BIGINT)\n(\"JobTitle\", STRING)\n(\"BirthDate\", DATE)\n(\"MaritalStatus\", STRING)\n(\"Gender\", STRING)\n(\"HireDate\", DATE)\n(\"SalariedFlag\", BIGINT)\n(\"VacationHours\", BIGINT)\n(\"SickLeaveHours\", BIGINT)\n(\"CurrentFlag\", BIGINT)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"EmployeeDepartmentHistory\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"DepartmentID\", BIGINT, primary key)\n(\"ShiftID\", BIGINT, primary key)\n(\"StartDate\", DATE, primary key)\n(\"EndDate\", DATE)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 536,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.FirstName, T1.LastName FROM Person AS T1 INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN EmployeeDepartmentHistory AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID INNER JOIN Department AS T4 ON T3.DepartmentID = T4.DepartmentID WHERE STRFTIME('%Y', T2.HireDate) = '2009' AND T4.Name = 'Shipping and Receiving'",
        "target_query": "SELECT \"T1\".\"FirstName\", \"T1\".\"LastName\" \nFROM \"Person\" AS \"T1\" \nINNER JOIN \"Employee\" AS \"T2\" ON \"T1\".\"BusinessEntityID\" = \"T2\".\"BusinessEntityID\" \nINNER JOIN \"EmployeeDepartmentHistory\" AS \"T3\" ON \"T2\".\"BusinessEntityID\" = \"T3\".\"BusinessEntityID\" \nINNER JOIN \"Department\" AS \"T4\" ON \"T3\".\"DepartmentID\" = \"T4\".\"DepartmentID\" \nWHERE sys.timestamp_to_str(\"T2\".\"HireDate\", '%Y') = '2009' \nAND \"T4\".\"Name\" = 'Shipping and Receiving';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 281,
                "end_index": 307,
                "dilatect_content": "STRFTIME('%Y', T2.HireDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 387,
                "end_index": 433,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"HireDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`PersonType`, text)\n(`NameStyle`, integer)\n(`Title`, text)\n(`FirstName`, text)\n(`MiddleName`, text)\n(`LastName`, text)\n(`Suffix`, text)\n(`EmailPromotion`, integer)\n(`AdditionalContactInfo`, text)\n(`Demographics`, text)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `EmployeeDepartmentHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`DepartmentID`, integer, primary key)\n(`ShiftID`, integer, primary key)\n(`StartDate`, date, primary key)\n(`EndDate`, date)\n(`ModifiedDate`, datetime)\n",
            "Table: `Department`\nColumns:\n(`DepartmentID`, integer, primary key)\n(`Name`, text)\n(`GroupName`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"Person\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"PersonType\", STRING)\n(\"NameStyle\", BIGINT)\n(\"Title\", STRING)\n(\"FirstName\", STRING)\n(\"MiddleName\", STRING)\n(\"LastName\", STRING)\n(\"Suffix\", STRING)\n(\"EmailPromotion\", BIGINT)\n(\"AdditionalContactInfo\", STRING)\n(\"Demographics\", STRING)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"Employee\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"NationalIDNumber\", STRING)\n(\"LoginID\", STRING)\n(\"OrganizationNode\", STRING)\n(\"OrganizationLevel\", BIGINT)\n(\"JobTitle\", STRING)\n(\"BirthDate\", DATE)\n(\"MaritalStatus\", STRING)\n(\"Gender\", STRING)\n(\"HireDate\", DATE)\n(\"SalariedFlag\", BIGINT)\n(\"VacationHours\", BIGINT)\n(\"SickLeaveHours\", BIGINT)\n(\"CurrentFlag\", BIGINT)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"EmployeeDepartmentHistory\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"DepartmentID\", BIGINT, primary key)\n(\"ShiftID\", BIGINT, primary key)\n(\"StartDate\", DATE, primary key)\n(\"EndDate\", DATE)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"Department\"\nColumns:\n(\"DepartmentID\", BIGINT, primary key)\n(\"Name\", STRING)\n(\"GroupName\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 537,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT AVG(STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.HireDate)) FROM Employee AS T1 INNER JOIN EmployeeDepartmentHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Department AS T3 ON T2.DepartmentID = T3.DepartmentID WHERE T3.Name = 'Research and Development'",
        "target_query": "SELECT AVG(CAST(sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y') AS BIGINT) - CAST(sys.timestamp_to_str(\"T1\".\"HireDate\", '%Y') AS BIGINT)) FROM \"Employee\" AS \"T1\" INNER JOIN \"EmployeeDepartmentHistory\" AS \"T2\" ON \"T1\".\"BusinessEntityID\" = \"T2\".\"BusinessEntityID\" INNER JOIN \"Department\" AS \"T3\" ON \"T2\".\"DepartmentID\" = \"T3\".\"DepartmentID\" WHERE \"T3\".\"Name\" = 'Research and Development';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 43,
                "dilatect_content": "STRFTIME('%Y', CURRENT_TIMESTAMP)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 47,
                "end_index": 73,
                "dilatect_content": "STRFTIME('%Y', T1.HireDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 60,
                "dilatect_content": "sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 80,
                "end_index": 126,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"HireDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `EmployeeDepartmentHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`DepartmentID`, integer, primary key)\n(`ShiftID`, integer, primary key)\n(`StartDate`, date, primary key)\n(`EndDate`, date)\n(`ModifiedDate`, datetime)\n",
            "Table: `Department`\nColumns:\n(`DepartmentID`, integer, primary key)\n(`Name`, text)\n(`GroupName`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"Employee\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"NationalIDNumber\", STRING)\n(\"LoginID\", STRING)\n(\"OrganizationNode\", STRING)\n(\"OrganizationLevel\", BIGINT)\n(\"JobTitle\", STRING)\n(\"BirthDate\", DATE)\n(\"MaritalStatus\", STRING)\n(\"Gender\", STRING)\n(\"HireDate\", DATE)\n(\"SalariedFlag\", BIGINT)\n(\"VacationHours\", BIGINT)\n(\"SickLeaveHours\", BIGINT)\n(\"CurrentFlag\", BIGINT)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"EmployeeDepartmentHistory\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"DepartmentID\", BIGINT, primary key)\n(\"ShiftID\", BIGINT, primary key)\n(\"StartDate\", DATE, primary key)\n(\"EndDate\", DATE)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"Department\"\nColumns:\n(\"DepartmentID\", BIGINT, primary key)\n(\"Name\", STRING)\n(\"GroupName\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 538,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT AVG(STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', BirthDate)) FROM Employee",
        "target_query": "SELECT AVG(CAST(sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y') AS INTEGER) - CAST(sys.timestamp_to_str(\"BirthDate\", '%Y') AS INTEGER)) FROM \"Employee\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 43,
                "dilatect_content": "STRFTIME('%Y', CURRENT_TIMESTAMP)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 47,
                "end_index": 71,
                "dilatect_content": "STRFTIME('%Y', BirthDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 60,
                "dilatect_content": "sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 81,
                "end_index": 121,
                "dilatect_content": "sys.timestamp_to_str(\"BirthDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"Employee\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"NationalIDNumber\", STRING)\n(\"LoginID\", STRING)\n(\"OrganizationNode\", STRING)\n(\"OrganizationLevel\", BIGINT)\n(\"JobTitle\", STRING)\n(\"BirthDate\", DATE)\n(\"MaritalStatus\", STRING)\n(\"Gender\", STRING)\n(\"HireDate\", DATE)\n(\"SalariedFlag\", BIGINT)\n(\"VacationHours\", BIGINT)\n(\"SickLeaveHours\", BIGINT)\n(\"CurrentFlag\", BIGINT)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 539,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.Name, T3.Name FROM Product AS T1 INNER JOIN ProductVendor AS T2 ON T1.ProductID = T2.ProductID INNER JOIN Vendor AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID WHERE STRFTIME('%Y', T1.SellStartDate) = '2013'",
        "target_query": "SELECT \"T1\".\"Name\", \"T3\".\"Name\" FROM \"Product\" AS \"T1\" INNER JOIN \"ProductVendor\" AS \"T2\" ON \"T1\".\"ProductID\" = \"T2\".\"ProductID\" INNER JOIN \"Vendor\" AS \"T3\" ON \"T2\".\"BusinessEntityID\" = \"T3\".\"BusinessEntityID\" WHERE sys.timestamp_to_str(\"T1\".\"SellStartDate\", '%Y') = '2013';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 180,
                "end_index": 211,
                "dilatect_content": "STRFTIME('%Y', T1.SellStartDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 252,
                "end_index": 303,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"SellStartDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Product`\nColumns:\n(`ProductID`, integer, primary key)\n(`Name`, text)\n(`ProductNumber`, text)\n(`MakeFlag`, integer)\n(`FinishedGoodsFlag`, integer)\n(`Color`, text)\n(`SafetyStockLevel`, integer)\n(`ReorderPoint`, integer)\n(`StandardCost`, real)\n(`ListPrice`, real)\n(`Size`, text)\n(`SizeUnitMeasureCode`, text)\n(`WeightUnitMeasureCode`, text)\n(`Weight`, real)\n(`DaysToManufacture`, integer)\n(`ProductLine`, text)\n(`Class`, text)\n(`Style`, text)\n(`ProductSubcategoryID`, integer)\n(`ProductModelID`, integer)\n(`SellStartDate`, datetime)\n(`SellEndDate`, datetime)\n(`DiscontinuedDate`, datetime)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `ProductVendor`\nColumns:\n(`ProductID`, integer, primary key)\n(`BusinessEntityID`, integer, primary key)\n(`AverageLeadTime`, integer)\n(`StandardPrice`, real)\n(`LastReceiptCost`, real)\n(`LastReceiptDate`, datetime)\n(`MinOrderQty`, integer)\n(`MaxOrderQty`, integer)\n(`OnOrderQty`, integer)\n(`UnitMeasureCode`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `Vendor`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`AccountNumber`, text)\n(`Name`, text)\n(`CreditRating`, integer)\n(`PreferredVendorStatus`, integer)\n(`ActiveFlag`, integer)\n(`PurchasingWebServiceURL`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"Product\"\nColumns:\n(\"ProductID\", BIGINT, primary key)\n(\"Name\", STRING)\n(\"ProductNumber\", STRING)\n(\"MakeFlag\", BIGINT)\n(\"FinishedGoodsFlag\", BIGINT)\n(\"Color\", STRING)\n(\"SafetyStockLevel\", BIGINT)\n(\"ReorderPoint\", BIGINT)\n(\"StandardCost\", DOUBLE PRECISION)\n(\"ListPrice\", DOUBLE PRECISION)\n(\"Size\", STRING)\n(\"SizeUnitMeasureCode\", STRING)\n(\"WeightUnitMeasureCode\", STRING)\n(\"Weight\", DOUBLE PRECISION)\n(\"DaysToManufacture\", BIGINT)\n(\"ProductLine\", STRING)\n(\"Class\", STRING)\n(\"Style\", STRING)\n(\"ProductSubcategoryID\", BIGINT)\n(\"ProductModelID\", BIGINT)\n(\"SellStartDate\", TIMESTAMP)\n(\"SellEndDate\", TIMESTAMP)\n(\"DiscontinuedDate\", TIMESTAMP)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"ProductVendor\"\nColumns:\n(\"ProductID\", BIGINT, primary key)\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"AverageLeadTime\", BIGINT)\n(\"StandardPrice\", DOUBLE PRECISION)\n(\"LastReceiptCost\", DOUBLE PRECISION)\n(\"LastReceiptDate\", TIMESTAMP)\n(\"MinOrderQty\", BIGINT)\n(\"MaxOrderQty\", BIGINT)\n(\"OnOrderQty\", BIGINT)\n(\"UnitMeasureCode\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"Vendor\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"AccountNumber\", STRING)\n(\"Name\", STRING)\n(\"CreditRating\", BIGINT)\n(\"PreferredVendorStatus\", BIGINT)\n(\"ActiveFlag\", BIGINT)\n(\"PurchasingWebServiceURL\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 540,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.FirstName, T2.LastName FROM Employee AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE STRFTIME('%Y', T1.BirthDate) > '1970' ORDER BY T1.SickLeaveHours LIMIT 1",
        "target_query": "SELECT \"T2\".\"FirstName\", \"T2\".\"LastName\" FROM \"Employee\" AS \"T1\" INNER JOIN \"Person\" AS \"T2\" ON \"T1\".\"BusinessEntityID\" = \"T2\".\"BusinessEntityID\" WHERE sys.timestamp_to_str(\"T1\".\"BirthDate\", '%Y') > '1970' ORDER BY \"T1\".\"SickLeaveHours\" LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 128,
                "end_index": 155,
                "dilatect_content": "STRFTIME('%Y', T1.BirthDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 176,
                "end_index": 223,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"BirthDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`PersonType`, text)\n(`NameStyle`, integer)\n(`Title`, text)\n(`FirstName`, text)\n(`MiddleName`, text)\n(`LastName`, text)\n(`Suffix`, text)\n(`EmailPromotion`, integer)\n(`AdditionalContactInfo`, text)\n(`Demographics`, text)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"Employee\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"NationalIDNumber\", STRING)\n(\"LoginID\", STRING)\n(\"OrganizationNode\", STRING)\n(\"OrganizationLevel\", BIGINT)\n(\"JobTitle\", STRING)\n(\"BirthDate\", DATE)\n(\"MaritalStatus\", STRING)\n(\"Gender\", STRING)\n(\"HireDate\", DATE)\n(\"SalariedFlag\", BIGINT)\n(\"VacationHours\", BIGINT)\n(\"SickLeaveHours\", BIGINT)\n(\"CurrentFlag\", BIGINT)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"Person\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"PersonType\", STRING)\n(\"NameStyle\", BIGINT)\n(\"Title\", STRING)\n(\"FirstName\", STRING)\n(\"MiddleName\", STRING)\n(\"LastName\", STRING)\n(\"Suffix\", STRING)\n(\"EmailPromotion\", BIGINT)\n(\"AdditionalContactInfo\", STRING)\n(\"Demographics\", STRING)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 541,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.BirthDate) + 1 , T3.Name FROM Employee AS T1 INNER JOIN EmployeeDepartmentHistory AS T2 USING (BusinessEntityID) INNER JOIN Department AS T3 USING (DepartmentID) ORDER BY T1.BirthDate DESC LIMIT 1",
        "target_query": "SELECT (CAST(sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y') AS INTEGER) - CAST(sys.timestamp_to_str(\"T1\".\"BirthDate\", '%Y') AS INTEGER) + 1) AS Age, \"T3\".\"Name\" FROM \"Employee\" AS \"T1\" INNER JOIN \"EmployeeDepartmentHistory\" AS \"T2\" USING (\"BusinessEntityID\") INNER JOIN \"Department\" AS \"T3\" USING (\"DepartmentID\") ORDER BY \"T1\".\"BirthDate\" DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 39,
                "dilatect_content": "STRFTIME('%Y', CURRENT_TIMESTAMP)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 43,
                "end_index": 70,
                "dilatect_content": "STRFTIME('%Y', T1.BirthDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 13,
                "end_index": 57,
                "dilatect_content": "sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 78,
                "end_index": 125,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"BirthDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `EmployeeDepartmentHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`DepartmentID`, integer, primary key)\n(`ShiftID`, integer, primary key)\n(`StartDate`, date, primary key)\n(`EndDate`, date)\n(`ModifiedDate`, datetime)\n",
            "Table: `Department`\nColumns:\n(`DepartmentID`, integer, primary key)\n(`Name`, text)\n(`GroupName`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"Employee\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"NationalIDNumber\", STRING)\n(\"LoginID\", STRING)\n(\"OrganizationNode\", STRING)\n(\"OrganizationLevel\", BIGINT)\n(\"JobTitle\", STRING)\n(\"BirthDate\", DATE)\n(\"MaritalStatus\", STRING)\n(\"Gender\", STRING)\n(\"HireDate\", DATE)\n(\"SalariedFlag\", BIGINT)\n(\"VacationHours\", BIGINT)\n(\"SickLeaveHours\", BIGINT)\n(\"CurrentFlag\", BIGINT)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"EmployeeDepartmentHistory\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"DepartmentID\", BIGINT, primary key)\n(\"ShiftID\", BIGINT, primary key)\n(\"StartDate\", DATE, primary key)\n(\"EndDate\", DATE)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"Department\"\nColumns:\n(\"DepartmentID\", BIGINT, primary key)\n(\"Name\", STRING)\n(\"GroupName\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 543,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T3.StartTime, T3.EndTime FROM Employee AS T1 INNER JOIN EmployeeDepartmentHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Shift AS T3 ON T2.ShiftId = T3.ShiftId WHERE STRFTIME('%Y', T1.BirthDate) < '1969' ORDER BY T1.BirthDate LIMIT 5, 1",
        "target_query": "SELECT \"T3\".\"StartTime\", \"T3\".\"EndTime\" \nFROM \"Employee\" AS \"T1\" \nINNER JOIN \"EmployeeDepartmentHistory\" AS \"T2\" ON \"T1\".\"BusinessEntityID\" = \"T2\".\"BusinessEntityID\" \nINNER JOIN \"Shift\" AS \"T3\" ON \"T2\".\"ShiftID\" = \"T3\".\"ShiftID\" \nWHERE EXTRACT(YEAR FROM \"T1\".\"BirthDate\") < 1969 \nORDER BY \"T1\".\"BirthDate\" \nLIMIT 1 OFFSET 5;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 196,
                "end_index": 223,
                "dilatect_content": "STRFTIME('%Y', T1.BirthDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 284,
                "end_index": 313,
                "dilatect_content": "YEAR FROM \"T1\".\"BirthDate\"",
                "feature": ""
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `EmployeeDepartmentHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`DepartmentID`, integer, primary key)\n(`ShiftID`, integer, primary key)\n(`StartDate`, date, primary key)\n(`EndDate`, date)\n(`ModifiedDate`, datetime)\n",
            "Table: `Shift`\nColumns:\n(`ShiftID`, integer, primary key)\n(`Name`, text)\n(`StartTime`, text)\n(`EndTime`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"Employee\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"NationalIDNumber\", STRING)\n(\"LoginID\", STRING)\n(\"OrganizationNode\", STRING)\n(\"OrganizationLevel\", BIGINT)\n(\"JobTitle\", STRING)\n(\"BirthDate\", DATE)\n(\"MaritalStatus\", STRING)\n(\"Gender\", STRING)\n(\"HireDate\", DATE)\n(\"SalariedFlag\", BIGINT)\n(\"VacationHours\", BIGINT)\n(\"SickLeaveHours\", BIGINT)\n(\"CurrentFlag\", BIGINT)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"EmployeeDepartmentHistory\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"DepartmentID\", BIGINT, primary key)\n(\"ShiftID\", BIGINT, primary key)\n(\"StartDate\", DATE, primary key)\n(\"EndDate\", DATE)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"Shift\"\nColumns:\n(\"ShiftID\", BIGINT, primary key)\n(\"Name\", STRING)\n(\"StartTime\", STRING)\n(\"EndTime\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 544,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.EndDate FROM Employee AS T1 INNER JOIN EmployeeDepartmentHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Department AS T3 ON T2.DepartmentID = T3.DepartmentID WHERE T1.JobTitle = 'Senior Tool Designer' AND STRFTIME('%Y', T1.HireDate) - STRFTIME('%Y', T1.BirthDate) = 33 AND T2.EndDate IS NOT NULL",
        "target_query": "SELECT \"T2\".\"EndDate\" \nFROM \"Employee\" AS \"T1\" \nINNER JOIN \"EmployeeDepartmentHistory\" AS \"T2\" ON \"T1\".\"BusinessEntityID\" = \"T2\".\"BusinessEntityID\" \nINNER JOIN \"Department\" AS \"T3\" ON \"T2\".\"DepartmentID\" = \"T3\".\"DepartmentID\" \nWHERE \"T1\".\"JobTitle\" = 'Senior Tool Designer' \nAND (EXTRACT(YEAR FROM \"T1\".\"HireDate\") - EXTRACT(YEAR FROM \"T1\".\"BirthDate\")) = 33 \nAND \"T2\".\"EndDate\" IS NOT NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 238,
                "end_index": 264,
                "dilatect_content": "STRFTIME('%Y', T1.HireDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 268,
                "end_index": 295,
                "dilatect_content": "STRFTIME('%Y', T1.BirthDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 329,
                "end_index": 357,
                "dilatect_content": "YEAR FROM \"T1\".\"HireDate\"",
                "feature": ""
            },
            {
                "start_index": 370,
                "end_index": 399,
                "dilatect_content": "YEAR FROM \"T1\".\"BirthDate\"",
                "feature": ""
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `EmployeeDepartmentHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`DepartmentID`, integer, primary key)\n(`ShiftID`, integer, primary key)\n(`StartDate`, date, primary key)\n(`EndDate`, date)\n(`ModifiedDate`, datetime)\n",
            "Table: `Department`\nColumns:\n(`DepartmentID`, integer, primary key)\n(`Name`, text)\n(`GroupName`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"Employee\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"NationalIDNumber\", STRING)\n(\"LoginID\", STRING)\n(\"OrganizationNode\", STRING)\n(\"OrganizationLevel\", BIGINT)\n(\"JobTitle\", STRING)\n(\"BirthDate\", DATE)\n(\"MaritalStatus\", STRING)\n(\"Gender\", STRING)\n(\"HireDate\", DATE)\n(\"SalariedFlag\", BIGINT)\n(\"VacationHours\", BIGINT)\n(\"SickLeaveHours\", BIGINT)\n(\"CurrentFlag\", BIGINT)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"EmployeeDepartmentHistory\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"DepartmentID\", BIGINT, primary key)\n(\"ShiftID\", BIGINT, primary key)\n(\"StartDate\", DATE, primary key)\n(\"EndDate\", DATE)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"Department\"\nColumns:\n(\"DepartmentID\", BIGINT, primary key)\n(\"Name\", STRING)\n(\"GroupName\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 545,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT STRFTIME('%Y', T1.HireDate) - STRFTIME('%Y', T1.BirthDate), T2.FirstName, T2.MiddleName, T2.LastName FROM Employee AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.VacationHours <= 10 ORDER BY STRFTIME('%Y', T1.HireDate) - STRFTIME('%Y', T1.BirthDate) DESC LIMIT 1",
        "target_query": "SELECT EXTRACT(YEAR FROM \"T1\".\"HireDate\") - EXTRACT(YEAR FROM \"T1\".\"BirthDate\"), \"T2\".\"FirstName\", \"T2\".\"MiddleName\", \"T2\".\"LastName\" FROM \"Employee\" AS \"T1\" INNER JOIN \"Person\" AS \"T2\" ON \"T1\".\"BusinessEntityID\" = \"T2\".\"BusinessEntityID\" WHERE \"T1\".\"VacationHours\" <= 10 ORDER BY EXTRACT(YEAR FROM \"T1\".\"HireDate\") - EXTRACT(YEAR FROM \"T1\".\"BirthDate\") DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 33,
                "dilatect_content": "STRFTIME('%Y', T1.HireDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 37,
                "end_index": 64,
                "dilatect_content": "STRFTIME('%Y', T1.BirthDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 235,
                "end_index": 261,
                "dilatect_content": "STRFTIME('%Y', T1.HireDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 265,
                "end_index": 292,
                "dilatect_content": "STRFTIME('%Y', T1.BirthDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 15,
                "end_index": 43,
                "dilatect_content": "YEAR FROM \"T1\".\"HireDate\"",
                "feature": ""
            },
            {
                "start_index": 56,
                "end_index": 85,
                "dilatect_content": "YEAR FROM \"T1\".\"BirthDate\"",
                "feature": ""
            },
            {
                "start_index": 329,
                "end_index": 357,
                "dilatect_content": "YEAR FROM \"T1\".\"HireDate\"",
                "feature": ""
            },
            {
                "start_index": 390,
                "end_index": 419,
                "dilatect_content": "YEAR FROM \"T1\".\"BirthDate\"",
                "feature": ""
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`PersonType`, text)\n(`NameStyle`, integer)\n(`Title`, text)\n(`FirstName`, text)\n(`MiddleName`, text)\n(`LastName`, text)\n(`Suffix`, text)\n(`EmailPromotion`, integer)\n(`AdditionalContactInfo`, text)\n(`Demographics`, text)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"Employee\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"NationalIDNumber\", STRING)\n(\"LoginID\", STRING)\n(\"OrganizationNode\", STRING)\n(\"OrganizationLevel\", BIGINT)\n(\"JobTitle\", STRING)\n(\"BirthDate\", DATE)\n(\"MaritalStatus\", STRING)\n(\"Gender\", STRING)\n(\"HireDate\", DATE)\n(\"SalariedFlag\", BIGINT)\n(\"VacationHours\", BIGINT)\n(\"SickLeaveHours\", BIGINT)\n(\"CurrentFlag\", BIGINT)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"Person\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"PersonType\", STRING)\n(\"NameStyle\", BIGINT)\n(\"Title\", STRING)\n(\"FirstName\", STRING)\n(\"MiddleName\", STRING)\n(\"LastName\", STRING)\n(\"Suffix\", STRING)\n(\"EmailPromotion\", BIGINT)\n(\"AdditionalContactInfo\", STRING)\n(\"Demographics\", STRING)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 546,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.PersonType FROM Employee AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.Gender = 'F' AND T1.MaritalStatus = 'S' AND STRFTIME('%Y-%m-%d', T1.HireDate) BETWEEN '2008-1-1' AND '2008-12-31' GROUP BY T2.PersonType ORDER BY COUNT(T2.PersonType) DESC LIMIT 1",
        "target_query": "SELECT \"T2\".\"PersonType\" FROM \"Employee\" AS \"T1\" INNER JOIN \"Person\" AS \"T2\" ON \"T1\".\"BusinessEntityID\" = \"T2\".\"BusinessEntityID\" WHERE \"T1\".\"Gender\" = 'F' AND \"T1\".\"MaritalStatus\" = 'S' AND sys.timestamp_to_str(\"T1\".\"HireDate\", '%Y-%m-%d') BETWEEN '2008-01-01' AND '2008-12-31' GROUP BY \"T2\".\"PersonType\" ORDER BY COUNT(\"T2\".\"PersonType\") DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 163,
                "end_index": 195,
                "dilatect_content": "STRFTIME('%Y-%m-%d', T1.HireDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 219,
                "end_index": 271,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"HireDate\", '%Y-%m-%d')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`PersonType`, text)\n(`NameStyle`, integer)\n(`Title`, text)\n(`FirstName`, text)\n(`MiddleName`, text)\n(`LastName`, text)\n(`Suffix`, text)\n(`EmailPromotion`, integer)\n(`AdditionalContactInfo`, text)\n(`Demographics`, text)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"Employee\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"NationalIDNumber\", STRING)\n(\"LoginID\", STRING)\n(\"OrganizationNode\", STRING)\n(\"OrganizationLevel\", BIGINT)\n(\"JobTitle\", STRING)\n(\"BirthDate\", DATE)\n(\"MaritalStatus\", STRING)\n(\"Gender\", STRING)\n(\"HireDate\", DATE)\n(\"SalariedFlag\", BIGINT)\n(\"VacationHours\", BIGINT)\n(\"SickLeaveHours\", BIGINT)\n(\"CurrentFlag\", BIGINT)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"Person\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"PersonType\", STRING)\n(\"NameStyle\", BIGINT)\n(\"Title\", STRING)\n(\"FirstName\", STRING)\n(\"MiddleName\", STRING)\n(\"LastName\", STRING)\n(\"Suffix\", STRING)\n(\"EmailPromotion\", BIGINT)\n(\"AdditionalContactInfo\", STRING)\n(\"Demographics\", STRING)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 547,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T1.BusinessEntityID) FROM Person AS T1 INNER JOIN EmployeeDepartmentHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Department AS T3 ON T2.DepartmentID = T3.DepartmentID WHERE T3.Name = 'Engineering' AND STRFTIME('%Y', T2.EndDate) > '2009' AND STRFTIME('%Y', T2.StartDate) < '2009'",
        "target_query": "SELECT COUNT(\"T1\".\"BusinessEntityID\") \nFROM \"Person\" AS \"T1\" \nINNER JOIN \"EmployeeDepartmentHistory\" AS \"T2\" ON \"T1\".\"BusinessEntityID\" = \"T2\".\"BusinessEntityID\" \nINNER JOIN \"Department\" AS \"T3\" ON \"T2\".\"DepartmentID\" = \"T3\".\"DepartmentID\" \nWHERE \"T3\".\"Name\" = 'Engineering' \nAND sys.timestamp_to_str(\"T2\".\"EndDate\", '%Y') > '2009' \nAND sys.timestamp_to_str(\"T2\".\"StartDate\", '%Y') < '2009';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 239,
                "end_index": 264,
                "dilatect_content": "STRFTIME('%Y', T2.EndDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 279,
                "end_index": 306,
                "dilatect_content": "STRFTIME('%Y', T2.StartDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 321,
                "end_index": 366,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"EndDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 383,
                "end_index": 430,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"StartDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`PersonType`, text)\n(`NameStyle`, integer)\n(`Title`, text)\n(`FirstName`, text)\n(`MiddleName`, text)\n(`LastName`, text)\n(`Suffix`, text)\n(`EmailPromotion`, integer)\n(`AdditionalContactInfo`, text)\n(`Demographics`, text)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `EmployeeDepartmentHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`DepartmentID`, integer, primary key)\n(`ShiftID`, integer, primary key)\n(`StartDate`, date, primary key)\n(`EndDate`, date)\n(`ModifiedDate`, datetime)\n",
            "Table: `Department`\nColumns:\n(`DepartmentID`, integer, primary key)\n(`Name`, text)\n(`GroupName`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"Person\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"PersonType\", STRING)\n(\"NameStyle\", BIGINT)\n(\"Title\", STRING)\n(\"FirstName\", STRING)\n(\"MiddleName\", STRING)\n(\"LastName\", STRING)\n(\"Suffix\", STRING)\n(\"EmailPromotion\", BIGINT)\n(\"AdditionalContactInfo\", STRING)\n(\"Demographics\", STRING)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"EmployeeDepartmentHistory\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"DepartmentID\", BIGINT, primary key)\n(\"ShiftID\", BIGINT, primary key)\n(\"StartDate\", DATE, primary key)\n(\"EndDate\", DATE)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"Department\"\nColumns:\n(\"DepartmentID\", BIGINT, primary key)\n(\"Name\", STRING)\n(\"GroupName\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 548,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T1.BusinessEntityID) FROM EmployeeDepartmentHistory AS T1 INNER JOIN Department AS T2 ON T1.DepartmentID = T2.DepartmentID INNER JOIN Person AS T3 ON T1.BusinessEntityID WHERE T3.PersonType = 'SC' AND T2.GroupName = 'Manufacturing' AND STRFTIME('%Y', T1.EndDate) >= '2007' AND STRFTIME('%Y', T1.StartDate) <= '2007'",
        "target_query": "SELECT COUNT(\"T1\".\"BusinessEntityID\") FROM \"EmployeeDepartmentHistory\" AS \"T1\" INNER JOIN \"Department\" AS \"T2\" ON \"T1\".\"DepartmentID\" = \"T2\".\"DepartmentID\" INNER JOIN \"Person\" AS \"T3\" ON \"T1\".\"BusinessEntityID\" = \"T3\".\"BusinessEntityID\" WHERE \"T3\".\"PersonType\" = 'SC' AND \"T2\".\"GroupName\" = 'Manufacturing' AND sys.timestamp_to_str(\"T1\".\"EndDate\", '%Y') >= '2007' AND sys.timestamp_to_str(\"T1\".\"StartDate\", '%Y') <= '2007';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 249,
                "end_index": 274,
                "dilatect_content": "STRFTIME('%Y', T1.EndDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 290,
                "end_index": 317,
                "dilatect_content": "STRFTIME('%Y', T1.StartDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 351,
                "end_index": 396,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"EndDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 412,
                "end_index": 459,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"StartDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `EmployeeDepartmentHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`DepartmentID`, integer, primary key)\n(`ShiftID`, integer, primary key)\n(`StartDate`, date, primary key)\n(`EndDate`, date)\n(`ModifiedDate`, datetime)\n",
            "Table: `Department`\nColumns:\n(`DepartmentID`, integer, primary key)\n(`Name`, text)\n(`GroupName`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`PersonType`, text)\n(`NameStyle`, integer)\n(`Title`, text)\n(`FirstName`, text)\n(`MiddleName`, text)\n(`LastName`, text)\n(`Suffix`, text)\n(`EmailPromotion`, integer)\n(`AdditionalContactInfo`, text)\n(`Demographics`, text)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"EmployeeDepartmentHistory\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"DepartmentID\", BIGINT, primary key)\n(\"ShiftID\", BIGINT, primary key)\n(\"StartDate\", DATE, primary key)\n(\"EndDate\", DATE)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"Department\"\nColumns:\n(\"DepartmentID\", BIGINT, primary key)\n(\"Name\", STRING)\n(\"GroupName\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"Person\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"PersonType\", STRING)\n(\"NameStyle\", BIGINT)\n(\"Title\", STRING)\n(\"FirstName\", STRING)\n(\"MiddleName\", STRING)\n(\"LastName\", STRING)\n(\"Suffix\", STRING)\n(\"EmailPromotion\", BIGINT)\n(\"AdditionalContactInfo\", STRING)\n(\"Demographics\", STRING)\n(\"rowguid\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 549,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T1.BusinessEntityID) FROM EmployeeDepartmentHistory AS T1 INNER JOIN Department AS T2 ON T1.DepartmentID = T2.DepartmentID WHERE T2.GroupName = 'Quality Assurance' AND STRFTIME('%Y', T1.StartDate) = '2007'",
        "target_query": "SELECT COUNT(\"T1\".\"BusinessEntityID\") FROM \"EmployeeDepartmentHistory\" AS \"T1\" INNER JOIN \"Department\" AS \"T2\" ON \"T1\".\"DepartmentID\" = \"T2\".\"DepartmentID\" WHERE \"T2\".\"GroupName\" = 'Quality Assurance' AND sys.timestamp_to_str(\"T1\".\"StartDate\", '%Y') = '2007';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 181,
                "end_index": 208,
                "dilatect_content": "STRFTIME('%Y', T1.StartDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 229,
                "end_index": 276,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"StartDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `EmployeeDepartmentHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`DepartmentID`, integer, primary key)\n(`ShiftID`, integer, primary key)\n(`StartDate`, date, primary key)\n(`EndDate`, date)\n(`ModifiedDate`, datetime)\n",
            "Table: `Department`\nColumns:\n(`DepartmentID`, integer, primary key)\n(`Name`, text)\n(`GroupName`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"EmployeeDepartmentHistory\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"DepartmentID\", BIGINT, primary key)\n(\"ShiftID\", BIGINT, primary key)\n(\"StartDate\", DATE, primary key)\n(\"EndDate\", DATE)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"Department\"\nColumns:\n(\"DepartmentID\", BIGINT, primary key)\n(\"Name\", STRING)\n(\"GroupName\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 550,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(365 * (STRFTIME('%Y', T1.EndDate) - STRFTIME('%Y', T1.StartDate)) + 30 * (STRFTIME('%m', T1.EndDate) - STRFTIME('%m', T1.StartDate)) + STRFTIME('%d', T1.EndDate) - STRFTIME('%d', T1.StartDate)) AS REAL) / COUNT(T1.BusinessEntityID) FROM EmployeeDepartmentHistory AS T1 INNER JOIN Department AS T2 ON T1.DepartmentID = T2.DepartmentID WHERE T2.Name = 'Engineering' AND T1.EndDate IS NOT NULL",
        "target_query": "SELECT CAST(SUM(365 * (CAST(sys.timestamp_to_str(\"T1\".\"EndDate\", '%Y') AS INTEGER) - CAST(sys.timestamp_to_str(\"T1\".\"StartDate\", '%Y') AS INTEGER)) + 30 * (CAST(sys.timestamp_to_str(\"T1\".\"EndDate\", '%m') AS INTEGER) - CAST(sys.timestamp_to_str(\"T1\".\"StartDate\", '%m') AS INTEGER)) + (CAST(sys.timestamp_to_str(\"T1\".\"EndDate\", '%d') AS INTEGER) - CAST(sys.timestamp_to_str(\"T1\".\"StartDate\", '%d') AS INTEGER))) AS REAL) / COUNT(\"T1\".\"BusinessEntityID\") \nFROM \"EmployeeDepartmentHistory\" AS \"T1\" \nINNER JOIN \"Department\" AS \"T2\" ON \"T1\".\"DepartmentID\" = \"T2\".\"DepartmentID\" \nWHERE \"T2\".\"Name\" = 'Engineering' AND \"T1\".\"EndDate\" IS NOT NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 23,
                "end_index": 48,
                "dilatect_content": "STRFTIME('%Y', T1.EndDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 52,
                "end_index": 79,
                "dilatect_content": "STRFTIME('%Y', T1.StartDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 90,
                "end_index": 115,
                "dilatect_content": "STRFTIME('%m', T1.EndDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 119,
                "end_index": 146,
                "dilatect_content": "STRFTIME('%m', T1.StartDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 151,
                "end_index": 176,
                "dilatect_content": "STRFTIME('%d', T1.EndDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 152,
                "end_index": 207,
                "dilatect_content": "STRFTIME('%d', T1.StartDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `EmployeeDepartmentHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`DepartmentID`, integer, primary key)\n(`ShiftID`, integer, primary key)\n(`StartDate`, date, primary key)\n(`EndDate`, date)\n(`ModifiedDate`, datetime)\n",
            "Table: `Department`\nColumns:\n(`DepartmentID`, integer, primary key)\n(`Name`, text)\n(`GroupName`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"EmployeeDepartmentHistory\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"DepartmentID\", BIGINT, primary key)\n(\"ShiftID\", BIGINT, primary key)\n(\"StartDate\", DATE, primary key)\n(\"EndDate\", DATE)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"Department\"\nColumns:\n(\"DepartmentID\", BIGINT, primary key)\n(\"Name\", STRING)\n(\"GroupName\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 551,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT AVG(T3.Rate) FROM EmployeeDepartmentHistory AS T1 INNER JOIN Department AS T2 ON T1.DepartmentID = T2.DepartmentID INNER JOIN EmployeePayHistory AS T3 ON T1.BusinessEntityID = T3.BusinessEntityID WHERE T2.Name = 'Engineering' AND STRFTIME('%Y', EndDate) > '2007' AND STRFTIME('%Y', T1.StartDate) < '2007'",
        "target_query": "SELECT AVG(\"T3\".\"Rate\") FROM \"EmployeeDepartmentHistory\" AS \"T1\" INNER JOIN \"Department\" AS \"T2\" ON \"T1\".\"DepartmentID\" = \"T2\".\"DepartmentID\" INNER JOIN \"EmployeePayHistory\" AS \"T3\" ON \"T1\".\"BusinessEntityID\" = \"T3\".\"BusinessEntityID\" WHERE \"T2\".\"Name\" = 'Engineering' AND sys.timestamp_to_str(\"T1\".\"EndDate\", '%Y') > '2007' AND sys.timestamp_to_str(\"T1\".\"StartDate\", '%Y') < '2007';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 237,
                "end_index": 259,
                "dilatect_content": "STRFTIME('%Y', EndDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 274,
                "end_index": 301,
                "dilatect_content": "STRFTIME('%Y', T1.StartDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 309,
                "end_index": 354,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"EndDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 369,
                "end_index": 416,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"StartDate\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `EmployeeDepartmentHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`DepartmentID`, integer, primary key)\n(`ShiftID`, integer, primary key)\n(`StartDate`, date, primary key)\n(`EndDate`, date)\n(`ModifiedDate`, datetime)\n",
            "Table: `Department`\nColumns:\n(`DepartmentID`, integer, primary key)\n(`Name`, text)\n(`GroupName`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `EmployeePayHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`RateChangeDate`, datetime, primary key)\n(`Rate`, real)\n(`PayFrequency`, integer)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"EmployeeDepartmentHistory\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"DepartmentID\", BIGINT, primary key)\n(\"ShiftID\", BIGINT, primary key)\n(\"StartDate\", DATE, primary key)\n(\"EndDate\", DATE)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"Department\"\nColumns:\n(\"DepartmentID\", BIGINT, primary key)\n(\"Name\", STRING)\n(\"GroupName\", STRING)\n(\"ModifiedDate\", TIMESTAMP)\n",
            "Table: \"EmployeePayHistory\"\nColumns:\n(\"BusinessEntityID\", BIGINT, primary key)\n(\"RateChangeDate\", TIMESTAMP, primary key)\n(\"Rate\", DOUBLE PRECISION)\n(\"PayFrequency\", BIGINT)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 552,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT 365 * (STRFTIME('%Y', ActualEndDate) - STRFTIME('%Y', ActualStartDate)) + 30 * (STRFTIME('%m', ActualEndDate) - STRFTIME('%m', ActualStartDate)) + STRFTIME('%d', ActualEndDate) - STRFTIME('%d', ActualStartDate) FROM WorkOrderRouting WHERE WorkOrderID = 425",
        "target_query": "SELECT 365 * (CAST(sys.timestamp_to_str(\"ActualEndDate\", '%Y') AS INTEGER) - CAST(sys.timestamp_to_str(\"ActualStartDate\", '%Y') AS INTEGER)) + 30 * (CAST(sys.timestamp_to_str(\"ActualEndDate\", '%m') AS INTEGER) - CAST(sys.timestamp_to_str(\"ActualStartDate\", '%m') AS INTEGER)) + (CAST(sys.timestamp_to_str(\"ActualEndDate\", '%d') AS INTEGER) - CAST(sys.timestamp_to_str(\"ActualStartDate\", '%d') AS INTEGER)) FROM \"WorkOrderRouting\" WHERE \"WorkOrderID\" = 425;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 14,
                "end_index": 42,
                "dilatect_content": "STRFTIME('%Y', ActualEndDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 46,
                "end_index": 76,
                "dilatect_content": "STRFTIME('%Y', ActualStartDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 87,
                "end_index": 115,
                "dilatect_content": "STRFTIME('%m', ActualEndDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 119,
                "end_index": 149,
                "dilatect_content": "STRFTIME('%m', ActualStartDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 154,
                "end_index": 182,
                "dilatect_content": "STRFTIME('%d', ActualEndDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 186,
                "end_index": 216,
                "dilatect_content": "STRFTIME('%d', ActualStartDate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `WorkOrderRouting`\nColumns:\n(`WorkOrderID`, integer, primary key)\n(`ProductID`, integer, primary key)\n(`OperationSequence`, integer, primary key)\n(`LocationID`, integer)\n(`ScheduledStartDate`, datetime)\n(`ScheduledEndDate`, datetime)\n(`ActualStartDate`, datetime)\n(`ActualEndDate`, datetime)\n(`ActualResourceHrs`, real)\n(`PlannedCost`, real)\n(`ActualCost`, real)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"WorkOrderRouting\"\nColumns:\n(\"WorkOrderID\", BIGINT, primary key)\n(\"ProductID\", BIGINT, primary key)\n(\"OperationSequence\", BIGINT, primary key)\n(\"LocationID\", BIGINT)\n(\"ScheduledStartDate\", TIMESTAMP)\n(\"ScheduledEndDate\", TIMESTAMP)\n(\"ActualStartDate\", TIMESTAMP)\n(\"ActualEndDate\", TIMESTAMP)\n(\"ActualResourceHrs\", DOUBLE PRECISION)\n(\"PlannedCost\", DOUBLE PRECISION)\n(\"ActualCost\", DOUBLE PRECISION)\n(\"ModifiedDate\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 553,
        "database_name": "image_and_language",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(T1.IMG_ID = 1, 1, 0)), SUM(IIF(T1.X = 341 AND T1.Y = 27 AND T1.W = 42 AND T1.H = 51, 1, 0)) FROM IMG_OBJ AS T1 INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID",
        "target_query": "SELECT SUM(CASE WHEN \"T1\".\"IMG_ID\" = 1 THEN 1 ELSE 0 END), SUM(CASE WHEN \"T1\".\"X\" = 341 AND \"T1\".\"Y\" = 27 AND \"T1\".\"W\" = 42 AND \"T1\".\"H\" = 51 THEN 1 ELSE 0 END) FROM \"IMG_OBJ\" AS \"T1\" INNER JOIN \"OBJ_CLASSES\" AS \"T2\" ON \"T1\".\"OBJ_CLASS_ID\" = \"T2\".\"OBJ_CLASS_ID\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 34,
                "dilatect_content": "IIF(T1.IMG_ID = 1, 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 42,
                "end_index": 104,
                "dilatect_content": "IIF(T1.X = 341 AND T1.Y = 27 AND T1.W = 42 AND T1.H = 51, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 59,
                "dilatect_content": "CASE WHEN \"T1\".\"IMG_ID\" = 1 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 67,
                "end_index": 178,
                "dilatect_content": "CASE WHEN \"T1\".\"X\" = 341 AND \"T1\".\"Y\" = 27 AND \"T1\".\"W\" = 42 AND \"T1\".\"H\" = 51 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `IMG_OBJ`\nColumns:\n(`IMG_ID`, integer, primary key)\n(`OBJ_SAMPLE_ID`, integer, primary key)\n(`OBJ_CLASS_ID`, integer)\n(`X`, integer)\n(`Y`, integer)\n(`W`, integer)\n(`H`, integer)\n",
            "Table: `OBJ_CLASSES`\nColumns:\n(`OBJ_CLASS_ID`, integer, primary key)\n(`OBJ_CLASS`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"IMG_OBJ\"\nColumns:\n(\"IMG_ID\", BIGINT, primary key)\n(\"OBJ_SAMPLE_ID\", BIGINT, primary key)\n(\"OBJ_CLASS_ID\", BIGINT)\n(\"X\", BIGINT)\n(\"Y\", BIGINT)\n(\"W\", BIGINT)\n(\"H\", BIGINT)\n",
            "Table: \"OBJ_CLASSES\"\nColumns:\n(\"OBJ_CLASS_ID\", BIGINT, primary key)\n(\"OBJ_CLASS\", STRING)\n"
        ]
    },
    {
        "sql_id": 554,
        "database_name": "hockey",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.nameGiven, T1.height , T1.weight, STRFTIME('%Y', CURRENT_TIMESTAMP) - birthYear FROM Master AS T1 INNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID WHERE T2.tmID = 'COL' AND T2.year >= 2000 AND T2.year <= 2010 GROUP BY T1.playerID",
        "target_query": "SELECT MAX(\"T1\".\"nameGiven\") AS \"nameGiven\", MAX(\"T1\".\"height\") AS \"height\", MAX(\"T1\".\"weight\") AS \"weight\", CAST(sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y') AS INTEGER) - MAX(CAST(\"T1\".\"birthYear\" AS INTEGER)) AS \"age\" FROM \"Master\" AS \"T1\" INNER JOIN \"Goalies\" AS \"T2\" ON \"T1\".\"playerID\" = \"T2\".\"playerID\" WHERE \"T2\".\"tmID\" = 'COL' AND \"T2\".\"_year\" >= 2000 AND \"T2\".\"_year\" <= 2010 GROUP BY \"T1\".\"playerID\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 44,
                "end_index": 76,
                "dilatect_content": "STRFTIME('%Y', CURRENT_TIMESTAMP)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 132,
                "end_index": 176,
                "dilatect_content": "sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Master`\nColumns:\n(`playerID`, text)\n(`coachID`, text)\n(`hofID`, text)\n(`firstName`, text)\n(`lastName`, text)\n(`nameNote`, text)\n(`nameGiven`, text)\n(`nameNick`, text)\n(`height`, text)\n(`weight`, text)\n(`shootCatch`, text)\n(`legendsID`, text)\n(`ihdbID`, text)\n(`hrefID`, text)\n(`firstNHL`, text)\n(`lastNHL`, text)\n(`firstWHA`, text)\n(`lastWHA`, text)\n(`pos`, text)\n(`birthYear`, text)\n(`birthMon`, text)\n(`birthDay`, text)\n(`birthCountry`, text)\n(`birthState`, text)\n(`birthCity`, text)\n(`deathYear`, text)\n(`deathMon`, text)\n(`deathDay`, text)\n(`deathCountry`, text)\n(`deathState`, text)\n(`deathCity`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `Goalies`\nColumns:\n(`playerID`, text, primary key)\n(`year`, integer, primary key)\n(`stint`, integer, primary key)\n(`tmID`, text)\n(`lgID`, text)\n(`GP`, text)\n(`Min`, text)\n(`W`, text)\n(`L`, text)\n(`T/OL`, text)\n(`ENG`, text)\n(`SHO`, text)\n(`GA`, text)\n(`SA`, text)\n(`PostGP`, text)\n(`PostMin`, text)\n(`PostW`, text)\n(`PostL`, text)\n(`PostT`, text)\n(`PostENG`, text)\n(`PostSHO`, text)\n(`PostGA`, text)\n(`PostSA`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Master\"\nColumns:\n(\"playerID\", STRING)\n(\"coachID\", STRING)\n(\"hofID\", STRING)\n(\"firstName\", STRING)\n(\"lastName\", STRING)\n(\"nameNote\", STRING)\n(\"nameGiven\", STRING)\n(\"nameNick\", STRING)\n(\"height\", STRING)\n(\"weight\", STRING)\n(\"shootCatch\", STRING)\n(\"legendsID\", STRING)\n(\"ihdbID\", STRING)\n(\"hrefID\", STRING)\n(\"firstNHL\", STRING)\n(\"lastNHL\", STRING)\n(\"firstWHA\", STRING)\n(\"lastWHA\", STRING)\n(\"pos\", STRING)\n(\"birthYear\", STRING)\n(\"birthMon\", STRING)\n(\"birthDay\", STRING)\n(\"birthCountry\", STRING)\n(\"birthState\", STRING)\n(\"birthCity\", STRING)\n(\"deathYear\", STRING)\n(\"deathMon\", STRING)\n(\"deathDay\", STRING)\n(\"deathCountry\", STRING)\n(\"deathState\", STRING)\n(\"deathCity\", STRING)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"Goalies\"\nColumns:\n(\"playerID\", STRING, primary key)\n(\"_year\", BIGINT, primary key)\n(\"stint\", BIGINT, primary key)\n(\"tmID\", STRING)\n(\"lgID\", STRING)\n(\"GP\", STRING)\n(\"_Min\", STRING)\n(\"W\", STRING)\n(\"L\", STRING)\n(\"T_OL\", STRING)\n(\"ENG\", STRING)\n(\"SHO\", STRING)\n(\"GA\", STRING)\n(\"SA\", STRING)\n(\"PostGP\", STRING)\n(\"PostMin\", STRING)\n(\"PostW\", STRING)\n(\"PostL\", STRING)\n(\"PostT\", STRING)\n(\"PostENG\", STRING)\n(\"PostSHO\", STRING)\n(\"PostGA\", STRING)\n(\"PostSA\", STRING)\n"
        ]
    },
    {
        "sql_id": 555,
        "database_name": "hockey",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT AVG(IIF(birthYear < 1990, height, NULL)) - AVG(IIF(birthYear >= 1990, height, NULL)) FROM Master",
        "target_query": "SELECT AVG(CASE WHEN \"birthYear\" < 1990 THEN \"height\" ELSE NULL END) - AVG(CASE WHEN \"birthYear\" >= 1990 THEN \"height\" ELSE NULL END) FROM \"Master\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 45,
                "dilatect_content": "IIF(birthYear < 1990, height, NULL)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 54,
                "end_index": 89,
                "dilatect_content": "IIF(birthYear >= 1990, height, NULL)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 70,
                "dilatect_content": "CASE WHEN \"birthYear\" < 1990 THEN \"height\" ELSE NULL END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 79,
                "end_index": 139,
                "dilatect_content": "CASE WHEN \"birthYear\" >= 1990 THEN \"height\" ELSE NULL END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Master`\nColumns:\n(`playerID`, text)\n(`coachID`, text)\n(`hofID`, text)\n(`firstName`, text)\n(`lastName`, text)\n(`nameNote`, text)\n(`nameGiven`, text)\n(`nameNick`, text)\n(`height`, text)\n(`weight`, text)\n(`shootCatch`, text)\n(`legendsID`, text)\n(`ihdbID`, text)\n(`hrefID`, text)\n(`firstNHL`, text)\n(`lastNHL`, text)\n(`firstWHA`, text)\n(`lastWHA`, text)\n(`pos`, text)\n(`birthYear`, text)\n(`birthMon`, text)\n(`birthDay`, text)\n(`birthCountry`, text)\n(`birthState`, text)\n(`birthCity`, text)\n(`deathYear`, text)\n(`deathMon`, text)\n(`deathDay`, text)\n(`deathCountry`, text)\n(`deathState`, text)\n(`deathCity`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"Master\"\nColumns:\n(\"playerID\", STRING)\n(\"coachID\", STRING)\n(\"hofID\", STRING)\n(\"firstName\", STRING)\n(\"lastName\", STRING)\n(\"nameNote\", STRING)\n(\"nameGiven\", STRING)\n(\"nameNick\", STRING)\n(\"height\", STRING)\n(\"weight\", STRING)\n(\"shootCatch\", STRING)\n(\"legendsID\", STRING)\n(\"ihdbID\", STRING)\n(\"hrefID\", STRING)\n(\"firstNHL\", STRING)\n(\"lastNHL\", STRING)\n(\"firstWHA\", STRING)\n(\"lastWHA\", STRING)\n(\"pos\", STRING)\n(\"birthYear\", STRING)\n(\"birthMon\", STRING)\n(\"birthDay\", STRING)\n(\"birthCountry\", STRING)\n(\"birthState\", STRING)\n(\"birthCity\", STRING)\n(\"deathYear\", STRING)\n(\"deathMon\", STRING)\n(\"deathDay\", STRING)\n(\"deathCountry\", STRING)\n(\"deathState\", STRING)\n(\"deathCity\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 556,
        "database_name": "hockey",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT IIF(T1.note = 'posthumous', 'YES', 'NO') FROM AwardsMisc AS T1 RIGHT JOIN Master AS T2 ON T1.ID = T2.playerID WHERE T2.legendsID = 'P194502'",
        "target_query": "SELECT CASE WHEN \"T1\".\"note\" = 'posthumous' THEN 'YES' ELSE 'NO' END FROM \"AwardsMisc\" AS \"T1\" RIGHT JOIN \"Master\" AS \"T2\" ON \"T1\".\"ID\" = \"T2\".\"playerID\" WHERE \"T2\".\"legendsID\" = 'P194502';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 46,
                "dilatect_content": "IIF(T1.note = 'posthumous', 'YES', 'NO')",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 71,
                "dilatect_content": "CASE WHEN \"T1\".\"note\" = 'posthumous' THEN 'YES' ELSE 'NO' END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `AwardsMisc`\nColumns:\n(`name`, text, primary key)\n(`ID`, text)\n(`award`, text)\n(`year`, integer)\n(`lgID`, text)\n(`note`, text)\n",
            "Table: `Master`\nColumns:\n(`playerID`, text)\n(`coachID`, text)\n(`hofID`, text)\n(`firstName`, text)\n(`lastName`, text)\n(`nameNote`, text)\n(`nameGiven`, text)\n(`nameNick`, text)\n(`height`, text)\n(`weight`, text)\n(`shootCatch`, text)\n(`legendsID`, text)\n(`ihdbID`, text)\n(`hrefID`, text)\n(`firstNHL`, text)\n(`lastNHL`, text)\n(`firstWHA`, text)\n(`lastWHA`, text)\n(`pos`, text)\n(`birthYear`, text)\n(`birthMon`, text)\n(`birthDay`, text)\n(`birthCountry`, text)\n(`birthState`, text)\n(`birthCity`, text)\n(`deathYear`, text)\n(`deathMon`, text)\n(`deathDay`, text)\n(`deathCountry`, text)\n(`deathState`, text)\n(`deathCity`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"AwardsMisc\"\nColumns:\n(\"name\", STRING, primary key)\n(\"ID\", STRING)\n(\"award\", STRING)\n(\"_year\", BIGINT)\n(\"lgID\", STRING)\n(\"note\", STRING)\n",
            "Table: \"Master\"\nColumns:\n(\"playerID\", STRING)\n(\"coachID\", STRING)\n(\"hofID\", STRING)\n(\"firstName\", STRING)\n(\"lastName\", STRING)\n(\"nameNote\", STRING)\n(\"nameGiven\", STRING)\n(\"nameNick\", STRING)\n(\"height\", STRING)\n(\"weight\", STRING)\n(\"shootCatch\", STRING)\n(\"legendsID\", STRING)\n(\"ihdbID\", STRING)\n(\"hrefID\", STRING)\n(\"firstNHL\", STRING)\n(\"lastNHL\", STRING)\n(\"firstWHA\", STRING)\n(\"lastWHA\", STRING)\n(\"pos\", STRING)\n(\"birthYear\", STRING)\n(\"birthMon\", STRING)\n(\"birthDay\", STRING)\n(\"birthCountry\", STRING)\n(\"birthState\", STRING)\n(\"birthCity\", STRING)\n(\"deathYear\", STRING)\n(\"deathMon\", STRING)\n(\"deathDay\", STRING)\n(\"deathCountry\", STRING)\n(\"deathState\", STRING)\n(\"deathCity\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 557,
        "database_name": "hockey",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.firstName, T2.lastName , IIF(T1.tmID = 'BOS', 'YES', 'NO') FROM Goalies AS T1 INNER JOIN Master AS T2 ON T1.playerID = T2.playerID WHERE T1.year = 1972 AND T1.tmID = 'BOS' AND T2.coachID IS NOT NULL AND T2.hofID IS NULL",
        "target_query": "SELECT \"T2\".\"firstName\", \"T2\".\"lastName\", CASE WHEN \"T1\".\"tmID\" = 'BOS' THEN 'YES' ELSE 'NO' END FROM \"Goalies\" AS \"T1\" INNER JOIN \"Master\" AS \"T2\" ON \"T1\".\"playerID\" = \"T2\".\"playerID\" WHERE \"T1\".\"_year\" = 1972 AND \"T1\".\"tmID\" = 'BOS' AND \"T2\".\"coachID\" IS NOT NULL AND \"T2\".\"hofID\" IS NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 35,
                "end_index": 67,
                "dilatect_content": "IIF(T1.tmID = 'BOS', 'YES', 'NO')",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 50,
                "end_index": 107,
                "dilatect_content": "CASE WHEN \"T1\".\"tmID\" = 'BOS' THEN 'YES' ELSE 'NO' END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Goalies`\nColumns:\n(`playerID`, text, primary key)\n(`year`, integer, primary key)\n(`stint`, integer, primary key)\n(`tmID`, text)\n(`lgID`, text)\n(`GP`, text)\n(`Min`, text)\n(`W`, text)\n(`L`, text)\n(`T/OL`, text)\n(`ENG`, text)\n(`SHO`, text)\n(`GA`, text)\n(`SA`, text)\n(`PostGP`, text)\n(`PostMin`, text)\n(`PostW`, text)\n(`PostL`, text)\n(`PostT`, text)\n(`PostENG`, text)\n(`PostSHO`, text)\n(`PostGA`, text)\n(`PostSA`, text)\n",
            "Table: `Master`\nColumns:\n(`playerID`, text)\n(`coachID`, text)\n(`hofID`, text)\n(`firstName`, text)\n(`lastName`, text)\n(`nameNote`, text)\n(`nameGiven`, text)\n(`nameNick`, text)\n(`height`, text)\n(`weight`, text)\n(`shootCatch`, text)\n(`legendsID`, text)\n(`ihdbID`, text)\n(`hrefID`, text)\n(`firstNHL`, text)\n(`lastNHL`, text)\n(`firstWHA`, text)\n(`lastWHA`, text)\n(`pos`, text)\n(`birthYear`, text)\n(`birthMon`, text)\n(`birthDay`, text)\n(`birthCountry`, text)\n(`birthState`, text)\n(`birthCity`, text)\n(`deathYear`, text)\n(`deathMon`, text)\n(`deathDay`, text)\n(`deathCountry`, text)\n(`deathState`, text)\n(`deathCity`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"Goalies\"\nColumns:\n(\"playerID\", STRING, primary key)\n(\"_year\", BIGINT, primary key)\n(\"stint\", BIGINT, primary key)\n(\"tmID\", STRING)\n(\"lgID\", STRING)\n(\"GP\", STRING)\n(\"_Min\", STRING)\n(\"W\", STRING)\n(\"L\", STRING)\n(\"T_OL\", STRING)\n(\"ENG\", STRING)\n(\"SHO\", STRING)\n(\"GA\", STRING)\n(\"SA\", STRING)\n(\"PostGP\", STRING)\n(\"PostMin\", STRING)\n(\"PostW\", STRING)\n(\"PostL\", STRING)\n(\"PostT\", STRING)\n(\"PostENG\", STRING)\n(\"PostSHO\", STRING)\n(\"PostGA\", STRING)\n(\"PostSA\", STRING)\n",
            "Table: \"Master\"\nColumns:\n(\"playerID\", STRING)\n(\"coachID\", STRING)\n(\"hofID\", STRING)\n(\"firstName\", STRING)\n(\"lastName\", STRING)\n(\"nameNote\", STRING)\n(\"nameGiven\", STRING)\n(\"nameNick\", STRING)\n(\"height\", STRING)\n(\"weight\", STRING)\n(\"shootCatch\", STRING)\n(\"legendsID\", STRING)\n(\"ihdbID\", STRING)\n(\"hrefID\", STRING)\n(\"firstNHL\", STRING)\n(\"lastNHL\", STRING)\n(\"firstWHA\", STRING)\n(\"lastWHA\", STRING)\n(\"pos\", STRING)\n(\"birthYear\", STRING)\n(\"birthMon\", STRING)\n(\"birthDay\", STRING)\n(\"birthCountry\", STRING)\n(\"birthState\", STRING)\n(\"birthCity\", STRING)\n(\"deathYear\", STRING)\n(\"deathMon\", STRING)\n(\"deathDay\", STRING)\n(\"deathCountry\", STRING)\n(\"deathState\", STRING)\n(\"deathCity\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 558,
        "database_name": "hockey",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(T2.G), STRFTIME('%Y', CURRENT_TIMESTAMP) - T1.birthyear FROM Master AS T1 INNER JOIN Scoring AS T2 ON T1.playerID = T2.playerID WHERE T1.playerID = 'aaltoan01' GROUP BY T1.birthyear",
        "target_query": "SELECT SUM(T2.\"G\"), CAST(sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y') AS INTEGER) - CAST(T1.\"birthYear\" AS INTEGER) FROM \"Master\" AS T1 INNER JOIN \"Scoring\" AS T2 ON T1.\"playerID\" = T2.\"playerID\" WHERE T1.\"playerID\" = 'aaltoan01' GROUP BY T1.\"birthYear\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 18,
                "end_index": 50,
                "dilatect_content": "STRFTIME('%Y', CURRENT_TIMESTAMP)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 27,
                "end_index": 71,
                "dilatect_content": "sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Master`\nColumns:\n(`playerID`, text)\n(`coachID`, text)\n(`hofID`, text)\n(`firstName`, text)\n(`lastName`, text)\n(`nameNote`, text)\n(`nameGiven`, text)\n(`nameNick`, text)\n(`height`, text)\n(`weight`, text)\n(`shootCatch`, text)\n(`legendsID`, text)\n(`ihdbID`, text)\n(`hrefID`, text)\n(`firstNHL`, text)\n(`lastNHL`, text)\n(`firstWHA`, text)\n(`lastWHA`, text)\n(`pos`, text)\n(`birthYear`, text)\n(`birthMon`, text)\n(`birthDay`, text)\n(`birthCountry`, text)\n(`birthState`, text)\n(`birthCity`, text)\n(`deathYear`, text)\n(`deathMon`, text)\n(`deathDay`, text)\n(`deathCountry`, text)\n(`deathState`, text)\n(`deathCity`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `Scoring`\nColumns:\n(`playerID`, text)\n(`year`, integer)\n(`stint`, integer)\n(`tmID`, text)\n(`lgID`, text)\n(`pos`, text)\n(`GP`, integer)\n(`G`, integer)\n(`A`, integer)\n(`Pts`, integer)\n(`PIM`, integer)\n(`+/-`, text)\n(`PPG`, text)\n(`PPA`, text)\n(`SHG`, text)\n(`SHA`, text)\n(`GWG`, text)\n(`GTG`, text)\n(`SOG`, text)\n(`PostGP`, text)\n(`PostG`, text)\n(`PostA`, text)\n(`PostPts`, text)\n(`PostPIM`, text)\n(`Post+/-`, text)\n(`PostPPG`, text)\n(`PostPPA`, text)\n(`PostSHG`, text)\n(`PostSHA`, text)\n(`PostGWG`, text)\n(`PostSOG`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"Master\"\nColumns:\n(\"playerID\", STRING)\n(\"coachID\", STRING)\n(\"hofID\", STRING)\n(\"firstName\", STRING)\n(\"lastName\", STRING)\n(\"nameNote\", STRING)\n(\"nameGiven\", STRING)\n(\"nameNick\", STRING)\n(\"height\", STRING)\n(\"weight\", STRING)\n(\"shootCatch\", STRING)\n(\"legendsID\", STRING)\n(\"ihdbID\", STRING)\n(\"hrefID\", STRING)\n(\"firstNHL\", STRING)\n(\"lastNHL\", STRING)\n(\"firstWHA\", STRING)\n(\"lastWHA\", STRING)\n(\"pos\", STRING)\n(\"birthYear\", STRING)\n(\"birthMon\", STRING)\n(\"birthDay\", STRING)\n(\"birthCountry\", STRING)\n(\"birthState\", STRING)\n(\"birthCity\", STRING)\n(\"deathYear\", STRING)\n(\"deathMon\", STRING)\n(\"deathDay\", STRING)\n(\"deathCountry\", STRING)\n(\"deathState\", STRING)\n(\"deathCity\", STRING)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"Scoring\"\nColumns:\n(\"playerID\", STRING)\n(\"_year\", BIGINT)\n(\"stint\", BIGINT)\n(\"tmID\", STRING)\n(\"lgID\", STRING)\n(\"pos\", STRING)\n(\"GP\", BIGINT)\n(\"G\", BIGINT)\n(\"A\", BIGINT)\n(\"Pts\", BIGINT)\n(\"PIM\", BIGINT)\n(\"___\", STRING)\n(\"PPG\", STRING)\n(\"PPA\", STRING)\n(\"SHG\", STRING)\n(\"SHA\", STRING)\n(\"GWG\", STRING)\n(\"GTG\", STRING)\n(\"SOG\", STRING)\n(\"PostGP\", STRING)\n(\"PostG\", STRING)\n(\"PostA\", STRING)\n(\"PostPts\", STRING)\n(\"PostPIM\", STRING)\n(\"Post___\", STRING)\n(\"PostPPG\", STRING)\n(\"PostPPA\", STRING)\n(\"PostSHG\", STRING)\n(\"PostSHA\", STRING)\n(\"PostGWG\", STRING)\n(\"PostSOG\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 559,
        "database_name": "world",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.Language = 'English', 1, 0)) AS REAL) * 100 / COUNT(T1.Code) FROM Country AS T1 INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"Language\" = 'English' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"Code\") FROM \"Country\" AS \"T1\" INNER JOIN \"CountryLanguage\" AS \"T2\" ON \"T1\".\"Code\" = \"T2\".\"CountryCode\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 49,
                "dilatect_content": "IIF(T2.Language = 'English', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 74,
                "dilatect_content": "CASE WHEN \"T2\".\"Language\" = 'English' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Country`\nColumns:\n(`Code`, text, primary key)\n(`Name`, text)\n(`Continent`, text)\n(`Region`, text)\n(`SurfaceArea`, real)\n(`IndepYear`, integer)\n(`Population`, integer)\n(`LifeExpectancy`, real)\n(`GNP`, real)\n(`GNPOld`, real)\n(`LocalName`, text)\n(`GovernmentForm`, text)\n(`HeadOfState`, text)\n(`Capital`, integer)\n(`Code2`, text)\n",
            "Table: `CountryLanguage`\nColumns:\n(`CountryCode`, text, primary key)\n(`Language`, text, primary key)\n(`IsOfficial`, text)\n(`Percentage`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"Country\"\nColumns:\n(\"Code\", STRING, primary key)\n(\"Name\", STRING)\n(\"Continent\", STRING)\n(\"Region\", STRING)\n(\"SurfaceArea\", DOUBLE PRECISION)\n(\"IndepYear\", BIGINT)\n(\"Population\", BIGINT)\n(\"LifeExpectancy\", DOUBLE PRECISION)\n(\"GNP\", DOUBLE PRECISION)\n(\"GNPOld\", DOUBLE PRECISION)\n(\"LocalName\", STRING)\n(\"GovernmentForm\", STRING)\n(\"HeadOfState\", STRING)\n(\"Capital\", BIGINT)\n(\"Code2\", STRING)\n",
            "Table: \"CountryLanguage\"\nColumns:\n(\"CountryCode\", STRING, primary key)\n(\"Language\", STRING, primary key)\n(\"IsOfficial\", STRING)\n(\"Percentage\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 560,
        "database_name": "world",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.Language = 'English', 1, 0)) AS REAL) * 100 / COUNT(T1.Code) FROM Country AS T1 INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE T1.GNP > 1500",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"Language\" = 'English' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"Code\") FROM \"Country\" AS \"T1\" INNER JOIN \"CountryLanguage\" AS \"T2\" ON \"T1\".\"Code\" = \"T2\".\"CountryCode\" WHERE \"T1\".\"GNP\" > 1500;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 49,
                "dilatect_content": "IIF(T2.Language = 'English', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 74,
                "dilatect_content": "CASE WHEN \"T2\".\"Language\" = 'English' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Country`\nColumns:\n(`Code`, text, primary key)\n(`Name`, text)\n(`Continent`, text)\n(`Region`, text)\n(`SurfaceArea`, real)\n(`IndepYear`, integer)\n(`Population`, integer)\n(`LifeExpectancy`, real)\n(`GNP`, real)\n(`GNPOld`, real)\n(`LocalName`, text)\n(`GovernmentForm`, text)\n(`HeadOfState`, text)\n(`Capital`, integer)\n(`Code2`, text)\n",
            "Table: `CountryLanguage`\nColumns:\n(`CountryCode`, text, primary key)\n(`Language`, text, primary key)\n(`IsOfficial`, text)\n(`Percentage`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"Country\"\nColumns:\n(\"Code\", STRING, primary key)\n(\"Name\", STRING)\n(\"Continent\", STRING)\n(\"Region\", STRING)\n(\"SurfaceArea\", DOUBLE PRECISION)\n(\"IndepYear\", BIGINT)\n(\"Population\", BIGINT)\n(\"LifeExpectancy\", DOUBLE PRECISION)\n(\"GNP\", DOUBLE PRECISION)\n(\"GNPOld\", DOUBLE PRECISION)\n(\"LocalName\", STRING)\n(\"GovernmentForm\", STRING)\n(\"HeadOfState\", STRING)\n(\"Capital\", BIGINT)\n(\"Code2\", STRING)\n",
            "Table: \"CountryLanguage\"\nColumns:\n(\"CountryCode\", STRING, primary key)\n(\"Language\", STRING, primary key)\n(\"IsOfficial\", STRING)\n(\"Percentage\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 561,
        "database_name": "world",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.Language = 'Chinese', T1.SurfaceArea, 0)) AS REAL) * 100 / SUM(T1.SurfaceArea) FROM Country AS T1 INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"Language\" = 'Chinese' THEN \"T1\".\"SurfaceArea\" ELSE 0 END) AS REAL) * 100 / SUM(\"T1\".\"SurfaceArea\") FROM \"Country\" AS \"T1\" INNER JOIN \"CountryLanguage\" AS \"T2\" ON \"T1\".\"Code\" = \"T2\".\"CountryCode\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 62,
                "dilatect_content": "IIF(T2.Language = 'Chinese', T1.SurfaceArea, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 95,
                "dilatect_content": "CASE WHEN \"T2\".\"Language\" = 'Chinese' THEN \"T1\".\"SurfaceArea\" ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Country`\nColumns:\n(`Code`, text, primary key)\n(`Name`, text)\n(`Continent`, text)\n(`Region`, text)\n(`SurfaceArea`, real)\n(`IndepYear`, integer)\n(`Population`, integer)\n(`LifeExpectancy`, real)\n(`GNP`, real)\n(`GNPOld`, real)\n(`LocalName`, text)\n(`GovernmentForm`, text)\n(`HeadOfState`, text)\n(`Capital`, integer)\n(`Code2`, text)\n",
            "Table: `CountryLanguage`\nColumns:\n(`CountryCode`, text, primary key)\n(`Language`, text, primary key)\n(`IsOfficial`, text)\n(`Percentage`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"Country\"\nColumns:\n(\"Code\", STRING, primary key)\n(\"Name\", STRING)\n(\"Continent\", STRING)\n(\"Region\", STRING)\n(\"SurfaceArea\", DOUBLE PRECISION)\n(\"IndepYear\", BIGINT)\n(\"Population\", BIGINT)\n(\"LifeExpectancy\", DOUBLE PRECISION)\n(\"GNP\", DOUBLE PRECISION)\n(\"GNPOld\", DOUBLE PRECISION)\n(\"LocalName\", STRING)\n(\"GovernmentForm\", STRING)\n(\"HeadOfState\", STRING)\n(\"Capital\", BIGINT)\n(\"Code2\", STRING)\n",
            "Table: \"CountryLanguage\"\nColumns:\n(\"CountryCode\", STRING, primary key)\n(\"Language\", STRING, primary key)\n(\"IsOfficial\", STRING)\n(\"Percentage\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 562,
        "database_name": "music_platform_2",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT title FROM reviews ORDER BY LENGTH(content) DESC LIMIT 1",
        "target_query": "SELECT \"title\" FROM \"reviews\" ORDER BY length(\"content\") DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 35,
                "end_index": 49,
                "dilatect_content": "LENGTH(content)",
                "feature": "length(X)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 43,
                "end_index": 61,
                "dilatect_content": "length(\"content\")",
                "feature": "length(X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "length(X)",
                "explanation": "MonetDB supports the length() function for both string and BLOB values. For a string value X, the function returns the number of characters (code points) in the string. For a BLOB value, it returns the byte-length of the BLOB.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `reviews`\nColumns:\n(`podcast_id`, text)\n(`title`, text)\n(`content`, text)\n(`rating`, integer)\n(`author_id`, text)\n(`created_at`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"reviews\"\nColumns:\n(\"podcast_id\", STRING)\n(\"title\", STRING)\n(\"content\", STRING)\n(\"rating\", BIGINT)\n(\"author_id\", STRING)\n(\"created_at\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 563,
        "database_name": "music_platform_2",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.title FROM categories AS T1 INNER JOIN podcasts AS T2 ON T2.podcast_id = T1.podcast_id WHERE T1.category = 'music' ORDER BY LENGTH(T2.title) DESC LIMIT 1",
        "target_query": "SELECT \"T2\".\"title\" FROM \"categories\" AS \"T1\" INNER JOIN \"podcasts\" AS \"T2\" ON \"T2\".\"podcast_id\" = \"T1\".\"podcast_id\" WHERE \"T1\".\"category\" = 'music' ORDER BY length(\"T2\".\"title\") DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 134,
                "end_index": 149,
                "dilatect_content": "LENGTH(T2.title)",
                "feature": "length(X)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 182,
                "end_index": 205,
                "dilatect_content": "length(\"T2\".\"title\")",
                "feature": "length(X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "length(X)",
                "explanation": "MonetDB supports the length() function for both string and BLOB values. For a string value X, the function returns the number of characters (code points) in the string. For a BLOB value, it returns the byte-length of the BLOB.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `categories`\nColumns:\n(`podcast_id`, text, primary key)\n(`category`, text, primary key)\n",
            "Table: `podcasts`\nColumns:\n(`podcast_id`, text, primary key)\n(`itunes_id`, integer)\n(`slug`, text)\n(`itunes_url`, text)\n(`title`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"categories\"\nColumns:\n(\"podcast_id\", STRING, primary key)\n(\"category\", STRING, primary key)\n",
            "Table: \"podcasts\"\nColumns:\n(\"podcast_id\", STRING, primary key)\n(\"itunes_id\", BIGINT)\n(\"slug\", STRING)\n(\"itunes_url\", STRING)\n(\"title\", STRING)\n"
        ]
    },
    {
        "sql_id": 564,
        "database_name": "sales_in_weather",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(units) FROM sales_in_weather WHERE SUBSTR(`date`, 6, 2) = '01' AND SUBSTR(`date`, 1, 4) = '2012' AND item_nbr = 9 AND store_nbr = 1",
        "target_query": "SELECT SUM(\"units\") FROM \"sales_in_weather\" WHERE substring(\"_date\" from 6 for 2) = '01' AND substring(\"_date\" from 1 for 4) = '2012' AND \"item_nbr\" = 9 AND \"store_nbr\" = 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 46,
                "end_index": 65,
                "dilatect_content": "SUBSTR(`date`, 6, 2)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 78,
                "end_index": 97,
                "dilatect_content": "SUBSTR(`date`, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 54,
                "end_index": 86,
                "dilatect_content": "substring(\"_date\" from 6 for 2)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 99,
                "end_index": 131,
                "dilatect_content": "substring(\"_date\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `sales_in_weather`\nColumns:\n(`date`, date, primary key)\n(`store_nbr`, integer, primary key)\n(`item_nbr`, integer, primary key)\n(`units`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"sales_in_weather\"\nColumns:\n(\"_date\", DATE, primary key)\n(\"store_nbr\", BIGINT, primary key)\n(\"item_nbr\", BIGINT, primary key)\n(\"units\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 565,
        "database_name": "sales_in_weather",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(CASE WHEN T3.depart < 0 THEN units ELSE 0 END) AS sum FROM sales_in_weather AS T1 INNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr INNER JOIN weather AS T3 ON T2.station_nbr = T3.station_nbr WHERE T2.store_nbr = 3 AND SUBSTR(T1.`date`, 1, 4) = '2012' AND T1.item_nbr = 5",
        "target_query": "SELECT SUM(CASE WHEN T3.\"depart\" < 0 THEN T1.\"units\" ELSE 0 END) AS \"sum\" FROM \"sales_in_weather\" AS T1 INNER JOIN \"relation\" AS T2 ON T1.\"store_nbr\" = T2.\"store_nbr\" INNER JOIN \"weather\" AS T3 ON T2.\"station_nbr\" = T3.\"station_nbr\" WHERE T2.\"store_nbr\" = 3 AND substring(T1.\"_date\" from 1 for 4) = '2012' AND T1.\"item_nbr\" = 5;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 237,
                "end_index": 259,
                "dilatect_content": "SUBSTR(T1.`date`, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 284,
                "end_index": 319,
                "dilatect_content": "substring(T1.\"_date\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `sales_in_weather`\nColumns:\n(`date`, date, primary key)\n(`store_nbr`, integer, primary key)\n(`item_nbr`, integer, primary key)\n(`units`, integer)\n",
            "Table: `relation`\nColumns:\n(`store_nbr`, integer, primary key)\n(`station_nbr`, integer)\n",
            "Table: `weather`\nColumns:\n(`station_nbr`, integer, primary key)\n(`date`, date, primary key)\n(`tmax`, integer)\n(`tmin`, integer)\n(`tavg`, integer)\n(`depart`, integer)\n(`dewpoint`, integer)\n(`wetbulb`, integer)\n(`heat`, integer)\n(`cool`, integer)\n(`sunrise`, text)\n(`sunset`, text)\n(`codesum`, text)\n(`snowfall`, real)\n(`preciptotal`, real)\n(`stnpressure`, real)\n(`sealevel`, real)\n(`resultspeed`, real)\n(`resultdir`, integer)\n(`avgspeed`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"sales_in_weather\"\nColumns:\n(\"_date\", DATE, primary key)\n(\"store_nbr\", BIGINT, primary key)\n(\"item_nbr\", BIGINT, primary key)\n(\"units\", BIGINT)\n",
            "Table: \"relation\"\nColumns:\n(\"store_nbr\", BIGINT, primary key)\n(\"station_nbr\", BIGINT)\n",
            "Table: \"weather\"\nColumns:\n(\"station_nbr\", BIGINT, primary key)\n(\"_date\", DATE, primary key)\n(\"tmax\", BIGINT)\n(\"tmin\", BIGINT)\n(\"tavg\", BIGINT)\n(\"depart\", BIGINT)\n(\"dewpoint\", BIGINT)\n(\"wetbulb\", BIGINT)\n(\"heat\", BIGINT)\n(\"cool\", BIGINT)\n(\"sunrise\", STRING)\n(\"sunset\", STRING)\n(\"codesum\", STRING)\n(\"snowfall\", DOUBLE PRECISION)\n(\"preciptotal\", DOUBLE PRECISION)\n(\"stnpressure\", DOUBLE PRECISION)\n(\"sealevel\", DOUBLE PRECISION)\n(\"resultspeed\", DOUBLE PRECISION)\n(\"resultdir\", BIGINT)\n(\"avgspeed\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 566,
        "database_name": "sales_in_weather",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.units FROM sales_in_weather AS T1 INNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr INNER JOIN weather AS T3 ON T2.station_nbr = T3.station_nbr WHERE T2.store_nbr = 3 AND SUBSTR(T1.`date`, 1, 4) = '2012' AND T1.item_nbr = 5 ORDER BY tmax DESC LIMIT 1",
        "target_query": "SELECT T1.units FROM \"sales_in_weather\" AS T1 INNER JOIN \"relation\" AS T2 ON T1.store_nbr = T2.store_nbr INNER JOIN \"weather\" AS T3 ON T2.station_nbr = T3.station_nbr WHERE T2.store_nbr = 3 AND substring(T1.\"_date\" from 1 for 4) = '2012' AND T1.item_nbr = 5 ORDER BY T3.tmax DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 188,
                "end_index": 210,
                "dilatect_content": "SUBSTR(T1.`date`, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 200,
                "end_index": 235,
                "dilatect_content": "substring(T1.\"_date\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `sales_in_weather`\nColumns:\n(`date`, date, primary key)\n(`store_nbr`, integer, primary key)\n(`item_nbr`, integer, primary key)\n(`units`, integer)\n",
            "Table: `relation`\nColumns:\n(`store_nbr`, integer, primary key)\n(`station_nbr`, integer)\n",
            "Table: `weather`\nColumns:\n(`station_nbr`, integer, primary key)\n(`date`, date, primary key)\n(`tmax`, integer)\n(`tmin`, integer)\n(`tavg`, integer)\n(`depart`, integer)\n(`dewpoint`, integer)\n(`wetbulb`, integer)\n(`heat`, integer)\n(`cool`, integer)\n(`sunrise`, text)\n(`sunset`, text)\n(`codesum`, text)\n(`snowfall`, real)\n(`preciptotal`, real)\n(`stnpressure`, real)\n(`sealevel`, real)\n(`resultspeed`, real)\n(`resultdir`, integer)\n(`avgspeed`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"sales_in_weather\"\nColumns:\n(\"_date\", DATE, primary key)\n(\"store_nbr\", BIGINT, primary key)\n(\"item_nbr\", BIGINT, primary key)\n(\"units\", BIGINT)\n",
            "Table: \"relation\"\nColumns:\n(\"store_nbr\", BIGINT, primary key)\n(\"station_nbr\", BIGINT)\n",
            "Table: \"weather\"\nColumns:\n(\"station_nbr\", BIGINT, primary key)\n(\"_date\", DATE, primary key)\n(\"tmax\", BIGINT)\n(\"tmin\", BIGINT)\n(\"tavg\", BIGINT)\n(\"depart\", BIGINT)\n(\"dewpoint\", BIGINT)\n(\"wetbulb\", BIGINT)\n(\"heat\", BIGINT)\n(\"cool\", BIGINT)\n(\"sunrise\", STRING)\n(\"sunset\", STRING)\n(\"codesum\", STRING)\n(\"snowfall\", DOUBLE PRECISION)\n(\"preciptotal\", DOUBLE PRECISION)\n(\"stnpressure\", DOUBLE PRECISION)\n(\"sealevel\", DOUBLE PRECISION)\n(\"resultspeed\", DOUBLE PRECISION)\n(\"resultdir\", BIGINT)\n(\"avgspeed\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 567,
        "database_name": "sales_in_weather",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT dewpoint FROM sales_in_weather AS T1 INNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr INNER JOIN weather AS T3 ON T2.station_nbr = T3.station_nbr WHERE T2.store_nbr = 3 AND SUBSTR(T1.`date`, 1, 4) = '2012' AND T1.item_nbr = 5 ORDER BY units DESC LIMIT 1",
        "target_query": "SELECT \"dewpoint\" FROM \"sales_in_weather\" AS T1 INNER JOIN \"relation\" AS T2 ON T1.\"store_nbr\" = T2.\"store_nbr\" INNER JOIN \"weather\" AS T3 ON T2.\"station_nbr\" = T3.\"station_nbr\" WHERE T2.\"store_nbr\" = 3 AND substring(T1.\"_date\" from 1 for 4) = '2012' AND T1.\"item_nbr\" = 5 ORDER BY T1.\"units\" DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 188,
                "end_index": 210,
                "dilatect_content": "SUBSTR(T1.`date`, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 224,
                "end_index": 259,
                "dilatect_content": "substring(T1.\"_date\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `sales_in_weather`\nColumns:\n(`date`, date, primary key)\n(`store_nbr`, integer, primary key)\n(`item_nbr`, integer, primary key)\n(`units`, integer)\n",
            "Table: `relation`\nColumns:\n(`store_nbr`, integer, primary key)\n(`station_nbr`, integer)\n",
            "Table: `weather`\nColumns:\n(`station_nbr`, integer, primary key)\n(`date`, date, primary key)\n(`tmax`, integer)\n(`tmin`, integer)\n(`tavg`, integer)\n(`depart`, integer)\n(`dewpoint`, integer)\n(`wetbulb`, integer)\n(`heat`, integer)\n(`cool`, integer)\n(`sunrise`, text)\n(`sunset`, text)\n(`codesum`, text)\n(`snowfall`, real)\n(`preciptotal`, real)\n(`stnpressure`, real)\n(`sealevel`, real)\n(`resultspeed`, real)\n(`resultdir`, integer)\n(`avgspeed`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"sales_in_weather\"\nColumns:\n(\"_date\", DATE, primary key)\n(\"store_nbr\", BIGINT, primary key)\n(\"item_nbr\", BIGINT, primary key)\n(\"units\", BIGINT)\n",
            "Table: \"relation\"\nColumns:\n(\"store_nbr\", BIGINT, primary key)\n(\"station_nbr\", BIGINT)\n",
            "Table: \"weather\"\nColumns:\n(\"station_nbr\", BIGINT, primary key)\n(\"_date\", DATE, primary key)\n(\"tmax\", BIGINT)\n(\"tmin\", BIGINT)\n(\"tavg\", BIGINT)\n(\"depart\", BIGINT)\n(\"dewpoint\", BIGINT)\n(\"wetbulb\", BIGINT)\n(\"heat\", BIGINT)\n(\"cool\", BIGINT)\n(\"sunrise\", STRING)\n(\"sunset\", STRING)\n(\"codesum\", STRING)\n(\"snowfall\", DOUBLE PRECISION)\n(\"preciptotal\", DOUBLE PRECISION)\n(\"stnpressure\", DOUBLE PRECISION)\n(\"sealevel\", DOUBLE PRECISION)\n(\"resultspeed\", DOUBLE PRECISION)\n(\"resultdir\", BIGINT)\n(\"avgspeed\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 568,
        "database_name": "sales_in_weather",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(CASE WHEN units > 100 THEN 1 ELSE 0 END) AS count FROM sales_in_weather AS T1 INNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr INNER JOIN weather AS T3 ON T2.station_nbr = T3.station_nbr WHERE T2.store_nbr = 3 AND SUBSTR(T1.`date`, 1, 4) = '2012' AND T1.item_nbr = 5 AND tmax > 90",
        "target_query": "SELECT SUM(CASE WHEN \"units\" > 100 THEN 1 ELSE 0 END) AS \"count\" FROM \"sales_in_weather\" AS T1 INNER JOIN \"relation\" AS T2 ON T1.\"store_nbr\" = T2.\"store_nbr\" INNER JOIN \"weather\" AS T3 ON T2.\"station_nbr\" = T3.\"station_nbr\" WHERE T2.\"store_nbr\" = 3 AND substring(T1.\"_date\" from 1 for 4) = '2012' AND T1.\"item_nbr\" = 5 AND T3.\"tmax\" > 90;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 233,
                "end_index": 255,
                "dilatect_content": "SUBSTR(T1.`date`, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 273,
                "end_index": 308,
                "dilatect_content": "substring(T1.\"_date\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `sales_in_weather`\nColumns:\n(`date`, date, primary key)\n(`store_nbr`, integer, primary key)\n(`item_nbr`, integer, primary key)\n(`units`, integer)\n",
            "Table: `relation`\nColumns:\n(`store_nbr`, integer, primary key)\n(`station_nbr`, integer)\n",
            "Table: `weather`\nColumns:\n(`station_nbr`, integer, primary key)\n(`date`, date, primary key)\n(`tmax`, integer)\n(`tmin`, integer)\n(`tavg`, integer)\n(`depart`, integer)\n(`dewpoint`, integer)\n(`wetbulb`, integer)\n(`heat`, integer)\n(`cool`, integer)\n(`sunrise`, text)\n(`sunset`, text)\n(`codesum`, text)\n(`snowfall`, real)\n(`preciptotal`, real)\n(`stnpressure`, real)\n(`sealevel`, real)\n(`resultspeed`, real)\n(`resultdir`, integer)\n(`avgspeed`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"sales_in_weather\"\nColumns:\n(\"_date\", DATE, primary key)\n(\"store_nbr\", BIGINT, primary key)\n(\"item_nbr\", BIGINT, primary key)\n(\"units\", BIGINT)\n",
            "Table: \"relation\"\nColumns:\n(\"store_nbr\", BIGINT, primary key)\n(\"station_nbr\", BIGINT)\n",
            "Table: \"weather\"\nColumns:\n(\"station_nbr\", BIGINT, primary key)\n(\"_date\", DATE, primary key)\n(\"tmax\", BIGINT)\n(\"tmin\", BIGINT)\n(\"tavg\", BIGINT)\n(\"depart\", BIGINT)\n(\"dewpoint\", BIGINT)\n(\"wetbulb\", BIGINT)\n(\"heat\", BIGINT)\n(\"cool\", BIGINT)\n(\"sunrise\", STRING)\n(\"sunset\", STRING)\n(\"codesum\", STRING)\n(\"snowfall\", DOUBLE PRECISION)\n(\"preciptotal\", DOUBLE PRECISION)\n(\"stnpressure\", DOUBLE PRECISION)\n(\"sealevel\", DOUBLE PRECISION)\n(\"resultspeed\", DOUBLE PRECISION)\n(\"resultdir\", BIGINT)\n(\"avgspeed\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 569,
        "database_name": "sales_in_weather",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(DISTINCT T1.item_nbr) FROM sales_in_weather AS T1 INNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr INNER JOIN weather AS T3 ON T2.station_nbr = T3.station_nbr AND T1.store_nbr = 3 AND SUBSTR(T1.`date`, 1, 4) = '2012' AND T1.units = 0 GROUP BY T3.tmax ORDER BY T3.tmax DESC LIMIT 1",
        "target_query": "SELECT COUNT(DISTINCT T1.item_nbr) FROM \"sales_in_weather\" AS T1 INNER JOIN \"relation\" AS T2 ON T1.store_nbr = T2.store_nbr INNER JOIN \"weather\" AS T3 ON T2.station_nbr = T3.station_nbr AND T1.store_nbr = 3 AND substring(T1.\"_date\" from 1 for 4) = '2012' AND T1.units = 0 GROUP BY T3.tmax ORDER BY T3.tmax DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 205,
                "end_index": 227,
                "dilatect_content": "SUBSTR(T1.`date`, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 217,
                "end_index": 252,
                "dilatect_content": "substring(T1.\"_date\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `sales_in_weather`\nColumns:\n(`date`, date, primary key)\n(`store_nbr`, integer, primary key)\n(`item_nbr`, integer, primary key)\n(`units`, integer)\n",
            "Table: `relation`\nColumns:\n(`store_nbr`, integer, primary key)\n(`station_nbr`, integer)\n",
            "Table: `weather`\nColumns:\n(`station_nbr`, integer, primary key)\n(`date`, date, primary key)\n(`tmax`, integer)\n(`tmin`, integer)\n(`tavg`, integer)\n(`depart`, integer)\n(`dewpoint`, integer)\n(`wetbulb`, integer)\n(`heat`, integer)\n(`cool`, integer)\n(`sunrise`, text)\n(`sunset`, text)\n(`codesum`, text)\n(`snowfall`, real)\n(`preciptotal`, real)\n(`stnpressure`, real)\n(`sealevel`, real)\n(`resultspeed`, real)\n(`resultdir`, integer)\n(`avgspeed`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"sales_in_weather\"\nColumns:\n(\"_date\", DATE, primary key)\n(\"store_nbr\", BIGINT, primary key)\n(\"item_nbr\", BIGINT, primary key)\n(\"units\", BIGINT)\n",
            "Table: \"relation\"\nColumns:\n(\"store_nbr\", BIGINT, primary key)\n(\"station_nbr\", BIGINT)\n",
            "Table: \"weather\"\nColumns:\n(\"station_nbr\", BIGINT, primary key)\n(\"_date\", DATE, primary key)\n(\"tmax\", BIGINT)\n(\"tmin\", BIGINT)\n(\"tavg\", BIGINT)\n(\"depart\", BIGINT)\n(\"dewpoint\", BIGINT)\n(\"wetbulb\", BIGINT)\n(\"heat\", BIGINT)\n(\"cool\", BIGINT)\n(\"sunrise\", STRING)\n(\"sunset\", STRING)\n(\"codesum\", STRING)\n(\"snowfall\", DOUBLE PRECISION)\n(\"preciptotal\", DOUBLE PRECISION)\n(\"stnpressure\", DOUBLE PRECISION)\n(\"sealevel\", DOUBLE PRECISION)\n(\"resultspeed\", DOUBLE PRECISION)\n(\"resultdir\", BIGINT)\n(\"avgspeed\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 570,
        "database_name": "sales_in_weather",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT `date` FROM weather WHERE station_nbr = 1 AND CAST(SUBSTR(`date`, 1, 4) AS int) BETWEEN 2012 AND 2014 ORDER BY tmax DESC LIMIT 1",
        "target_query": "SELECT \"_date\" FROM \"weather\" WHERE \"station_nbr\" = 1 AND substring(\"_date\" from 1 for 4) BETWEEN '2012' AND '2014' ORDER BY \"tmax\" DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 58,
                "end_index": 77,
                "dilatect_content": "SUBSTR(`date`, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 64,
                "end_index": 96,
                "dilatect_content": "substring(\"_date\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `weather`\nColumns:\n(`station_nbr`, integer, primary key)\n(`date`, date, primary key)\n(`tmax`, integer)\n(`tmin`, integer)\n(`tavg`, integer)\n(`depart`, integer)\n(`dewpoint`, integer)\n(`wetbulb`, integer)\n(`heat`, integer)\n(`cool`, integer)\n(`sunrise`, text)\n(`sunset`, text)\n(`codesum`, text)\n(`snowfall`, real)\n(`preciptotal`, real)\n(`stnpressure`, real)\n(`sealevel`, real)\n(`resultspeed`, real)\n(`resultdir`, integer)\n(`avgspeed`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"weather\"\nColumns:\n(\"station_nbr\", BIGINT, primary key)\n(\"_date\", DATE, primary key)\n(\"tmax\", BIGINT)\n(\"tmin\", BIGINT)\n(\"tavg\", BIGINT)\n(\"depart\", BIGINT)\n(\"dewpoint\", BIGINT)\n(\"wetbulb\", BIGINT)\n(\"heat\", BIGINT)\n(\"cool\", BIGINT)\n(\"sunrise\", STRING)\n(\"sunset\", STRING)\n(\"codesum\", STRING)\n(\"snowfall\", DOUBLE PRECISION)\n(\"preciptotal\", DOUBLE PRECISION)\n(\"stnpressure\", DOUBLE PRECISION)\n(\"sealevel\", DOUBLE PRECISION)\n(\"resultspeed\", DOUBLE PRECISION)\n(\"resultdir\", BIGINT)\n(\"avgspeed\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 571,
        "database_name": "sales_in_weather",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT station_nbr FROM weather WHERE SUBSTR(`date`, 1, 4) = '2014' AND SUBSTR(`date`, 6, 2) = '03' AND depart < 0 GROUP BY station_nbr HAVING COUNT(DISTINCT `date`) = ( SELECT COUNT(DISTINCT `date`) FROM weather WHERE SUBSTR(`date`, 1, 4) = '2014' AND SUBSTR(`date`, 6, 2) = '03' AND depart < 0 GROUP BY station_nbr ORDER BY COUNT(`date`) DESC LIMIT 1 )",
        "target_query": "WITH station_counts AS (\n    SELECT \"station_nbr\", COUNT(DISTINCT \"_date\") AS date_count\n    FROM \"weather\"\n    WHERE substring(\"_date\" from 1 for 4) = '2014' AND substring(\"_date\" from 6 for 2) = '03' AND \"depart\" < 0\n    GROUP BY \"station_nbr\"\n)\nSELECT \"station_nbr\" FROM \"weather\" WHERE substring(\"_date\" from 1 for 4) = '2014' AND substring(\"_date\" from 6 for 2) = '03' AND \"depart\" < 0 GROUP BY \"station_nbr\" HAVING COUNT(DISTINCT \"_date\") = (SELECT MAX(date_count) FROM station_counts);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 38,
                "end_index": 57,
                "dilatect_content": "SUBSTR(`date`, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 72,
                "end_index": 91,
                "dilatect_content": "SUBSTR(`date`, 6, 2)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 219,
                "end_index": 238,
                "dilatect_content": "SUBSTR(`date`, 1, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 253,
                "end_index": 272,
                "dilatect_content": "SUBSTR(`date`, 6, 2)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 127,
                "end_index": 159,
                "dilatect_content": "substring(\"_date\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 174,
                "end_index": 206,
                "dilatect_content": "substring(\"_date\" from 6 for 2)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 314,
                "end_index": 346,
                "dilatect_content": "substring(\"_date\" from 1 for 4)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 361,
                "end_index": 393,
                "dilatect_content": "substring(\"_date\" from 6 for 2)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `weather`\nColumns:\n(`station_nbr`, integer, primary key)\n(`date`, date, primary key)\n(`tmax`, integer)\n(`tmin`, integer)\n(`tavg`, integer)\n(`depart`, integer)\n(`dewpoint`, integer)\n(`wetbulb`, integer)\n(`heat`, integer)\n(`cool`, integer)\n(`sunrise`, text)\n(`sunset`, text)\n(`codesum`, text)\n(`snowfall`, real)\n(`preciptotal`, real)\n(`stnpressure`, real)\n(`sealevel`, real)\n(`resultspeed`, real)\n(`resultdir`, integer)\n(`avgspeed`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"weather\"\nColumns:\n(\"station_nbr\", BIGINT, primary key)\n(\"_date\", DATE, primary key)\n(\"tmax\", BIGINT)\n(\"tmin\", BIGINT)\n(\"tavg\", BIGINT)\n(\"depart\", BIGINT)\n(\"dewpoint\", BIGINT)\n(\"wetbulb\", BIGINT)\n(\"heat\", BIGINT)\n(\"cool\", BIGINT)\n(\"sunrise\", STRING)\n(\"sunset\", STRING)\n(\"codesum\", STRING)\n(\"snowfall\", DOUBLE PRECISION)\n(\"preciptotal\", DOUBLE PRECISION)\n(\"stnpressure\", DOUBLE PRECISION)\n(\"sealevel\", DOUBLE PRECISION)\n(\"resultspeed\", DOUBLE PRECISION)\n(\"resultdir\", BIGINT)\n(\"avgspeed\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 572,
        "database_name": "sales_in_weather",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(T2.tmax) AS REAL) / 29 FROM ( SELECT station_nbr FROM relation GROUP BY station_nbr ORDER BY COUNT(store_nbr) DESC LIMIT 1 ) AS T1 INNER JOIN weather AS T2 ON T1.station_nbr = T2.station_nbr WHERE SUBSTR(T2.`date`, 1, 7) = '2012-02'",
        "target_query": "SELECT CAST(SUM(T2.tmax) AS REAL) / 29 FROM ( SELECT \"station_nbr\" FROM \"relation\" GROUP BY \"station_nbr\" ORDER BY COUNT(\"store_nbr\") DESC LIMIT 1 ) AS T1 INNER JOIN \"weather\" AS T2 ON T1.\"station_nbr\" = T2.\"station_nbr\" WHERE substring(T2.\"_date\" from 1 for 7) = '2012-02';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 213,
                "end_index": 235,
                "dilatect_content": "SUBSTR(T2.`date`, 1, 7)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 241,
                "end_index": 276,
                "dilatect_content": "substring(T2.\"_date\" from 1 for 7)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `relation`\nColumns:\n(`store_nbr`, integer, primary key)\n(`station_nbr`, integer)\n",
            "Table: `weather`\nColumns:\n(`station_nbr`, integer, primary key)\n(`date`, date, primary key)\n(`tmax`, integer)\n(`tmin`, integer)\n(`tavg`, integer)\n(`depart`, integer)\n(`dewpoint`, integer)\n(`wetbulb`, integer)\n(`heat`, integer)\n(`cool`, integer)\n(`sunrise`, text)\n(`sunset`, text)\n(`codesum`, text)\n(`snowfall`, real)\n(`preciptotal`, real)\n(`stnpressure`, real)\n(`sealevel`, real)\n(`resultspeed`, real)\n(`resultdir`, integer)\n(`avgspeed`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"relation\"\nColumns:\n(\"store_nbr\", BIGINT, primary key)\n(\"station_nbr\", BIGINT)\n",
            "Table: \"weather\"\nColumns:\n(\"station_nbr\", BIGINT, primary key)\n(\"_date\", DATE, primary key)\n(\"tmax\", BIGINT)\n(\"tmin\", BIGINT)\n(\"tavg\", BIGINT)\n(\"depart\", BIGINT)\n(\"dewpoint\", BIGINT)\n(\"wetbulb\", BIGINT)\n(\"heat\", BIGINT)\n(\"cool\", BIGINT)\n(\"sunrise\", STRING)\n(\"sunset\", STRING)\n(\"codesum\", STRING)\n(\"snowfall\", DOUBLE PRECISION)\n(\"preciptotal\", DOUBLE PRECISION)\n(\"stnpressure\", DOUBLE PRECISION)\n(\"sealevel\", DOUBLE PRECISION)\n(\"resultspeed\", DOUBLE PRECISION)\n(\"resultdir\", BIGINT)\n(\"avgspeed\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 573,
        "database_name": "sales_in_weather",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(DISTINCT `date`) AS days FROM weather WHERE sunrise < time('05:00:00')",
        "target_query": "SELECT COUNT(DISTINCT \"_date\") AS days FROM \"weather\" WHERE \"sunrise\" < sys.time_to_str(time '05:00:00', '%H:%M:%S');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 67,
                "end_index": 82,
                "dilatect_content": "time('05:00:00')",
                "feature": "time(time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 78,
                "end_index": 121,
                "dilatect_content": "sys.time_to_str(time '05:00:00', '%H:%M:%S')",
                "feature": "sys.time_to_str(time-value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "time(time-value, modifier, modifier, ...)",
                "explanation": "The time(time-value, modifier, modifier, ...) function returns the time as text formatted as HH:MM:SS or HH:MM:SS.SSS if the subsec modifier is used. It accepts a time-value and zero or more modifiers.\nParameters: time-value (e.g., 'now', '14:16:00'), modifiers (e.g., '+1 hour', 'subsec').\nReturns: A string formatted as HH:MM:SS or HH:MM:SS.SSS.",
                "examples": [
                    "SELECT time(); -- Returns the current time.",
                    "SELECT time('now', '+1 hour'); -- Returns the time one hour after the current time.",
                    "SELECT time('14:16:00', 'subsec'); -- Returns '14:16:00.000' with milliseconds."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.time_to_str(time-value, format)",
                "explanation": "In MonetDB, the TIME function from SQLite can be emulated using sys.time_to_str to format TIME values as strings in the format 'HH:MM:SS' or 'HH:MM:SS.SSS'. Time arithmetic can be performed using sql_add with INTERVAL expressions.",
                "examples": [
                    "SELECT sys.time_to_str(CURRENT_TIME, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.time_to_str(sql_add(CURRENT_TIME, interval '1' hour), '%H:%M:%S'); -- Returns the time one hour after the current time.",
                    "SELECT sys.time_to_str(time '14:16:00', '%H:%M:%S.000'); -- Returns '14:16:00.000' with milliseconds."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `weather`\nColumns:\n(`station_nbr`, integer, primary key)\n(`date`, date, primary key)\n(`tmax`, integer)\n(`tmin`, integer)\n(`tavg`, integer)\n(`depart`, integer)\n(`dewpoint`, integer)\n(`wetbulb`, integer)\n(`heat`, integer)\n(`cool`, integer)\n(`sunrise`, text)\n(`sunset`, text)\n(`codesum`, text)\n(`snowfall`, real)\n(`preciptotal`, real)\n(`stnpressure`, real)\n(`sealevel`, real)\n(`resultspeed`, real)\n(`resultdir`, integer)\n(`avgspeed`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"weather\"\nColumns:\n(\"station_nbr\", BIGINT, primary key)\n(\"_date\", DATE, primary key)\n(\"tmax\", BIGINT)\n(\"tmin\", BIGINT)\n(\"tavg\", BIGINT)\n(\"depart\", BIGINT)\n(\"dewpoint\", BIGINT)\n(\"wetbulb\", BIGINT)\n(\"heat\", BIGINT)\n(\"cool\", BIGINT)\n(\"sunrise\", STRING)\n(\"sunset\", STRING)\n(\"codesum\", STRING)\n(\"snowfall\", DOUBLE PRECISION)\n(\"preciptotal\", DOUBLE PRECISION)\n(\"stnpressure\", DOUBLE PRECISION)\n(\"sealevel\", DOUBLE PRECISION)\n(\"resultspeed\", DOUBLE PRECISION)\n(\"resultdir\", BIGINT)\n(\"avgspeed\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 574,
        "database_name": "sales_in_weather",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(DISTINCT T2.station_nbr) AS number FROM sales_in_weather AS T1 INNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr WHERE SUBSTR(`date`, 1, 7) = '2014-01' AND item_nbr = 5",
        "target_query": "SELECT COUNT(DISTINCT \"T2\".\"station_nbr\") AS \"number\" FROM \"sales_in_weather\" AS \"T1\" INNER JOIN \"relation\" AS \"T2\" ON \"T1\".\"store_nbr\" = \"T2\".\"store_nbr\" WHERE substring(\"T1\".\"_date\" from 1 for 7) = '2014-01' AND \"T1\".\"item_nbr\" = 5;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 139,
                "end_index": 158,
                "dilatect_content": "SUBSTR(`date`, 1, 7)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 183,
                "end_index": 222,
                "dilatect_content": "substring(\"T1\".\"_date\" from 1 for 7)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `sales_in_weather`\nColumns:\n(`date`, date, primary key)\n(`store_nbr`, integer, primary key)\n(`item_nbr`, integer, primary key)\n(`units`, integer)\n",
            "Table: `relation`\nColumns:\n(`store_nbr`, integer, primary key)\n(`station_nbr`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"sales_in_weather\"\nColumns:\n(\"_date\", DATE, primary key)\n(\"store_nbr\", BIGINT, primary key)\n(\"item_nbr\", BIGINT, primary key)\n(\"units\", BIGINT)\n",
            "Table: \"relation\"\nColumns:\n(\"store_nbr\", BIGINT, primary key)\n(\"station_nbr\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 575,
        "database_name": "mondial_geo",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(CASE WHEN Government = 'republic' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(Country) FROM politics WHERE STRFTIME('%Y', Independence) > '1970'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"Government\" = 'republic' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"Country\") FROM \"politics\" WHERE EXTRACT(YEAR FROM \"Independence\") > 1970",
        "semantic_equivalent_type": "approximate_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 121,
                "end_index": 148,
                "dilatect_content": "STRFTIME('%Y', Independence)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 141,
                "end_index": 166,
                "dilatect_content": "YEAR FROM \"Independence\"",
                "feature": ""
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `politics`\nColumns:\n(`Country`, text, primary key)\n(`Independence`, date)\n(`Dependent`, text)\n(`Government`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"politics\"\nColumns:\n(\"Country\", STRING, primary key)\n(\"Independence\", DATE)\n(\"Dependent\", STRING)\n(\"Government\", STRING)\n"
        ]
    },
    {
        "sql_id": 576,
        "database_name": "mondial_geo",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.Country, COUNT(T1.Country) FROM economy AS T1 INNER JOIN organization AS T2 ON T1.Country = T2.Country WHERE T1.GDP < 500000 AND STRFTIME('%Y', T2.Established) < '1999' GROUP BY T1.Country",
        "target_query": "SELECT \"T1\".\"Country\", COUNT(\"T1\".\"Country\") FROM \"economy\" AS \"T1\" INNER JOIN \"organization\" AS \"T2\" ON \"T1\".\"Country\" = \"T2\".\"Country\" WHERE \"T1\".\"GDP\" < 500000 AND sys.timestamp_to_str(\"T2\".\"Established\", '%Y') < '1999' GROUP BY \"T1\".\"Country\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 139,
                "end_index": 168,
                "dilatect_content": "STRFTIME('%Y', T2.Established)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 195,
                "end_index": 244,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"Established\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `economy`\nColumns:\n(`Country`, text, primary key)\n(`GDP`, real)\n(`Agriculture`, real)\n(`Service`, real)\n(`Industry`, real)\n(`Inflation`, real)\n",
            "Table: `organization`\nColumns:\n(`Abbreviation`, text, primary key)\n(`Name`, text)\n(`City`, text)\n(`Country`, text)\n(`Province`, text)\n(`Established`, date)\n"
        ],
        "target_related_schemas": [
            "Table: \"economy\"\nColumns:\n(\"Country\", STRING, primary key)\n(\"GDP\", DOUBLE PRECISION)\n(\"Agriculture\", DOUBLE PRECISION)\n(\"Service\", DOUBLE PRECISION)\n(\"Industry\", DOUBLE PRECISION)\n(\"Inflation\", DOUBLE PRECISION)\n",
            "Table: \"organization\"\nColumns:\n(\"Abbreviation\", STRING, primary key)\n(\"Name\", STRING)\n(\"City\", STRING)\n(\"Country\", STRING)\n(\"Province\", STRING)\n(\"Established\", DATE)\n"
        ]
    },
    {
        "sql_id": 577,
        "database_name": "mondial_geo",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.Country FROM politics AS T1 INNER JOIN population AS T2 ON T1.Country = T2.Country WHERE STRFTIME('%Y', T1.Independence) = '1960' ORDER BY T2.Infant_Mortality DESC LIMIT 1",
        "target_query": "SELECT \"T1\".\"Country\" FROM \"politics\" AS \"T1\" INNER JOIN \"population\" AS \"T2\" ON \"T1\".\"Country\" = \"T2\".\"Country\" WHERE sys.timestamp_to_str(\"T1\".\"Independence\", '%Y') = '1960' ORDER BY \"T2\".\"Infant_Mortality\" DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 99,
                "end_index": 129,
                "dilatect_content": "STRFTIME('%Y', T1.Independence)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 139,
                "end_index": 189,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"Independence\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `politics`\nColumns:\n(`Country`, text, primary key)\n(`Independence`, date)\n(`Dependent`, text)\n(`Government`, text)\n",
            "Table: `population`\nColumns:\n(`Country`, text, primary key)\n(`Population_Growth`, real)\n(`Infant_Mortality`, real)\n"
        ],
        "target_related_schemas": [
            "Table: \"politics\"\nColumns:\n(\"Country\", STRING, primary key)\n(\"Independence\", DATE)\n(\"Dependent\", STRING)\n(\"Government\", STRING)\n",
            "Table: \"population\"\nColumns:\n(\"Country\", STRING, primary key)\n(\"Population_Growth\", DOUBLE PRECISION)\n(\"Infant_Mortality\", DOUBLE PRECISION)\n"
        ]
    },
    {
        "sql_id": 578,
        "database_name": "mondial_geo",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT River, GROUP_CONCAT(Province) FROM geo_river GROUP BY River HAVING COUNT(DISTINCT Country) > 1",
        "target_query": "SELECT \"River\", group_concat(\"Province\") FROM \"geo_river\" GROUP BY \"River\" HAVING COUNT(DISTINCT \"Country\") > 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 14,
                "end_index": 35,
                "dilatect_content": "GROUP_CONCAT(Province)",
                "feature": "group_concat(X)group_concat(X,Y)string_agg(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 18,
                "end_index": 43,
                "dilatect_content": "group_concat(\"Province\")",
                "feature": "group_concat(X) group_concat(X,Y)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
                "explanation": "The group_concat() function returns\n  a string which is the concatenation of\n  all non-NULL values of X.  If parameter Y is present then\n  it is used as the separator\n  between instances of X.A comma (\",\") is used as the separator\n  if Y is omitted.\n  \n  The string_agg(X,Y) function is an alias\n  for group_concat(X,Y).  String_agg() is compatible with PostgreSQL\n  and SQL-Server and group_concat() is compatible with MySQL.\n  \n  The order of the concatenated elements is arbitrary unless an\n  ORDER BY argument is included immediately after the last parameter.\n",
                "examples": [
                    "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
                    "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "group_concat(X) group_concat(X,Y)",
                "explanation": "The group_concat(X,Y) function returns a string which is the concatenation of all non-NULL values of X. If parameter Y is present, it is used as the separator between values. A comma (\",\") is used as the default separator if Y is omitted.\n\nThe order of concatenated elements is arbitrary unless an ORDER BY clause is explicitly used.",
                "examples": [
                    "SELECT group_concat(name) FROM students; -- Returns names separated by commas",
                    "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by ' | '",
                    "SELECT department, group_concat(name, '; ') FROM employees GROUP BY department; -- Groups names by department"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `geo_river`\nColumns:\n(`River`, text, primary key)\n(`Country`, text, primary key)\n(`Province`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"geo_river\"\nColumns:\n(\"River\", STRING, primary key)\n(\"Country\", STRING, primary key)\n(\"Province\", STRING, primary key)\n"
        ]
    },
    {
        "sql_id": 579,
        "database_name": "mondial_geo",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.Population / T1.Area FROM country AS T1 INNER JOIN organization AS T2 ON T1.Code = T2.Country WHERE STRFTIME('%Y', T2.Established) = '1947'",
        "target_query": "SELECT \"T1\".\"Population\" / \"T1\".\"Area\" FROM \"country\" AS \"T1\" INNER JOIN \"organization\" AS \"T2\" ON \"T1\".\"Code\" = \"T2\".\"Country\" WHERE sys.timestamp_to_str(\"T2\".\"Established\", '%Y') = '1947';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 110,
                "end_index": 139,
                "dilatect_content": "STRFTIME('%Y', T2.Established)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 158,
                "end_index": 207,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"Established\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `country`\nColumns:\n(`Name`, text)\n(`Code`, text, primary key)\n(`Capital`, text)\n(`Province`, text)\n(`Area`, real)\n(`Population`, integer)\n",
            "Table: `organization`\nColumns:\n(`Abbreviation`, text, primary key)\n(`Name`, text)\n(`City`, text)\n(`Country`, text)\n(`Province`, text)\n(`Established`, date)\n"
        ],
        "target_related_schemas": [
            "Table: \"country\"\nColumns:\n(\"Name\", STRING)\n(\"Code\", STRING, primary key)\n(\"Capital\", STRING)\n(\"Province\", STRING)\n(\"Area\", DOUBLE PRECISION)\n(\"Population\", BIGINT)\n",
            "Table: \"organization\"\nColumns:\n(\"Abbreviation\", STRING, primary key)\n(\"Name\", STRING)\n(\"City\", STRING)\n(\"Country\", STRING)\n(\"Province\", STRING)\n(\"Established\", DATE)\n"
        ]
    },
    {
        "sql_id": 582,
        "database_name": "mondial_geo",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.Name FROM country AS T1 INNER JOIN organization AS T2 ON T1.Code = T2.Country INNER JOIN politics AS T3 ON T3.Country = T2.Country WHERE STRFTIME('%Y', T2.Established) > '1907' AND T3.Government = 'constitutional monarchy' GROUP BY T1.Name ORDER BY COUNT(DISTINCT T2.Name) DESC LIMIT 1",
        "target_query": "SELECT \"T1\".\"Name\" FROM \"country\" AS \"T1\" INNER JOIN \"organization\" AS \"T2\" ON \"T1\".\"Code\" = \"T2\".\"Country\" INNER JOIN \"politics\" AS \"T3\" ON \"T3\".\"Country\" = \"T2\".\"Country\" WHERE sys.timestamp_to_str(\"T2\".\"Established\", '%Y') > '1907' AND \"T3\".\"Government\" = 'constitutional monarchy' GROUP BY \"T1\".\"Name\" ORDER BY COUNT(DISTINCT \"T2\".\"Name\") DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 147,
                "end_index": 176,
                "dilatect_content": "STRFTIME('%Y', T2.Established)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 211,
                "end_index": 260,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"Established\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `country`\nColumns:\n(`Name`, text)\n(`Code`, text, primary key)\n(`Capital`, text)\n(`Province`, text)\n(`Area`, real)\n(`Population`, integer)\n",
            "Table: `organization`\nColumns:\n(`Abbreviation`, text, primary key)\n(`Name`, text)\n(`City`, text)\n(`Country`, text)\n(`Province`, text)\n(`Established`, date)\n",
            "Table: `politics`\nColumns:\n(`Country`, text, primary key)\n(`Independence`, date)\n(`Dependent`, text)\n(`Government`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"country\"\nColumns:\n(\"Name\", STRING)\n(\"Code\", STRING, primary key)\n(\"Capital\", STRING)\n(\"Province\", STRING)\n(\"Area\", DOUBLE PRECISION)\n(\"Population\", BIGINT)\n",
            "Table: \"organization\"\nColumns:\n(\"Abbreviation\", STRING, primary key)\n(\"Name\", STRING)\n(\"City\", STRING)\n(\"Country\", STRING)\n(\"Province\", STRING)\n(\"Established\", DATE)\n",
            "Table: \"politics\"\nColumns:\n(\"Country\", STRING, primary key)\n(\"Independence\", DATE)\n(\"Dependent\", STRING)\n(\"Government\", STRING)\n"
        ]
    },
    {
        "sql_id": 583,
        "database_name": "mondial_geo",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(government = 'parliamentary democracy', 1, 0)) , CAST(SUM(IIF(government = 'parliamentary democracy', 1, 0)) AS REAL) * 100 / COUNT(*) FROM politics AS t1 WHERE STRFTIME('%Y', independence) >= '1993'",
        "target_query": "SELECT SUM(CASE WHEN \"Government\" = 'parliamentary democracy' THEN 1 ELSE 0 END), CAST(SUM(CASE WHEN \"Government\" = 'parliamentary democracy' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM \"politics\" AS t1 WHERE sys.timestamp_to_str(\"Independence\", '%Y') >= '1993';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 59,
                "dilatect_content": "IIF(government = 'parliamentary democracy', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 73,
                "end_index": 121,
                "dilatect_content": "IIF(government = 'parliamentary democracy', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 176,
                "end_index": 203,
                "dilatect_content": "STRFTIME('%Y', independence)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 80,
                "dilatect_content": "CASE WHEN \"Government\" = 'parliamentary democracy' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 93,
                "end_index": 162,
                "dilatect_content": "CASE WHEN \"Government\" = 'parliamentary democracy' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 221,
                "end_index": 264,
                "dilatect_content": "sys.timestamp_to_str(\"Independence\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            },
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            },
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `politics`\nColumns:\n(`Country`, text, primary key)\n(`Independence`, date)\n(`Dependent`, text)\n(`Government`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"politics\"\nColumns:\n(\"Country\", STRING, primary key)\n(\"Independence\", DATE)\n(\"Dependent\", STRING)\n(\"Government\", STRING)\n"
        ]
    },
    {
        "sql_id": 584,
        "database_name": "mondial_geo",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT Name FROM organization WHERE STRFTIME('%Y', Established) BETWEEN '1970' AND '1980'",
        "target_query": "SELECT \"Name\" FROM \"organization\" WHERE sys.timestamp_to_str(\"Established\", '%Y') BETWEEN '1970' AND '1980';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 36,
                "end_index": 62,
                "dilatect_content": "STRFTIME('%Y', Established)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 44,
                "end_index": 86,
                "dilatect_content": "sys.timestamp_to_str(\"Established\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `organization`\nColumns:\n(`Abbreviation`, text, primary key)\n(`Name`, text)\n(`City`, text)\n(`Country`, text)\n(`Province`, text)\n(`Established`, date)\n"
        ],
        "target_related_schemas": [
            "Table: \"organization\"\nColumns:\n(\"Abbreviation\", STRING, primary key)\n(\"Name\", STRING)\n(\"City\", STRING)\n(\"Country\", STRING)\n(\"Province\", STRING)\n(\"Established\", DATE)\n"
        ]
    },
    {
        "sql_id": 585,
        "database_name": "mondial_geo",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT STRFTIME('%Y', T4.Established) FROM continent AS T1 INNER JOIN encompasses AS T2 ON T1.Name = T2.Continent INNER JOIN country AS T3 ON T2.Country = T3.Code INNER JOIN organization AS T4 ON T4.Country = T3.Code WHERE T1.Name = 'Europe' GROUP BY STRFTIME('%Y', T4.Established) ORDER BY COUNT(T4.Name) DESC LIMIT 1",
        "target_query": "SELECT sys.timestamp_to_str(\"T4\".\"Established\", '%Y') FROM \"continent\" AS \"T1\" INNER JOIN \"encompasses\" AS \"T2\" ON \"T1\".\"Name\" = \"T2\".\"Continent\" INNER JOIN \"country\" AS \"T3\" ON \"T2\".\"Country\" = \"T3\".\"Code\" INNER JOIN \"organization\" AS \"T4\" ON \"T4\".\"Country\" = \"T3\".\"Code\" WHERE \"T1\".\"Name\" = 'Europe' GROUP BY sys.timestamp_to_str(\"T4\".\"Established\", '%Y') ORDER BY COUNT(\"T4\".\"Name\") DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 36,
                "dilatect_content": "STRFTIME('%Y', T4.Established)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 251,
                "end_index": 280,
                "dilatect_content": "STRFTIME('%Y', T4.Established)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 56,
                "dilatect_content": "sys.timestamp_to_str(\"T4\".\"Established\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 359,
                "end_index": 408,
                "dilatect_content": "sys.timestamp_to_str(\"T4\".\"Established\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `continent`\nColumns:\n(`Name`, text, primary key)\n(`Area`, real)\n",
            "Table: `encompasses`\nColumns:\n(`Country`, text, primary key)\n(`Continent`, text, primary key)\n(`Percentage`, real)\n",
            "Table: `country`\nColumns:\n(`Name`, text)\n(`Code`, text, primary key)\n(`Capital`, text)\n(`Province`, text)\n(`Area`, real)\n(`Population`, integer)\n",
            "Table: `organization`\nColumns:\n(`Abbreviation`, text, primary key)\n(`Name`, text)\n(`City`, text)\n(`Country`, text)\n(`Province`, text)\n(`Established`, date)\n"
        ],
        "target_related_schemas": [
            "Table: \"continent\"\nColumns:\n(\"Name\", STRING, primary key)\n(\"Area\", DOUBLE PRECISION)\n",
            "Table: \"encompasses\"\nColumns:\n(\"Country\", STRING, primary key)\n(\"Continent\", STRING, primary key)\n(\"Percentage\", DOUBLE PRECISION)\n",
            "Table: \"country\"\nColumns:\n(\"Name\", STRING)\n(\"Code\", STRING, primary key)\n(\"Capital\", STRING)\n(\"Province\", STRING)\n(\"Area\", DOUBLE PRECISION)\n(\"Population\", BIGINT)\n",
            "Table: \"organization\"\nColumns:\n(\"Abbreviation\", STRING, primary key)\n(\"Name\", STRING)\n(\"City\", STRING)\n(\"Country\", STRING)\n(\"Province\", STRING)\n(\"Established\", DATE)\n"
        ]
    },
    {
        "sql_id": 586,
        "database_name": "mondial_geo",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT * FROM politics WHERE STRFTIME('%Y', Independence) BETWEEN '1950' AND '1999' AND Government = 'parliamentary democracy'",
        "target_query": "SELECT * FROM \"politics\" WHERE sys.timestamp_to_str(\"Independence\", '%Y') BETWEEN '1950' AND '1999' AND \"Government\" = 'parliamentary democracy';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 29,
                "end_index": 56,
                "dilatect_content": "STRFTIME('%Y', Independence)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 33,
                "end_index": 76,
                "dilatect_content": "sys.timestamp_to_str(\"Independence\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `politics`\nColumns:\n(`Country`, text, primary key)\n(`Independence`, date)\n(`Dependent`, text)\n(`Government`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"politics\"\nColumns:\n(\"Country\", STRING, primary key)\n(\"Independence\", DATE)\n(\"Dependent\", STRING)\n(\"Government\", STRING)\n"
        ]
    },
    {
        "sql_id": 587,
        "database_name": "mondial_geo",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(CASE WHEN STRFTIME('%Y', Independence) = '1960' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(Country) FROM politics",
        "target_query": "SELECT CAST(SUM(CASE WHEN sys.timestamp_to_str(\"Independence\", '%Y') = '1960' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"Country\") FROM \"politics\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 26,
                "end_index": 53,
                "dilatect_content": "STRFTIME('%Y', Independence)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 26,
                "end_index": 69,
                "dilatect_content": "sys.timestamp_to_str(\"Independence\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `politics`\nColumns:\n(`Country`, text, primary key)\n(`Independence`, date)\n(`Dependent`, text)\n(`Government`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"politics\"\nColumns:\n(\"Country\", STRING, primary key)\n(\"Independence\", DATE)\n(\"Dependent\", STRING)\n(\"Government\", STRING)\n"
        ]
    },
    {
        "sql_id": 588,
        "database_name": "chicago_crime",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(COUNT(T1.fbi_code_no) AS REAL) / 4 FROM FBI_Code AS T1 INNER JOIN Crime AS T2 ON T1.fbi_code_no = T2.fbi_code_no WHERE SUBSTR(T2.date, 1, 1) = '1' AND SUBSTR(T2.date, 5, 4) = '2018'",
        "target_query": "SELECT CAST(COUNT(\"T1\".\"fbi_code_no\") AS REAL) / 4 FROM \"FBI_Code\" AS \"T1\" INNER JOIN \"Crime\" AS \"T2\" ON \"T1\".\"fbi_code_no\" = \"T2\".\"fbi_code_no\" WHERE substring(\"T2\".\"_date\" from 1 for 1) = '1' AND substring(\"T2\".\"_date\" from 5 for 4) = '2018';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 131,
                "end_index": 151,
                "dilatect_content": "SUBSTR(T2.date, 1, 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 163,
                "end_index": 183,
                "dilatect_content": "SUBSTR(T2.date, 5, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 171,
                "end_index": 210,
                "dilatect_content": "substring(\"T2\".\"_date\" from 1 for 1)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 222,
                "end_index": 261,
                "dilatect_content": "substring(\"T2\".\"_date\" from 5 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `FBI_Code`\nColumns:\n(`fbi_code_no`, text, primary key)\n(`title`, text)\n(`description`, text)\n(`crime_against`, text)\n",
            "Table: `Crime`\nColumns:\n(`report_no`, integer, primary key)\n(`case_number`, text)\n(`date`, text)\n(`block`, text)\n(`iucr_no`, text)\n(`location_description`, text)\n(`arrest`, text)\n(`domestic`, text)\n(`beat`, integer)\n(`district_no`, integer)\n(`ward_no`, integer)\n(`community_area_no`, integer)\n(`fbi_code_no`, text)\n(`latitude`, text)\n(`longitude`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"FBI_Code\"\nColumns:\n(\"fbi_code_no\", STRING, primary key)\n(\"title\", STRING)\n(\"description\", STRING)\n(\"crime_against\", STRING)\n",
            "Table: \"Crime\"\nColumns:\n(\"report_no\", BIGINT, primary key)\n(\"case_number\", STRING)\n(\"_date\", STRING)\n(\"block\", STRING)\n(\"iucr_no\", STRING)\n(\"location_description\", STRING)\n(\"arrest\", STRING)\n(\"domestic\", STRING)\n(\"beat\", BIGINT)\n(\"district_no\", BIGINT)\n(\"ward_no\", BIGINT)\n(\"community_area_no\", BIGINT)\n(\"fbi_code_no\", STRING)\n(\"latitude\", STRING)\n(\"longitude\", STRING)\n"
        ]
    },
    {
        "sql_id": 589,
        "database_name": "chicago_crime",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.ward_no, T1.alderman_first_name, T1.alderman_last_name, T1.alderman_name_suffix FROM Ward AS T1 INNER JOIN Crime AS T2 ON T1.ward_no = T2.ward_no WHERE SUBSTR(T2.date, 1, 1) = '1' AND SUBSTR(T2.date, 5, 4) = '2018' GROUP BY T1.ward_no ORDER BY COUNT(T1.ward_no) DESC LIMIT 1",
        "target_query": "SELECT \"T1\".\"ward_no\", MAX(\"T1\".\"alderman_first_name\") AS \"alderman_first_name\", MAX(\"T1\".\"alderman_last_name\") AS \"alderman_last_name\", MAX(\"T1\".\"alderman_name_suffix\") AS \"alderman_name_suffix\" FROM \"Ward\" AS \"T1\" INNER JOIN \"Crime\" AS \"T2\" ON \"T1\".\"ward_no\" = \"T2\".\"ward_no\" WHERE substring(\"T2\"._date from 1 for 1) = '1' AND substring(\"T2\"._date from 5 for 4) = '2018' GROUP BY \"T1\".\"ward_no\" ORDER BY COUNT(\"T1\".\"ward_no\") DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 162,
                "end_index": 182,
                "dilatect_content": "SUBSTR(T2.date, 1, 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 194,
                "end_index": 214,
                "dilatect_content": "SUBSTR(T2.date, 5, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 322,
                "end_index": 357,
                "dilatect_content": "substring(\"T2\"._date from 1 for 1)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 369,
                "end_index": 404,
                "dilatect_content": "substring(\"T2\"._date from 5 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Ward`\nColumns:\n(`ward_no`, integer, primary key)\n(`alderman_first_name`, text)\n(`alderman_last_name`, text)\n(`alderman_name_suffix`, text)\n(`ward_office_address`, text)\n(`ward_office_zip`, text)\n(`ward_email`, text)\n(`ward_office_phone`, text)\n(`ward_office_fax`, text)\n(`city_hall_office_room`, integer)\n(`city_hall_office_phone`, text)\n(`city_hall_office_fax`, text)\n(`Population`, integer)\n",
            "Table: `Crime`\nColumns:\n(`report_no`, integer, primary key)\n(`case_number`, text)\n(`date`, text)\n(`block`, text)\n(`iucr_no`, text)\n(`location_description`, text)\n(`arrest`, text)\n(`domestic`, text)\n(`beat`, integer)\n(`district_no`, integer)\n(`ward_no`, integer)\n(`community_area_no`, integer)\n(`fbi_code_no`, text)\n(`latitude`, text)\n(`longitude`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Ward\"\nColumns:\n(\"ward_no\", BIGINT, primary key)\n(\"alderman_first_name\", STRING)\n(\"alderman_last_name\", STRING)\n(\"alderman_name_suffix\", STRING)\n(\"ward_office_address\", STRING)\n(\"ward_office_zip\", STRING)\n(\"ward_email\", STRING)\n(\"ward_office_phone\", STRING)\n(\"ward_office_fax\", STRING)\n(\"city_hall_office_room\", BIGINT)\n(\"city_hall_office_phone\", STRING)\n(\"city_hall_office_fax\", STRING)\n(\"Population\", BIGINT)\n",
            "Table: \"Crime\"\nColumns:\n(\"report_no\", BIGINT, primary key)\n(\"case_number\", STRING)\n(\"_date\", STRING)\n(\"block\", STRING)\n(\"iucr_no\", STRING)\n(\"location_description\", STRING)\n(\"arrest\", STRING)\n(\"domestic\", STRING)\n(\"beat\", BIGINT)\n(\"district_no\", BIGINT)\n(\"ward_no\", BIGINT)\n(\"community_area_no\", BIGINT)\n(\"fbi_code_no\", STRING)\n(\"latitude\", STRING)\n(\"longitude\", STRING)\n"
        ]
    },
    {
        "sql_id": 590,
        "database_name": "chicago_crime",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.alderman_first_name, T1.alderman_last_name, COUNT(T1.ward_no) AS num FROM Ward AS T1 INNER JOIN Crime AS T2 ON T1.ward_no = T2.ward_no WHERE (SUBSTR(T2.date, 1, 1) = '1' AND SUBSTR(T2.date, 5, 4) = '2018' AND T1.alderman_first_name = 'Pat' AND T1.alderman_last_name = 'Dowell') OR (T1.alderman_first_name = 'Sophia' AND T1.alderman_last_name = 'King') GROUP BY T1.ward_no",
        "target_query": "SELECT \"T1\".\"alderman_first_name\", \"T1\".\"alderman_last_name\", COUNT(\"T1\".\"ward_no\") AS num \nFROM \"Ward\" AS \"T1\" \nINNER JOIN \"Crime\" AS \"T2\" ON \"T1\".\"ward_no\" = \"T2\".\"ward_no\" \nWHERE (substring(\"T2\".\"_date\" from 1 for 1) = '1' AND substring(\"T2\".\"_date\" from 5 for 4) = '2018' AND \"T1\".\"alderman_first_name\" = 'Pat' AND \"T1\".\"alderman_last_name\" = 'Dowell') \nOR (\"T1\".\"alderman_first_name\" = 'Sophia' AND \"T1\".\"alderman_last_name\" = 'King') \nGROUP BY \"T1\".\"ward_no\", \"T1\".\"alderman_first_name\", \"T1\".\"alderman_last_name\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 152,
                "end_index": 172,
                "dilatect_content": "SUBSTR(T2.date, 1, 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 184,
                "end_index": 204,
                "dilatect_content": "SUBSTR(T2.date, 5, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 214,
                "end_index": 252,
                "dilatect_content": "substring(\"T2\".\"_date\" from 1 for 1",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 265,
                "end_index": 303,
                "dilatect_content": "substring(\"T2\".\"_date\" from 5 for 4",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Ward`\nColumns:\n(`ward_no`, integer, primary key)\n(`alderman_first_name`, text)\n(`alderman_last_name`, text)\n(`alderman_name_suffix`, text)\n(`ward_office_address`, text)\n(`ward_office_zip`, text)\n(`ward_email`, text)\n(`ward_office_phone`, text)\n(`ward_office_fax`, text)\n(`city_hall_office_room`, integer)\n(`city_hall_office_phone`, text)\n(`city_hall_office_fax`, text)\n(`Population`, integer)\n",
            "Table: `Crime`\nColumns:\n(`report_no`, integer, primary key)\n(`case_number`, text)\n(`date`, text)\n(`block`, text)\n(`iucr_no`, text)\n(`location_description`, text)\n(`arrest`, text)\n(`domestic`, text)\n(`beat`, integer)\n(`district_no`, integer)\n(`ward_no`, integer)\n(`community_area_no`, integer)\n(`fbi_code_no`, text)\n(`latitude`, text)\n(`longitude`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"Ward\"\nColumns:\n(\"ward_no\", BIGINT, primary key)\n(\"alderman_first_name\", STRING)\n(\"alderman_last_name\", STRING)\n(\"alderman_name_suffix\", STRING)\n(\"ward_office_address\", STRING)\n(\"ward_office_zip\", STRING)\n(\"ward_email\", STRING)\n(\"ward_office_phone\", STRING)\n(\"ward_office_fax\", STRING)\n(\"city_hall_office_room\", BIGINT)\n(\"city_hall_office_phone\", STRING)\n(\"city_hall_office_fax\", STRING)\n(\"Population\", BIGINT)\n",
            "Table: \"Crime\"\nColumns:\n(\"report_no\", BIGINT, primary key)\n(\"case_number\", STRING)\n(\"_date\", STRING)\n(\"block\", STRING)\n(\"iucr_no\", STRING)\n(\"location_description\", STRING)\n(\"arrest\", STRING)\n(\"domestic\", STRING)\n(\"beat\", BIGINT)\n(\"district_no\", BIGINT)\n(\"ward_no\", BIGINT)\n(\"community_area_no\", BIGINT)\n(\"fbi_code_no\", STRING)\n(\"latitude\", STRING)\n(\"longitude\", STRING)\n"
        ]
    },
    {
        "sql_id": 591,
        "database_name": "chicago_crime",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(CASE WHEN SUBSTR(T2.date, 5, 4) = '2018' THEN 1 ELSE 0 END) FROM FBI_Code AS T1 INNER JOIN Crime AS T2 ON T1.fbi_code_no = T2.fbi_code_no WHERE T1.crime_against = 'Property' AND SUBSTR(T2.date, 1, 1) = '1'",
        "target_query": "SELECT SUM(CASE WHEN substring(\"T2\".\"_date\" from 5 for 4) = '2018' THEN 1 ELSE 0 END) FROM \"FBI_Code\" AS \"T1\" INNER JOIN \"Crime\" AS \"T2\" ON \"T1\".\"fbi_code_no\" = \"T2\".\"fbi_code_no\" WHERE \"T1\".\"crime_against\" = 'Property' AND substring(\"T2\".\"_date\" from 1 for 1) = '1';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 41,
                "dilatect_content": "SUBSTR(T2.date, 5, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 189,
                "end_index": 209,
                "dilatect_content": "SUBSTR(T2.date, 1, 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 60,
                "dilatect_content": "substring(\"T2\".\"_date\" from 5 for 4)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 248,
                "end_index": 287,
                "dilatect_content": "substring(\"T2\".\"_date\" from 1 for 1)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `FBI_Code`\nColumns:\n(`fbi_code_no`, text, primary key)\n(`title`, text)\n(`description`, text)\n(`crime_against`, text)\n",
            "Table: `Crime`\nColumns:\n(`report_no`, integer, primary key)\n(`case_number`, text)\n(`date`, text)\n(`block`, text)\n(`iucr_no`, text)\n(`location_description`, text)\n(`arrest`, text)\n(`domestic`, text)\n(`beat`, integer)\n(`district_no`, integer)\n(`ward_no`, integer)\n(`community_area_no`, integer)\n(`fbi_code_no`, text)\n(`latitude`, text)\n(`longitude`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"FBI_Code\"\nColumns:\n(\"fbi_code_no\", STRING, primary key)\n(\"title\", STRING)\n(\"description\", STRING)\n(\"crime_against\", STRING)\n",
            "Table: \"Crime\"\nColumns:\n(\"report_no\", BIGINT, primary key)\n(\"case_number\", STRING)\n(\"_date\", STRING)\n(\"block\", STRING)\n(\"iucr_no\", STRING)\n(\"location_description\", STRING)\n(\"arrest\", STRING)\n(\"domestic\", STRING)\n(\"beat\", BIGINT)\n(\"district_no\", BIGINT)\n(\"ward_no\", BIGINT)\n(\"community_area_no\", BIGINT)\n(\"fbi_code_no\", STRING)\n(\"latitude\", STRING)\n(\"longitude\", STRING)\n"
        ]
    },
    {
        "sql_id": 592,
        "database_name": "chicago_crime",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(CASE WHEN SUBSTR(T2.date, 5, 4) = '2018' THEN 1 ELSE 0 END) FROM District AS T1 INNER JOIN Crime AS T2 ON T1.district_no = T2.district_no WHERE T1.commander = 'Robert A. Rubio' AND SUBSTR(T2.date, 1, 1) = '1'",
        "target_query": "SELECT SUM(CASE WHEN substring(T2.\"_date\" from 5 for 4) = '2018' THEN 1 ELSE 0 END) FROM \"District\" AS T1 INNER JOIN \"Crime\" AS T2 ON T1.\"district_no\" = T2.\"district_no\" WHERE T1.\"commander\" = 'Robert A. Rubio' AND substring(T2.\"_date\" from 1 for 1) = '1';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 41,
                "dilatect_content": "SUBSTR(T2.date, 5, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 192,
                "end_index": 212,
                "dilatect_content": "SUBSTR(T2.date, 1, 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 56,
                "dilatect_content": "substring(T2.\"_date\" from 5 for 4)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 227,
                "end_index": 262,
                "dilatect_content": "substring(T2.\"_date\" from 1 for 1)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `District`\nColumns:\n(`district_no`, integer, primary key)\n(`district_name`, text)\n(`address`, text)\n(`zip_code`, integer)\n(`commander`, text)\n(`email`, text)\n(`phone`, text)\n(`fax`, text)\n(`tty`, text)\n(`twitter`, text)\n",
            "Table: `Crime`\nColumns:\n(`report_no`, integer, primary key)\n(`case_number`, text)\n(`date`, text)\n(`block`, text)\n(`iucr_no`, text)\n(`location_description`, text)\n(`arrest`, text)\n(`domestic`, text)\n(`beat`, integer)\n(`district_no`, integer)\n(`ward_no`, integer)\n(`community_area_no`, integer)\n(`fbi_code_no`, text)\n(`latitude`, text)\n(`longitude`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"District\"\nColumns:\n(\"district_no\", BIGINT, primary key)\n(\"district_name\", STRING)\n(\"address\", STRING)\n(\"zip_code\", BIGINT)\n(\"commander\", STRING)\n(\"email\", STRING)\n(\"phone\", STRING)\n(\"fax\", STRING)\n(\"tty\", STRING)\n(\"twitter\", STRING)\n",
            "Table: \"Crime\"\nColumns:\n(\"report_no\", BIGINT, primary key)\n(\"case_number\", STRING)\n(\"_date\", STRING)\n(\"block\", STRING)\n(\"iucr_no\", STRING)\n(\"location_description\", STRING)\n(\"arrest\", STRING)\n(\"domestic\", STRING)\n(\"beat\", BIGINT)\n(\"district_no\", BIGINT)\n(\"ward_no\", BIGINT)\n(\"community_area_no\", BIGINT)\n(\"fbi_code_no\", STRING)\n(\"latitude\", STRING)\n(\"longitude\", STRING)\n"
        ]
    },
    {
        "sql_id": 593,
        "database_name": "chicago_crime",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.commander FROM District AS T1 INNER JOIN Crime AS T2 ON T1.district_no = T2.district_no WHERE T1.commander IN ('Robert A. Rubio', 'Glenn White') AND SUBSTR(T2.date, 1, 1) = '1' AND SUBSTR(T2.date, 5, 4) = '2018' GROUP BY T1.commander",
        "target_query": "SELECT \"T1\".\"commander\" FROM \"District\" AS \"T1\" INNER JOIN \"Crime\" AS \"T2\" ON \"T1\".\"district_no\" = \"T2\".\"district_no\" WHERE \"T1\".\"commander\" IN ('Robert A. Rubio', 'Glenn White') AND substring(\"T2\".\"_date\" from 1 for 1) = '1' AND substring(\"T2\".\"_date\" from 5 for 4) = '2018' GROUP BY \"T1\".\"commander\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 159,
                "end_index": 179,
                "dilatect_content": "SUBSTR(T2.date, 1, 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 191,
                "end_index": 211,
                "dilatect_content": "SUBSTR(T2.date, 5, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 207,
                "end_index": 246,
                "dilatect_content": "substring(\"T2\".\"_date\" from 1 for 1)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 258,
                "end_index": 297,
                "dilatect_content": "substring(\"T2\".\"_date\" from 5 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `District`\nColumns:\n(`district_no`, integer, primary key)\n(`district_name`, text)\n(`address`, text)\n(`zip_code`, integer)\n(`commander`, text)\n(`email`, text)\n(`phone`, text)\n(`fax`, text)\n(`tty`, text)\n(`twitter`, text)\n",
            "Table: `Crime`\nColumns:\n(`report_no`, integer, primary key)\n(`case_number`, text)\n(`date`, text)\n(`block`, text)\n(`iucr_no`, text)\n(`location_description`, text)\n(`arrest`, text)\n(`domestic`, text)\n(`beat`, integer)\n(`district_no`, integer)\n(`ward_no`, integer)\n(`community_area_no`, integer)\n(`fbi_code_no`, text)\n(`latitude`, text)\n(`longitude`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"District\"\nColumns:\n(\"district_no\", BIGINT, primary key)\n(\"district_name\", STRING)\n(\"address\", STRING)\n(\"zip_code\", BIGINT)\n(\"commander\", STRING)\n(\"email\", STRING)\n(\"phone\", STRING)\n(\"fax\", STRING)\n(\"tty\", STRING)\n(\"twitter\", STRING)\n",
            "Table: \"Crime\"\nColumns:\n(\"report_no\", BIGINT, primary key)\n(\"case_number\", STRING)\n(\"_date\", STRING)\n(\"block\", STRING)\n(\"iucr_no\", STRING)\n(\"location_description\", STRING)\n(\"arrest\", STRING)\n(\"domestic\", STRING)\n(\"beat\", BIGINT)\n(\"district_no\", BIGINT)\n(\"ward_no\", BIGINT)\n(\"community_area_no\", BIGINT)\n(\"fbi_code_no\", STRING)\n(\"latitude\", STRING)\n(\"longitude\", STRING)\n"
        ]
    },
    {
        "sql_id": 594,
        "database_name": "food_inspection",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(`date`) FROM inspections WHERE STRFTIME('%Y', `date`) = '2016' AND type = 'Routine - Unscheduled'",
        "target_query": "SELECT COUNT(\"_date\") FROM \"inspections\" WHERE sys.timestamp_to_str(\"_date\", '%Y') = '2016' AND \"type\" = 'Routine - Unscheduled';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 44,
                "end_index": 65,
                "dilatect_content": "STRFTIME('%Y', `date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 51,
                "end_index": 87,
                "dilatect_content": "sys.timestamp_to_str(\"_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspections`\nColumns:\n(`business_id`, integer)\n(`score`, integer)\n(`date`, date)\n(`type`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"inspections\"\nColumns:\n(\"business_id\", BIGINT)\n(\"score\", BIGINT)\n(\"_date\", DATE)\n(\"type\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 595,
        "database_name": "food_inspection",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(DISTINCT T2.business_id) FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE STRFTIME('%Y', T1.`date`) = '2016' AND T2.city IN ('San Francisco', 'SAN FRANCISCO', 'SF', 'S.F.')",
        "target_query": "SELECT COUNT(DISTINCT T2.\"business_id\") FROM \"inspections\" AS T1 INNER JOIN \"businesses\" AS T2 ON T1.\"business_id\" = T2.\"business_id\" WHERE sys.timestamp_to_str(T1.\"_date\", '%Y') = '2016' AND T2.\"city\" IN ('San Francisco', 'SAN FRANCISCO', 'SF', 'S.F.');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 130,
                "end_index": 154,
                "dilatect_content": "STRFTIME('%Y', T1.`date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 150,
                "end_index": 189,
                "dilatect_content": "sys.timestamp_to_str(T1.\"_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspections`\nColumns:\n(`business_id`, integer)\n(`score`, integer)\n(`date`, date)\n(`type`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `businesses`\nColumns:\n(`business_id`, integer, primary key)\n(`name`, text)\n(`address`, text)\n(`city`, text)\n(`postal_code`, text)\n(`latitude`, real)\n(`longitude`, real)\n(`phone_number`, integer)\n(`tax_code`, text)\n(`business_certificate`, integer)\n(`application_date`, date)\n(`owner_name`, text)\n(`owner_address`, text)\n(`owner_city`, text)\n(`owner_state`, text)\n(`owner_zip`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"inspections\"\nColumns:\n(\"business_id\", BIGINT)\n(\"score\", BIGINT)\n(\"_date\", DATE)\n(\"type\", STRING)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"businesses\"\nColumns:\n(\"business_id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"postal_code\", STRING)\n(\"latitude\", DOUBLE PRECISION)\n(\"longitude\", DOUBLE PRECISION)\n(\"phone_number\", BIGINT)\n(\"tax_code\", STRING)\n(\"business_certificate\", BIGINT)\n(\"application_date\", DATE)\n(\"owner_name\", STRING)\n(\"owner_address\", STRING)\n(\"owner_city\", STRING)\n(\"owner_state\", STRING)\n(\"owner_zip\", STRING)\n"
        ]
    },
    {
        "sql_id": 596,
        "database_name": "food_inspection",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT T2.name FROM violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE STRFTIME('%Y', T1.`date`) = '2014' AND T1.risk_category = 'Low Risk'",
        "target_query": "SELECT DISTINCT T2.\"name\" FROM \"violations\" AS T1 INNER JOIN \"businesses\" AS T2 ON T1.\"business_id\" = T2.\"business_id\" WHERE sys.timestamp_to_str(T1.\"_date\", '%Y') = '2014' AND T1.\"risk_category\" = 'Low Risk';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 115,
                "end_index": 139,
                "dilatect_content": "STRFTIME('%Y', T1.`date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 135,
                "end_index": 174,
                "dilatect_content": "sys.timestamp_to_str(T1.\"_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `violations`\nColumns:\n(`business_id`, integer)\n(`date`, date)\n(`violation_type_id`, text)\n(`risk_category`, text)\n(`description`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `businesses`\nColumns:\n(`business_id`, integer, primary key)\n(`name`, text)\n(`address`, text)\n(`city`, text)\n(`postal_code`, text)\n(`latitude`, real)\n(`longitude`, real)\n(`phone_number`, integer)\n(`tax_code`, text)\n(`business_certificate`, integer)\n(`application_date`, date)\n(`owner_name`, text)\n(`owner_address`, text)\n(`owner_city`, text)\n(`owner_state`, text)\n(`owner_zip`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"violations\"\nColumns:\n(\"business_id\", BIGINT)\n(\"_date\", DATE)\n(\"violation_type_id\", STRING)\n(\"risk_category\", STRING)\n(\"description\", STRING)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"businesses\"\nColumns:\n(\"business_id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"postal_code\", STRING)\n(\"latitude\", DOUBLE PRECISION)\n(\"longitude\", DOUBLE PRECISION)\n(\"phone_number\", BIGINT)\n(\"tax_code\", STRING)\n(\"business_certificate\", BIGINT)\n(\"application_date\", DATE)\n(\"owner_name\", STRING)\n(\"owner_address\", STRING)\n(\"owner_city\", STRING)\n(\"owner_state\", STRING)\n(\"owner_zip\", STRING)\n"
        ]
    },
    {
        "sql_id": 597,
        "database_name": "food_inspection",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(business_id) FROM businesses WHERE STRFTIME('%Y', application_date) = '2012'",
        "target_query": "SELECT COUNT(\"business_id\") FROM \"businesses\" WHERE sys.timestamp_to_str(\"application_date\", '%Y') = '2012';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 48,
                "end_index": 79,
                "dilatect_content": "STRFTIME('%Y', application_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 56,
                "end_index": 103,
                "dilatect_content": "sys.timestamp_to_str(\"application_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `businesses`\nColumns:\n(`business_id`, integer, primary key)\n(`name`, text)\n(`address`, text)\n(`city`, text)\n(`postal_code`, text)\n(`latitude`, real)\n(`longitude`, real)\n(`phone_number`, integer)\n(`tax_code`, text)\n(`business_certificate`, integer)\n(`application_date`, date)\n(`owner_name`, text)\n(`owner_address`, text)\n(`owner_city`, text)\n(`owner_state`, text)\n(`owner_zip`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"businesses\"\nColumns:\n(\"business_id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"postal_code\", STRING)\n(\"latitude\", DOUBLE PRECISION)\n(\"longitude\", DOUBLE PRECISION)\n(\"phone_number\", BIGINT)\n(\"tax_code\", STRING)\n(\"business_certificate\", BIGINT)\n(\"application_date\", DATE)\n(\"owner_name\", STRING)\n(\"owner_address\", STRING)\n(\"owner_city\", STRING)\n(\"owner_state\", STRING)\n(\"owner_zip\", STRING)\n"
        ]
    },
    {
        "sql_id": 598,
        "database_name": "food_inspection",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(business_id) FROM inspections WHERE STRFTIME('%Y', `date`) = '2014' AND type = 'Foodborne Illness Investigation'",
        "target_query": "SELECT COUNT(\"business_id\") FROM \"inspections\" WHERE sys.timestamp_to_str(\"_date\", '%Y') = '2014' AND \"type\" = 'Foodborne Illness Investigation';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 49,
                "end_index": 70,
                "dilatect_content": "STRFTIME('%Y', `date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 57,
                "end_index": 93,
                "dilatect_content": "sys.timestamp_to_str(\"_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspections`\nColumns:\n(`business_id`, integer)\n(`score`, integer)\n(`date`, date)\n(`type`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"inspections\"\nColumns:\n(\"business_id\", BIGINT)\n(\"score\", BIGINT)\n(\"_date\", DATE)\n(\"type\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 599,
        "database_name": "food_inspection",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT T2.name FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE STRFTIME('%Y', T1.`date`) = '2013' AND T1.score = 100",
        "target_query": "SELECT DISTINCT \"T2\".\"name\" FROM \"inspections\" AS \"T1\" INNER JOIN \"businesses\" AS \"T2\" ON \"T1\".\"business_id\" = \"T2\".\"business_id\" WHERE sys.timestamp_to_str(\"T1\".\"_date\", '%Y') = '2013' AND \"T1\".\"score\" = 100;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 116,
                "end_index": 140,
                "dilatect_content": "STRFTIME('%Y', T1.`date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 156,
                "end_index": 199,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspections`\nColumns:\n(`business_id`, integer)\n(`score`, integer)\n(`date`, date)\n(`type`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `businesses`\nColumns:\n(`business_id`, integer, primary key)\n(`name`, text)\n(`address`, text)\n(`city`, text)\n(`postal_code`, text)\n(`latitude`, real)\n(`longitude`, real)\n(`phone_number`, integer)\n(`tax_code`, text)\n(`business_certificate`, integer)\n(`application_date`, date)\n(`owner_name`, text)\n(`owner_address`, text)\n(`owner_city`, text)\n(`owner_state`, text)\n(`owner_zip`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"inspections\"\nColumns:\n(\"business_id\", BIGINT)\n(\"score\", BIGINT)\n(\"_date\", DATE)\n(\"type\", STRING)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"businesses\"\nColumns:\n(\"business_id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"postal_code\", STRING)\n(\"latitude\", DOUBLE PRECISION)\n(\"longitude\", DOUBLE PRECISION)\n(\"phone_number\", BIGINT)\n(\"tax_code\", STRING)\n(\"business_certificate\", BIGINT)\n(\"application_date\", DATE)\n(\"owner_name\", STRING)\n(\"owner_address\", STRING)\n(\"owner_city\", STRING)\n(\"owner_state\", STRING)\n(\"owner_zip\", STRING)\n"
        ]
    },
    {
        "sql_id": 600,
        "database_name": "food_inspection",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.city FROM violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE STRFTIME('%Y', T1.`date`) = '2016' AND T1.risk_category = 'High Risk' GROUP BY T2.city ORDER BY COUNT(T2.city) DESC LIMIT 1",
        "target_query": "SELECT T2.\"city\" FROM \"violations\" AS T1 INNER JOIN \"businesses\" AS T2 ON T1.\"business_id\" = T2.\"business_id\" WHERE sys.timestamp_to_str(T1.\"_date\", '%Y') = '2016' AND T1.\"risk_category\" = 'High Risk' GROUP BY T2.\"city\" ORDER BY COUNT(T2.\"city\") DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 106,
                "end_index": 130,
                "dilatect_content": "STRFTIME('%Y', T1.`date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 126,
                "end_index": 165,
                "dilatect_content": "sys.timestamp_to_str(T1.\"_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `violations`\nColumns:\n(`business_id`, integer)\n(`date`, date)\n(`violation_type_id`, text)\n(`risk_category`, text)\n(`description`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `businesses`\nColumns:\n(`business_id`, integer, primary key)\n(`name`, text)\n(`address`, text)\n(`city`, text)\n(`postal_code`, text)\n(`latitude`, real)\n(`longitude`, real)\n(`phone_number`, integer)\n(`tax_code`, text)\n(`business_certificate`, integer)\n(`application_date`, date)\n(`owner_name`, text)\n(`owner_address`, text)\n(`owner_city`, text)\n(`owner_state`, text)\n(`owner_zip`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"violations\"\nColumns:\n(\"business_id\", BIGINT)\n(\"_date\", DATE)\n(\"violation_type_id\", STRING)\n(\"risk_category\", STRING)\n(\"description\", STRING)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"businesses\"\nColumns:\n(\"business_id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"postal_code\", STRING)\n(\"latitude\", DOUBLE PRECISION)\n(\"longitude\", DOUBLE PRECISION)\n(\"phone_number\", BIGINT)\n(\"tax_code\", STRING)\n(\"business_certificate\", BIGINT)\n(\"application_date\", DATE)\n(\"owner_name\", STRING)\n(\"owner_address\", STRING)\n(\"owner_city\", STRING)\n(\"owner_state\", STRING)\n(\"owner_zip\", STRING)\n"
        ]
    },
    {
        "sql_id": 601,
        "database_name": "food_inspection",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.name FROM violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE STRFTIME('%Y', T1.`date`) = '2013' AND T1.description = 'Contaminated or adulterated food'",
        "target_query": "SELECT T2.\"name\" FROM \"violations\" AS T1 INNER JOIN \"businesses\" AS T2 ON T1.\"business_id\" = T2.\"business_id\" WHERE sys.timestamp_to_str(T1.\"_date\", '%Y') = '2013' AND T1.\"description\" = 'Contaminated or adulterated food';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 106,
                "end_index": 130,
                "dilatect_content": "STRFTIME('%Y', T1.`date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 126,
                "end_index": 165,
                "dilatect_content": "sys.timestamp_to_str(T1.\"_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `violations`\nColumns:\n(`business_id`, integer)\n(`date`, date)\n(`violation_type_id`, text)\n(`risk_category`, text)\n(`description`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `businesses`\nColumns:\n(`business_id`, integer, primary key)\n(`name`, text)\n(`address`, text)\n(`city`, text)\n(`postal_code`, text)\n(`latitude`, real)\n(`longitude`, real)\n(`phone_number`, integer)\n(`tax_code`, text)\n(`business_certificate`, integer)\n(`application_date`, date)\n(`owner_name`, text)\n(`owner_address`, text)\n(`owner_city`, text)\n(`owner_state`, text)\n(`owner_zip`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"violations\"\nColumns:\n(\"business_id\", BIGINT)\n(\"_date\", DATE)\n(\"violation_type_id\", STRING)\n(\"risk_category\", STRING)\n(\"description\", STRING)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"businesses\"\nColumns:\n(\"business_id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"postal_code\", STRING)\n(\"latitude\", DOUBLE PRECISION)\n(\"longitude\", DOUBLE PRECISION)\n(\"phone_number\", BIGINT)\n(\"tax_code\", STRING)\n(\"business_certificate\", BIGINT)\n(\"application_date\", DATE)\n(\"owner_name\", STRING)\n(\"owner_address\", STRING)\n(\"owner_city\", STRING)\n(\"owner_state\", STRING)\n(\"owner_zip\", STRING)\n"
        ]
    },
    {
        "sql_id": 602,
        "database_name": "food_inspection",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(DISTINCT T2.business_id) FROM violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id INNER JOIN inspections AS T3 ON T2.business_id = T3.business_id WHERE STRFTIME('%Y', T1.`date`) = '2015' AND T2.postal_code = '94102' AND T3.score > 90",
        "target_query": "SELECT COUNT(DISTINCT T2.\"business_id\") FROM \"violations\" AS T1 INNER JOIN \"businesses\" AS T2 ON T1.\"business_id\" = T2.\"business_id\" INNER JOIN \"inspections\" AS T3 ON T2.\"business_id\" = T3.\"business_id\" WHERE sys.timestamp_to_str(T1.\"_date\", '%Y') = '2015' AND T2.\"postal_code\" = '94102' AND T3.\"score\" > 90;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 193,
                "end_index": 217,
                "dilatect_content": "STRFTIME('%Y', T1.`date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 225,
                "end_index": 264,
                "dilatect_content": "sys.timestamp_to_str(T1.\"_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `violations`\nColumns:\n(`business_id`, integer)\n(`date`, date)\n(`violation_type_id`, text)\n(`risk_category`, text)\n(`description`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `businesses`\nColumns:\n(`business_id`, integer, primary key)\n(`name`, text)\n(`address`, text)\n(`city`, text)\n(`postal_code`, text)\n(`latitude`, real)\n(`longitude`, real)\n(`phone_number`, integer)\n(`tax_code`, text)\n(`business_certificate`, integer)\n(`application_date`, date)\n(`owner_name`, text)\n(`owner_address`, text)\n(`owner_city`, text)\n(`owner_state`, text)\n(`owner_zip`, text)\n",
            "Table: `inspections`\nColumns:\n(`business_id`, integer)\n(`score`, integer)\n(`date`, date)\n(`type`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"violations\"\nColumns:\n(\"business_id\", BIGINT)\n(\"_date\", DATE)\n(\"violation_type_id\", STRING)\n(\"risk_category\", STRING)\n(\"description\", STRING)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"businesses\"\nColumns:\n(\"business_id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"postal_code\", STRING)\n(\"latitude\", DOUBLE PRECISION)\n(\"longitude\", DOUBLE PRECISION)\n(\"phone_number\", BIGINT)\n(\"tax_code\", STRING)\n(\"business_certificate\", BIGINT)\n(\"application_date\", DATE)\n(\"owner_name\", STRING)\n(\"owner_address\", STRING)\n(\"owner_city\", STRING)\n(\"owner_state\", STRING)\n(\"owner_zip\", STRING)\n",
            "Table: \"inspections\"\nColumns:\n(\"business_id\", BIGINT)\n(\"score\", BIGINT)\n(\"_date\", DATE)\n(\"type\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 604,
        "database_name": "food_inspection",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT AVG(T1.score) FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE STRFTIME('%Y', T1.`date`) BETWEEN '2014' AND '2016' AND T2.owner_name = 'Yiu Tim Chan' AND T2.address = '808 Pacific Ave' AND T2.city = 'San Francisco'",
        "target_query": "SELECT AVG(\"T1\".\"score\") FROM \"inspections\" AS \"T1\" INNER JOIN \"businesses\" AS \"T2\" ON \"T1\".\"business_id\" = \"T2\".\"business_id\" WHERE sys.timestamp_to_str(\"T1\".\"_date\", '%Y') BETWEEN '2014' AND '2016' AND \"T2\".\"owner_name\" = 'Yiu Tim Chan' AND \"T2\".\"address\" = '808 Pacific Ave' AND \"T2\".\"city\" = 'San Francisco';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 113,
                "end_index": 137,
                "dilatect_content": "STRFTIME('%Y', T1.`date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 153,
                "end_index": 196,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspections`\nColumns:\n(`business_id`, integer)\n(`score`, integer)\n(`date`, date)\n(`type`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `businesses`\nColumns:\n(`business_id`, integer, primary key)\n(`name`, text)\n(`address`, text)\n(`city`, text)\n(`postal_code`, text)\n(`latitude`, real)\n(`longitude`, real)\n(`phone_number`, integer)\n(`tax_code`, text)\n(`business_certificate`, integer)\n(`application_date`, date)\n(`owner_name`, text)\n(`owner_address`, text)\n(`owner_city`, text)\n(`owner_state`, text)\n(`owner_zip`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"inspections\"\nColumns:\n(\"business_id\", BIGINT)\n(\"score\", BIGINT)\n(\"_date\", DATE)\n(\"type\", STRING)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"businesses\"\nColumns:\n(\"business_id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"address\", STRING)\n(\"city\", STRING)\n(\"postal_code\", STRING)\n(\"latitude\", DOUBLE PRECISION)\n(\"longitude\", DOUBLE PRECISION)\n(\"phone_number\", BIGINT)\n(\"tax_code\", STRING)\n(\"business_certificate\", BIGINT)\n(\"application_date\", DATE)\n(\"owner_name\", STRING)\n(\"owner_address\", STRING)\n(\"owner_city\", STRING)\n(\"owner_state\", STRING)\n(\"owner_zip\", STRING)\n"
        ]
    },
    {
        "sql_id": 606,
        "database_name": "food_inspection",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(DISTINCT business_id) FROM inspections WHERE STRFTIME('%Y', `date`) = '2013' AND score = ( SELECT MAX(score) FROM inspections WHERE STRFTIME('%Y', `date`) = '2013' )",
        "target_query": "SELECT COUNT(DISTINCT \"business_id\") FROM \"inspections\" WHERE sys.timestamp_to_str(\"inspections\".\"_date\", '%Y') = '2013' AND \"score\" = ( SELECT MAX(\"score\") FROM \"inspections\" WHERE sys.timestamp_to_str(\"inspections\".\"_date\", '%Y') = '2013' );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 58,
                "end_index": 79,
                "dilatect_content": "STRFTIME('%Y', `date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 145,
                "end_index": 166,
                "dilatect_content": "STRFTIME('%Y', `date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 66,
                "end_index": 118,
                "dilatect_content": "sys.timestamp_to_str(\"inspections\".\"_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 196,
                "end_index": 248,
                "dilatect_content": "sys.timestamp_to_str(\"inspections\".\"_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspections`\nColumns:\n(`business_id`, integer)\n(`score`, integer)\n(`date`, date)\n(`type`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"inspections\"\nColumns:\n(\"business_id\", BIGINT)\n(\"score\", BIGINT)\n(\"_date\", DATE)\n(\"type\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 607,
        "database_name": "food_inspection",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(risk_category) FROM violations WHERE STRFTIME('%Y', `date`) = '2014' AND risk_category = 'Low Risk'",
        "target_query": "SELECT COUNT(\"risk_category\") FROM \"violations\" WHERE sys.timestamp_to_str(\"_date\", '%Y') = '2014' AND \"risk_category\" = 'Low Risk';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 50,
                "end_index": 71,
                "dilatect_content": "STRFTIME('%Y', `date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 58,
                "end_index": 94,
                "dilatect_content": "sys.timestamp_to_str(\"_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `violations`\nColumns:\n(`business_id`, integer)\n(`date`, date)\n(`violation_type_id`, text)\n(`risk_category`, text)\n(`description`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"violations\"\nColumns:\n(\"business_id\", BIGINT)\n(\"_date\", DATE)\n(\"violation_type_id\", STRING)\n(\"risk_category\", STRING)\n(\"description\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 608,
        "database_name": "food_inspection",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T2.business_id) FROM violations AS T1 INNER JOIN inspections AS T2 ON T1.business_id = T2.business_id WHERE STRFTIME('%Y', T1.`date`) = '2016' AND T2.type = 'Routine - Unscheduled'",
        "target_query": "SELECT COUNT(\"T2\".\"business_id\") FROM \"violations\" AS \"T1\" INNER JOIN \"inspections\" AS \"T2\" ON \"T1\".\"business_id\" = \"T2\".\"business_id\" WHERE sys.timestamp_to_str(\"T1\".\"_date\", '%Y') = '2016' AND \"T2\".\"type\" = 'Routine - Unscheduled';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 121,
                "end_index": 145,
                "dilatect_content": "STRFTIME('%Y', T1.`date`)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 161,
                "end_index": 204,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `violations`\nColumns:\n(`business_id`, integer)\n(`date`, date)\n(`violation_type_id`, text)\n(`risk_category`, text)\n(`description`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `inspections`\nColumns:\n(`business_id`, integer)\n(`score`, integer)\n(`date`, date)\n(`type`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"violations\"\nColumns:\n(\"business_id\", BIGINT)\n(\"_date\", DATE)\n(\"violation_type_id\", STRING)\n(\"risk_category\", STRING)\n(\"description\", STRING)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"inspections\"\nColumns:\n(\"business_id\", BIGINT)\n(\"score\", BIGINT)\n(\"_date\", DATE)\n(\"type\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 609,
        "database_name": "craftbeer",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T1.style = 'American Adjunct Lager', 1, 0)) AS REAL) * 100 / COUNT(T1.brewery_id) FROM beers AS T1 INNER JOIN breweries AS T2 ON T1.brewery_id = T2.id WHERE T2.name = 'Stevens Point Brewery'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T1\".\"style\" = 'American Adjunct Lager' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"brewery_id\") FROM \"beers\" AS \"T1\" INNER JOIN \"breweries\" AS \"T2\" ON \"T1\".\"brewery_id\" = \"T2\".\"id\" WHERE \"T2\".\"name\" = 'Stevens Point Brewery';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 61,
                "dilatect_content": "IIF(T1.style = 'American Adjunct Lager', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 86,
                "dilatect_content": "CASE WHEN \"T1\".\"style\" = 'American Adjunct Lager' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `beers`\nColumns:\n(`id`, integer, primary key)\n(`brewery_id`, integer)\n(`abv`, real)\n(`ibu`, real)\n(`name`, text)\n(`style`, text)\n(`ounces`, real)\n",
            "Table: `breweries`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`city`, text)\n(`state`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"beers\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"brewery_id\", BIGINT)\n(\"abv\", DOUBLE PRECISION)\n(\"ibu\", DOUBLE PRECISION)\n(\"name\", STRING)\n(\"style\", STRING)\n(\"ounces\", DOUBLE PRECISION)\n",
            "Table: \"breweries\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n"
        ]
    },
    {
        "sql_id": 610,
        "database_name": "craftbeer",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.state = 'WI', 1, 0)) AS REAL) * 100 / COUNT(T1.id) FROM beers AS T1 INNER JOIN breweries AS T2 ON T1.brewery_id = T2.id WHERE T1.style = 'American Blonde Ale'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"state\" = 'WI' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"id\") FROM \"beers\" AS \"T1\" INNER JOIN \"breweries\" AS \"T2\" ON \"T1\".\"brewery_id\" = \"T2\".\"id\" WHERE \"T1\".\"style\" = 'American Blonde Ale';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 41,
                "dilatect_content": "IIF(T2.state = 'WI', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 66,
                "dilatect_content": "CASE WHEN \"T2\".\"state\" = 'WI' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `beers`\nColumns:\n(`id`, integer, primary key)\n(`brewery_id`, integer)\n(`abv`, real)\n(`ibu`, real)\n(`name`, text)\n(`style`, text)\n(`ounces`, real)\n",
            "Table: `breweries`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`city`, text)\n(`state`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"beers\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"brewery_id\", BIGINT)\n(\"abv\", DOUBLE PRECISION)\n(\"ibu\", DOUBLE PRECISION)\n(\"name\", STRING)\n(\"style\", STRING)\n(\"ounces\", DOUBLE PRECISION)\n",
            "Table: \"breweries\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"city\", STRING)\n(\"state\", STRING)\n"
        ]
    },
    {
        "sql_id": 611,
        "database_name": "human_resources",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT ssn FROM employee WHERE gender = 'M' AND CAST(REPLACE(SUBSTR(salary, 4), ',', '') AS REAL) > 70000",
        "target_query": "SELECT \"ssn\" FROM \"employee\" WHERE \"gender\" = 'M' AND CAST(REPLACE(substring(\"salary\" from 4), ',', '') AS REAL) > 70000;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 61,
                "end_index": 77,
                "dilatect_content": "SUBSTR(salary, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 73,
                "end_index": 100,
                "dilatect_content": "substring(\"salary\" from 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`ssn`, text, primary key)\n(`lastname`, text)\n(`firstname`, text)\n(`hiredate`, text)\n(`salary`, text)\n(`gender`, text)\n(`performance`, text)\n(`positionID`, integer)\n(`locationID`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"employee\"\nColumns:\n(\"ssn\", STRING, primary key)\n(\"lastname\", STRING)\n(\"firstname\", STRING)\n(\"hiredate\", STRING)\n(\"salary\", STRING)\n(\"gender\", STRING)\n(\"performance\", STRING)\n(\"positionID\", BIGINT)\n(\"locationID\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 612,
        "database_name": "human_resources",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(REPLACE(SUBSTR(T1.salary, 4), ',', '') AS REAL) - CAST(REPLACE(SUBSTR(T2.minsalary, 4), ',', '') AS REAL) AS diff FROM employee AS T1  INNER JOIN position AS T2  ON T1.positionID = T2.positionID WHERE T1.lastname = 'Johnson' AND T1.firstname = 'James'",
        "target_query": "SELECT CAST(REPLACE(substring(\"T1\".\"salary\" from 4 for char_length(\"T1\".\"salary\") - 3), ',', '') AS REAL) - CAST(REPLACE(substring(\"T2\".\"minsalary\" from 4 for char_length(\"T2\".\"minsalary\") - 3), ',', '') AS REAL) AS diff FROM \"employee\" AS \"T1\" INNER JOIN \"_position\" AS \"T2\" ON \"T1\".\"positionID\" = \"T2\".\"positionID\" WHERE \"T1\".\"lastname\" = 'Johnson' AND \"T1\".\"firstname\" = 'James';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 20,
                "end_index": 39,
                "dilatect_content": "SUBSTR(T1.salary, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 75,
                "end_index": 97,
                "dilatect_content": "SUBSTR(T2.minsalary, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 20,
                "end_index": 93,
                "dilatect_content": "substring(\"T1\".\"salary\" from 4 for char_length(\"T1\".\"salary\") - 3)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 129,
                "end_index": 208,
                "dilatect_content": "substring(\"T2\".\"minsalary\" from 4 for char_length(\"T2\".\"minsalary\") - 3)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`ssn`, text, primary key)\n(`lastname`, text)\n(`firstname`, text)\n(`hiredate`, text)\n(`salary`, text)\n(`gender`, text)\n(`performance`, text)\n(`positionID`, integer)\n(`locationID`, integer)\n",
            "Table: `position`\nColumns:\n(`positionID`, integer, primary key)\n(`positiontitle`, text)\n(`educationrequired`, text)\n(`minsalary`, text)\n(`maxsalary`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"employee\"\nColumns:\n(\"ssn\", STRING, primary key)\n(\"lastname\", STRING)\n(\"firstname\", STRING)\n(\"hiredate\", STRING)\n(\"salary\", STRING)\n(\"gender\", STRING)\n(\"performance\", STRING)\n(\"positionID\", BIGINT)\n(\"locationID\", BIGINT)\n",
            "Table: \"_position\"\nColumns:\n(\"positionID\", BIGINT, primary key)\n(\"positiontitle\", STRING)\n(\"educationrequired\", STRING)\n(\"minsalary\", STRING)\n(\"maxsalary\", STRING)\n"
        ]
    },
    {
        "sql_id": 613,
        "database_name": "human_resources",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(*) FROM employee AS T1  INNER JOIN position AS T2  ON T1.positionID = T2.positionID WHERE CAST(REPLACE(SUBSTR(T1.salary, 4), ',', '') AS REAL) > 20000 AND T2.positiontitle = 'Trainee'",
        "target_query": "SELECT COUNT(*) FROM \"employee\" AS \"T1\" INNER JOIN \"_position\" AS \"T2\" ON \"T1\".\"positionID\" = \"T2\".\"positionID\" WHERE CAST(REPLACE(substring(\"T1\".\"salary\" from 4) , ',', '') AS REAL) > 20000 AND \"T2\".\"positiontitle\" = 'Trainee';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 116,
                "end_index": 135,
                "dilatect_content": "SUBSTR(T1.salary, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 147,
                "end_index": 181,
                "dilatect_content": "substring(\"T1\".\"salary\" from 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`ssn`, text, primary key)\n(`lastname`, text)\n(`firstname`, text)\n(`hiredate`, text)\n(`salary`, text)\n(`gender`, text)\n(`performance`, text)\n(`positionID`, integer)\n(`locationID`, integer)\n",
            "Table: `position`\nColumns:\n(`positionID`, integer, primary key)\n(`positiontitle`, text)\n(`educationrequired`, text)\n(`minsalary`, text)\n(`maxsalary`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"employee\"\nColumns:\n(\"ssn\", STRING, primary key)\n(\"lastname\", STRING)\n(\"firstname\", STRING)\n(\"hiredate\", STRING)\n(\"salary\", STRING)\n(\"gender\", STRING)\n(\"performance\", STRING)\n(\"positionID\", BIGINT)\n(\"locationID\", BIGINT)\n",
            "Table: \"_position\"\nColumns:\n(\"positionID\", BIGINT, primary key)\n(\"positiontitle\", STRING)\n(\"educationrequired\", STRING)\n(\"minsalary\", STRING)\n(\"maxsalary\", STRING)\n"
        ]
    },
    {
        "sql_id": 614,
        "database_name": "human_resources",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT AVG(CAST(REPLACE(SUBSTR(T1.salary, 4), ',', '') AS REAL)) AS avg FROM employee AS T1  INNER JOIN position AS T2  ON T1.positionID = T2.positionID WHERE T2.positiontitle = 'Trainee'",
        "target_query": "SELECT AVG(CAST(REPLACE(substring(\"T1\".\"salary\" from 4) , ',', '') AS REAL)) AS avg FROM \"employee\" AS \"T1\" INNER JOIN \"_position\" AS \"T2\" ON \"T1\".\"positionID\" = \"T2\".\"positionID\" WHERE \"T2\".\"positiontitle\" = 'Trainee';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 24,
                "end_index": 43,
                "dilatect_content": "SUBSTR(T1.salary, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 24,
                "end_index": 58,
                "dilatect_content": "substring(\"T1\".\"salary\" from 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`ssn`, text, primary key)\n(`lastname`, text)\n(`firstname`, text)\n(`hiredate`, text)\n(`salary`, text)\n(`gender`, text)\n(`performance`, text)\n(`positionID`, integer)\n(`locationID`, integer)\n",
            "Table: `position`\nColumns:\n(`positionID`, integer, primary key)\n(`positiontitle`, text)\n(`educationrequired`, text)\n(`minsalary`, text)\n(`maxsalary`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"employee\"\nColumns:\n(\"ssn\", STRING, primary key)\n(\"lastname\", STRING)\n(\"firstname\", STRING)\n(\"hiredate\", STRING)\n(\"salary\", STRING)\n(\"gender\", STRING)\n(\"performance\", STRING)\n(\"positionID\", BIGINT)\n(\"locationID\", BIGINT)\n",
            "Table: \"_position\"\nColumns:\n(\"positionID\", BIGINT, primary key)\n(\"positiontitle\", STRING)\n(\"educationrequired\", STRING)\n(\"minsalary\", STRING)\n(\"maxsalary\", STRING)\n"
        ]
    },
    {
        "sql_id": 617,
        "database_name": "human_resources",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(*) FROM employee WHERE performance = 'Poor' AND CAST(REPLACE(SUBSTR(salary, 4), ',', '') AS REAL) > 50000",
        "target_query": "SELECT COUNT(*) FROM \"employee\" WHERE \"performance\" = 'Poor' AND CAST(REPLACE(substring(\"salary\" from 4) , ',', '') AS DOUBLE PRECISION) > 50000;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 74,
                "end_index": 90,
                "dilatect_content": "SUBSTR(salary, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 82,
                "end_index": 109,
                "dilatect_content": "substring(\"salary\" from 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`ssn`, text, primary key)\n(`lastname`, text)\n(`firstname`, text)\n(`hiredate`, text)\n(`salary`, text)\n(`gender`, text)\n(`performance`, text)\n(`positionID`, integer)\n(`locationID`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"employee\"\nColumns:\n(\"ssn\", STRING, primary key)\n(\"lastname\", STRING)\n(\"firstname\", STRING)\n(\"hiredate\", STRING)\n(\"salary\", STRING)\n(\"gender\", STRING)\n(\"performance\", STRING)\n(\"positionID\", BIGINT)\n(\"locationID\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 618,
        "database_name": "human_resources",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT firstname, lastname FROM employee WHERE CAST(REPLACE(SUBSTR(salary, 4), ',', '') AS REAL) = ( SELECT MAX(CAST(REPLACE(SUBSTR(salary, 4), ',', '') AS REAL)) FROM employee )",
        "target_query": "SELECT \"firstname\", \"lastname\" FROM \"employee\" WHERE CAST(REPLACE(substring(\"salary\" from 4), ',', '') AS REAL) = ( SELECT MAX(CAST(REPLACE(substring(\"salary\" from 4), ',', '') AS REAL)) FROM \"employee\" );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 60,
                "end_index": 76,
                "dilatect_content": "SUBSTR(salary, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 125,
                "end_index": 141,
                "dilatect_content": "SUBSTR(salary, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 72,
                "end_index": 99,
                "dilatect_content": "substring(\"salary\" from 4)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 148,
                "end_index": 175,
                "dilatect_content": "substring(\"salary\" from 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`ssn`, text, primary key)\n(`lastname`, text)\n(`firstname`, text)\n(`hiredate`, text)\n(`salary`, text)\n(`gender`, text)\n(`performance`, text)\n(`positionID`, integer)\n(`locationID`, integer)\n",
            "Table: `employee`\nColumns:\n(`ssn`, text, primary key)\n(`lastname`, text)\n(`firstname`, text)\n(`hiredate`, text)\n(`salary`, text)\n(`gender`, text)\n(`performance`, text)\n(`positionID`, integer)\n(`locationID`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"employee\"\nColumns:\n(\"ssn\", STRING, primary key)\n(\"lastname\", STRING)\n(\"firstname\", STRING)\n(\"hiredate\", STRING)\n(\"salary\", STRING)\n(\"gender\", STRING)\n(\"performance\", STRING)\n(\"positionID\", BIGINT)\n(\"locationID\", BIGINT)\n",
            "Table: \"employee\"\nColumns:\n(\"ssn\", STRING, primary key)\n(\"lastname\", STRING)\n(\"firstname\", STRING)\n(\"hiredate\", STRING)\n(\"salary\", STRING)\n(\"gender\", STRING)\n(\"performance\", STRING)\n(\"positionID\", BIGINT)\n(\"locationID\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 619,
        "database_name": "human_resources",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(*) FROM position WHERE CAST(REPLACE(SUBSTR(maxsalary, 4), ',', '') AS REAL) < 100000",
        "target_query": "SELECT COUNT(*) FROM \"_position\" WHERE CAST(REPLACE(substring(\"maxsalary\" from 4 for char_length(\"maxsalary\") - 3), ',', '') AS REAL) < 100000;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 49,
                "end_index": 68,
                "dilatect_content": "SUBSTR(maxsalary, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 54,
                "end_index": 119,
                "dilatect_content": "substring(\"maxsalary\" from 4 for char_length(\"maxsalary\") - 3)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `position`\nColumns:\n(`positionID`, integer, primary key)\n(`positiontitle`, text)\n(`educationrequired`, text)\n(`minsalary`, text)\n(`maxsalary`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"_position\"\nColumns:\n(\"positionID\", BIGINT, primary key)\n(\"positiontitle\", STRING)\n(\"educationrequired\", STRING)\n(\"minsalary\", STRING)\n(\"maxsalary\", STRING)\n"
        ]
    },
    {
        "sql_id": 620,
        "database_name": "human_resources",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT AVG(CAST(REPLACE(SUBSTR(T1.salary, 4), ',', '') AS REAL)) FROM employee AS T1  INNER JOIN position AS T2  ON T1.positionID = T2.positionID WHERE T2.educationrequired = '2 year degree'",
        "target_query": "SELECT AVG(CAST(REPLACE(substring(\"T1\".\"salary\" from 4) , ',', '') AS REAL)) FROM \"employee\" AS \"T1\" INNER JOIN \"_position\" AS \"T2\" ON \"T1\".\"positionID\" = \"T2\".\"positionID\" WHERE \"T2\".\"educationrequired\" = '2 year degree';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 24,
                "end_index": 43,
                "dilatect_content": "SUBSTR(T1.salary, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 24,
                "end_index": 58,
                "dilatect_content": "substring(\"T1\".\"salary\" from 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`ssn`, text, primary key)\n(`lastname`, text)\n(`firstname`, text)\n(`hiredate`, text)\n(`salary`, text)\n(`gender`, text)\n(`performance`, text)\n(`positionID`, integer)\n(`locationID`, integer)\n",
            "Table: `position`\nColumns:\n(`positionID`, integer, primary key)\n(`positiontitle`, text)\n(`educationrequired`, text)\n(`minsalary`, text)\n(`maxsalary`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"employee\"\nColumns:\n(\"ssn\", STRING, primary key)\n(\"lastname\", STRING)\n(\"firstname\", STRING)\n(\"hiredate\", STRING)\n(\"salary\", STRING)\n(\"gender\", STRING)\n(\"performance\", STRING)\n(\"positionID\", BIGINT)\n(\"locationID\", BIGINT)\n",
            "Table: \"_position\"\nColumns:\n(\"positionID\", BIGINT, primary key)\n(\"positiontitle\", STRING)\n(\"educationrequired\", STRING)\n(\"minsalary\", STRING)\n(\"maxsalary\", STRING)\n"
        ]
    },
    {
        "sql_id": 621,
        "database_name": "human_resources",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT AVG(CAST(REPLACE(SUBSTR(T1.salary, 4), ',', '') AS REAL)) FROM employee AS T1 INNER JOIN position AS T2  ON T1.positionID = T2.positionID WHERE T1.performance = 'Poor' AND T2.positiontitle = 'Manager'",
        "target_query": "SELECT AVG(CAST(REPLACE(substring(\"T1\".\"salary\" from 4), ',', '') AS DOUBLE PRECISION)) FROM \"employee\" AS \"T1\" INNER JOIN \"_position\" AS \"T2\" ON \"T1\".\"positionID\" = \"T2\".\"positionID\" WHERE \"T1\".\"performance\" = 'Poor' AND \"T2\".\"positiontitle\" = 'Manager';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 24,
                "end_index": 43,
                "dilatect_content": "SUBSTR(T1.salary, 4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 24,
                "end_index": 58,
                "dilatect_content": "substring(\"T1\".\"salary\" from 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`ssn`, text, primary key)\n(`lastname`, text)\n(`firstname`, text)\n(`hiredate`, text)\n(`salary`, text)\n(`gender`, text)\n(`performance`, text)\n(`positionID`, integer)\n(`locationID`, integer)\n",
            "Table: `position`\nColumns:\n(`positionID`, integer, primary key)\n(`positiontitle`, text)\n(`educationrequired`, text)\n(`minsalary`, text)\n(`maxsalary`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"employee\"\nColumns:\n(\"ssn\", STRING, primary key)\n(\"lastname\", STRING)\n(\"firstname\", STRING)\n(\"hiredate\", STRING)\n(\"salary\", STRING)\n(\"gender\", STRING)\n(\"performance\", STRING)\n(\"positionID\", BIGINT)\n(\"locationID\", BIGINT)\n",
            "Table: \"_position\"\nColumns:\n(\"positionID\", BIGINT, primary key)\n(\"positiontitle\", STRING)\n(\"educationrequired\", STRING)\n(\"minsalary\", STRING)\n(\"maxsalary\", STRING)\n"
        ]
    },
    {
        "sql_id": 624,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT MAX(T2.max_temperature_f) FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code AND T2.date = SUBSTR(CAST(T1.start_date AS TEXT), 1, INSTR(T1.start_date, ' ') - 1) WHERE T1.id = 4080",
        "target_query": "SELECT MAX(\"T2\".\"max_temperature_f\") FROM \"trip\" AS \"T1\" INNER JOIN \"weather\" AS \"T2\" ON \"T2\".\"zip_code\" = \"T1\".\"zip_code\" AND \"T2\".\"_date\" = substring(\"T1\".\"start_date\" from 1 for POSITION(' ' IN \"T1\".\"start_date\") - 1) WHERE \"T1\".\"id\" = 4080;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 117,
                "end_index": 185,
                "dilatect_content": "SUBSTR(CAST(T1.start_date AS TEXT), 1, INSTR(T1.start_date, ' ') - 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 156,
                "end_index": 180,
                "dilatect_content": "INSTR(T1.start_date, ' ')",
                "feature": "instr(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 166,
                "end_index": 251,
                "dilatect_content": "substring(\"T1\".\"start_date\" from 1 for POSITION(' ' IN \"T1\".\"start_date\") - 1)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 209,
                "end_index": 246,
                "dilatect_content": "POSITION(' ' IN \"T1\".\"start_date\")",
                "feature": "POSITION(Y IN X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "instr(X,Y)",
                "explanation": "The instr(X,Y) function finds the first occurrence of string Y within \n  string X and returns the number of prior characters plus 1, or 0 if\n  Y is nowhere found within X.\n  Or, if X and Y are both BLOBs, then instr(X,Y) returns one\n  more than the number bytes prior to the first occurrence of Y, or 0 if\n  Y does not occur anywhere within X.\n  If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs\n  then both are interpreted as strings.\n  If either X or Y are NULL in instr(X,Y) then the result is NULL.\n",
                "examples": [
                    "SELECT instr('Hello World', 'World'); -- Returns 7",
                    "SELECT instr('abcdefg', 'x'); -- Returns 0 (not found)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            },
            {
                "feature": "POSITION(Y IN X)",
                "explanation": "In MonetDB, the POSITION function is used to find the first occurrence of string Y within string X and returns the number of characters from the beginning of X to the start of Y. If Y is not found within X, it returns 0.",
                "examples": [
                    "SELECT POSITION('World' IN 'Hello World'); -- Returns 7",
                    "SELECT POSITION('x' IN 'abcdefg'); -- Returns 0 (not found)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `trip`\nColumns:\n(`id`, integer, primary key)\n(`duration`, integer)\n(`start_date`, text)\n(`start_station_name`, text)\n(`start_station_id`, integer)\n(`end_date`, text)\n(`end_station_name`, text)\n(`end_station_id`, integer)\n(`bike_id`, integer)\n(`subscription_type`, text)\n(`zip_code`, integer)\n",
            "Table: `weather`\nColumns:\n(`date`, text)\n(`max_temperature_f`, integer)\n(`mean_temperature_f`, integer)\n(`min_temperature_f`, integer)\n(`max_dew_point_f`, integer)\n(`mean_dew_point_f`, integer)\n(`min_dew_point_f`, integer)\n(`max_humidity`, integer)\n(`mean_humidity`, integer)\n(`min_humidity`, integer)\n(`max_sea_level_pressure_inches`, real)\n(`mean_sea_level_pressure_inches`, real)\n(`min_sea_level_pressure_inches`, real)\n(`max_visibility_miles`, integer)\n(`mean_visibility_miles`, integer)\n(`min_visibility_miles`, integer)\n(`max_wind_Speed_mph`, integer)\n(`mean_wind_speed_mph`, integer)\n(`max_gust_speed_mph`, integer)\n(`precipitation_inches`, text)\n(`cloud_cover`, integer)\n(`events`, text)\n(`wind_dir_degrees`, integer)\n(`zip_code`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"trip\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"duration\", BIGINT)\n(\"start_date\", STRING)\n(\"start_station_name\", STRING)\n(\"start_station_id\", BIGINT)\n(\"end_date\", STRING)\n(\"end_station_name\", STRING)\n(\"end_station_id\", BIGINT)\n(\"bike_id\", BIGINT)\n(\"subscription_type\", STRING)\n(\"zip_code\", BIGINT)\n",
            "Table: \"weather\"\nColumns:\n(\"_date\", STRING)\n(\"max_temperature_f\", BIGINT)\n(\"mean_temperature_f\", BIGINT)\n(\"min_temperature_f\", BIGINT)\n(\"max_dew_point_f\", BIGINT)\n(\"mean_dew_point_f\", BIGINT)\n(\"min_dew_point_f\", BIGINT)\n(\"max_humidity\", BIGINT)\n(\"mean_humidity\", BIGINT)\n(\"min_humidity\", BIGINT)\n(\"max_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"mean_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"min_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"max_visibility_miles\", BIGINT)\n(\"mean_visibility_miles\", BIGINT)\n(\"min_visibility_miles\", BIGINT)\n(\"max_wind_Speed_mph\", BIGINT)\n(\"mean_wind_speed_mph\", BIGINT)\n(\"max_gust_speed_mph\", BIGINT)\n(\"precipitation_inches\", STRING)\n(\"cloud_cover\", BIGINT)\n(\"events\", STRING)\n(\"wind_dir_degrees\", BIGINT)\n(\"zip_code\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 625,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.id, T1.duration FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code AND T2.date = SUBSTR(CAST(T1.start_date AS TEXT), 1, INSTR(T1.start_date, ' ') - 1) WHERE T2.events LIKE '%Rain%' OR T2.events LIKE '%rain%'",
        "target_query": "SELECT \"T1\".\"id\", \"T1\".\"duration\" FROM \"trip\" AS \"T1\" INNER JOIN \"weather\" AS \"T2\" ON \"T2\".\"zip_code\" = \"T1\".\"zip_code\" AND \"T2\".\"_date\" = substring(CAST(\"T1\".\"start_date\" AS TEXT) from 1 for POSITION(' ' IN \"T1\".\"start_date\") - 1) WHERE \"T2\".\"events\" LIKE '%Rain%' OR \"T2\".\"events\" LIKE '%rain%';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 110,
                "end_index": 178,
                "dilatect_content": "SUBSTR(CAST(T1.start_date AS TEXT), 1, INSTR(T1.start_date, ' ') - 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 149,
                "end_index": 173,
                "dilatect_content": "INSTR(T1.start_date, ' ')",
                "feature": "instr(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 167,
                "end_index": 266,
                "dilatect_content": "substring(CAST(\"T1\".\"start_date\" AS TEXT) from 1 for POSITION(' ' IN \"T1\".\"start_date\") - 1)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 224,
                "end_index": 261,
                "dilatect_content": "POSITION(' ' IN \"T1\".\"start_date\")",
                "feature": "POSITION(Y IN X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "instr(X,Y)",
                "explanation": "The instr(X,Y) function finds the first occurrence of string Y within \n  string X and returns the number of prior characters plus 1, or 0 if\n  Y is nowhere found within X.\n  Or, if X and Y are both BLOBs, then instr(X,Y) returns one\n  more than the number bytes prior to the first occurrence of Y, or 0 if\n  Y does not occur anywhere within X.\n  If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs\n  then both are interpreted as strings.\n  If either X or Y are NULL in instr(X,Y) then the result is NULL.\n",
                "examples": [
                    "SELECT instr('Hello World', 'World'); -- Returns 7",
                    "SELECT instr('abcdefg', 'x'); -- Returns 0 (not found)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            },
            {
                "feature": "POSITION(Y IN X)",
                "explanation": "In MonetDB, the POSITION function is used to find the first occurrence of string Y within string X and returns the number of characters from the beginning of X to the start of Y. If Y is not found within X, it returns 0.",
                "examples": [
                    "SELECT POSITION('World' IN 'Hello World'); -- Returns 7",
                    "SELECT POSITION('x' IN 'abcdefg'); -- Returns 0 (not found)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `trip`\nColumns:\n(`id`, integer, primary key)\n(`duration`, integer)\n(`start_date`, text)\n(`start_station_name`, text)\n(`start_station_id`, integer)\n(`end_date`, text)\n(`end_station_name`, text)\n(`end_station_id`, integer)\n(`bike_id`, integer)\n(`subscription_type`, text)\n(`zip_code`, integer)\n",
            "Table: `weather`\nColumns:\n(`date`, text)\n(`max_temperature_f`, integer)\n(`mean_temperature_f`, integer)\n(`min_temperature_f`, integer)\n(`max_dew_point_f`, integer)\n(`mean_dew_point_f`, integer)\n(`min_dew_point_f`, integer)\n(`max_humidity`, integer)\n(`mean_humidity`, integer)\n(`min_humidity`, integer)\n(`max_sea_level_pressure_inches`, real)\n(`mean_sea_level_pressure_inches`, real)\n(`min_sea_level_pressure_inches`, real)\n(`max_visibility_miles`, integer)\n(`mean_visibility_miles`, integer)\n(`min_visibility_miles`, integer)\n(`max_wind_Speed_mph`, integer)\n(`mean_wind_speed_mph`, integer)\n(`max_gust_speed_mph`, integer)\n(`precipitation_inches`, text)\n(`cloud_cover`, integer)\n(`events`, text)\n(`wind_dir_degrees`, integer)\n(`zip_code`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"trip\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"duration\", BIGINT)\n(\"start_date\", STRING)\n(\"start_station_name\", STRING)\n(\"start_station_id\", BIGINT)\n(\"end_date\", STRING)\n(\"end_station_name\", STRING)\n(\"end_station_id\", BIGINT)\n(\"bike_id\", BIGINT)\n(\"subscription_type\", STRING)\n(\"zip_code\", BIGINT)\n",
            "Table: \"weather\"\nColumns:\n(\"_date\", STRING)\n(\"max_temperature_f\", BIGINT)\n(\"mean_temperature_f\", BIGINT)\n(\"min_temperature_f\", BIGINT)\n(\"max_dew_point_f\", BIGINT)\n(\"mean_dew_point_f\", BIGINT)\n(\"min_dew_point_f\", BIGINT)\n(\"max_humidity\", BIGINT)\n(\"mean_humidity\", BIGINT)\n(\"min_humidity\", BIGINT)\n(\"max_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"mean_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"min_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"max_visibility_miles\", BIGINT)\n(\"mean_visibility_miles\", BIGINT)\n(\"min_visibility_miles\", BIGINT)\n(\"max_wind_Speed_mph\", BIGINT)\n(\"mean_wind_speed_mph\", BIGINT)\n(\"max_gust_speed_mph\", BIGINT)\n(\"precipitation_inches\", STRING)\n(\"cloud_cover\", BIGINT)\n(\"events\", STRING)\n(\"wind_dir_degrees\", BIGINT)\n(\"zip_code\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 626,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT AVG(T1.duration), AVG(T2.wind_dir_degrees) FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE SUBSTR(CAST(T2.date AS TEXT), 1, INSTR(T2.date, '/') - 1) IN ('7', '8', '9') AND SUBSTR(CAST(T2.date AS TEXT), -4) = '2013'",
        "target_query": "SELECT AVG(\"T1\".\"duration\"), AVG(\"T2\".\"wind_dir_degrees\") FROM \"trip\" AS \"T1\" INNER JOIN \"weather\" AS \"T2\" ON \"T2\".\"zip_code\" = \"T1\".\"zip_code\" WHERE \"T2\".\"_date\" IS NOT NULL AND substring(\"T2\".\"_date\" from 1 for POSITION('/' IN \"T2\".\"_date\") - 1) IN ('7', '8', '9') AND substring(\"T2\".\"_date\" from char_length(\"T2\".\"_date\") - 3 for 4) = '2013' AND \"T1\".\"duration\" IS NOT NULL AND \"T2\".\"wind_dir_degrees\" IS NOT NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 126,
                "end_index": 182,
                "dilatect_content": "SUBSTR(CAST(T2.date AS TEXT), 1, INSTR(T2.date, '/') - 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 159,
                "end_index": 177,
                "dilatect_content": "INSTR(T2.date, '/')",
                "feature": "instr(X,Y)"
            },
            {
                "start_index": 207,
                "end_index": 239,
                "dilatect_content": "SUBSTR(CAST(T2.date AS TEXT), -4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 207,
                "end_index": 282,
                "dilatect_content": "substring(\"T2\".\"_date\" from 1 for POSITION('/' IN \"T2\".\"_date\") - 1)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 245,
                "end_index": 277,
                "dilatect_content": "POSITION('/' IN \"T2\".\"_date\")",
                "feature": "POSITION(Y IN X)"
            },
            {
                "start_index": 307,
                "end_index": 378,
                "dilatect_content": "substring(\"T2\".\"_date\" from char_length(\"T2\".\"_date\") - 3 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "instr(X,Y)",
                "explanation": "The instr(X,Y) function finds the first occurrence of string Y within \n  string X and returns the number of prior characters plus 1, or 0 if\n  Y is nowhere found within X.\n  Or, if X and Y are both BLOBs, then instr(X,Y) returns one\n  more than the number bytes prior to the first occurrence of Y, or 0 if\n  Y does not occur anywhere within X.\n  If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs\n  then both are interpreted as strings.\n  If either X or Y are NULL in instr(X,Y) then the result is NULL.\n",
                "examples": [
                    "SELECT instr('Hello World', 'World'); -- Returns 7",
                    "SELECT instr('abcdefg', 'x'); -- Returns 0 (not found)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            },
            {
                "feature": "POSITION(Y IN X)",
                "explanation": "In MonetDB, the POSITION function is used to find the first occurrence of string Y within string X and returns the number of characters from the beginning of X to the start of Y. If Y is not found within X, it returns 0.",
                "examples": [
                    "SELECT POSITION('World' IN 'Hello World'); -- Returns 7",
                    "SELECT POSITION('x' IN 'abcdefg'); -- Returns 0 (not found)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `trip`\nColumns:\n(`id`, integer, primary key)\n(`duration`, integer)\n(`start_date`, text)\n(`start_station_name`, text)\n(`start_station_id`, integer)\n(`end_date`, text)\n(`end_station_name`, text)\n(`end_station_id`, integer)\n(`bike_id`, integer)\n(`subscription_type`, text)\n(`zip_code`, integer)\n",
            "Table: `weather`\nColumns:\n(`date`, text)\n(`max_temperature_f`, integer)\n(`mean_temperature_f`, integer)\n(`min_temperature_f`, integer)\n(`max_dew_point_f`, integer)\n(`mean_dew_point_f`, integer)\n(`min_dew_point_f`, integer)\n(`max_humidity`, integer)\n(`mean_humidity`, integer)\n(`min_humidity`, integer)\n(`max_sea_level_pressure_inches`, real)\n(`mean_sea_level_pressure_inches`, real)\n(`min_sea_level_pressure_inches`, real)\n(`max_visibility_miles`, integer)\n(`mean_visibility_miles`, integer)\n(`min_visibility_miles`, integer)\n(`max_wind_Speed_mph`, integer)\n(`mean_wind_speed_mph`, integer)\n(`max_gust_speed_mph`, integer)\n(`precipitation_inches`, text)\n(`cloud_cover`, integer)\n(`events`, text)\n(`wind_dir_degrees`, integer)\n(`zip_code`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"trip\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"duration\", BIGINT)\n(\"start_date\", STRING)\n(\"start_station_name\", STRING)\n(\"start_station_id\", BIGINT)\n(\"end_date\", STRING)\n(\"end_station_name\", STRING)\n(\"end_station_id\", BIGINT)\n(\"bike_id\", BIGINT)\n(\"subscription_type\", STRING)\n(\"zip_code\", BIGINT)\n",
            "Table: \"weather\"\nColumns:\n(\"_date\", STRING)\n(\"max_temperature_f\", BIGINT)\n(\"mean_temperature_f\", BIGINT)\n(\"min_temperature_f\", BIGINT)\n(\"max_dew_point_f\", BIGINT)\n(\"mean_dew_point_f\", BIGINT)\n(\"min_dew_point_f\", BIGINT)\n(\"max_humidity\", BIGINT)\n(\"mean_humidity\", BIGINT)\n(\"min_humidity\", BIGINT)\n(\"max_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"mean_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"min_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"max_visibility_miles\", BIGINT)\n(\"mean_visibility_miles\", BIGINT)\n(\"min_visibility_miles\", BIGINT)\n(\"max_wind_Speed_mph\", BIGINT)\n(\"mean_wind_speed_mph\", BIGINT)\n(\"max_gust_speed_mph\", BIGINT)\n(\"precipitation_inches\", STRING)\n(\"cloud_cover\", BIGINT)\n(\"events\", STRING)\n(\"wind_dir_degrees\", BIGINT)\n(\"zip_code\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 628,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUBSTR(CAST(date AS TEXT), -4) FROM weather GROUP BY SUBSTR(CAST(date AS TEXT), -4) ORDER BY SUM(CASE WHEN events LIKE '%Rain%' OR events LIKE '%rain%' THEN 1 ELSE 0 END) DESC LIMIT 1",
        "target_query": "SELECT substring(\"_date\" from char_length(\"_date\") - 3 for 4) FROM \"weather\" GROUP BY substring(\"_date\" from char_length(\"_date\") - 3 for 4) ORDER BY SUM(CASE WHEN \"events\" LIKE '%Rain%' OR \"events\" LIKE '%rain%' THEN 1 ELSE 0 END) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 30,
                "dilatect_content": "SUBSTR(CAST(date AS TEXT), -4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 60,
                "end_index": 83,
                "dilatect_content": "SUBSTR(CAST(date AS TEXT), -4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 64,
                "dilatect_content": "substring(\"_date\" from char_length(\"_date\") - 3 for 4)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 92,
                "end_index": 149,
                "dilatect_content": "substring(\"_date\" from char_length(\"_date\") - 3 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `weather`\nColumns:\n(`date`, text)\n(`max_temperature_f`, integer)\n(`mean_temperature_f`, integer)\n(`min_temperature_f`, integer)\n(`max_dew_point_f`, integer)\n(`mean_dew_point_f`, integer)\n(`min_dew_point_f`, integer)\n(`max_humidity`, integer)\n(`mean_humidity`, integer)\n(`min_humidity`, integer)\n(`max_sea_level_pressure_inches`, real)\n(`mean_sea_level_pressure_inches`, real)\n(`min_sea_level_pressure_inches`, real)\n(`max_visibility_miles`, integer)\n(`mean_visibility_miles`, integer)\n(`min_visibility_miles`, integer)\n(`max_wind_Speed_mph`, integer)\n(`mean_wind_speed_mph`, integer)\n(`max_gust_speed_mph`, integer)\n(`precipitation_inches`, text)\n(`cloud_cover`, integer)\n(`events`, text)\n(`wind_dir_degrees`, integer)\n(`zip_code`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"weather\"\nColumns:\n(\"_date\", STRING)\n(\"max_temperature_f\", BIGINT)\n(\"mean_temperature_f\", BIGINT)\n(\"min_temperature_f\", BIGINT)\n(\"max_dew_point_f\", BIGINT)\n(\"mean_dew_point_f\", BIGINT)\n(\"min_dew_point_f\", BIGINT)\n(\"max_humidity\", BIGINT)\n(\"mean_humidity\", BIGINT)\n(\"min_humidity\", BIGINT)\n(\"max_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"mean_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"min_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"max_visibility_miles\", BIGINT)\n(\"mean_visibility_miles\", BIGINT)\n(\"min_visibility_miles\", BIGINT)\n(\"max_wind_Speed_mph\", BIGINT)\n(\"mean_wind_speed_mph\", BIGINT)\n(\"max_gust_speed_mph\", BIGINT)\n(\"precipitation_inches\", STRING)\n(\"cloud_cover\", BIGINT)\n(\"events\", STRING)\n(\"wind_dir_degrees\", BIGINT)\n(\"zip_code\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 630,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.max_gust_speed_mph, T2.cloud_cover FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code AND T2.date = SUBSTR(CAST(T1.start_date AS TEXT), 1, INSTR(T1.start_date, ' ') - 1) WHERE T1.bike_id = 10 AND T2.mean_temperature_f > 62 AND T1.subscription_type = 'Customer' AND T1.start_station_name = 'MLK Library' AND T1.end_station_name = 'San Salvador at 1st' AND T1.duration = 386",
        "target_query": "SELECT T2.\"max_gust_speed_mph\", T2.\"cloud_cover\" \nFROM \"trip\" AS T1 \nINNER JOIN \"weather\" AS T2 \nON T2.\"zip_code\" = T1.\"zip_code\" \nAND T2.\"_date\" = substring(CAST(T1.\"start_date\" AS TEXT) from 1 for POSITION(' ' IN T1.\"start_date\") - 1) \nWHERE T1.\"bike_id\" = 10 \nAND T2.\"mean_temperature_f\" > 62 \nAND T1.\"subscription_type\" = 'Customer' \nAND T1.\"start_station_name\" = 'MLK Library' \nAND T1.\"end_station_name\" = 'San Salvador at 1st' \nAND T1.\"duration\" = 386;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 129,
                "end_index": 197,
                "dilatect_content": "SUBSTR(CAST(T1.start_date AS TEXT), 1, INSTR(T1.start_date, ' ') - 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 168,
                "end_index": 192,
                "dilatect_content": "INSTR(T1.start_date, ' ')",
                "feature": "instr(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 166,
                "end_index": 257,
                "dilatect_content": "substring(CAST(T1.\"start_date\" AS TEXT) from 1 for POSITION(' ' IN T1.\"start_date\") - 1)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 219,
                "end_index": 252,
                "dilatect_content": "POSITION(' ' IN T1.\"start_date\")",
                "feature": "POSITION(Y IN X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "instr(X,Y)",
                "explanation": "The instr(X,Y) function finds the first occurrence of string Y within \n  string X and returns the number of prior characters plus 1, or 0 if\n  Y is nowhere found within X.\n  Or, if X and Y are both BLOBs, then instr(X,Y) returns one\n  more than the number bytes prior to the first occurrence of Y, or 0 if\n  Y does not occur anywhere within X.\n  If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs\n  then both are interpreted as strings.\n  If either X or Y are NULL in instr(X,Y) then the result is NULL.\n",
                "examples": [
                    "SELECT instr('Hello World', 'World'); -- Returns 7",
                    "SELECT instr('abcdefg', 'x'); -- Returns 0 (not found)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            },
            {
                "feature": "POSITION(Y IN X)",
                "explanation": "In MonetDB, the POSITION function is used to find the first occurrence of string Y within string X and returns the number of characters from the beginning of X to the start of Y. If Y is not found within X, it returns 0.",
                "examples": [
                    "SELECT POSITION('World' IN 'Hello World'); -- Returns 7",
                    "SELECT POSITION('x' IN 'abcdefg'); -- Returns 0 (not found)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `trip`\nColumns:\n(`id`, integer, primary key)\n(`duration`, integer)\n(`start_date`, text)\n(`start_station_name`, text)\n(`start_station_id`, integer)\n(`end_date`, text)\n(`end_station_name`, text)\n(`end_station_id`, integer)\n(`bike_id`, integer)\n(`subscription_type`, text)\n(`zip_code`, integer)\n",
            "Table: `weather`\nColumns:\n(`date`, text)\n(`max_temperature_f`, integer)\n(`mean_temperature_f`, integer)\n(`min_temperature_f`, integer)\n(`max_dew_point_f`, integer)\n(`mean_dew_point_f`, integer)\n(`min_dew_point_f`, integer)\n(`max_humidity`, integer)\n(`mean_humidity`, integer)\n(`min_humidity`, integer)\n(`max_sea_level_pressure_inches`, real)\n(`mean_sea_level_pressure_inches`, real)\n(`min_sea_level_pressure_inches`, real)\n(`max_visibility_miles`, integer)\n(`mean_visibility_miles`, integer)\n(`min_visibility_miles`, integer)\n(`max_wind_Speed_mph`, integer)\n(`mean_wind_speed_mph`, integer)\n(`max_gust_speed_mph`, integer)\n(`precipitation_inches`, text)\n(`cloud_cover`, integer)\n(`events`, text)\n(`wind_dir_degrees`, integer)\n(`zip_code`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"trip\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"duration\", BIGINT)\n(\"start_date\", STRING)\n(\"start_station_name\", STRING)\n(\"start_station_id\", BIGINT)\n(\"end_date\", STRING)\n(\"end_station_name\", STRING)\n(\"end_station_id\", BIGINT)\n(\"bike_id\", BIGINT)\n(\"subscription_type\", STRING)\n(\"zip_code\", BIGINT)\n",
            "Table: \"weather\"\nColumns:\n(\"_date\", STRING)\n(\"max_temperature_f\", BIGINT)\n(\"mean_temperature_f\", BIGINT)\n(\"min_temperature_f\", BIGINT)\n(\"max_dew_point_f\", BIGINT)\n(\"mean_dew_point_f\", BIGINT)\n(\"min_dew_point_f\", BIGINT)\n(\"max_humidity\", BIGINT)\n(\"mean_humidity\", BIGINT)\n(\"min_humidity\", BIGINT)\n(\"max_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"mean_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"min_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"max_visibility_miles\", BIGINT)\n(\"mean_visibility_miles\", BIGINT)\n(\"min_visibility_miles\", BIGINT)\n(\"max_wind_Speed_mph\", BIGINT)\n(\"mean_wind_speed_mph\", BIGINT)\n(\"max_gust_speed_mph\", BIGINT)\n(\"precipitation_inches\", STRING)\n(\"cloud_cover\", BIGINT)\n(\"events\", STRING)\n(\"wind_dir_degrees\", BIGINT)\n(\"zip_code\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 631,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(subscription_type = 'Subscriber', 1, 0)) - SUM(IIF(subscription_type = 'Customer', 1, 0)) FROM trip WHERE start_date LIKE '6/%/2013%'",
        "target_query": "SELECT SUM(CASE WHEN \"subscription_type\" = 'Subscriber' THEN 1 ELSE 0 END) - SUM(CASE WHEN \"subscription_type\" = 'Customer' THEN 1 ELSE 0 END) FROM \"trip\" WHERE \"start_date\" LIKE '6/%/2013%';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 53,
                "dilatect_content": "IIF(subscription_type = 'Subscriber', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 62,
                "end_index": 102,
                "dilatect_content": "IIF(subscription_type = 'Customer', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 74,
                "dilatect_content": "CASE WHEN \"subscription_type\" = 'Subscriber' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 83,
                "end_index": 144,
                "dilatect_content": "CASE WHEN \"subscription_type\" = 'Customer' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `trip`\nColumns:\n(`id`, integer, primary key)\n(`duration`, integer)\n(`start_date`, text)\n(`start_station_name`, text)\n(`start_station_id`, integer)\n(`end_date`, text)\n(`end_station_name`, text)\n(`end_station_id`, integer)\n(`bike_id`, integer)\n(`subscription_type`, text)\n(`zip_code`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"trip\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"duration\", BIGINT)\n(\"start_date\", STRING)\n(\"start_station_name\", STRING)\n(\"start_station_id\", BIGINT)\n(\"end_date\", STRING)\n(\"end_station_name\", STRING)\n(\"end_station_id\", BIGINT)\n(\"bike_id\", BIGINT)\n(\"subscription_type\", STRING)\n(\"zip_code\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 632,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T2.date, T1.bike_id FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE SUBSTR(CAST(T2.date AS TEXT), -4) = '2013' AND T2.events = 'Fog-Rain'",
        "target_query": "SELECT \"weather\".\"_date\", \"trip\".\"bike_id\" FROM \"trip\" INNER JOIN \"weather\" ON \"weather\".\"zip_code\" = \"trip\".\"zip_code\" WHERE substring(\"weather\".\"_date\" from char_length(\"weather\".\"_date\") - 3 for 4) = '2013' AND \"weather\".\"events\" = 'Fog-Rain';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 103,
                "end_index": 135,
                "dilatect_content": "SUBSTR(CAST(T2.date AS TEXT), -4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 146,
                "end_index": 227,
                "dilatect_content": "substring(\"weather\".\"_date\" from char_length(\"weather\".\"_date\") - 3 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `trip`\nColumns:\n(`id`, integer, primary key)\n(`duration`, integer)\n(`start_date`, text)\n(`start_station_name`, text)\n(`start_station_id`, integer)\n(`end_date`, text)\n(`end_station_name`, text)\n(`end_station_id`, integer)\n(`bike_id`, integer)\n(`subscription_type`, text)\n(`zip_code`, integer)\n",
            "Table: `weather`\nColumns:\n(`date`, text)\n(`max_temperature_f`, integer)\n(`mean_temperature_f`, integer)\n(`min_temperature_f`, integer)\n(`max_dew_point_f`, integer)\n(`mean_dew_point_f`, integer)\n(`min_dew_point_f`, integer)\n(`max_humidity`, integer)\n(`mean_humidity`, integer)\n(`min_humidity`, integer)\n(`max_sea_level_pressure_inches`, real)\n(`mean_sea_level_pressure_inches`, real)\n(`min_sea_level_pressure_inches`, real)\n(`max_visibility_miles`, integer)\n(`mean_visibility_miles`, integer)\n(`min_visibility_miles`, integer)\n(`max_wind_Speed_mph`, integer)\n(`mean_wind_speed_mph`, integer)\n(`max_gust_speed_mph`, integer)\n(`precipitation_inches`, text)\n(`cloud_cover`, integer)\n(`events`, text)\n(`wind_dir_degrees`, integer)\n(`zip_code`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"trip\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"duration\", BIGINT)\n(\"start_date\", STRING)\n(\"start_station_name\", STRING)\n(\"start_station_id\", BIGINT)\n(\"end_date\", STRING)\n(\"end_station_name\", STRING)\n(\"end_station_id\", BIGINT)\n(\"bike_id\", BIGINT)\n(\"subscription_type\", STRING)\n(\"zip_code\", BIGINT)\n",
            "Table: \"weather\"\nColumns:\n(\"_date\", STRING)\n(\"max_temperature_f\", BIGINT)\n(\"mean_temperature_f\", BIGINT)\n(\"min_temperature_f\", BIGINT)\n(\"max_dew_point_f\", BIGINT)\n(\"mean_dew_point_f\", BIGINT)\n(\"min_dew_point_f\", BIGINT)\n(\"max_humidity\", BIGINT)\n(\"mean_humidity\", BIGINT)\n(\"min_humidity\", BIGINT)\n(\"max_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"mean_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"min_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"max_visibility_miles\", BIGINT)\n(\"mean_visibility_miles\", BIGINT)\n(\"min_visibility_miles\", BIGINT)\n(\"max_wind_Speed_mph\", BIGINT)\n(\"mean_wind_speed_mph\", BIGINT)\n(\"max_gust_speed_mph\", BIGINT)\n(\"precipitation_inches\", STRING)\n(\"cloud_cover\", BIGINT)\n(\"events\", STRING)\n(\"wind_dir_degrees\", BIGINT)\n(\"zip_code\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 633,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.start_date FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code AND T2.date = SUBSTR(CAST(T1.start_date AS TEXT), 1, INSTR(T1.start_date, ' ') - 1) WHERE T2.date LIKE '8/%/2013' AND T1.start_station_name = 'Market at 10th' AND T1.end_station_name = 'South Van Ness at Market' AND T2.min_temperature_f = ( SELECT MIN(T2.min_temperature_f) FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code AND T2.date = SUBSTR(CAST(T1.start_date AS TEXT), 1, INSTR(T1.start_date, ' ') - 1) WHERE T2.date LIKE '8/%/2013' AND T1.start_station_name = 'Market at 10th' AND T1.end_station_name = 'South Van Ness at Market' )",
        "target_query": "SELECT \"T1\".\"start_date\" FROM \"trip\" AS \"T1\" INNER JOIN \"weather\" AS \"T2\" ON \"T2\".\"zip_code\" = \"T1\".\"zip_code\" AND \"T2\".\"_date\" = substring(CAST(\"T1\".\"start_date\" AS TEXT) from 1 for POSITION(' ' IN \"T1\".\"start_date\") - 1) WHERE \"T2\".\"_date\" LIKE '8/%/2013' AND \"T1\".\"start_station_name\" = 'Market at 10th' AND \"T1\".\"end_station_name\" = 'South Van Ness at Market' AND \"T2\".\"min_temperature_f\" = ( SELECT MIN(\"T2\".\"min_temperature_f\") FROM \"trip\" AS \"T1\" INNER JOIN \"weather\" AS \"T2\" ON \"T2\".\"zip_code\" = \"T1\".\"zip_code\" AND \"T2\".\"_date\" = substring(CAST(\"T1\".\"start_date\" AS TEXT) from 1 for POSITION(' ' IN \"T1\".\"start_date\") - 1) WHERE \"T2\".\"_date\" LIKE '8/%/2013' AND \"T1\".\"start_station_name\" = 'Market at 10th' AND \"T1\".\"end_station_name\" = 'South Van Ness at Market' );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 105,
                "end_index": 173,
                "dilatect_content": "SUBSTR(CAST(T1.start_date AS TEXT), 1, INSTR(T1.start_date, ' ') - 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 144,
                "end_index": 168,
                "dilatect_content": "INSTR(T1.start_date, ' ')",
                "feature": "instr(X,Y)"
            },
            {
                "start_index": 449,
                "end_index": 517,
                "dilatect_content": "SUBSTR(CAST(T1.start_date AS TEXT), 1, INSTR(T1.start_date, ' ') - 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 488,
                "end_index": 512,
                "dilatect_content": "INSTR(T1.start_date, ' ')",
                "feature": "instr(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 154,
                "end_index": 253,
                "dilatect_content": "substring(CAST(\"T1\".\"start_date\" AS TEXT) from 1 for POSITION(' ' IN \"T1\".\"start_date\") - 1)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 211,
                "end_index": 248,
                "dilatect_content": "POSITION(' ' IN \"T1\".\"start_date\")",
                "feature": "POSITION(Y IN X)"
            },
            {
                "start_index": 611,
                "end_index": 710,
                "dilatect_content": "substring(CAST(\"T1\".\"start_date\" AS TEXT) from 1 for POSITION(' ' IN \"T1\".\"start_date\") - 1)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 668,
                "end_index": 704,
                "dilatect_content": "POSITION(' ' IN \"T1\".\"start_date\")",
                "feature": "POSITION(Y IN X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "instr(X,Y)",
                "explanation": "The instr(X,Y) function finds the first occurrence of string Y within \n  string X and returns the number of prior characters plus 1, or 0 if\n  Y is nowhere found within X.\n  Or, if X and Y are both BLOBs, then instr(X,Y) returns one\n  more than the number bytes prior to the first occurrence of Y, or 0 if\n  Y does not occur anywhere within X.\n  If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs\n  then both are interpreted as strings.\n  If either X or Y are NULL in instr(X,Y) then the result is NULL.\n",
                "examples": [
                    "SELECT instr('Hello World', 'World'); -- Returns 7",
                    "SELECT instr('abcdefg', 'x'); -- Returns 0 (not found)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            },
            {
                "feature": "POSITION(Y IN X)",
                "explanation": "In MonetDB, the POSITION function is used to find the first occurrence of string Y within string X and returns the number of characters from the beginning of X to the start of Y. If Y is not found within X, it returns 0.",
                "examples": [
                    "SELECT POSITION('World' IN 'Hello World'); -- Returns 7",
                    "SELECT POSITION('x' IN 'abcdefg'); -- Returns 0 (not found)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `trip`\nColumns:\n(`id`, integer, primary key)\n(`duration`, integer)\n(`start_date`, text)\n(`start_station_name`, text)\n(`start_station_id`, integer)\n(`end_date`, text)\n(`end_station_name`, text)\n(`end_station_id`, integer)\n(`bike_id`, integer)\n(`subscription_type`, text)\n(`zip_code`, integer)\n",
            "Table: `weather`\nColumns:\n(`date`, text)\n(`max_temperature_f`, integer)\n(`mean_temperature_f`, integer)\n(`min_temperature_f`, integer)\n(`max_dew_point_f`, integer)\n(`mean_dew_point_f`, integer)\n(`min_dew_point_f`, integer)\n(`max_humidity`, integer)\n(`mean_humidity`, integer)\n(`min_humidity`, integer)\n(`max_sea_level_pressure_inches`, real)\n(`mean_sea_level_pressure_inches`, real)\n(`min_sea_level_pressure_inches`, real)\n(`max_visibility_miles`, integer)\n(`mean_visibility_miles`, integer)\n(`min_visibility_miles`, integer)\n(`max_wind_Speed_mph`, integer)\n(`mean_wind_speed_mph`, integer)\n(`max_gust_speed_mph`, integer)\n(`precipitation_inches`, text)\n(`cloud_cover`, integer)\n(`events`, text)\n(`wind_dir_degrees`, integer)\n(`zip_code`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `trip`\nColumns:\n(`id`, integer, primary key)\n(`duration`, integer)\n(`start_date`, text)\n(`start_station_name`, text)\n(`start_station_id`, integer)\n(`end_date`, text)\n(`end_station_name`, text)\n(`end_station_id`, integer)\n(`bike_id`, integer)\n(`subscription_type`, text)\n(`zip_code`, integer)\n",
            "Table: `weather`\nColumns:\n(`date`, text)\n(`max_temperature_f`, integer)\n(`mean_temperature_f`, integer)\n(`min_temperature_f`, integer)\n(`max_dew_point_f`, integer)\n(`mean_dew_point_f`, integer)\n(`min_dew_point_f`, integer)\n(`max_humidity`, integer)\n(`mean_humidity`, integer)\n(`min_humidity`, integer)\n(`max_sea_level_pressure_inches`, real)\n(`mean_sea_level_pressure_inches`, real)\n(`min_sea_level_pressure_inches`, real)\n(`max_visibility_miles`, integer)\n(`mean_visibility_miles`, integer)\n(`min_visibility_miles`, integer)\n(`max_wind_Speed_mph`, integer)\n(`mean_wind_speed_mph`, integer)\n(`max_gust_speed_mph`, integer)\n(`precipitation_inches`, text)\n(`cloud_cover`, integer)\n(`events`, text)\n(`wind_dir_degrees`, integer)\n(`zip_code`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"trip\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"duration\", BIGINT)\n(\"start_date\", STRING)\n(\"start_station_name\", STRING)\n(\"start_station_id\", BIGINT)\n(\"end_date\", STRING)\n(\"end_station_name\", STRING)\n(\"end_station_id\", BIGINT)\n(\"bike_id\", BIGINT)\n(\"subscription_type\", STRING)\n(\"zip_code\", BIGINT)\n",
            "Table: \"weather\"\nColumns:\n(\"_date\", STRING)\n(\"max_temperature_f\", BIGINT)\n(\"mean_temperature_f\", BIGINT)\n(\"min_temperature_f\", BIGINT)\n(\"max_dew_point_f\", BIGINT)\n(\"mean_dew_point_f\", BIGINT)\n(\"min_dew_point_f\", BIGINT)\n(\"max_humidity\", BIGINT)\n(\"mean_humidity\", BIGINT)\n(\"min_humidity\", BIGINT)\n(\"max_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"mean_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"min_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"max_visibility_miles\", BIGINT)\n(\"mean_visibility_miles\", BIGINT)\n(\"min_visibility_miles\", BIGINT)\n(\"max_wind_Speed_mph\", BIGINT)\n(\"mean_wind_speed_mph\", BIGINT)\n(\"max_gust_speed_mph\", BIGINT)\n(\"precipitation_inches\", STRING)\n(\"cloud_cover\", BIGINT)\n(\"events\", STRING)\n(\"wind_dir_degrees\", BIGINT)\n(\"zip_code\", STRING)\n(\"rowid\", BIGINT, primary key)\n",
            "Table: \"trip\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"duration\", BIGINT)\n(\"start_date\", STRING)\n(\"start_station_name\", STRING)\n(\"start_station_id\", BIGINT)\n(\"end_date\", STRING)\n(\"end_station_name\", STRING)\n(\"end_station_id\", BIGINT)\n(\"bike_id\", BIGINT)\n(\"subscription_type\", STRING)\n(\"zip_code\", BIGINT)\n",
            "Table: \"weather\"\nColumns:\n(\"_date\", STRING)\n(\"max_temperature_f\", BIGINT)\n(\"mean_temperature_f\", BIGINT)\n(\"min_temperature_f\", BIGINT)\n(\"max_dew_point_f\", BIGINT)\n(\"mean_dew_point_f\", BIGINT)\n(\"min_dew_point_f\", BIGINT)\n(\"max_humidity\", BIGINT)\n(\"mean_humidity\", BIGINT)\n(\"min_humidity\", BIGINT)\n(\"max_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"mean_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"min_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"max_visibility_miles\", BIGINT)\n(\"mean_visibility_miles\", BIGINT)\n(\"min_visibility_miles\", BIGINT)\n(\"max_wind_Speed_mph\", BIGINT)\n(\"mean_wind_speed_mph\", BIGINT)\n(\"max_gust_speed_mph\", BIGINT)\n(\"precipitation_inches\", STRING)\n(\"cloud_cover\", BIGINT)\n(\"events\", STRING)\n(\"wind_dir_degrees\", BIGINT)\n(\"zip_code\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 634,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(CASE WHEN city = 'San Francisco' AND SUBSTR(installation_date, -4) = '2014' THEN 1 ELSE 0 END) FROM station",
        "target_query": "SELECT SUM(CASE WHEN \"city\" = 'San Francisco' AND substring(\"installation_date\" from char_length(\"installation_date\") - 3 for 4) = '2014' THEN 1 ELSE 0 END) FROM \"station\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 48,
                "end_index": 76,
                "dilatect_content": "SUBSTR(installation_date, -4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 52,
                "end_index": 133,
                "dilatect_content": "substring(\"installation_date\" from char_length(\"installation_date\") - 3 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `station`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`lat`, real)\n(`long`, real)\n(`dock_count`, integer)\n(`city`, text)\n(`installation_date`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"station\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"lat\", DOUBLE PRECISION)\n(\"long\", DOUBLE PRECISION)\n(\"dock_count\", BIGINT)\n(\"city\", STRING)\n(\"installation_date\", STRING)\n"
        ]
    },
    {
        "sql_id": 636,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(start_station_id = end_station_id, 1, 0)) FROM trip",
        "target_query": "SELECT SUM(CASE WHEN \"start_station_id\" = \"end_station_id\" THEN 1 ELSE 0 END) FROM \"trip\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 54,
                "dilatect_content": "IIF(start_station_id = end_station_id, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 79,
                "dilatect_content": "CASE WHEN \"start_station_id\" = \"end_station_id\" THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `trip`\nColumns:\n(`id`, integer, primary key)\n(`duration`, integer)\n(`start_date`, text)\n(`start_station_name`, text)\n(`start_station_id`, integer)\n(`end_date`, text)\n(`end_station_name`, text)\n(`end_station_id`, integer)\n(`bike_id`, integer)\n(`subscription_type`, text)\n(`zip_code`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"trip\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"duration\", BIGINT)\n(\"start_date\", STRING)\n(\"start_station_name\", STRING)\n(\"start_station_id\", BIGINT)\n(\"end_date\", STRING)\n(\"end_station_name\", STRING)\n(\"end_station_id\", BIGINT)\n(\"bike_id\", BIGINT)\n(\"subscription_type\", STRING)\n(\"zip_code\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 637,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT AVG(T2.mean_temperature_f) FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE SUBSTR(CAST(T2.date AS TEXT), -4) = '2013' AND T1.start_station_name = 'Market at 4th'",
        "target_query": "SELECT AVG(\"T2\".\"mean_temperature_f\") FROM \"trip\" AS \"T1\" INNER JOIN \"weather\" AS \"T2\" ON \"T2\".\"zip_code\" = \"T1\".\"zip_code\" WHERE substring(\"T2\".\"_date\" from char_length(\"T2\".\"_date\") - 3 for 4) = '2013' AND \"T1\".\"start_station_name\" = 'Market at 4th';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 110,
                "end_index": 142,
                "dilatect_content": "SUBSTR(CAST(T2.date AS TEXT), -4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 150,
                "end_index": 221,
                "dilatect_content": "substring(\"T2\".\"_date\" from char_length(\"T2\".\"_date\") - 3 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `trip`\nColumns:\n(`id`, integer, primary key)\n(`duration`, integer)\n(`start_date`, text)\n(`start_station_name`, text)\n(`start_station_id`, integer)\n(`end_date`, text)\n(`end_station_name`, text)\n(`end_station_id`, integer)\n(`bike_id`, integer)\n(`subscription_type`, text)\n(`zip_code`, integer)\n",
            "Table: `weather`\nColumns:\n(`date`, text)\n(`max_temperature_f`, integer)\n(`mean_temperature_f`, integer)\n(`min_temperature_f`, integer)\n(`max_dew_point_f`, integer)\n(`mean_dew_point_f`, integer)\n(`min_dew_point_f`, integer)\n(`max_humidity`, integer)\n(`mean_humidity`, integer)\n(`min_humidity`, integer)\n(`max_sea_level_pressure_inches`, real)\n(`mean_sea_level_pressure_inches`, real)\n(`min_sea_level_pressure_inches`, real)\n(`max_visibility_miles`, integer)\n(`mean_visibility_miles`, integer)\n(`min_visibility_miles`, integer)\n(`max_wind_Speed_mph`, integer)\n(`mean_wind_speed_mph`, integer)\n(`max_gust_speed_mph`, integer)\n(`precipitation_inches`, text)\n(`cloud_cover`, integer)\n(`events`, text)\n(`wind_dir_degrees`, integer)\n(`zip_code`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"trip\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"duration\", BIGINT)\n(\"start_date\", STRING)\n(\"start_station_name\", STRING)\n(\"start_station_id\", BIGINT)\n(\"end_date\", STRING)\n(\"end_station_name\", STRING)\n(\"end_station_id\", BIGINT)\n(\"bike_id\", BIGINT)\n(\"subscription_type\", STRING)\n(\"zip_code\", BIGINT)\n",
            "Table: \"weather\"\nColumns:\n(\"_date\", STRING)\n(\"max_temperature_f\", BIGINT)\n(\"mean_temperature_f\", BIGINT)\n(\"min_temperature_f\", BIGINT)\n(\"max_dew_point_f\", BIGINT)\n(\"mean_dew_point_f\", BIGINT)\n(\"min_dew_point_f\", BIGINT)\n(\"max_humidity\", BIGINT)\n(\"mean_humidity\", BIGINT)\n(\"min_humidity\", BIGINT)\n(\"max_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"mean_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"min_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"max_visibility_miles\", BIGINT)\n(\"mean_visibility_miles\", BIGINT)\n(\"min_visibility_miles\", BIGINT)\n(\"max_wind_Speed_mph\", BIGINT)\n(\"mean_wind_speed_mph\", BIGINT)\n(\"max_gust_speed_mph\", BIGINT)\n(\"precipitation_inches\", STRING)\n(\"cloud_cover\", BIGINT)\n(\"events\", STRING)\n(\"wind_dir_degrees\", BIGINT)\n(\"zip_code\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 638,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(CASE WHEN T2.events = 'Rain' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE SUBSTR(CAST(T2.date AS TEXT), -4) = '2015' AND T1.subscription_type = 'Customer'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"weather\".\"events\" = 'Rain' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"trip\".\"id\") FROM \"trip\" INNER JOIN \"weather\" ON \"weather\".\"zip_code\" = \"trip\".\"zip_code\" WHERE substring(\"weather\".\"_date\" from char_length(\"weather\".\"_date\") - 3 for 4) = '2015' AND \"trip\".\"subscription_type\" = 'Customer';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 170,
                "end_index": 202,
                "dilatect_content": "SUBSTR(CAST(T2.date AS TEXT), -4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 212,
                "end_index": 293,
                "dilatect_content": "substring(\"weather\".\"_date\" from char_length(\"weather\".\"_date\") - 3 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `trip`\nColumns:\n(`id`, integer, primary key)\n(`duration`, integer)\n(`start_date`, text)\n(`start_station_name`, text)\n(`start_station_id`, integer)\n(`end_date`, text)\n(`end_station_name`, text)\n(`end_station_id`, integer)\n(`bike_id`, integer)\n(`subscription_type`, text)\n(`zip_code`, integer)\n",
            "Table: `weather`\nColumns:\n(`date`, text)\n(`max_temperature_f`, integer)\n(`mean_temperature_f`, integer)\n(`min_temperature_f`, integer)\n(`max_dew_point_f`, integer)\n(`mean_dew_point_f`, integer)\n(`min_dew_point_f`, integer)\n(`max_humidity`, integer)\n(`mean_humidity`, integer)\n(`min_humidity`, integer)\n(`max_sea_level_pressure_inches`, real)\n(`mean_sea_level_pressure_inches`, real)\n(`min_sea_level_pressure_inches`, real)\n(`max_visibility_miles`, integer)\n(`mean_visibility_miles`, integer)\n(`min_visibility_miles`, integer)\n(`max_wind_Speed_mph`, integer)\n(`mean_wind_speed_mph`, integer)\n(`max_gust_speed_mph`, integer)\n(`precipitation_inches`, text)\n(`cloud_cover`, integer)\n(`events`, text)\n(`wind_dir_degrees`, integer)\n(`zip_code`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"trip\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"duration\", BIGINT)\n(\"start_date\", STRING)\n(\"start_station_name\", STRING)\n(\"start_station_id\", BIGINT)\n(\"end_date\", STRING)\n(\"end_station_name\", STRING)\n(\"end_station_id\", BIGINT)\n(\"bike_id\", BIGINT)\n(\"subscription_type\", STRING)\n(\"zip_code\", BIGINT)\n",
            "Table: \"weather\"\nColumns:\n(\"_date\", STRING)\n(\"max_temperature_f\", BIGINT)\n(\"mean_temperature_f\", BIGINT)\n(\"min_temperature_f\", BIGINT)\n(\"max_dew_point_f\", BIGINT)\n(\"mean_dew_point_f\", BIGINT)\n(\"min_dew_point_f\", BIGINT)\n(\"max_humidity\", BIGINT)\n(\"mean_humidity\", BIGINT)\n(\"min_humidity\", BIGINT)\n(\"max_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"mean_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"min_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"max_visibility_miles\", BIGINT)\n(\"mean_visibility_miles\", BIGINT)\n(\"min_visibility_miles\", BIGINT)\n(\"max_wind_Speed_mph\", BIGINT)\n(\"mean_wind_speed_mph\", BIGINT)\n(\"max_gust_speed_mph\", BIGINT)\n(\"precipitation_inches\", STRING)\n(\"cloud_cover\", BIGINT)\n(\"events\", STRING)\n(\"wind_dir_degrees\", BIGINT)\n(\"zip_code\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 639,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(installation_date) FROM station WHERE city = 'San Jose' AND (SUBSTR(CAST(installation_date AS TEXT), 1, INSTR(installation_date, '/') - 1) IN ('8', '9', '10', '11', '12') AND SUBSTR(CAST(installation_date AS TEXT), -4) = '2013') OR SUBSTR(CAST(installation_date AS TEXT), -4) > '2013'",
        "target_query": "SELECT COUNT(\"installation_date\") FROM \"station\" WHERE \"city\" = 'San Jose' AND (substring(\"installation_date\" from 1 for POSITION('/' IN \"installation_date\") - 1) IN ('8', '9', '10', '11', '12') AND substring(\"installation_date\" from char_length(\"installation_date\") - 3 for 4) = '2013') OR substring(\"installation_date\" from char_length(\"installation_date\") - 3 for 4) > '2013';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 74,
                "end_index": 150,
                "dilatect_content": "SUBSTR(CAST(installation_date AS TEXT), 1, INSTR(installation_date, '/') - 1)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 117,
                "end_index": 145,
                "dilatect_content": "INSTR(installation_date, '/')",
                "feature": "instr(X,Y)"
            },
            {
                "start_index": 188,
                "end_index": 230,
                "dilatect_content": "SUBSTR(CAST(installation_date AS TEXT), -4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 245,
                "end_index": 287,
                "dilatect_content": "SUBSTR(CAST(installation_date AS TEXT), -4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 86,
                "end_index": 171,
                "dilatect_content": "substring(\"installation_date\" from 1 for POSITION('/' IN \"installation_date\") - 1)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 129,
                "end_index": 166,
                "dilatect_content": "POSITION('/' IN \"installation_date\")",
                "feature": "POSITION(Y IN X)"
            },
            {
                "start_index": 188,
                "end_index": 269,
                "dilatect_content": "substring(\"installation_date\" from char_length(\"installation_date\") - 3 for 4)",
                "feature": "substring(X from Y for Z)"
            },
            {
                "start_index": 305,
                "end_index": 386,
                "dilatect_content": "substring(\"installation_date\" from char_length(\"installation_date\") - 3 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "instr(X,Y)",
                "explanation": "The instr(X,Y) function finds the first occurrence of string Y within \n  string X and returns the number of prior characters plus 1, or 0 if\n  Y is nowhere found within X.\n  Or, if X and Y are both BLOBs, then instr(X,Y) returns one\n  more than the number bytes prior to the first occurrence of Y, or 0 if\n  Y does not occur anywhere within X.\n  If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs\n  then both are interpreted as strings.\n  If either X or Y are NULL in instr(X,Y) then the result is NULL.\n",
                "examples": [
                    "SELECT instr('Hello World', 'World'); -- Returns 7",
                    "SELECT instr('abcdefg', 'x'); -- Returns 0 (not found)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            },
            {
                "feature": "POSITION(Y IN X)",
                "explanation": "In MonetDB, the POSITION function is used to find the first occurrence of string Y within string X and returns the number of characters from the beginning of X to the start of Y. If Y is not found within X, it returns 0.",
                "examples": [
                    "SELECT POSITION('World' IN 'Hello World'); -- Returns 7",
                    "SELECT POSITION('x' IN 'abcdefg'); -- Returns 0 (not found)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `station`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`lat`, real)\n(`long`, real)\n(`dock_count`, integer)\n(`city`, text)\n(`installation_date`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"station\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"lat\", DOUBLE PRECISION)\n(\"long\", DOUBLE PRECISION)\n(\"dock_count\", BIGINT)\n(\"city\", STRING)\n(\"installation_date\", STRING)\n"
        ]
    },
    {
        "sql_id": 640,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(zip_code = 94107 AND date = '8/29/2013', mean_temperature_f, 0)) FROM weather",
        "target_query": "SELECT SUM(CASE WHEN \"zip_code\" = '94107' AND \"_date\" = '8/29/2013' THEN \"mean_temperature_f\" ELSE 0 END) FROM \"weather\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 77,
                "dilatect_content": "IIF(zip_code = 94107 AND date = '8/29/2013', mean_temperature_f, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 109,
                "dilatect_content": "CASE WHEN \"zip_code\" = '94107' AND \"_date\" = '8/29/2013' THEN \"mean_temperature_f\" ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `weather`\nColumns:\n(`date`, text)\n(`max_temperature_f`, integer)\n(`mean_temperature_f`, integer)\n(`min_temperature_f`, integer)\n(`max_dew_point_f`, integer)\n(`mean_dew_point_f`, integer)\n(`min_dew_point_f`, integer)\n(`max_humidity`, integer)\n(`mean_humidity`, integer)\n(`min_humidity`, integer)\n(`max_sea_level_pressure_inches`, real)\n(`mean_sea_level_pressure_inches`, real)\n(`min_sea_level_pressure_inches`, real)\n(`max_visibility_miles`, integer)\n(`mean_visibility_miles`, integer)\n(`min_visibility_miles`, integer)\n(`max_wind_Speed_mph`, integer)\n(`mean_wind_speed_mph`, integer)\n(`max_gust_speed_mph`, integer)\n(`precipitation_inches`, text)\n(`cloud_cover`, integer)\n(`events`, text)\n(`wind_dir_degrees`, integer)\n(`zip_code`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"weather\"\nColumns:\n(\"_date\", STRING)\n(\"max_temperature_f\", BIGINT)\n(\"mean_temperature_f\", BIGINT)\n(\"min_temperature_f\", BIGINT)\n(\"max_dew_point_f\", BIGINT)\n(\"mean_dew_point_f\", BIGINT)\n(\"min_dew_point_f\", BIGINT)\n(\"max_humidity\", BIGINT)\n(\"mean_humidity\", BIGINT)\n(\"min_humidity\", BIGINT)\n(\"max_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"mean_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"min_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"max_visibility_miles\", BIGINT)\n(\"mean_visibility_miles\", BIGINT)\n(\"min_visibility_miles\", BIGINT)\n(\"max_wind_Speed_mph\", BIGINT)\n(\"mean_wind_speed_mph\", BIGINT)\n(\"max_gust_speed_mph\", BIGINT)\n(\"precipitation_inches\", STRING)\n(\"cloud_cover\", BIGINT)\n(\"events\", STRING)\n(\"wind_dir_degrees\", BIGINT)\n(\"zip_code\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 641,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(zip_code = 94107 AND date = '8/29/2013', max_temperature_f - min_temperature_f, 0)) FROM weather",
        "target_query": "SELECT SUM(CASE WHEN \"zip_code\" = '94107' AND \"_date\" = '8/29/2013' THEN \"max_temperature_f\" - \"min_temperature_f\" ELSE 0 END) FROM \"weather\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 96,
                "dilatect_content": "IIF(zip_code = 94107 AND date = '8/29/2013', max_temperature_f - min_temperature_f, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 132,
                "dilatect_content": "CASE WHEN \"zip_code\" = '94107' AND \"_date\" = '8/29/2013' THEN \"max_temperature_f\" - \"min_temperature_f\" ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `weather`\nColumns:\n(`date`, text)\n(`max_temperature_f`, integer)\n(`mean_temperature_f`, integer)\n(`min_temperature_f`, integer)\n(`max_dew_point_f`, integer)\n(`mean_dew_point_f`, integer)\n(`min_dew_point_f`, integer)\n(`max_humidity`, integer)\n(`mean_humidity`, integer)\n(`min_humidity`, integer)\n(`max_sea_level_pressure_inches`, real)\n(`mean_sea_level_pressure_inches`, real)\n(`min_sea_level_pressure_inches`, real)\n(`max_visibility_miles`, integer)\n(`mean_visibility_miles`, integer)\n(`min_visibility_miles`, integer)\n(`max_wind_Speed_mph`, integer)\n(`mean_wind_speed_mph`, integer)\n(`max_gust_speed_mph`, integer)\n(`precipitation_inches`, text)\n(`cloud_cover`, integer)\n(`events`, text)\n(`wind_dir_degrees`, integer)\n(`zip_code`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"weather\"\nColumns:\n(\"_date\", STRING)\n(\"max_temperature_f\", BIGINT)\n(\"mean_temperature_f\", BIGINT)\n(\"min_temperature_f\", BIGINT)\n(\"max_dew_point_f\", BIGINT)\n(\"mean_dew_point_f\", BIGINT)\n(\"min_dew_point_f\", BIGINT)\n(\"max_humidity\", BIGINT)\n(\"mean_humidity\", BIGINT)\n(\"min_humidity\", BIGINT)\n(\"max_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"mean_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"min_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"max_visibility_miles\", BIGINT)\n(\"mean_visibility_miles\", BIGINT)\n(\"min_visibility_miles\", BIGINT)\n(\"max_wind_Speed_mph\", BIGINT)\n(\"mean_wind_speed_mph\", BIGINT)\n(\"max_gust_speed_mph\", BIGINT)\n(\"precipitation_inches\", STRING)\n(\"cloud_cover\", BIGINT)\n(\"events\", STRING)\n(\"wind_dir_degrees\", BIGINT)\n(\"zip_code\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 642,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT DISTINCT T1.start_station_name FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE SUBSTR(CAST(T2.date AS TEXT), -4) = '2013' AND T2.zip_code = 94107 AND T2.max_temperature_f > 80",
        "target_query": "SELECT DISTINCT \"T1\".\"start_station_name\" FROM \"trip\" AS \"T1\" INNER JOIN \"weather\" AS \"T2\" ON \"T2\".\"zip_code\" = \"T1\".\"zip_code\" WHERE substring(\"T2\".\"_date\" from char_length(\"T2\".\"_date\") - 3 for 4) = '2013' AND \"T2\".\"zip_code\" = '94107' AND \"T2\".\"max_temperature_f\" > 80;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 114,
                "end_index": 146,
                "dilatect_content": "SUBSTR(CAST(T2.date AS TEXT), -4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 154,
                "end_index": 225,
                "dilatect_content": "substring(\"T2\".\"_date\" from char_length(\"T2\".\"_date\") - 3 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `trip`\nColumns:\n(`id`, integer, primary key)\n(`duration`, integer)\n(`start_date`, text)\n(`start_station_name`, text)\n(`start_station_id`, integer)\n(`end_date`, text)\n(`end_station_name`, text)\n(`end_station_id`, integer)\n(`bike_id`, integer)\n(`subscription_type`, text)\n(`zip_code`, integer)\n",
            "Table: `weather`\nColumns:\n(`date`, text)\n(`max_temperature_f`, integer)\n(`mean_temperature_f`, integer)\n(`min_temperature_f`, integer)\n(`max_dew_point_f`, integer)\n(`mean_dew_point_f`, integer)\n(`min_dew_point_f`, integer)\n(`max_humidity`, integer)\n(`mean_humidity`, integer)\n(`min_humidity`, integer)\n(`max_sea_level_pressure_inches`, real)\n(`mean_sea_level_pressure_inches`, real)\n(`min_sea_level_pressure_inches`, real)\n(`max_visibility_miles`, integer)\n(`mean_visibility_miles`, integer)\n(`min_visibility_miles`, integer)\n(`max_wind_Speed_mph`, integer)\n(`mean_wind_speed_mph`, integer)\n(`max_gust_speed_mph`, integer)\n(`precipitation_inches`, text)\n(`cloud_cover`, integer)\n(`events`, text)\n(`wind_dir_degrees`, integer)\n(`zip_code`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"trip\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"duration\", BIGINT)\n(\"start_date\", STRING)\n(\"start_station_name\", STRING)\n(\"start_station_id\", BIGINT)\n(\"end_date\", STRING)\n(\"end_station_name\", STRING)\n(\"end_station_id\", BIGINT)\n(\"bike_id\", BIGINT)\n(\"subscription_type\", STRING)\n(\"zip_code\", BIGINT)\n",
            "Table: \"weather\"\nColumns:\n(\"_date\", STRING)\n(\"max_temperature_f\", BIGINT)\n(\"mean_temperature_f\", BIGINT)\n(\"min_temperature_f\", BIGINT)\n(\"max_dew_point_f\", BIGINT)\n(\"mean_dew_point_f\", BIGINT)\n(\"min_dew_point_f\", BIGINT)\n(\"max_humidity\", BIGINT)\n(\"mean_humidity\", BIGINT)\n(\"min_humidity\", BIGINT)\n(\"max_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"mean_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"min_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"max_visibility_miles\", BIGINT)\n(\"mean_visibility_miles\", BIGINT)\n(\"min_visibility_miles\", BIGINT)\n(\"max_wind_Speed_mph\", BIGINT)\n(\"mean_wind_speed_mph\", BIGINT)\n(\"max_gust_speed_mph\", BIGINT)\n(\"precipitation_inches\", STRING)\n(\"cloud_cover\", BIGINT)\n(\"events\", STRING)\n(\"wind_dir_degrees\", BIGINT)\n(\"zip_code\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 643,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(zip_code = 94041 AND events = 'Rain', 1, 0)) FROM weather",
        "target_query": "SELECT SUM(CASE WHEN \"zip_code\" = '94041' AND \"events\" = 'Rain' THEN 1 ELSE 0 END) FROM \"weather\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 57,
                "dilatect_content": "IIF(zip_code = 94041 AND events = 'Rain', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 84,
                "dilatect_content": "CASE WHEN \"zip_code\" = '94041' AND \"events\" = 'Rain' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `weather`\nColumns:\n(`date`, text)\n(`max_temperature_f`, integer)\n(`mean_temperature_f`, integer)\n(`min_temperature_f`, integer)\n(`max_dew_point_f`, integer)\n(`mean_dew_point_f`, integer)\n(`min_dew_point_f`, integer)\n(`max_humidity`, integer)\n(`mean_humidity`, integer)\n(`min_humidity`, integer)\n(`max_sea_level_pressure_inches`, real)\n(`mean_sea_level_pressure_inches`, real)\n(`min_sea_level_pressure_inches`, real)\n(`max_visibility_miles`, integer)\n(`mean_visibility_miles`, integer)\n(`min_visibility_miles`, integer)\n(`max_wind_Speed_mph`, integer)\n(`mean_wind_speed_mph`, integer)\n(`max_gust_speed_mph`, integer)\n(`precipitation_inches`, text)\n(`cloud_cover`, integer)\n(`events`, text)\n(`wind_dir_degrees`, integer)\n(`zip_code`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: \"weather\"\nColumns:\n(\"_date\", STRING)\n(\"max_temperature_f\", BIGINT)\n(\"mean_temperature_f\", BIGINT)\n(\"min_temperature_f\", BIGINT)\n(\"max_dew_point_f\", BIGINT)\n(\"mean_dew_point_f\", BIGINT)\n(\"min_dew_point_f\", BIGINT)\n(\"max_humidity\", BIGINT)\n(\"mean_humidity\", BIGINT)\n(\"min_humidity\", BIGINT)\n(\"max_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"mean_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"min_sea_level_pressure_inches\", DOUBLE PRECISION)\n(\"max_visibility_miles\", BIGINT)\n(\"mean_visibility_miles\", BIGINT)\n(\"min_visibility_miles\", BIGINT)\n(\"max_wind_Speed_mph\", BIGINT)\n(\"mean_wind_speed_mph\", BIGINT)\n(\"max_gust_speed_mph\", BIGINT)\n(\"precipitation_inches\", STRING)\n(\"cloud_cover\", BIGINT)\n(\"events\", STRING)\n(\"wind_dir_degrees\", BIGINT)\n(\"zip_code\", STRING)\n(\"rowid\", BIGINT, primary key)\n"
        ]
    },
    {
        "sql_id": 644,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(CASE WHEN city = 'Redwood City' AND SUBSTR(installation_date, -4) < '2014' THEN dock_count ELSE 0 END) NUM FROM station",
        "target_query": "SELECT SUM(CASE WHEN \"city\" = 'Redwood City' AND substring(\"installation_date\" from char_length(\"installation_date\") - 3 for 4) < '2014' THEN \"dock_count\" ELSE 0 END) AS \"NUM\" FROM \"station\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 47,
                "end_index": 75,
                "dilatect_content": "SUBSTR(installation_date, -4)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 51,
                "end_index": 132,
                "dilatect_content": "substring(\"installation_date\" from char_length(\"installation_date\") - 3 for 4)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `station`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`lat`, real)\n(`long`, real)\n(`dock_count`, integer)\n(`city`, text)\n(`installation_date`, text)\n"
        ],
        "target_related_schemas": [
            "Table: \"station\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"lat\", DOUBLE PRECISION)\n(\"long\", DOUBLE PRECISION)\n(\"dock_count\", BIGINT)\n(\"city\", STRING)\n(\"installation_date\", STRING)\n"
        ]
    },
    {
        "sql_id": 646,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(subscription_type = 'Subscriber', 1, 0)) AS REAL) / SUM(IIF(subscription_type = 'Customer', 1, 0)) FROM trip WHERE start_station_name = '2nd at South Park' AND end_station_name = '2nd at South Park'",
        "target_query": "SELECT CASE WHEN SUM(CASE WHEN \"subscription_type\" = 'Customer' THEN 1 ELSE 0 END) = 0 THEN NULL ELSE CAST(SUM(CASE WHEN \"subscription_type\" = 'Subscriber' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN \"subscription_type\" = 'Customer' THEN 1 ELSE 0 END) END FROM \"trip\" WHERE \"start_station_name\" = '2nd at South Park' AND \"end_station_name\" = '2nd at South Park';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 58,
                "dilatect_content": "IIF(subscription_type = 'Subscriber', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 76,
                "end_index": 116,
                "dilatect_content": "IIF(subscription_type = 'Customer', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 82,
                "dilatect_content": "CASE WHEN \"subscription_type\" = 'Customer' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 113,
                "end_index": 176,
                "dilatect_content": "CASE WHEN \"subscription_type\" = 'Subscriber' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `trip`\nColumns:\n(`id`, integer, primary key)\n(`duration`, integer)\n(`start_date`, text)\n(`start_station_name`, text)\n(`start_station_id`, integer)\n(`end_date`, text)\n(`end_station_name`, text)\n(`end_station_id`, integer)\n(`bike_id`, integer)\n(`subscription_type`, text)\n(`zip_code`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: \"trip\"\nColumns:\n(\"id\", BIGINT, primary key)\n(\"duration\", BIGINT)\n(\"start_date\", STRING)\n(\"start_station_name\", STRING)\n(\"start_station_id\", BIGINT)\n(\"end_date\", STRING)\n(\"end_station_name\", STRING)\n(\"end_station_id\", BIGINT)\n(\"bike_id\", BIGINT)\n(\"subscription_type\", STRING)\n(\"zip_code\", BIGINT)\n"
        ]
    },
    {
        "sql_id": 647,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T1.customer_id) FROM customer AS T1 INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id WHERE T1.first_name = 'RUTH' AND T1.last_name = 'MARTINEZ' AND STRFTIME('%m',T2.return_date) = '8' AND STRFTIME('%Y', T2.return_date) = '2005'",
        "target_query": "SELECT COUNT(\"T1\".\"customer_id\") FROM \"customer\" AS \"T1\" INNER JOIN \"rental\" AS \"T2\" ON \"T1\".\"customer_id\" = \"T2\".\"customer_id\" WHERE \"T1\".\"first_name\" = 'RUTH' AND \"T1\".\"last_name\" = 'MARTINEZ' AND sys.timestamp_to_str(\"T2\".\"return_date\", '%m') = '8' AND sys.timestamp_to_str(\"T2\".\"return_date\", '%Y') = '2005';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 171,
                "end_index": 199,
                "dilatect_content": "STRFTIME('%m',T2.return_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 211,
                "end_index": 240,
                "dilatect_content": "STRFTIME('%Y', T2.return_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 227,
                "end_index": 276,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"return_date\", '%m')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 288,
                "end_index": 337,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"return_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`store_id`, integer)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n(`address_id`, integer)\n(`active`, integer)\n(`create_date`, datetime)\n(`last_update`, datetime)\n",
            "Table: `rental`\nColumns:\n(`rental_id`, integer, primary key)\n(`rental_date`, datetime)\n(`inventory_id`, integer)\n(`customer_id`, integer)\n(`return_date`, datetime)\n(`staff_id`, integer)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"customer\"\nColumns:\n(\"customer_id\", BIGINT, primary key)\n(\"store_id\", BIGINT)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"email\", STRING)\n(\"address_id\", BIGINT)\n(\"active\", BIGINT)\n(\"create_date\", TIMESTAMP)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"rental\"\nColumns:\n(\"rental_id\", BIGINT, primary key)\n(\"rental_date\", TIMESTAMP)\n(\"inventory_id\", BIGINT)\n(\"customer_id\", BIGINT)\n(\"return_date\", TIMESTAMP)\n(\"staff_id\", BIGINT)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 648,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T3.name = 'Music', 1, 0)) AS REAL) * 100 / COUNT(T1.film_id) FROM film AS T1 INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id INNER JOIN inventory AS T4 ON T1.film_id = T4.film_id INNER JOIN customer AS T5 ON T4.store_id = T5.store_id INNER JOIN rental AS T6 ON T4.inventory_id = T6.inventory_id WHERE T5.first_name = 'RUTH' AND T5.last_name = 'MARTINEZ'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T3\".\"name\" = 'Music' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"film_id\") FROM \"film\" AS \"T1\" INNER JOIN \"film_category\" AS \"T2\" ON \"T1\".\"film_id\" = \"T2\".\"film_id\" INNER JOIN \"category\" AS \"T3\" ON \"T2\".\"category_id\" = \"T3\".\"category_id\" INNER JOIN \"inventory\" AS \"T4\" ON \"T1\".\"film_id\" = \"T4\".\"film_id\" INNER JOIN \"customer\" AS \"T5\" ON \"T4\".\"store_id\" = \"T5\".\"store_id\" INNER JOIN \"rental\" AS \"T6\" ON \"T4\".\"inventory_id\" = \"T6\".\"inventory_id\" WHERE \"T5\".\"first_name\" = 'RUTH' AND \"T5\".\"last_name\" = 'MARTINEZ';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 43,
                "dilatect_content": "IIF(T3.name = 'Music', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 68,
                "dilatect_content": "CASE WHEN \"T3\".\"name\" = 'Music' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `film`\nColumns:\n(`film_id`, integer, primary key)\n(`title`, text)\n(`description`, text)\n(`release_year`, text)\n(`language_id`, integer)\n(`original_language_id`, integer)\n(`rental_duration`, integer)\n(`rental_rate`, real)\n(`length`, integer)\n(`replacement_cost`, real)\n(`rating`, text)\n(`special_features`, text)\n(`last_update`, datetime)\n",
            "Table: `film_category`\nColumns:\n(`film_id`, integer, primary key)\n(`category_id`, integer, primary key)\n(`last_update`, datetime)\n",
            "Table: `category`\nColumns:\n(`category_id`, integer, primary key)\n(`name`, text)\n(`last_update`, datetime)\n",
            "Table: `inventory`\nColumns:\n(`inventory_id`, integer, primary key)\n(`film_id`, integer)\n(`store_id`, integer)\n(`last_update`, datetime)\n",
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`store_id`, integer)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n(`address_id`, integer)\n(`active`, integer)\n(`create_date`, datetime)\n(`last_update`, datetime)\n",
            "Table: `rental`\nColumns:\n(`rental_id`, integer, primary key)\n(`rental_date`, datetime)\n(`inventory_id`, integer)\n(`customer_id`, integer)\n(`return_date`, datetime)\n(`staff_id`, integer)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"film\"\nColumns:\n(\"film_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"description\", STRING)\n(\"release_year\", STRING)\n(\"language_id\", BIGINT)\n(\"original_language_id\", BIGINT)\n(\"rental_duration\", BIGINT)\n(\"rental_rate\", DOUBLE PRECISION)\n(\"_length\", BIGINT)\n(\"replacement_cost\", DOUBLE PRECISION)\n(\"rating\", STRING)\n(\"special_features\", STRING)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"film_category\"\nColumns:\n(\"film_id\", BIGINT, primary key)\n(\"category_id\", BIGINT, primary key)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"category\"\nColumns:\n(\"category_id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"inventory\"\nColumns:\n(\"inventory_id\", BIGINT, primary key)\n(\"film_id\", BIGINT)\n(\"store_id\", BIGINT)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"customer\"\nColumns:\n(\"customer_id\", BIGINT, primary key)\n(\"store_id\", BIGINT)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"email\", STRING)\n(\"address_id\", BIGINT)\n(\"active\", BIGINT)\n(\"create_date\", TIMESTAMP)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"rental\"\nColumns:\n(\"rental_id\", BIGINT, primary key)\n(\"rental_date\", TIMESTAMP)\n(\"inventory_id\", BIGINT)\n(\"customer_id\", BIGINT)\n(\"return_date\", TIMESTAMP)\n(\"staff_id\", BIGINT)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 649,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST((SUM(IIF(T2.store_id = 2, T1.amount, 0)) - SUM(IIF(T2.store_id = 1, T1.amount, 0))) AS REAL) * 100 / SUM(IIF(T2.store_id = 1, T1.amount, 0)) FROM payment AS T1 INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id INNER JOIN store AS T3 ON T2.store_id = T3.store_id",
        "target_query": "SELECT CAST((SUM(CASE WHEN \"T2\".\"store_id\" = 2 THEN \"T1\".\"amount\" ELSE 0 END) - SUM(CASE WHEN \"T2\".\"store_id\" = 1 THEN \"T1\".\"amount\" ELSE 0 END)) AS DOUBLE PRECISION) * 100 / SUM(CASE WHEN \"T2\".\"store_id\" = 1 THEN \"T1\".\"amount\" ELSE 0 END) FROM \"payment\" AS \"T1\" INNER JOIN \"customer\" AS \"T2\" ON \"T1\".\"customer_id\" = \"T2\".\"customer_id\" INNER JOIN \"store\" AS \"T3\" ON \"T2\".\"store_id\" = \"T3\".\"store_id\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 17,
                "end_index": 50,
                "dilatect_content": "IIF(T2.store_id = 2, T1.amount, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 59,
                "end_index": 92,
                "dilatect_content": "IIF(T2.store_id = 1, T1.amount, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 117,
                "end_index": 150,
                "dilatect_content": "IIF(T2.store_id = 1, T1.amount, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 17,
                "end_index": 83,
                "dilatect_content": "CASE WHEN \"T2\".\"store_id\" = 2 THEN \"T1\".\"amount\" ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 92,
                "end_index": 158,
                "dilatect_content": "CASE WHEN \"T2\".\"store_id\" = 1 THEN \"T1\".\"amount\" ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 195,
                "end_index": 261,
                "dilatect_content": "CASE WHEN \"T2\".\"store_id\" = 1 THEN \"T1\".\"amount\" ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `payment`\nColumns:\n(`payment_id`, integer, primary key)\n(`customer_id`, integer)\n(`staff_id`, integer)\n(`rental_id`, integer)\n(`amount`, real)\n(`payment_date`, datetime)\n(`last_update`, datetime)\n",
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`store_id`, integer)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n(`address_id`, integer)\n(`active`, integer)\n(`create_date`, datetime)\n(`last_update`, datetime)\n",
            "Table: `store`\nColumns:\n(`store_id`, integer, primary key)\n(`manager_staff_id`, integer)\n(`address_id`, integer)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"payment\"\nColumns:\n(\"payment_id\", BIGINT, primary key)\n(\"customer_id\", BIGINT)\n(\"staff_id\", BIGINT)\n(\"rental_id\", BIGINT)\n(\"amount\", DOUBLE PRECISION)\n(\"payment_date\", TIMESTAMP)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"customer\"\nColumns:\n(\"customer_id\", BIGINT, primary key)\n(\"store_id\", BIGINT)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"email\", STRING)\n(\"address_id\", BIGINT)\n(\"active\", BIGINT)\n(\"create_date\", TIMESTAMP)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"store\"\nColumns:\n(\"store_id\", BIGINT, primary key)\n(\"manager_staff_id\", BIGINT)\n(\"address_id\", BIGINT)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 650,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T1.country = 'India', 1, 0)) AS REAL) / SUM(IIF(T1.country = 'Italy', 1, 0)) FROM country AS T1 INNER JOIN city AS T2 ON T1.country_id = T2.country_id",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T1\".\"country\" = 'India' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN \"T1\".\"country\" = 'Italy' THEN 1 ELSE 0 END) FROM \"country\" AS \"T1\" INNER JOIN \"city\" AS \"T2\" ON \"T1\".\"country_id\" = \"T2\".\"country_id\"",
        "semantic_equivalent_type": "approximate_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 46,
                "dilatect_content": "IIF(T1.country = 'India', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 64,
                "end_index": 94,
                "dilatect_content": "IIF(T1.country = 'Italy', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 71,
                "dilatect_content": "CASE WHEN \"T1\".\"country\" = 'India' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 89,
                "end_index": 144,
                "dilatect_content": "CASE WHEN \"T1\".\"country\" = 'Italy' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `country`\nColumns:\n(`country_id`, integer, primary key)\n(`country`, text)\n(`last_update`, datetime)\n",
            "Table: `city`\nColumns:\n(`city_id`, integer, primary key)\n(`city`, text)\n(`country_id`, integer)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"country\"\nColumns:\n(\"country_id\", BIGINT, primary key)\n(\"country\", STRING)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"city\"\nColumns:\n(\"city_id\", BIGINT, primary key)\n(\"city\", STRING)\n(\"country_id\", BIGINT)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 651,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.first_name = 'GINA' AND T2.last_name = 'DEGENERES', 1, 0)) AS REAL) * 100 / SUM(IIF(T2.first_name = 'PENELOPE' AND T2.last_name = 'GUINESS', 1, 0)) FROM film_actor AS T1 INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"first_name\" = 'GINA' AND \"T2\".\"last_name\" = 'DEGENERES' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN \"T2\".\"first_name\" = 'PENELOPE' AND \"T2\".\"last_name\" = 'GUINESS' THEN 1 ELSE 0 END) FROM \"film_actor\" AS \"T1\" INNER JOIN \"actor\" AS \"T2\" ON \"T1\".\"actor_id\" = \"T2\".\"actor_id\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 79,
                "dilatect_content": "IIF(T2.first_name = 'GINA' AND T2.last_name = 'DEGENERES', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 103,
                "end_index": 168,
                "dilatect_content": "IIF(T2.first_name = 'PENELOPE' AND T2.last_name = 'GUINESS', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 112,
                "dilatect_content": "CASE WHEN \"T2\".\"first_name\" = 'GINA' AND \"T2\".\"last_name\" = 'DEGENERES' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 136,
                "end_index": 234,
                "dilatect_content": "CASE WHEN \"T2\".\"first_name\" = 'PENELOPE' AND \"T2\".\"last_name\" = 'GUINESS' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `film_actor`\nColumns:\n(`actor_id`, integer, primary key)\n(`film_id`, integer, primary key)\n(`last_update`, datetime)\n",
            "Table: `actor`\nColumns:\n(`actor_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"film_actor\"\nColumns:\n(\"actor_id\", BIGINT, primary key)\n(\"film_id\", BIGINT, primary key)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"actor\"\nColumns:\n(\"actor_id\", BIGINT, primary key)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 652,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(customer_id) FROM payment WHERE SUBSTR(payment_date, 1, 7) LIKE '2005-08'",
        "target_query": "SELECT COUNT(\"customer_id\") FROM \"payment\" WHERE substring(\"payment_date\" from 1 for 7) LIKE '2005-08';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 45,
                "end_index": 70,
                "dilatect_content": "SUBSTR(payment_date, 1, 7)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 53,
                "end_index": 92,
                "dilatect_content": "substring(\"payment_date\" from 1 for 7)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `payment`\nColumns:\n(`payment_id`, integer, primary key)\n(`customer_id`, integer)\n(`staff_id`, integer)\n(`rental_id`, integer)\n(`amount`, real)\n(`payment_date`, datetime)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"payment\"\nColumns:\n(\"payment_id\", BIGINT, primary key)\n(\"customer_id\", BIGINT)\n(\"staff_id\", BIGINT)\n(\"rental_id\", BIGINT)\n(\"amount\", DOUBLE PRECISION)\n(\"payment_date\", TIMESTAMP)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 654,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(DISTINCT rental_id) FROM rental WHERE date(rental_date) BETWEEN '2005-05-26' AND '2005-05-30'",
        "target_query": "SELECT COUNT(DISTINCT \"rental_id\") FROM \"rental\" WHERE sys.timestamp_to_str(\"rental_date\", '%Y-%m-%d') BETWEEN '2005-05-26' AND '2005-05-30';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 51,
                "end_index": 67,
                "dilatect_content": "date(rental_date)",
                "feature": "date(time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 59,
                "end_index": 107,
                "dilatect_content": "sys.timestamp_to_str(\"rental_date\", '%Y-%m-%d')",
                "feature": "sys.timestamp_to_str(date-value, '%Y-%m-%d')"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "date(time-value, modifier, modifier, ...)",
                "explanation": "The date(time-value, modifier, modifier, ...) function returns the date as text in the format: YYYY-MM-DD. The function accepts a time-value and zero or more modifiers to alter the date.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day', 'start of month').\nReturns: A string in the format YYYY-MM-DD.",
                "examples": [
                    "SELECT date(); -- Returns the current date.",
                    "SELECT date('now', '+1 day'); -- Returns the date one day after the current date.",
                    "SELECT date('2024-08-21'); -- Returns '2024-08-21'."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(date-value, '%Y-%m-%d')",
                "explanation": "In MonetDB, the DATE function from SQLite can be emulated using sys.timestamp_to_str to convert a DATE or TIMESTAMP value into a string in the format YYYY-MM-DD. Date arithmetic (e.g., +1 day) can be performed using sql_add with INTERVAL expressions.",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_DATE, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_DATE, interval '1' day), '%Y-%m-%d'); -- Returns the date one day after the current date.",
                    "SELECT sys.timestamp_to_str(date '2024-08-21', '%Y-%m-%d'); -- Returns '2024-08-21'."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `rental`\nColumns:\n(`rental_id`, integer, primary key)\n(`rental_date`, datetime)\n(`inventory_id`, integer)\n(`customer_id`, integer)\n(`return_date`, datetime)\n(`staff_id`, integer)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"rental\"\nColumns:\n(\"rental_id\", BIGINT, primary key)\n(\"rental_date\", TIMESTAMP)\n(\"inventory_id\", BIGINT)\n(\"customer_id\", BIGINT)\n(\"return_date\", TIMESTAMP)\n(\"staff_id\", BIGINT)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 655,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(active = 0, 1, 0)) AS REAL) * 100 / COUNT(customer_id) FROM customer",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"active\" = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"customer_id\") FROM \"customer\"",
        "semantic_equivalent_type": "approximate_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 36,
                "dilatect_content": "IIF(active = 0, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 57,
                "dilatect_content": "CASE WHEN \"active\" = 0 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`store_id`, integer)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n(`address_id`, integer)\n(`active`, integer)\n(`create_date`, datetime)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"customer\"\nColumns:\n(\"customer_id\", BIGINT, primary key)\n(\"store_id\", BIGINT)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"email\", STRING)\n(\"address_id\", BIGINT)\n(\"active\", BIGINT)\n(\"create_date\", TIMESTAMP)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 656,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(amount) FROM payment WHERE SUBSTR(payment_date, 1, 7) = '2005-08'",
        "target_query": "SELECT SUM(\"amount\") FROM \"payment\" WHERE substring(\"payment_date\" from 1 for 7) = '2005-08';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 38,
                "end_index": 63,
                "dilatect_content": "SUBSTR(payment_date, 1, 7)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 46,
                "end_index": 85,
                "dilatect_content": "substring(\"payment_date\" from 1 for 7)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `payment`\nColumns:\n(`payment_id`, integer, primary key)\n(`customer_id`, integer)\n(`staff_id`, integer)\n(`rental_id`, integer)\n(`amount`, real)\n(`payment_date`, datetime)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"payment\"\nColumns:\n(\"payment_id\", BIGINT, primary key)\n(\"customer_id\", BIGINT)\n(\"staff_id\", BIGINT)\n(\"rental_id\", BIGINT)\n(\"amount\", DOUBLE PRECISION)\n(\"payment_date\", TIMESTAMP)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 657,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.title FROM film AS T1 INNER JOIN inventory AS T2 ON T1.film_id = T2.film_id INNER JOIN rental AS T3 ON T2.inventory_id = T3.inventory_id WHERE SUBSTR(T3.rental_date, 1, 10) = '2005-05-24'",
        "target_query": "SELECT \"T1\".\"title\" FROM \"film\" AS \"T1\" INNER JOIN \"inventory\" AS \"T2\" ON \"T1\".\"film_id\" = \"T2\".\"film_id\" INNER JOIN \"rental\" AS \"T3\" ON \"T2\".\"inventory_id\" = \"T3\".\"inventory_id\" WHERE substring(\"T3\".\"rental_date\" from 1 for 10) = '2005-05-24';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 153,
                "end_index": 181,
                "dilatect_content": "SUBSTR(T3.rental_date, 1, 10)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 217,
                "end_index": 263,
                "dilatect_content": "substring(\"T3\".\"rental_date\" from 1 for 10)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `film`\nColumns:\n(`film_id`, integer, primary key)\n(`title`, text)\n(`description`, text)\n(`release_year`, text)\n(`language_id`, integer)\n(`original_language_id`, integer)\n(`rental_duration`, integer)\n(`rental_rate`, real)\n(`length`, integer)\n(`replacement_cost`, real)\n(`rating`, text)\n(`special_features`, text)\n(`last_update`, datetime)\n",
            "Table: `inventory`\nColumns:\n(`inventory_id`, integer, primary key)\n(`film_id`, integer)\n(`store_id`, integer)\n(`last_update`, datetime)\n",
            "Table: `rental`\nColumns:\n(`rental_id`, integer, primary key)\n(`rental_date`, datetime)\n(`inventory_id`, integer)\n(`customer_id`, integer)\n(`return_date`, datetime)\n(`staff_id`, integer)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"film\"\nColumns:\n(\"film_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"description\", STRING)\n(\"release_year\", STRING)\n(\"language_id\", BIGINT)\n(\"original_language_id\", BIGINT)\n(\"rental_duration\", BIGINT)\n(\"rental_rate\", DOUBLE PRECISION)\n(\"_length\", BIGINT)\n(\"replacement_cost\", DOUBLE PRECISION)\n(\"rating\", STRING)\n(\"special_features\", STRING)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"inventory\"\nColumns:\n(\"inventory_id\", BIGINT, primary key)\n(\"film_id\", BIGINT)\n(\"store_id\", BIGINT)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"rental\"\nColumns:\n(\"rental_id\", BIGINT, primary key)\n(\"rental_date\", TIMESTAMP)\n(\"inventory_id\", BIGINT)\n(\"customer_id\", BIGINT)\n(\"return_date\", TIMESTAMP)\n(\"staff_id\", BIGINT)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 658,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T4.title FROM customer AS T1 INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id INNER JOIN inventory AS T3 ON T2.inventory_id = T3.inventory_id INNER JOIN film AS T4 ON T3.film_id = T4.film_id WHERE T1.first_name = 'BRIAN' AND T1.last_name = 'WYMAN' AND STRFTIME('%Y', T2.rental_date) = '2005' AND STRFTIME('%m',T2.rental_date) = '7'",
        "target_query": "SELECT \"T4\".\"title\" FROM \"customer\" AS \"T1\" INNER JOIN \"rental\" AS \"T2\" ON \"T1\".\"customer_id\" = \"T2\".\"customer_id\" INNER JOIN \"inventory\" AS \"T3\" ON \"T2\".\"inventory_id\" = \"T3\".\"inventory_id\" INNER JOIN \"film\" AS \"T4\" ON \"T3\".\"film_id\" = \"T4\".\"film_id\" WHERE \"T1\".\"first_name\" = 'BRIAN' AND \"T1\".\"last_name\" = 'WYMAN' AND sys.timestamp_to_str(\"T2\".\"rental_date\", '%Y') = '2005' AND sys.timestamp_to_str(\"T2\".\"rental_date\", '%m') = '7';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 269,
                "end_index": 298,
                "dilatect_content": "STRFTIME('%Y', T2.rental_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 313,
                "end_index": 341,
                "dilatect_content": "STRFTIME('%m',T2.rental_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 373,
                "end_index": 422,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"rental_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 437,
                "end_index": 486,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"rental_date\", '%m')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`store_id`, integer)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n(`address_id`, integer)\n(`active`, integer)\n(`create_date`, datetime)\n(`last_update`, datetime)\n",
            "Table: `rental`\nColumns:\n(`rental_id`, integer, primary key)\n(`rental_date`, datetime)\n(`inventory_id`, integer)\n(`customer_id`, integer)\n(`return_date`, datetime)\n(`staff_id`, integer)\n(`last_update`, datetime)\n",
            "Table: `inventory`\nColumns:\n(`inventory_id`, integer, primary key)\n(`film_id`, integer)\n(`store_id`, integer)\n(`last_update`, datetime)\n",
            "Table: `film`\nColumns:\n(`film_id`, integer, primary key)\n(`title`, text)\n(`description`, text)\n(`release_year`, text)\n(`language_id`, integer)\n(`original_language_id`, integer)\n(`rental_duration`, integer)\n(`rental_rate`, real)\n(`length`, integer)\n(`replacement_cost`, real)\n(`rating`, text)\n(`special_features`, text)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"customer\"\nColumns:\n(\"customer_id\", BIGINT, primary key)\n(\"store_id\", BIGINT)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"email\", STRING)\n(\"address_id\", BIGINT)\n(\"active\", BIGINT)\n(\"create_date\", TIMESTAMP)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"rental\"\nColumns:\n(\"rental_id\", BIGINT, primary key)\n(\"rental_date\", TIMESTAMP)\n(\"inventory_id\", BIGINT)\n(\"customer_id\", BIGINT)\n(\"return_date\", TIMESTAMP)\n(\"staff_id\", BIGINT)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"inventory\"\nColumns:\n(\"inventory_id\", BIGINT, primary key)\n(\"film_id\", BIGINT)\n(\"store_id\", BIGINT)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"film\"\nColumns:\n(\"film_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"description\", STRING)\n(\"release_year\", STRING)\n(\"language_id\", BIGINT)\n(\"original_language_id\", BIGINT)\n(\"rental_duration\", BIGINT)\n(\"rental_rate\", DOUBLE PRECISION)\n(\"_length\", BIGINT)\n(\"replacement_cost\", DOUBLE PRECISION)\n(\"rating\", STRING)\n(\"special_features\", STRING)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 659,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T3.title, T2.name FROM film_category AS T1 INNER JOIN category AS T2 ON T1.category_id = T2.category_id INNER JOIN film AS T3 ON T1.film_id = T3.film_id INNER JOIN inventory AS T4 ON T3.film_id = T4.film_id INNER JOIN customer AS T5 ON T4.store_id = T5.store_id INNER JOIN rental AS T6 ON T4.inventory_id = T6.inventory_id WHERE T5.first_name = 'Natalie' AND T5.last_name = 'Meyer' AND STRFTIME('%Y',T3.rental_rate) = '2006' AND STRFTIME('%m',T3.rental_rate) = '2'",
        "target_query": "SELECT \"T3\".\"title\", \"T2\".\"name\" \nFROM \"film_category\" AS \"T1\" \nINNER JOIN \"category\" AS \"T2\" ON \"T1\".\"category_id\" = \"T2\".\"category_id\" \nINNER JOIN \"film\" AS \"T3\" ON \"T1\".\"film_id\" = \"T3\".\"film_id\" \nINNER JOIN \"inventory\" AS \"T4\" ON \"T3\".\"film_id\" = \"T4\".\"film_id\" \nINNER JOIN \"customer\" AS \"T5\" ON \"T4\".\"store_id\" = \"T5\".\"store_id\" \nINNER JOIN \"rental\" AS \"T6\" ON \"T4\".\"inventory_id\" = \"T6\".\"inventory_id\" \nWHERE \"T5\".\"first_name\" = 'Natalie' AND \"T5\".\"last_name\" = 'Meyer';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 393,
                "end_index": 421,
                "dilatect_content": "STRFTIME('%Y',T3.rental_rate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 436,
                "end_index": 464,
                "dilatect_content": "STRFTIME('%m',T3.rental_rate)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `film_category`\nColumns:\n(`film_id`, integer, primary key)\n(`category_id`, integer, primary key)\n(`last_update`, datetime)\n",
            "Table: `category`\nColumns:\n(`category_id`, integer, primary key)\n(`name`, text)\n(`last_update`, datetime)\n",
            "Table: `film`\nColumns:\n(`film_id`, integer, primary key)\n(`title`, text)\n(`description`, text)\n(`release_year`, text)\n(`language_id`, integer)\n(`original_language_id`, integer)\n(`rental_duration`, integer)\n(`rental_rate`, real)\n(`length`, integer)\n(`replacement_cost`, real)\n(`rating`, text)\n(`special_features`, text)\n(`last_update`, datetime)\n",
            "Table: `inventory`\nColumns:\n(`inventory_id`, integer, primary key)\n(`film_id`, integer)\n(`store_id`, integer)\n(`last_update`, datetime)\n",
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`store_id`, integer)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n(`address_id`, integer)\n(`active`, integer)\n(`create_date`, datetime)\n(`last_update`, datetime)\n",
            "Table: `rental`\nColumns:\n(`rental_id`, integer, primary key)\n(`rental_date`, datetime)\n(`inventory_id`, integer)\n(`customer_id`, integer)\n(`return_date`, datetime)\n(`staff_id`, integer)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"film_category\"\nColumns:\n(\"film_id\", BIGINT, primary key)\n(\"category_id\", BIGINT, primary key)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"category\"\nColumns:\n(\"category_id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"film\"\nColumns:\n(\"film_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"description\", STRING)\n(\"release_year\", STRING)\n(\"language_id\", BIGINT)\n(\"original_language_id\", BIGINT)\n(\"rental_duration\", BIGINT)\n(\"rental_rate\", DOUBLE PRECISION)\n(\"_length\", BIGINT)\n(\"replacement_cost\", DOUBLE PRECISION)\n(\"rating\", STRING)\n(\"special_features\", STRING)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"inventory\"\nColumns:\n(\"inventory_id\", BIGINT, primary key)\n(\"film_id\", BIGINT)\n(\"store_id\", BIGINT)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"customer\"\nColumns:\n(\"customer_id\", BIGINT, primary key)\n(\"store_id\", BIGINT)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"email\", STRING)\n(\"address_id\", BIGINT)\n(\"active\", BIGINT)\n(\"create_date\", TIMESTAMP)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"rental\"\nColumns:\n(\"rental_id\", BIGINT, primary key)\n(\"rental_date\", TIMESTAMP)\n(\"inventory_id\", BIGINT)\n(\"customer_id\", BIGINT)\n(\"return_date\", TIMESTAMP)\n(\"staff_id\", BIGINT)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 660,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T1.country = 'India', 1, 0)) AS REAL) * 100 / COUNT(T4.customer_id) FROM country AS T1 INNER JOIN city AS T2 ON T1.country_id = T2.country_id INNER JOIN address AS T3 ON T2.city_id = T3.city_id INNER JOIN customer AS T4 ON T3.address_id = T4.address_id",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T1\".\"country\" = 'India' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T4\".\"customer_id\") FROM \"country\" AS \"T1\" INNER JOIN \"city\" AS \"T2\" ON \"T1\".\"country_id\" = \"T2\".\"country_id\" INNER JOIN \"address\" AS \"T3\" ON \"T2\".\"city_id\" = \"T3\".\"city_id\" INNER JOIN \"customer\" AS \"T4\" ON \"T3\".\"address_id\" = \"T4\".\"address_id\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 46,
                "dilatect_content": "IIF(T1.country = 'India', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 71,
                "dilatect_content": "CASE WHEN \"T1\".\"country\" = 'India' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `country`\nColumns:\n(`country_id`, integer, primary key)\n(`country`, text)\n(`last_update`, datetime)\n",
            "Table: `city`\nColumns:\n(`city_id`, integer, primary key)\n(`city`, text)\n(`country_id`, integer)\n(`last_update`, datetime)\n",
            "Table: `address`\nColumns:\n(`address_id`, integer, primary key)\n(`address`, text)\n(`address2`, text)\n(`district`, text)\n(`city_id`, integer)\n(`postal_code`, text)\n(`phone`, text)\n(`last_update`, datetime)\n",
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`store_id`, integer)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n(`address_id`, integer)\n(`active`, integer)\n(`create_date`, datetime)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"country\"\nColumns:\n(\"country_id\", BIGINT, primary key)\n(\"country\", STRING)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"city\"\nColumns:\n(\"city_id\", BIGINT, primary key)\n(\"city\", STRING)\n(\"country_id\", BIGINT)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"address\"\nColumns:\n(\"address_id\", BIGINT, primary key)\n(\"address\", STRING)\n(\"address2\", STRING)\n(\"district\", STRING)\n(\"city_id\", BIGINT)\n(\"postal_code\", STRING)\n(\"phone\", STRING)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"customer\"\nColumns:\n(\"customer_id\", BIGINT, primary key)\n(\"store_id\", BIGINT)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"email\", STRING)\n(\"address_id\", BIGINT)\n(\"active\", BIGINT)\n(\"create_date\", TIMESTAMP)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 661,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST((SUM(IIF(T1.first_name = 'ANGELA' AND T1.last_name = 'WITHERSPOON', 1, 0)) - SUM(IIF(T1.first_name = 'MARY' AND T1.last_name = 'KEITEL', 1, 0))) AS REAL) * 100 / SUM(IIF(T1.first_name = 'MARY' AND T1.last_name = 'KEITEL', 1, 0)) FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id",
        "target_query": "SELECT CAST((SUM(CASE WHEN \"T1\".\"first_name\" = 'ANGELA' AND \"T1\".\"last_name\" = 'WITHERSPOON' THEN 1 ELSE 0 END) - SUM(CASE WHEN \"T1\".\"first_name\" = 'MARY' AND \"T1\".\"last_name\" = 'KEITEL' THEN 1 ELSE 0 END)) AS REAL) * 100 / NULLIF(SUM(CASE WHEN \"T1\".\"first_name\" = 'MARY' AND \"T1\".\"last_name\" = 'KEITEL' THEN 1 ELSE 0 END), 0) FROM \"actor\" AS \"T1\" INNER JOIN \"film_actor\" AS \"T2\" ON \"T1\".\"actor_id\" = \"T2\".\"actor_id\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 17,
                "end_index": 84,
                "dilatect_content": "IIF(T1.first_name = 'ANGELA' AND T1.last_name = 'WITHERSPOON', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 93,
                "end_index": 153,
                "dilatect_content": "IIF(T1.first_name = 'MARY' AND T1.last_name = 'KEITEL', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 178,
                "end_index": 238,
                "dilatect_content": "IIF(T1.first_name = 'MARY' AND T1.last_name = 'KEITEL', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 17,
                "end_index": 117,
                "dilatect_content": "CASE WHEN \"T1\".\"first_name\" = 'ANGELA' AND \"T1\".\"last_name\" = 'WITHERSPOON' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 126,
                "end_index": 219,
                "dilatect_content": "CASE WHEN \"T1\".\"first_name\" = 'MARY' AND \"T1\".\"last_name\" = 'KEITEL' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 251,
                "end_index": 344,
                "dilatect_content": "CASE WHEN \"T1\".\"first_name\" = 'MARY' AND \"T1\".\"last_name\" = 'KEITEL' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `actor`\nColumns:\n(`actor_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`last_update`, datetime)\n",
            "Table: `film_actor`\nColumns:\n(`actor_id`, integer, primary key)\n(`film_id`, integer, primary key)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"actor\"\nColumns:\n(\"actor_id\", BIGINT, primary key)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"film_actor\"\nColumns:\n(\"actor_id\", BIGINT, primary key)\n(\"film_id\", BIGINT, primary key)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 662,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T3.rating = 'G', 1, 0)) AS REAL) / COUNT(T3.film_id) FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE T1.first_name = 'Elvis' AND T1.last_name = 'Marx'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T3\".\"rating\" = 'G' THEN 1 ELSE 0 END) AS REAL) / COUNT(\"T3\".\"film_id\") FROM \"actor\" AS \"T1\" INNER JOIN \"film_actor\" AS \"T2\" ON \"T1\".\"actor_id\" = \"T2\".\"actor_id\" INNER JOIN \"film\" AS \"T3\" ON \"T2\".\"film_id\" = \"T3\".\"film_id\" WHERE \"T1\".\"first_name\" = 'Elvis' AND \"T1\".\"last_name\" = 'Marx';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 41,
                "dilatect_content": "IIF(T3.rating = 'G', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 66,
                "dilatect_content": "CASE WHEN \"T3\".\"rating\" = 'G' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `actor`\nColumns:\n(`actor_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`last_update`, datetime)\n",
            "Table: `film_actor`\nColumns:\n(`actor_id`, integer, primary key)\n(`film_id`, integer, primary key)\n(`last_update`, datetime)\n",
            "Table: `film`\nColumns:\n(`film_id`, integer, primary key)\n(`title`, text)\n(`description`, text)\n(`release_year`, text)\n(`language_id`, integer)\n(`original_language_id`, integer)\n(`rental_duration`, integer)\n(`rental_rate`, real)\n(`length`, integer)\n(`replacement_cost`, real)\n(`rating`, text)\n(`special_features`, text)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"actor\"\nColumns:\n(\"actor_id\", BIGINT, primary key)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"film_actor\"\nColumns:\n(\"actor_id\", BIGINT, primary key)\n(\"film_id\", BIGINT, primary key)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"film\"\nColumns:\n(\"film_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"description\", STRING)\n(\"release_year\", STRING)\n(\"language_id\", BIGINT)\n(\"original_language_id\", BIGINT)\n(\"rental_duration\", BIGINT)\n(\"rental_rate\", DOUBLE PRECISION)\n(\"_length\", BIGINT)\n(\"replacement_cost\", DOUBLE PRECISION)\n(\"rating\", STRING)\n(\"special_features\", STRING)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 663,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT first_name, last_name, email FROM customer WHERE STRFTIME('%Y',create_date) = '2006' AND active = 0",
        "target_query": "SELECT \"first_name\", \"last_name\", \"email\" FROM \"customer\" WHERE sys.timestamp_to_str(\"create_date\", '%Y') = '2006' AND \"active\" = 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 56,
                "end_index": 81,
                "dilatect_content": "STRFTIME('%Y',create_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 72,
                "end_index": 114,
                "dilatect_content": "sys.timestamp_to_str(\"create_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`store_id`, integer)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n(`address_id`, integer)\n(`active`, integer)\n(`create_date`, datetime)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"customer\"\nColumns:\n(\"customer_id\", BIGINT, primary key)\n(\"store_id\", BIGINT)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"email\", STRING)\n(\"address_id\", BIGINT)\n(\"active\", BIGINT)\n(\"create_date\", TIMESTAMP)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 664,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(rating = 'PG-13', 1, 0)) AS REAL) * 100 / COUNT(film_id) FROM film",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"rating\" = 'PG-13' THEN 1 ELSE 0 END) AS DOUBLE PRECISION) * 100 / COUNT(\"film_id\") FROM \"film\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 42,
                "dilatect_content": "IIF(rating = 'PG-13', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 63,
                "dilatect_content": "CASE WHEN \"rating\" = 'PG-13' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `film`\nColumns:\n(`film_id`, integer, primary key)\n(`title`, text)\n(`description`, text)\n(`release_year`, text)\n(`language_id`, integer)\n(`original_language_id`, integer)\n(`rental_duration`, integer)\n(`rental_rate`, real)\n(`length`, integer)\n(`replacement_cost`, real)\n(`rating`, text)\n(`special_features`, text)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"film\"\nColumns:\n(\"film_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"description\", STRING)\n(\"release_year\", STRING)\n(\"language_id\", BIGINT)\n(\"original_language_id\", BIGINT)\n(\"rental_duration\", BIGINT)\n(\"rental_rate\", DOUBLE PRECISION)\n(\"_length\", BIGINT)\n(\"replacement_cost\", DOUBLE PRECISION)\n(\"rating\", STRING)\n(\"special_features\", STRING)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 665,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.name = 'horror', 1, 0)) AS REAL) * 100 / COUNT(T2.category_id) FROM film_category AS T1 INNER JOIN category AS T2 ON T1.category_id = T2.category_id",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"name\" = 'horror' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T2\".\"category_id\") FROM \"film_category\" AS \"T1\" INNER JOIN \"category\" AS \"T2\" ON \"T1\".\"category_id\" = \"T2\".\"category_id\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 44,
                "dilatect_content": "IIF(T2.name = 'horror', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 69,
                "dilatect_content": "CASE WHEN \"T2\".\"name\" = 'horror' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `film_category`\nColumns:\n(`film_id`, integer, primary key)\n(`category_id`, integer, primary key)\n(`last_update`, datetime)\n",
            "Table: `category`\nColumns:\n(`category_id`, integer, primary key)\n(`name`, text)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"film_category\"\nColumns:\n(\"film_id\", BIGINT, primary key)\n(\"category_id\", BIGINT, primary key)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"category\"\nColumns:\n(\"category_id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 666,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT AVG(IIF(T4.country = 'Australia', 1, 0)) - AVG(IIF(T4.country = 'Canada', 1, 0)) AS diff FROM customer AS T1 INNER JOIN address AS T2 ON T1.address_id = T2.address_id INNER JOIN city AS T3 ON T2.city_id = T3.city_id INNER JOIN country AS T4 ON T3.country_id = T4.country_id",
        "target_query": "SELECT AVG(CASE WHEN \"T4\".\"country\" = 'Australia' THEN 1 ELSE 0 END) - AVG(CASE WHEN \"T4\".\"country\" = 'Canada' THEN 1 ELSE 0 END) AS \"diff\" \nFROM \"customer\" AS \"T1\" \nINNER JOIN \"address\" AS \"T2\" ON \"T1\".\"address_id\" = \"T2\".\"address_id\" \nINNER JOIN \"city\" AS \"T3\" ON \"T2\".\"city_id\" = \"T3\".\"city_id\" \nINNER JOIN \"country\" AS \"T4\" ON \"T3\".\"country_id\" = \"T4\".\"country_id\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 45,
                "dilatect_content": "IIF(T4.country = 'Australia', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 54,
                "end_index": 85,
                "dilatect_content": "IIF(T4.country = 'Canada', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 70,
                "dilatect_content": "CASE WHEN \"T4\".\"country\" = 'Australia' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 79,
                "end_index": 135,
                "dilatect_content": "CASE WHEN \"T4\".\"country\" = 'Canada' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`store_id`, integer)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n(`address_id`, integer)\n(`active`, integer)\n(`create_date`, datetime)\n(`last_update`, datetime)\n",
            "Table: `address`\nColumns:\n(`address_id`, integer, primary key)\n(`address`, text)\n(`address2`, text)\n(`district`, text)\n(`city_id`, integer)\n(`postal_code`, text)\n(`phone`, text)\n(`last_update`, datetime)\n",
            "Table: `city`\nColumns:\n(`city_id`, integer, primary key)\n(`city`, text)\n(`country_id`, integer)\n(`last_update`, datetime)\n",
            "Table: `country`\nColumns:\n(`country_id`, integer, primary key)\n(`country`, text)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"customer\"\nColumns:\n(\"customer_id\", BIGINT, primary key)\n(\"store_id\", BIGINT)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"email\", STRING)\n(\"address_id\", BIGINT)\n(\"active\", BIGINT)\n(\"create_date\", TIMESTAMP)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"address\"\nColumns:\n(\"address_id\", BIGINT, primary key)\n(\"address\", STRING)\n(\"address2\", STRING)\n(\"district\", STRING)\n(\"city_id\", BIGINT)\n(\"postal_code\", STRING)\n(\"phone\", STRING)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"city\"\nColumns:\n(\"city_id\", BIGINT, primary key)\n(\"city\", STRING)\n(\"country_id\", BIGINT)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"country\"\nColumns:\n(\"country_id\", BIGINT, primary key)\n(\"country\", STRING)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 667,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T4.name = 'Action', 1, 0)) AS REAL) * 100 / COUNT(T1.actor_id) FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film_category AS T3 ON T2.film_id = T3.film_id INNER JOIN category AS T4 ON T3.category_id = T4.category_id WHERE T1.first_name = 'Reese' AND T1.last_name = 'Kilmer'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T4\".\"name\" = 'Action' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"actor_id\") FROM \"actor\" AS \"T1\" INNER JOIN \"film_actor\" AS \"T2\" ON \"T1\".\"actor_id\" = \"T2\".\"actor_id\" INNER JOIN \"film_category\" AS \"T3\" ON \"T2\".\"film_id\" = \"T3\".\"film_id\" INNER JOIN \"category\" AS \"T4\" ON \"T3\".\"category_id\" = \"T4\".\"category_id\" WHERE \"T1\".\"first_name\" = 'Reese' AND \"T1\".\"last_name\" = 'Kilmer';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 44,
                "dilatect_content": "IIF(T4.name = 'Action', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 69,
                "dilatect_content": "CASE WHEN \"T4\".\"name\" = 'Action' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `actor`\nColumns:\n(`actor_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`last_update`, datetime)\n",
            "Table: `film_actor`\nColumns:\n(`actor_id`, integer, primary key)\n(`film_id`, integer, primary key)\n(`last_update`, datetime)\n",
            "Table: `film_category`\nColumns:\n(`film_id`, integer, primary key)\n(`category_id`, integer, primary key)\n(`last_update`, datetime)\n",
            "Table: `category`\nColumns:\n(`category_id`, integer, primary key)\n(`name`, text)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"actor\"\nColumns:\n(\"actor_id\", BIGINT, primary key)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"film_actor\"\nColumns:\n(\"actor_id\", BIGINT, primary key)\n(\"film_id\", BIGINT, primary key)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"film_category\"\nColumns:\n(\"film_id\", BIGINT, primary key)\n(\"category_id\", BIGINT, primary key)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"category\"\nColumns:\n(\"category_id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 670,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T1.rental_id) FROM rental AS T1 INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id WHERE T2.first_name = 'ELLA' AND T2.last_name = 'ELLA' AND date(T1.rental_date) BETWEEN '2005-06-01' AND '2005-06-30'",
        "target_query": "SELECT COUNT(\"T1\".\"rental_id\") FROM \"rental\" AS \"T1\" INNER JOIN \"customer\" AS \"T2\" ON \"T1\".\"customer_id\" = \"T2\".\"customer_id\" WHERE \"T2\".\"first_name\" = 'ELLA' AND \"T2\".\"last_name\" = 'ELLA' AND sys.timestamp_to_str(\"T1\".\"rental_date\", '%Y-%m-%d') BETWEEN '2005-06-01' AND '2005-06-30';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 165,
                "end_index": 184,
                "dilatect_content": "date(T1.rental_date)",
                "feature": "date(time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 221,
                "end_index": 276,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"rental_date\", '%Y-%m-%d')",
                "feature": "sys.timestamp_to_str(date-value, '%Y-%m-%d')"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "date(time-value, modifier, modifier, ...)",
                "explanation": "The date(time-value, modifier, modifier, ...) function returns the date as text in the format: YYYY-MM-DD. The function accepts a time-value and zero or more modifiers to alter the date.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day', 'start of month').\nReturns: A string in the format YYYY-MM-DD.",
                "examples": [
                    "SELECT date(); -- Returns the current date.",
                    "SELECT date('now', '+1 day'); -- Returns the date one day after the current date.",
                    "SELECT date('2024-08-21'); -- Returns '2024-08-21'."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(date-value, '%Y-%m-%d')",
                "explanation": "In MonetDB, the DATE function from SQLite can be emulated using sys.timestamp_to_str to convert a DATE or TIMESTAMP value into a string in the format YYYY-MM-DD. Date arithmetic (e.g., +1 day) can be performed using sql_add with INTERVAL expressions.",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_DATE, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_DATE, interval '1' day), '%Y-%m-%d'); -- Returns the date one day after the current date.",
                    "SELECT sys.timestamp_to_str(date '2024-08-21', '%Y-%m-%d'); -- Returns '2024-08-21'."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `rental`\nColumns:\n(`rental_id`, integer, primary key)\n(`rental_date`, datetime)\n(`inventory_id`, integer)\n(`customer_id`, integer)\n(`return_date`, datetime)\n(`staff_id`, integer)\n(`last_update`, datetime)\n",
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`store_id`, integer)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n(`address_id`, integer)\n(`active`, integer)\n(`create_date`, datetime)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"rental\"\nColumns:\n(\"rental_id\", BIGINT, primary key)\n(\"rental_date\", TIMESTAMP)\n(\"inventory_id\", BIGINT)\n(\"customer_id\", BIGINT)\n(\"return_date\", TIMESTAMP)\n(\"staff_id\", BIGINT)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"customer\"\nColumns:\n(\"customer_id\", BIGINT, primary key)\n(\"store_id\", BIGINT)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"email\", STRING)\n(\"address_id\", BIGINT)\n(\"active\", BIGINT)\n(\"create_date\", TIMESTAMP)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 671,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(T2.amount) FROM rental AS T1 INNER JOIN payment AS T2 ON T1.rental_id = T2.rental_id WHERE date(T1.rental_date) = '2005-07-29%'",
        "target_query": "SELECT SUM(\"T2\".\"amount\") FROM \"rental\" AS \"T1\" INNER JOIN \"payment\" AS \"T2\" ON \"T1\".\"rental_id\" = \"T2\".\"rental_id\" WHERE sys.timestamp_to_str(\"T1\".\"rental_date\", '%Y-%m-%d') = '2005-07-29';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 102,
                "end_index": 121,
                "dilatect_content": "date(T1.rental_date)",
                "feature": "date(time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 142,
                "end_index": 197,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"rental_date\", '%Y-%m-%d')",
                "feature": "sys.timestamp_to_str(date-value, '%Y-%m-%d')"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "date(time-value, modifier, modifier, ...)",
                "explanation": "The date(time-value, modifier, modifier, ...) function returns the date as text in the format: YYYY-MM-DD. The function accepts a time-value and zero or more modifiers to alter the date.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day', 'start of month').\nReturns: A string in the format YYYY-MM-DD.",
                "examples": [
                    "SELECT date(); -- Returns the current date.",
                    "SELECT date('now', '+1 day'); -- Returns the date one day after the current date.",
                    "SELECT date('2024-08-21'); -- Returns '2024-08-21'."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(date-value, '%Y-%m-%d')",
                "explanation": "In MonetDB, the DATE function from SQLite can be emulated using sys.timestamp_to_str to convert a DATE or TIMESTAMP value into a string in the format YYYY-MM-DD. Date arithmetic (e.g., +1 day) can be performed using sql_add with INTERVAL expressions.",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_DATE, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_DATE, interval '1' day), '%Y-%m-%d'); -- Returns the date one day after the current date.",
                    "SELECT sys.timestamp_to_str(date '2024-08-21', '%Y-%m-%d'); -- Returns '2024-08-21'."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `rental`\nColumns:\n(`rental_id`, integer, primary key)\n(`rental_date`, datetime)\n(`inventory_id`, integer)\n(`customer_id`, integer)\n(`return_date`, datetime)\n(`staff_id`, integer)\n(`last_update`, datetime)\n",
            "Table: `payment`\nColumns:\n(`payment_id`, integer, primary key)\n(`customer_id`, integer)\n(`staff_id`, integer)\n(`rental_id`, integer)\n(`amount`, real)\n(`payment_date`, datetime)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"rental\"\nColumns:\n(\"rental_id\", BIGINT, primary key)\n(\"rental_date\", TIMESTAMP)\n(\"inventory_id\", BIGINT)\n(\"customer_id\", BIGINT)\n(\"return_date\", TIMESTAMP)\n(\"staff_id\", BIGINT)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"payment\"\nColumns:\n(\"payment_id\", BIGINT, primary key)\n(\"customer_id\", BIGINT)\n(\"staff_id\", BIGINT)\n(\"rental_id\", BIGINT)\n(\"amount\", DOUBLE PRECISION)\n(\"payment_date\", TIMESTAMP)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 672,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT T1.first_name FROM customer AS T1 INNER JOIN address AS T2 ON T1.address_id = T2.address_id WHERE SUBSTR(T2.postal_code, 1, 2) = '76'",
        "target_query": "SELECT \"T1\".\"first_name\" FROM \"customer\" AS \"T1\" INNER JOIN \"address\" AS \"T2\" ON \"T1\".\"address_id\" = \"T2\".\"address_id\" WHERE substring(\"T2\".\"postal_code\" from 1 for 2) = '76';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 105,
                "end_index": 132,
                "dilatect_content": "SUBSTR(T2.postal_code, 1, 2)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 145,
                "end_index": 190,
                "dilatect_content": "substring(\"T2\".\"postal_code\" from 1 for 2)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`store_id`, integer)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n(`address_id`, integer)\n(`active`, integer)\n(`create_date`, datetime)\n(`last_update`, datetime)\n",
            "Table: `address`\nColumns:\n(`address_id`, integer, primary key)\n(`address`, text)\n(`address2`, text)\n(`district`, text)\n(`city_id`, integer)\n(`postal_code`, text)\n(`phone`, text)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"customer\"\nColumns:\n(\"customer_id\", BIGINT, primary key)\n(\"store_id\", BIGINT)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"email\", STRING)\n(\"address_id\", BIGINT)\n(\"active\", BIGINT)\n(\"create_date\", TIMESTAMP)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"address\"\nColumns:\n(\"address_id\", BIGINT, primary key)\n(\"address\", STRING)\n(\"address2\", STRING)\n(\"district\", STRING)\n(\"city_id\", BIGINT)\n(\"postal_code\", STRING)\n(\"phone\", STRING)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 673,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.length < 100 AND T3.name = 'Drama', 1, 0)) AS REAL) * 100 / COUNT(T1.film_id) FROM film_category AS T1 INNER JOIN film AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T1.category_id = T3.category_id",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"_length\" < 100 AND \"T3\".\"name\" = 'Drama' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"film_id\") FROM \"film_category\" AS \"T1\" INNER JOIN \"film\" AS \"T2\" ON \"T1\".\"film_id\" = \"T2\".\"film_id\" INNER JOIN \"category\" AS \"T3\" ON \"T1\".\"category_id\" = \"T3\".\"category_id\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 63,
                "dilatect_content": "IIF(T2.length < 100 AND T3.name = 'Drama', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 97,
                "dilatect_content": "CASE WHEN \"T2\".\"_length\" < 100 AND \"T3\".\"name\" = 'Drama' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `film_category`\nColumns:\n(`film_id`, integer, primary key)\n(`category_id`, integer, primary key)\n(`last_update`, datetime)\n",
            "Table: `film`\nColumns:\n(`film_id`, integer, primary key)\n(`title`, text)\n(`description`, text)\n(`release_year`, text)\n(`language_id`, integer)\n(`original_language_id`, integer)\n(`rental_duration`, integer)\n(`rental_rate`, real)\n(`length`, integer)\n(`replacement_cost`, real)\n(`rating`, text)\n(`special_features`, text)\n(`last_update`, datetime)\n",
            "Table: `category`\nColumns:\n(`category_id`, integer, primary key)\n(`name`, text)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"film_category\"\nColumns:\n(\"film_id\", BIGINT, primary key)\n(\"category_id\", BIGINT, primary key)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"film\"\nColumns:\n(\"film_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"description\", STRING)\n(\"release_year\", STRING)\n(\"language_id\", BIGINT)\n(\"original_language_id\", BIGINT)\n(\"rental_duration\", BIGINT)\n(\"rental_rate\", DOUBLE PRECISION)\n(\"_length\", BIGINT)\n(\"replacement_cost\", DOUBLE PRECISION)\n(\"rating\", STRING)\n(\"special_features\", STRING)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"category\"\nColumns:\n(\"category_id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 674,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(T2.name = 'Children', 1, 0)) - SUM(IIF(T2.name = 'Action', 1, 0)) AS diff FROM film_category AS T1 INNER JOIN category AS T2 ON T1.category_id = T2.category_id",
        "target_query": "SELECT SUM(CASE WHEN \"T2\".\"name\" = 'Children' THEN 1 ELSE 0 END) - SUM(CASE WHEN \"T2\".\"name\" = 'Action' THEN 1 ELSE 0 END) AS \"diff\" FROM \"film_category\" AS \"T1\" INNER JOIN \"category\" AS \"T2\" ON \"T1\".\"category_id\" = \"T2\".\"category_id\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 41,
                "dilatect_content": "IIF(T2.name = 'Children', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 50,
                "end_index": 78,
                "dilatect_content": "IIF(T2.name = 'Action', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 66,
                "dilatect_content": "CASE WHEN \"T2\".\"name\" = 'Children' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 75,
                "end_index": 128,
                "dilatect_content": "CASE WHEN \"T2\".\"name\" = 'Action' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `film_category`\nColumns:\n(`film_id`, integer, primary key)\n(`category_id`, integer, primary key)\n(`last_update`, datetime)\n",
            "Table: `category`\nColumns:\n(`category_id`, integer, primary key)\n(`name`, text)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"film_category\"\nColumns:\n(\"film_id\", BIGINT, primary key)\n(\"category_id\", BIGINT, primary key)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"category\"\nColumns:\n(\"category_id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 675,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.name = 'Documentary', 1, 0)) AS REAL) * 100 / COUNT(T1.film_id) FROM film_category AS T1 INNER JOIN category AS T2 ON T1.category_id = T2.category_id",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"name\" = 'Documentary' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"film_id\") FROM \"film_category\" AS \"T1\" INNER JOIN \"category\" AS \"T2\" ON \"T1\".\"category_id\" = \"T2\".\"category_id\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 49,
                "dilatect_content": "IIF(T2.name = 'Documentary', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 74,
                "dilatect_content": "CASE WHEN \"T2\".\"name\" = 'Documentary' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `film_category`\nColumns:\n(`film_id`, integer, primary key)\n(`category_id`, integer, primary key)\n(`last_update`, datetime)\n",
            "Table: `category`\nColumns:\n(`category_id`, integer, primary key)\n(`name`, text)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"film_category\"\nColumns:\n(\"film_id\", BIGINT, primary key)\n(\"category_id\", BIGINT, primary key)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"category\"\nColumns:\n(\"category_id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 676,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.name = 'Horror', 1, 0)) AS REAL) * 100 / COUNT(T1.film_id) FROM film_category AS T1 INNER JOIN category AS T2 ON T1.category_id = T2.category_id INNER JOIN film AS T3 ON T1.film_id = T3.film_id",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"name\" = 'Horror' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"film_id\") FROM \"film_category\" AS \"T1\" INNER JOIN \"category\" AS \"T2\" ON \"T1\".\"category_id\" = \"T2\".\"category_id\" INNER JOIN \"film\" AS \"T3\" ON \"T1\".\"film_id\" = \"T3\".\"film_id\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 44,
                "dilatect_content": "IIF(T2.name = 'Horror', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 69,
                "dilatect_content": "CASE WHEN \"T2\".\"name\" = 'Horror' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `film_category`\nColumns:\n(`film_id`, integer, primary key)\n(`category_id`, integer, primary key)\n(`last_update`, datetime)\n",
            "Table: `category`\nColumns:\n(`category_id`, integer, primary key)\n(`name`, text)\n(`last_update`, datetime)\n",
            "Table: `film`\nColumns:\n(`film_id`, integer, primary key)\n(`title`, text)\n(`description`, text)\n(`release_year`, text)\n(`language_id`, integer)\n(`original_language_id`, integer)\n(`rental_duration`, integer)\n(`rental_rate`, real)\n(`length`, integer)\n(`replacement_cost`, real)\n(`rating`, text)\n(`special_features`, text)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"film_category\"\nColumns:\n(\"film_id\", BIGINT, primary key)\n(\"category_id\", BIGINT, primary key)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"category\"\nColumns:\n(\"category_id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"film\"\nColumns:\n(\"film_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"description\", STRING)\n(\"release_year\", STRING)\n(\"language_id\", BIGINT)\n(\"original_language_id\", BIGINT)\n(\"rental_duration\", BIGINT)\n(\"rental_rate\", DOUBLE PRECISION)\n(\"_length\", BIGINT)\n(\"replacement_cost\", DOUBLE PRECISION)\n(\"rating\", STRING)\n(\"special_features\", STRING)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 677,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T2.first_name = 'MARGARET' AND T2.last_name = 'MOORE', T1.amount, 0)) AS REAL) * 100 / SUM(T1.amount) FROM payment AS T1 INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"first_name\" = 'MARGARET' AND \"T2\".\"last_name\" = 'MOORE' THEN \"T1\".\"amount\" ELSE 0 END) AS REAL) * 100 / SUM(\"T1\".\"amount\") FROM \"payment\" AS \"T1\" INNER JOIN \"customer\" AS \"T2\" ON \"T1\".\"customer_id\" = \"T2\".\"customer_id\";",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 87,
                "dilatect_content": "IIF(T2.first_name = 'MARGARET' AND T2.last_name = 'MOORE', T1.amount, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 128,
                "dilatect_content": "CASE WHEN \"T2\".\"first_name\" = 'MARGARET' AND \"T2\".\"last_name\" = 'MOORE' THEN \"T1\".\"amount\" ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `payment`\nColumns:\n(`payment_id`, integer, primary key)\n(`customer_id`, integer)\n(`staff_id`, integer)\n(`rental_id`, integer)\n(`amount`, real)\n(`payment_date`, datetime)\n(`last_update`, datetime)\n",
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`store_id`, integer)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n(`address_id`, integer)\n(`active`, integer)\n(`create_date`, datetime)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"payment\"\nColumns:\n(\"payment_id\", BIGINT, primary key)\n(\"customer_id\", BIGINT)\n(\"staff_id\", BIGINT)\n(\"rental_id\", BIGINT)\n(\"amount\", DOUBLE PRECISION)\n(\"payment_date\", TIMESTAMP)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"customer\"\nColumns:\n(\"customer_id\", BIGINT, primary key)\n(\"store_id\", BIGINT)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"email\", STRING)\n(\"address_id\", BIGINT)\n(\"active\", BIGINT)\n(\"create_date\", TIMESTAMP)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 678,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T3.`name` = 'Horror', 1, 0)) * 100 / COUNT(T1.film_id) AS REAL) FROM film AS T1 INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T3.category_id = T2.category_id WHERE T1.length > 120",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T3\".\"name\" = 'Horror' THEN 1 ELSE 0 END) * 100 / COUNT(\"T1\".\"film_id\") AS REAL) FROM \"film\" AS \"T1\" INNER JOIN \"film_category\" AS \"T2\" ON \"T1\".\"film_id\" = \"T2\".\"film_id\" INNER JOIN \"category\" AS \"T3\" ON \"T3\".\"category_id\" = \"T2\".\"category_id\" WHERE \"T1\".\"_length\" > 120;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 46,
                "dilatect_content": "IIF(T3.`name` = 'Horror', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 69,
                "dilatect_content": "CASE WHEN \"T3\".\"name\" = 'Horror' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `film`\nColumns:\n(`film_id`, integer, primary key)\n(`title`, text)\n(`description`, text)\n(`release_year`, text)\n(`language_id`, integer)\n(`original_language_id`, integer)\n(`rental_duration`, integer)\n(`rental_rate`, real)\n(`length`, integer)\n(`replacement_cost`, real)\n(`rating`, text)\n(`special_features`, text)\n(`last_update`, datetime)\n",
            "Table: `film_category`\nColumns:\n(`film_id`, integer, primary key)\n(`category_id`, integer, primary key)\n(`last_update`, datetime)\n",
            "Table: `category`\nColumns:\n(`category_id`, integer, primary key)\n(`name`, text)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"film\"\nColumns:\n(\"film_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"description\", STRING)\n(\"release_year\", STRING)\n(\"language_id\", BIGINT)\n(\"original_language_id\", BIGINT)\n(\"rental_duration\", BIGINT)\n(\"rental_rate\", DOUBLE PRECISION)\n(\"_length\", BIGINT)\n(\"replacement_cost\", DOUBLE PRECISION)\n(\"rating\", STRING)\n(\"special_features\", STRING)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"film_category\"\nColumns:\n(\"film_id\", BIGINT, primary key)\n(\"category_id\", BIGINT, primary key)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"category\"\nColumns:\n(\"category_id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 679,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT CAST(SUM(IIF(T3.name = 'Horror', 1, 0)) AS REAL) * 100 / COUNT(T1.film_id) FROM film_category AS T1 INNER JOIN film AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T1.category_id = T3.category_id INNER JOIN language AS T4 ON T2.language_id = T4.language_id WHERE T4.name = 'English'",
        "target_query": "SELECT CAST(SUM(CASE WHEN \"T3\".\"name\" = 'Horror' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"film_id\") FROM \"film_category\" AS \"T1\" INNER JOIN \"film\" AS \"T2\" ON \"T1\".\"film_id\" = \"T2\".\"film_id\" INNER JOIN \"category\" AS \"T3\" ON \"T1\".\"category_id\" = \"T3\".\"category_id\" INNER JOIN \"language\" AS \"T4\" ON \"T2\".\"language_id\" = \"T4\".\"language_id\" WHERE \"T4\".\"name\" = 'English';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 44,
                "dilatect_content": "IIF(T3.name = 'Horror', 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 69,
                "dilatect_content": "CASE WHEN \"T3\".\"name\" = 'Horror' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `film_category`\nColumns:\n(`film_id`, integer, primary key)\n(`category_id`, integer, primary key)\n(`last_update`, datetime)\n",
            "Table: `film`\nColumns:\n(`film_id`, integer, primary key)\n(`title`, text)\n(`description`, text)\n(`release_year`, text)\n(`language_id`, integer)\n(`original_language_id`, integer)\n(`rental_duration`, integer)\n(`rental_rate`, real)\n(`length`, integer)\n(`replacement_cost`, real)\n(`rating`, text)\n(`special_features`, text)\n(`last_update`, datetime)\n",
            "Table: `category`\nColumns:\n(`category_id`, integer, primary key)\n(`name`, text)\n(`last_update`, datetime)\n",
            "Table: `language`\nColumns:\n(`language_id`, integer, primary key)\n(`name`, text)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"film_category\"\nColumns:\n(\"film_id\", BIGINT, primary key)\n(\"category_id\", BIGINT, primary key)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"film\"\nColumns:\n(\"film_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"description\", STRING)\n(\"release_year\", STRING)\n(\"language_id\", BIGINT)\n(\"original_language_id\", BIGINT)\n(\"rental_duration\", BIGINT)\n(\"rental_rate\", DOUBLE PRECISION)\n(\"_length\", BIGINT)\n(\"replacement_cost\", DOUBLE PRECISION)\n(\"rating\", STRING)\n(\"special_features\", STRING)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"category\"\nColumns:\n(\"category_id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"language\"\nColumns:\n(\"language_id\", BIGINT, primary key)\n(\"name\", STRING)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 680,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(T1.amount) FROM payment AS T1 INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id WHERE T2.first_name = 'STEPHANIE' AND T2.last_name = 'MITCHELL' AND SUBSTR(T1.payment_date, 1, 7) = '2005-06'",
        "target_query": "SELECT SUM(\"T1\".\"amount\") FROM \"payment\" AS \"T1\" INNER JOIN \"customer\" AS \"T2\" ON \"T1\".\"customer_id\" = \"T2\".\"customer_id\" WHERE \"T2\".\"first_name\" = 'STEPHANIE' AND \"T2\".\"last_name\" = 'MITCHELL' AND substring(\"T1\".\"payment_date\" from 1 for 7) = '2005-06';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 170,
                "end_index": 198,
                "dilatect_content": "SUBSTR(T1.payment_date, 1, 7)",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 226,
                "end_index": 272,
                "dilatect_content": "substring(\"T1\".\"payment_date\" from 1 for 7)",
                "feature": "substring(X from Y for Z)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(X from Y for Z)",
                "explanation": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `payment`\nColumns:\n(`payment_id`, integer, primary key)\n(`customer_id`, integer)\n(`staff_id`, integer)\n(`rental_id`, integer)\n(`amount`, real)\n(`payment_date`, datetime)\n(`last_update`, datetime)\n",
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`store_id`, integer)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n(`address_id`, integer)\n(`active`, integer)\n(`create_date`, datetime)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"payment\"\nColumns:\n(\"payment_id\", BIGINT, primary key)\n(\"customer_id\", BIGINT)\n(\"staff_id\", BIGINT)\n(\"rental_id\", BIGINT)\n(\"amount\", DOUBLE PRECISION)\n(\"payment_date\", TIMESTAMP)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"customer\"\nColumns:\n(\"customer_id\", BIGINT, primary key)\n(\"store_id\", BIGINT)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"email\", STRING)\n(\"address_id\", BIGINT)\n(\"active\", BIGINT)\n(\"create_date\", TIMESTAMP)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 681,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T2.rental_id) , CAST(SUM(IIF(STRFTIME('%m',T2.rental_date) = '7', 1, 0)) AS REAL) * 100 / COUNT(T2.rental_id) FROM customer AS T1 INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id WHERE T1.first_name = 'Maria' AND T1.last_name = 'Miller' AND STRFTIME('%Y',T2.rental_date) = '2005'",
        "target_query": "SELECT COUNT(\"T2\".\"rental_id\"), CAST(SUM(CASE WHEN sys.timestamp_to_str(\"T2\".\"rental_date\", '%m') = '7' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T2\".\"rental_id\") FROM \"customer\" AS \"T1\" INNER JOIN \"rental\" AS \"T2\" ON \"T1\".\"customer_id\" = \"T2\".\"customer_id\" WHERE \"T1\".\"first_name\" = 'Maria' AND \"T1\".\"last_name\" = 'Miller' AND sys.timestamp_to_str(\"T2\".\"rental_date\", '%Y') = '2005';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 38,
                "end_index": 83,
                "dilatect_content": "IIF(STRFTIME('%m',T2.rental_date) = '7', 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 42,
                "end_index": 70,
                "dilatect_content": "STRFTIME('%m',T2.rental_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 264,
                "end_index": 292,
                "dilatect_content": "STRFTIME('%Y',T2.rental_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 45,
                "end_index": 128,
                "dilatect_content": "CASE WHEN sys.timestamp_to_str(\"T2\".\"rental_date\", '%m') = '7' THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 55,
                "end_index": 104,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"rental_date\", '%m')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 365,
                "end_index": 414,
                "dilatect_content": "sys.timestamp_to_str(\"T2\".\"rental_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            },
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            },
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`store_id`, integer)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n(`address_id`, integer)\n(`active`, integer)\n(`create_date`, datetime)\n(`last_update`, datetime)\n",
            "Table: `rental`\nColumns:\n(`rental_id`, integer, primary key)\n(`rental_date`, datetime)\n(`inventory_id`, integer)\n(`customer_id`, integer)\n(`return_date`, datetime)\n(`staff_id`, integer)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"customer\"\nColumns:\n(\"customer_id\", BIGINT, primary key)\n(\"store_id\", BIGINT)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"email\", STRING)\n(\"address_id\", BIGINT)\n(\"active\", BIGINT)\n(\"create_date\", TIMESTAMP)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"rental\"\nColumns:\n(\"rental_id\", BIGINT, primary key)\n(\"rental_date\", TIMESTAMP)\n(\"inventory_id\", BIGINT)\n(\"customer_id\", BIGINT)\n(\"return_date\", TIMESTAMP)\n(\"staff_id\", BIGINT)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 682,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT SUM(IIF(T4.film_id = 1, 1, 0)) - SUM(IIF(T4.film_id = 2, 1, 0)) AS diff FROM film_actor AS T1 INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T1.film_id = T3.film_id INNER JOIN inventory AS T4 ON T3.film_id = T4.film_id WHERE T2.first_name = 'Reese' AND T2.last_name = 'West'",
        "target_query": "SELECT SUM(CASE WHEN \"T4\".\"film_id\" = 1 THEN 1 ELSE 0 END) - SUM(CASE WHEN \"T4\".\"film_id\" = 2 THEN 1 ELSE 0 END) AS \"diff\" FROM \"film_actor\" AS \"T1\" INNER JOIN \"actor\" AS \"T2\" ON \"T1\".\"actor_id\" = \"T2\".\"actor_id\" INNER JOIN \"film\" AS \"T3\" ON \"T1\".\"film_id\" = \"T3\".\"film_id\" INNER JOIN \"inventory\" AS \"T4\" ON \"T3\".\"film_id\" = \"T4\".\"film_id\" WHERE \"T2\".\"first_name\" = 'Reese' AND \"T2\".\"last_name\" = 'West';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 35,
                "dilatect_content": "IIF(T4.film_id = 1, 1, 0)",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 44,
                "end_index": 68,
                "dilatect_content": "IIF(T4.film_id = 2, 1, 0)",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 60,
                "dilatect_content": "CASE WHEN \"T4\".\"film_id\" = 1 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            },
            {
                "start_index": 69,
                "end_index": 118,
                "dilatect_content": "CASE WHEN \"T4\".\"film_id\" = 2 THEN 1 ELSE 0 END",
                "feature": "CASE WHEN X THEN Y ELSE Z END"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "CASE WHEN X THEN Y ELSE Z END",
                "explanation": "MonetDB does not support the IIF function directly. Instead, the equivalent behavior can be achieved using a standard SQL CASE expression. It returns Y if X is true, otherwise returns Z.\nParameters:\n- X: A boolean condition.\n- Y: The result if the condition is true.\n- Z: The result if the condition is false.\nReturns: Y if X is true, otherwise Z.",
                "examples": [
                    "SELECT CASE WHEN 10 > 5 THEN 'Yes' ELSE 'No' END; -- Returns 'Yes'",
                    "SELECT CASE WHEN 3 = 4 THEN 'Equal' ELSE 'Not Equal' END; -- Returns 'Not Equal'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `film_actor`\nColumns:\n(`actor_id`, integer, primary key)\n(`film_id`, integer, primary key)\n(`last_update`, datetime)\n",
            "Table: `actor`\nColumns:\n(`actor_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`last_update`, datetime)\n",
            "Table: `film`\nColumns:\n(`film_id`, integer, primary key)\n(`title`, text)\n(`description`, text)\n(`release_year`, text)\n(`language_id`, integer)\n(`original_language_id`, integer)\n(`rental_duration`, integer)\n(`rental_rate`, real)\n(`length`, integer)\n(`replacement_cost`, real)\n(`rating`, text)\n(`special_features`, text)\n(`last_update`, datetime)\n",
            "Table: `inventory`\nColumns:\n(`inventory_id`, integer, primary key)\n(`film_id`, integer)\n(`store_id`, integer)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"film_actor\"\nColumns:\n(\"actor_id\", BIGINT, primary key)\n(\"film_id\", BIGINT, primary key)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"actor\"\nColumns:\n(\"actor_id\", BIGINT, primary key)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"film\"\nColumns:\n(\"film_id\", BIGINT, primary key)\n(\"title\", STRING)\n(\"description\", STRING)\n(\"release_year\", STRING)\n(\"language_id\", BIGINT)\n(\"original_language_id\", BIGINT)\n(\"rental_duration\", BIGINT)\n(\"rental_rate\", DOUBLE PRECISION)\n(\"_length\", BIGINT)\n(\"replacement_cost\", DOUBLE PRECISION)\n(\"rating\", STRING)\n(\"special_features\", STRING)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"inventory\"\nColumns:\n(\"inventory_id\", BIGINT, primary key)\n(\"film_id\", BIGINT)\n(\"store_id\", BIGINT)\n(\"last_update\", TIMESTAMP)\n"
        ]
    },
    {
        "sql_id": 683,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "monetdb",
        "source_query": "SELECT COUNT(T1.customer_id) FROM payment AS T1 INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id WHERE T2.first_name = 'MARY' AND T2.last_name = 'SMITH' AND STRFTIME('%Y',T1.payment_date) = '2005' AND STRFTIME('%Y', T1.payment_date) = '6'",
        "target_query": "SELECT COUNT(\"T1\".\"customer_id\") FROM \"payment\" AS \"T1\" INNER JOIN \"customer\" AS \"T2\" ON \"T1\".\"customer_id\" = \"T2\".\"customer_id\" WHERE \"T2\".\"first_name\" = 'MARY' AND \"T2\".\"last_name\" = 'SMITH' AND sys.timestamp_to_str(\"T1\".\"payment_date\", '%Y') = '2005' AND sys.timestamp_to_str(\"T1\".\"payment_date\", '%Y') = '6';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 169,
                "end_index": 198,
                "dilatect_content": "STRFTIME('%Y',T1.payment_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 213,
                "end_index": 243,
                "dilatect_content": "STRFTIME('%Y', T1.payment_date)",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 225,
                "end_index": 275,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"payment_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            },
            {
                "start_index": 290,
                "end_index": 340,
                "dilatect_content": "sys.timestamp_to_str(\"T1\".\"payment_date\", '%Y')",
                "feature": "sys.timestamp_to_str(timestamp, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sys.timestamp_to_str(timestamp, format)",
                "explanation": "The sys.timestamp_to_str function in MonetDB converts a TIMESTAMP value into a formatted string according to the given format pattern. It is analogous to SQLite's strftime function, and supports a wide range of standard format specifiers like %Y (year), %m (month), %d (day), %H (hour), %M (minute), and %S (second).",
                "examples": [
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT sys.timestamp_to_str(CURRENT_TIMESTAMP, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.timestamp_to_str(sql_add(CURRENT_TIMESTAMP, interval '1' hour), '%Y-%m-%d %H:%M:%S'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `payment`\nColumns:\n(`payment_id`, integer, primary key)\n(`customer_id`, integer)\n(`staff_id`, integer)\n(`rental_id`, integer)\n(`amount`, real)\n(`payment_date`, datetime)\n(`last_update`, datetime)\n",
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`store_id`, integer)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n(`address_id`, integer)\n(`active`, integer)\n(`create_date`, datetime)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: \"payment\"\nColumns:\n(\"payment_id\", BIGINT, primary key)\n(\"customer_id\", BIGINT)\n(\"staff_id\", BIGINT)\n(\"rental_id\", BIGINT)\n(\"amount\", DOUBLE PRECISION)\n(\"payment_date\", TIMESTAMP)\n(\"last_update\", TIMESTAMP)\n",
            "Table: \"customer\"\nColumns:\n(\"customer_id\", BIGINT, primary key)\n(\"store_id\", BIGINT)\n(\"first_name\", STRING)\n(\"last_name\", STRING)\n(\"email\", STRING)\n(\"address_id\", BIGINT)\n(\"active\", BIGINT)\n(\"create_date\", TIMESTAMP)\n(\"last_update\", TIMESTAMP)\n"
        ]
    }
]