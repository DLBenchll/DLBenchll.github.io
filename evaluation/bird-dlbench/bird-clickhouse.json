[
    {
        "sql_id": 216,
        "database_name": "app_store",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(CASE WHEN SUBSTR('Last Updated', -4) > '2018' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(App) PER FROM playstore WHERE Type = 'Free' AND Rating >= 4.5",
        "target_query": "SELECT SUM(CASE WHEN substring('Last Updated', -4) > '2018' THEN 1 ELSE 0 END) * 100 / COUNT(`App`) AS `PER` FROM `playstore` WHERE `_Type` = 'Free' AND `Rating` >= 4.5;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 26,
                "end_index": 52,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 50,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `playstore`\nColumns:\n(`App`, text)\n(`Category`, text)\n(`Rating`, real)\n(`Reviews`, integer)\n(`Size`, text)\n(`Installs`, text)\n(`Type`, text)\n(`Price`, text)\n(`Content Rating`, text)\n(`Genres`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `playstore`\nColumns:\n(`App`, String)\n(`Category`, String)\n(`Rating`, Float64)\n(`Reviews`, Int64)\n(`Size`, String)\n(`Installs`, String)\n(`_Type`, String)\n(`Price`, String)\n(`Content_Rating`, String)\n(`Genres`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 249,
        "database_name": "authors",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT FullName FROM Conference ORDER BY LENGTH(FullName) DESC LIMIT 1",
        "target_query": "SELECT `FullName` FROM `Conference` ORDER BY length(`FullName`) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 41,
                "end_index": 57,
                "dialect_content": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "feature": "length(X)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 45,
                "end_index": 63,
                "dialect_content": "The length(str) function returns the number of bytes in the given string str. Unlike SQLite, which counts Unicode code points for strings, ClickHouse measures the length in bytes. For multibyte characters (UTF-8 encoded), the byte count may be larger than the character count. If str is NULL, the function returns NULL.",
                "feature": "length(str)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "length(str)",
                "explanation": "The length(str) function returns the number of bytes in the given string str. Unlike SQLite, which counts Unicode code points for strings, ClickHouse measures the length in bytes. For multibyte characters (UTF-8 encoded), the byte count may be larger than the character count. If str is NULL, the function returns NULL.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(unhex('68656C6C6F')); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Conference`\nColumns:\n(`Id`, integer, primary key)\n(`ShortName`, text)\n(`FullName`, text)\n(`HomePage`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Conference`\nColumns:\n(`Id`, Int64, primary key)\n(`ShortName`, String)\n(`FullName`, String)\n(`HomePage`, String)\n"
        ]
    },
    {
        "sql_id": 357,
        "database_name": "beer_factory",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN `transaction` AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.First = 'Frank-Paul' AND T1.Last = 'Santangelo' AND STRFTIME('%Y-%m', T2.TransactionDate) = '2014-07'",
        "target_query": "SELECT COUNT(`T1`.`CustomerID`) FROM `customers` AS `T1` INNER JOIN `transaction` AS `T2` ON `T1`.`CustomerID` = `T2`.`CustomerID` WHERE `T1`.`First` = 'Frank-Paul' AND `T1`.`Last` = 'Santangelo' AND formatDateTime(`T2`.`TransactionDate`, '%Y-%m') = '2014-07';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 174,
                "end_index": 211,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 200,
                "end_index": 247,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customers`\nColumns:\n(`CustomerID`, integer, primary key)\n(`First`, text)\n(`Last`, text)\n(`StreetAddress`, text)\n(`City`, text)\n(`State`, text)\n(`ZipCode`, integer)\n(`Email`, text)\n(`PhoneNumber`, text)\n(`FirstPurchaseDate`, date)\n(`SubscribedToEmailList`, text)\n(`Gender`, text)\n",
            "Table: `transaction`\nColumns:\n(`TransactionID`, integer, primary key)\n(`CreditCardNumber`, integer)\n(`CustomerID`, integer)\n(`TransactionDate`, date)\n(`CreditCardType`, text)\n(`LocationID`, integer)\n(`RootBeerID`, integer)\n(`PurchasePrice`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `customers`\nColumns:\n(`CustomerID`, Int64, primary key)\n(`First`, String)\n(`Last`, String)\n(`StreetAddress`, String)\n(`City`, String)\n(`State`, String)\n(`ZipCode`, Int64)\n(`Email`, String)\n(`PhoneNumber`, String)\n(`FirstPurchaseDate`, Date32)\n(`SubscribedToEmailList`, String)\n(`Gender`, String)\n",
            "Table: `transaction`\nColumns:\n(`TransactionID`, Int64, primary key)\n(`CreditCardNumber`, Int64)\n(`CustomerID`, Int64)\n(`TransactionDate`, Date32)\n(`CreditCardType`, String)\n(`LocationID`, Int64)\n(`RootBeerID`, Int64)\n(`PurchasePrice`, Float64)\n"
        ]
    },
    {
        "sql_id": 358,
        "database_name": "beer_factory",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN `transaction` AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Gender = 'M' AND STRFTIME('%Y-%m', T2.TransactionDate) = '2014-07'",
        "target_query": "SELECT COUNT(`T1`.`CustomerID`) FROM `customers` AS `T1` INNER JOIN `transaction` AS `T2` ON `T1`.`CustomerID` = `T2`.`CustomerID` WHERE `T1`.`Gender` = 'M' AND formatDateTime(`T2`.`TransactionDate`, '%Y-%m') = '2014-07';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 139,
                "end_index": 176,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 161,
                "end_index": 208,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customers`\nColumns:\n(`CustomerID`, integer, primary key)\n(`First`, text)\n(`Last`, text)\n(`StreetAddress`, text)\n(`City`, text)\n(`State`, text)\n(`ZipCode`, integer)\n(`Email`, text)\n(`PhoneNumber`, text)\n(`FirstPurchaseDate`, date)\n(`SubscribedToEmailList`, text)\n(`Gender`, text)\n",
            "Table: `transaction`\nColumns:\n(`TransactionID`, integer, primary key)\n(`CreditCardNumber`, integer)\n(`CustomerID`, integer)\n(`TransactionDate`, date)\n(`CreditCardType`, text)\n(`LocationID`, integer)\n(`RootBeerID`, integer)\n(`PurchasePrice`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `customers`\nColumns:\n(`CustomerID`, Int64, primary key)\n(`First`, String)\n(`Last`, String)\n(`StreetAddress`, String)\n(`City`, String)\n(`State`, String)\n(`ZipCode`, Int64)\n(`Email`, String)\n(`PhoneNumber`, String)\n(`FirstPurchaseDate`, Date32)\n(`SubscribedToEmailList`, String)\n(`Gender`, String)\n",
            "Table: `transaction`\nColumns:\n(`TransactionID`, Int64, primary key)\n(`CreditCardNumber`, Int64)\n(`CustomerID`, Int64)\n(`TransactionDate`, Date32)\n(`CreditCardType`, String)\n(`LocationID`, Int64)\n(`RootBeerID`, Int64)\n(`PurchasePrice`, Float64)\n"
        ]
    },
    {
        "sql_id": 359,
        "database_name": "beer_factory",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN `transaction` AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.SubscribedToEmailList = 'TRUE' AND T2.CreditCardType = 'Visa' AND STRFTIME('%Y-%m', T2.TransactionDate) = '2014-07'",
        "target_query": "SELECT COUNT(`T1`.`CustomerID`) FROM `customers` AS `T1` INNER JOIN `transaction` AS `T2` ON `T1`.`CustomerID` = `T2`.`CustomerID` WHERE `T1`.`SubscribedToEmailList` = 'TRUE' AND `T2`.`CreditCardType` = 'Visa' AND formatDateTime(`T2`.`TransactionDate`, '%Y-%m') = '2014-07';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 188,
                "end_index": 225,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 214,
                "end_index": 261,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customers`\nColumns:\n(`CustomerID`, integer, primary key)\n(`First`, text)\n(`Last`, text)\n(`StreetAddress`, text)\n(`City`, text)\n(`State`, text)\n(`ZipCode`, integer)\n(`Email`, text)\n(`PhoneNumber`, text)\n(`FirstPurchaseDate`, date)\n(`SubscribedToEmailList`, text)\n(`Gender`, text)\n",
            "Table: `transaction`\nColumns:\n(`TransactionID`, integer, primary key)\n(`CreditCardNumber`, integer)\n(`CustomerID`, integer)\n(`TransactionDate`, date)\n(`CreditCardType`, text)\n(`LocationID`, integer)\n(`RootBeerID`, integer)\n(`PurchasePrice`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `customers`\nColumns:\n(`CustomerID`, Int64, primary key)\n(`First`, String)\n(`Last`, String)\n(`StreetAddress`, String)\n(`City`, String)\n(`State`, String)\n(`ZipCode`, Int64)\n(`Email`, String)\n(`PhoneNumber`, String)\n(`FirstPurchaseDate`, Date32)\n(`SubscribedToEmailList`, String)\n(`Gender`, String)\n",
            "Table: `transaction`\nColumns:\n(`TransactionID`, Int64, primary key)\n(`CreditCardNumber`, Int64)\n(`CustomerID`, Int64)\n(`TransactionDate`, Date32)\n(`CreditCardType`, String)\n(`LocationID`, Int64)\n(`RootBeerID`, Int64)\n(`PurchasePrice`, Float64)\n"
        ]
    },
    {
        "sql_id": 624,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT MAX(T2.max_temperature_f) FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code AND T2.date = SUBSTR(CAST(T1.start_date AS TEXT), 1, INSTR(T1.start_date, ' ') - 1) WHERE T1.id = 4080",
        "target_query": "SELECT MAX(`T2`.`max_temperature_f`) FROM `trip` AS `T1` INNER JOIN `weather` AS `T2` ON `T2`.`zip_code` = CAST(`T1`.`zip_code` AS String) AND `T2`.`date` = substring(`T1`.`start_date`, 1, positionCaseInsensitive(`T1`.`start_date`, ' ') - 1) WHERE `T1`.`id` = 4080;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 117,
                "end_index": 151,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 157,
                "end_index": 236,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "instr(X,Y)",
                "explanation": "The instr(X,Y) function finds the first occurrence of string Y within \n  string X and returns the number of prior characters plus 1, or 0 if\n  Y is nowhere found within X.\n  Or, if X and Y are both BLOBs, then instr(X,Y) returns one\n  more than the number bytes prior to the first occurrence of Y, or 0 if\n  Y does not occur anywhere within X.\n  If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs\n  then both are interpreted as strings.\n  If either X or Y are NULL in instr(X,Y) then the result is NULL.\n",
                "examples": [
                    "SELECT instr('Hello World', 'World'); -- Returns 7",
                    "SELECT instr('abcdefg', 'x'); -- Returns 0 (not found)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "positionCaseInsensitive",
                "explanation": "positionCaseInsensitive\nA case insensitive invariant of position.",
                "examples": [
                    "SELECT positionCaseInsensitive('Hello, world!', 'hello');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `trip`\nColumns:\n(`id`, integer, primary key)\n(`duration`, integer)\n(`start_date`, text)\n(`start_station_name`, text)\n(`start_station_id`, integer)\n(`end_date`, text)\n(`end_station_name`, text)\n(`end_station_id`, integer)\n(`bike_id`, integer)\n(`subscription_type`, text)\n(`zip_code`, integer)\n",
            "Table: `weather`\nColumns:\n(`date`, text)\n(`max_temperature_f`, integer)\n(`mean_temperature_f`, integer)\n(`min_temperature_f`, integer)\n(`max_dew_point_f`, integer)\n(`mean_dew_point_f`, integer)\n(`min_dew_point_f`, integer)\n(`max_humidity`, integer)\n(`mean_humidity`, integer)\n(`min_humidity`, integer)\n(`max_sea_level_pressure_inches`, real)\n(`mean_sea_level_pressure_inches`, real)\n(`min_sea_level_pressure_inches`, real)\n(`max_visibility_miles`, integer)\n(`mean_visibility_miles`, integer)\n(`min_visibility_miles`, integer)\n(`max_wind_Speed_mph`, integer)\n(`mean_wind_speed_mph`, integer)\n(`max_gust_speed_mph`, integer)\n(`precipitation_inches`, text)\n(`cloud_cover`, integer)\n(`events`, text)\n(`wind_dir_degrees`, integer)\n(`zip_code`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `trip`\nColumns:\n(`id`, Int64, primary key)\n(`duration`, Int64)\n(`start_date`, String)\n(`start_station_name`, String)\n(`start_station_id`, Int64)\n(`end_date`, String)\n(`end_station_name`, String)\n(`end_station_id`, Int64)\n(`bike_id`, Int64)\n(`subscription_type`, String)\n(`zip_code`, Int64)\n",
            "Table: `weather`\nColumns:\n(`date`, String)\n(`max_temperature_f`, Int64)\n(`mean_temperature_f`, Int64)\n(`min_temperature_f`, Int64)\n(`max_dew_point_f`, Int64)\n(`mean_dew_point_f`, Int64)\n(`min_dew_point_f`, Int64)\n(`max_humidity`, Int64)\n(`mean_humidity`, Int64)\n(`min_humidity`, Int64)\n(`max_sea_level_pressure_inches`, Float64)\n(`mean_sea_level_pressure_inches`, Float64)\n(`min_sea_level_pressure_inches`, Float64)\n(`max_visibility_miles`, Int64)\n(`mean_visibility_miles`, Int64)\n(`min_visibility_miles`, Int64)\n(`max_wind_Speed_mph`, Int64)\n(`mean_wind_speed_mph`, Int64)\n(`max_gust_speed_mph`, Int64)\n(`precipitation_inches`, String)\n(`cloud_cover`, Int64)\n(`events`, String)\n(`wind_dir_degrees`, Int64)\n(`zip_code`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 628,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUBSTR(CAST(date AS TEXT), -4) FROM weather GROUP BY SUBSTR(CAST(date AS TEXT), -4) ORDER BY SUM(CASE WHEN events LIKE '%Rain%' OR events LIKE '%rain%' THEN 1 ELSE 0 END) DESC LIMIT 1",
        "target_query": "SELECT substring(`date`, -4) FROM `weather` GROUP BY substring(`date`, -4) ORDER BY SUM(CASE WHEN `events` LIKE '%Rain%' OR `events` LIKE '%rain%' THEN 1 ELSE 0 END) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 32,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 60,
                "end_index": 85,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 28,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            },
            {
                "start_index": 53,
                "end_index": 74,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `weather`\nColumns:\n(`date`, text)\n(`max_temperature_f`, integer)\n(`mean_temperature_f`, integer)\n(`min_temperature_f`, integer)\n(`max_dew_point_f`, integer)\n(`mean_dew_point_f`, integer)\n(`min_dew_point_f`, integer)\n(`max_humidity`, integer)\n(`mean_humidity`, integer)\n(`min_humidity`, integer)\n(`max_sea_level_pressure_inches`, real)\n(`mean_sea_level_pressure_inches`, real)\n(`min_sea_level_pressure_inches`, real)\n(`max_visibility_miles`, integer)\n(`mean_visibility_miles`, integer)\n(`min_visibility_miles`, integer)\n(`max_wind_Speed_mph`, integer)\n(`mean_wind_speed_mph`, integer)\n(`max_gust_speed_mph`, integer)\n(`precipitation_inches`, text)\n(`cloud_cover`, integer)\n(`events`, text)\n(`wind_dir_degrees`, integer)\n(`zip_code`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `weather`\nColumns:\n(`date`, String)\n(`max_temperature_f`, Int64)\n(`mean_temperature_f`, Int64)\n(`min_temperature_f`, Int64)\n(`max_dew_point_f`, Int64)\n(`mean_dew_point_f`, Int64)\n(`min_dew_point_f`, Int64)\n(`max_humidity`, Int64)\n(`mean_humidity`, Int64)\n(`min_humidity`, Int64)\n(`max_sea_level_pressure_inches`, Float64)\n(`mean_sea_level_pressure_inches`, Float64)\n(`min_sea_level_pressure_inches`, Float64)\n(`max_visibility_miles`, Int64)\n(`mean_visibility_miles`, Int64)\n(`min_visibility_miles`, Int64)\n(`max_wind_Speed_mph`, Int64)\n(`mean_wind_speed_mph`, Int64)\n(`max_gust_speed_mph`, Int64)\n(`precipitation_inches`, String)\n(`cloud_cover`, Int64)\n(`events`, String)\n(`wind_dir_degrees`, Int64)\n(`zip_code`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 629,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT name, installation_date, city FROM station WHERE (SUBSTR(CAST(installation_date AS TEXT), 1, INSTR(installation_date, '/') - 1) = '5' AND SUBSTR(CAST(installation_date AS TEXT), INSTR(installation_date, '/') + 1, -6) >= '8' AND SUBSTR(CAST(installation_date AS TEXT), -4) = '2013') OR (SUBSTR(CAST(installation_date AS TEXT), 1, INSTR(installation_date, '/') - 1) IN ( '6', '7', '8', '9', '10', '11', '12' ) AND SUBSTR(CAST(installation_date AS TEXT), -4) = '2013')",
        "target_query": "SELECT `name`, `installation_date`, `city` FROM `station` WHERE (substring(CAST(`installation_date` AS String), 1, positionCaseInsensitive(`installation_date`, '/') - 1) = '5' AND substring(CAST(`installation_date` AS String), positionCaseInsensitive(`installation_date`, '/') + 1) >= '8' AND substring(CAST(`installation_date` AS String), -4) = '2013') OR (substring(CAST(`installation_date` AS String), 1, positionCaseInsensitive(`installation_date`, '/') - 1) IN ('6', '7', '8', '9', '10', '11', '12') AND substring(CAST(`installation_date` AS String), -4) = '2013');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 57,
                "end_index": 95,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 145,
                "end_index": 183,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 235,
                "end_index": 273,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 293,
                "end_index": 331,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 419,
                "end_index": 457,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 65,
                "end_index": 110,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            },
            {
                "start_index": 180,
                "end_index": 225,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            },
            {
                "start_index": 293,
                "end_index": 338,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            },
            {
                "start_index": 358,
                "end_index": 403,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            },
            {
                "start_index": 509,
                "end_index": 554,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "instr(X,Y)",
                "explanation": "The instr(X,Y) function finds the first occurrence of string Y within \n  string X and returns the number of prior characters plus 1, or 0 if\n  Y is nowhere found within X.\n  Or, if X and Y are both BLOBs, then instr(X,Y) returns one\n  more than the number bytes prior to the first occurrence of Y, or 0 if\n  Y does not occur anywhere within X.\n  If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs\n  then both are interpreted as strings.\n  If either X or Y are NULL in instr(X,Y) then the result is NULL.\n",
                "examples": [
                    "SELECT instr('Hello World', 'World'); -- Returns 7",
                    "SELECT instr('abcdefg', 'x'); -- Returns 0 (not found)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "positionCaseInsensitive",
                "explanation": "positionCaseInsensitive\nA case insensitive invariant of position.",
                "examples": [
                    "SELECT positionCaseInsensitive('Hello, world!', 'hello');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `station`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`lat`, real)\n(`long`, real)\n(`dock_count`, integer)\n(`city`, text)\n(`installation_date`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `station`\nColumns:\n(`id`, Int64, primary key)\n(`name`, String)\n(`lat`, Float64)\n(`long`, Float64)\n(`dock_count`, Int64)\n(`city`, String)\n(`installation_date`, String)\n"
        ]
    },
    {
        "sql_id": 634,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(CASE WHEN city = 'San Francisco' AND SUBSTR(installation_date, -4) = '2014' THEN 1 ELSE 0 END) FROM station",
        "target_query": "SELECT SUM(CASE WHEN `city` = 'San Francisco' AND substring(`installation_date`, -4) = '2014' THEN 1 ELSE 0 END) FROM `station`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 48,
                "end_index": 77,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 50,
                "end_index": 84,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `station`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`lat`, real)\n(`long`, real)\n(`dock_count`, integer)\n(`city`, text)\n(`installation_date`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `station`\nColumns:\n(`id`, Int64, primary key)\n(`name`, String)\n(`lat`, Float64)\n(`long`, Float64)\n(`dock_count`, Int64)\n(`city`, String)\n(`installation_date`, String)\n"
        ]
    },
    {
        "sql_id": 636,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(start_station_id = end_station_id, 1, 0)) FROM trip",
        "target_query": "SELECT SUM(if(`start_station_id` = `end_station_id`, 1, 0)) FROM `trip`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 55,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 58,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `trip`\nColumns:\n(`id`, integer, primary key)\n(`duration`, integer)\n(`start_date`, text)\n(`start_station_name`, text)\n(`start_station_id`, integer)\n(`end_date`, text)\n(`end_station_name`, text)\n(`end_station_id`, integer)\n(`bike_id`, integer)\n(`subscription_type`, text)\n(`zip_code`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `trip`\nColumns:\n(`id`, Int64, primary key)\n(`duration`, Int64)\n(`start_date`, String)\n(`start_station_name`, String)\n(`start_station_id`, Int64)\n(`end_date`, String)\n(`end_station_name`, String)\n(`end_station_id`, Int64)\n(`bike_id`, Int64)\n(`subscription_type`, String)\n(`zip_code`, Int64)\n"
        ]
    },
    {
        "sql_id": 639,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(installation_date) FROM station WHERE city = 'San Jose' AND (SUBSTR(CAST(installation_date AS TEXT), 1, INSTR(installation_date, '/') - 1) IN ('8', '9', '10', '11', '12') AND SUBSTR(CAST(installation_date AS TEXT), -4) = '2013') OR SUBSTR(CAST(installation_date AS TEXT), -4) > '2013'",
        "target_query": "SELECT COUNT(`installation_date`) FROM `station` WHERE `city` = 'San Jose' AND (substring(CAST(`installation_date` AS String), 1, positionCaseInsensitive(`installation_date`, '/') - 1) IN ('8', '9', '10', '11', '12') AND substring(CAST(`installation_date` AS String), -4) = '2013') OR substring(CAST(`installation_date` AS String), -4) > '2013';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 74,
                "end_index": 112,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 188,
                "end_index": 226,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 245,
                "end_index": 283,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 80,
                "end_index": 125,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            },
            {
                "start_index": 221,
                "end_index": 266,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            },
            {
                "start_index": 285,
                "end_index": 330,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "instr(X,Y)",
                "explanation": "The instr(X,Y) function finds the first occurrence of string Y within \n  string X and returns the number of prior characters plus 1, or 0 if\n  Y is nowhere found within X.\n  Or, if X and Y are both BLOBs, then instr(X,Y) returns one\n  more than the number bytes prior to the first occurrence of Y, or 0 if\n  Y does not occur anywhere within X.\n  If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs\n  then both are interpreted as strings.\n  If either X or Y are NULL in instr(X,Y) then the result is NULL.\n",
                "examples": [
                    "SELECT instr('Hello World', 'World'); -- Returns 7",
                    "SELECT instr('abcdefg', 'x'); -- Returns 0 (not found)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "positionCaseInsensitive",
                "explanation": "positionCaseInsensitive\nA case insensitive invariant of position.",
                "examples": [
                    "SELECT positionCaseInsensitive('Hello, world!', 'hello');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `station`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`lat`, real)\n(`long`, real)\n(`dock_count`, integer)\n(`city`, text)\n(`installation_date`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `station`\nColumns:\n(`id`, Int64, primary key)\n(`name`, String)\n(`lat`, Float64)\n(`long`, Float64)\n(`dock_count`, Int64)\n(`city`, String)\n(`installation_date`, String)\n"
        ]
    },
    {
        "sql_id": 640,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(zip_code = 94107 AND date = '8/29/2013', mean_temperature_f, 0)) FROM weather",
        "target_query": "SELECT SUM(if(`zip_code` = '94107' AND `date` = '8/29/2013', `mean_temperature_f`, 0)) FROM `weather`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 78,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 85,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `weather`\nColumns:\n(`date`, text)\n(`max_temperature_f`, integer)\n(`mean_temperature_f`, integer)\n(`min_temperature_f`, integer)\n(`max_dew_point_f`, integer)\n(`mean_dew_point_f`, integer)\n(`min_dew_point_f`, integer)\n(`max_humidity`, integer)\n(`mean_humidity`, integer)\n(`min_humidity`, integer)\n(`max_sea_level_pressure_inches`, real)\n(`mean_sea_level_pressure_inches`, real)\n(`min_sea_level_pressure_inches`, real)\n(`max_visibility_miles`, integer)\n(`mean_visibility_miles`, integer)\n(`min_visibility_miles`, integer)\n(`max_wind_Speed_mph`, integer)\n(`mean_wind_speed_mph`, integer)\n(`max_gust_speed_mph`, integer)\n(`precipitation_inches`, text)\n(`cloud_cover`, integer)\n(`events`, text)\n(`wind_dir_degrees`, integer)\n(`zip_code`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `weather`\nColumns:\n(`date`, String)\n(`max_temperature_f`, Int64)\n(`mean_temperature_f`, Int64)\n(`min_temperature_f`, Int64)\n(`max_dew_point_f`, Int64)\n(`mean_dew_point_f`, Int64)\n(`min_dew_point_f`, Int64)\n(`max_humidity`, Int64)\n(`mean_humidity`, Int64)\n(`min_humidity`, Int64)\n(`max_sea_level_pressure_inches`, Float64)\n(`mean_sea_level_pressure_inches`, Float64)\n(`min_sea_level_pressure_inches`, Float64)\n(`max_visibility_miles`, Int64)\n(`mean_visibility_miles`, Int64)\n(`min_visibility_miles`, Int64)\n(`max_wind_Speed_mph`, Int64)\n(`mean_wind_speed_mph`, Int64)\n(`max_gust_speed_mph`, Int64)\n(`precipitation_inches`, String)\n(`cloud_cover`, Int64)\n(`events`, String)\n(`wind_dir_degrees`, Int64)\n(`zip_code`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 641,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(zip_code = 94107 AND date = '8/29/2013', max_temperature_f - min_temperature_f, 0)) FROM weather",
        "target_query": "SELECT SUM(if(`zip_code` = '94107' AND `date` = '8/29/2013', `max_temperature_f` - `min_temperature_f`, 0)) FROM `weather`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 97,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 106,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `weather`\nColumns:\n(`date`, text)\n(`max_temperature_f`, integer)\n(`mean_temperature_f`, integer)\n(`min_temperature_f`, integer)\n(`max_dew_point_f`, integer)\n(`mean_dew_point_f`, integer)\n(`min_dew_point_f`, integer)\n(`max_humidity`, integer)\n(`mean_humidity`, integer)\n(`min_humidity`, integer)\n(`max_sea_level_pressure_inches`, real)\n(`mean_sea_level_pressure_inches`, real)\n(`min_sea_level_pressure_inches`, real)\n(`max_visibility_miles`, integer)\n(`mean_visibility_miles`, integer)\n(`min_visibility_miles`, integer)\n(`max_wind_Speed_mph`, integer)\n(`mean_wind_speed_mph`, integer)\n(`max_gust_speed_mph`, integer)\n(`precipitation_inches`, text)\n(`cloud_cover`, integer)\n(`events`, text)\n(`wind_dir_degrees`, integer)\n(`zip_code`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `weather`\nColumns:\n(`date`, String)\n(`max_temperature_f`, Int64)\n(`mean_temperature_f`, Int64)\n(`min_temperature_f`, Int64)\n(`max_dew_point_f`, Int64)\n(`mean_dew_point_f`, Int64)\n(`min_dew_point_f`, Int64)\n(`max_humidity`, Int64)\n(`mean_humidity`, Int64)\n(`min_humidity`, Int64)\n(`max_sea_level_pressure_inches`, Float64)\n(`mean_sea_level_pressure_inches`, Float64)\n(`min_sea_level_pressure_inches`, Float64)\n(`max_visibility_miles`, Int64)\n(`mean_visibility_miles`, Int64)\n(`min_visibility_miles`, Int64)\n(`max_wind_Speed_mph`, Int64)\n(`mean_wind_speed_mph`, Int64)\n(`max_gust_speed_mph`, Int64)\n(`precipitation_inches`, String)\n(`cloud_cover`, Int64)\n(`events`, String)\n(`wind_dir_degrees`, Int64)\n(`zip_code`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 643,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(zip_code = 94041 AND events = 'Rain', 1, 0)) FROM weather",
        "target_query": "SELECT SUM(if(`zip_code` = '94041' AND `events` = 'Rain', 1, 0)) FROM `weather`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 58,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 63,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `weather`\nColumns:\n(`date`, text)\n(`max_temperature_f`, integer)\n(`mean_temperature_f`, integer)\n(`min_temperature_f`, integer)\n(`max_dew_point_f`, integer)\n(`mean_dew_point_f`, integer)\n(`min_dew_point_f`, integer)\n(`max_humidity`, integer)\n(`mean_humidity`, integer)\n(`min_humidity`, integer)\n(`max_sea_level_pressure_inches`, real)\n(`mean_sea_level_pressure_inches`, real)\n(`min_sea_level_pressure_inches`, real)\n(`max_visibility_miles`, integer)\n(`mean_visibility_miles`, integer)\n(`min_visibility_miles`, integer)\n(`max_wind_Speed_mph`, integer)\n(`mean_wind_speed_mph`, integer)\n(`max_gust_speed_mph`, integer)\n(`precipitation_inches`, text)\n(`cloud_cover`, integer)\n(`events`, text)\n(`wind_dir_degrees`, integer)\n(`zip_code`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `weather`\nColumns:\n(`date`, String)\n(`max_temperature_f`, Int64)\n(`mean_temperature_f`, Int64)\n(`min_temperature_f`, Int64)\n(`max_dew_point_f`, Int64)\n(`mean_dew_point_f`, Int64)\n(`min_dew_point_f`, Int64)\n(`max_humidity`, Int64)\n(`mean_humidity`, Int64)\n(`min_humidity`, Int64)\n(`max_sea_level_pressure_inches`, Float64)\n(`mean_sea_level_pressure_inches`, Float64)\n(`min_sea_level_pressure_inches`, Float64)\n(`max_visibility_miles`, Int64)\n(`mean_visibility_miles`, Int64)\n(`min_visibility_miles`, Int64)\n(`max_wind_Speed_mph`, Int64)\n(`mean_wind_speed_mph`, Int64)\n(`max_gust_speed_mph`, Int64)\n(`precipitation_inches`, String)\n(`cloud_cover`, Int64)\n(`events`, String)\n(`wind_dir_degrees`, Int64)\n(`zip_code`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 644,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(CASE WHEN city = 'Redwood City' AND SUBSTR(installation_date, -4) < '2014' THEN dock_count ELSE 0 END) NUM FROM station",
        "target_query": "SELECT SUM(CASE WHEN `city` = 'Redwood City' AND substring(`installation_date`, -4) < '2014' THEN `dock_count` ELSE 0 END) AS `NUM` FROM `station`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 47,
                "end_index": 76,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 49,
                "end_index": 83,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `station`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`lat`, real)\n(`long`, real)\n(`dock_count`, integer)\n(`city`, text)\n(`installation_date`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `station`\nColumns:\n(`id`, Int64, primary key)\n(`name`, String)\n(`lat`, Float64)\n(`long`, Float64)\n(`dock_count`, Int64)\n(`city`, String)\n(`installation_date`, String)\n"
        ]
    },
    {
        "sql_id": 645,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT (max_temperature_f - 32) / 1.8000 , (mean_temperature_f - 32) / 1.8000 , (min_temperature_f - 32) / 1.8000 FROM weather WHERE SUBSTR(CAST(date AS TEXT), 1, INSTR(date, '/') - 1) = '8' AND SUBSTR(CAST(date AS TEXT), -4) = '2013' AND zip_code = 94107",
        "target_query": "SELECT (`max_temperature_f` - 32) / 1.8000, (`mean_temperature_f` - 32) / 1.8000, (`min_temperature_f` - 32) / 1.8000 FROM `weather` WHERE substring(`date`, 1, positionCaseInsensitive(`date`, '/') - 1) = '8' AND substring(`date`, -4) = '2013' AND `zip_code` = '94107';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 133,
                "end_index": 158,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 195,
                "end_index": 220,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 139,
                "end_index": 196,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            },
            {
                "start_index": 212,
                "end_index": 233,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "instr(X,Y)",
                "explanation": "The instr(X,Y) function finds the first occurrence of string Y within \n  string X and returns the number of prior characters plus 1, or 0 if\n  Y is nowhere found within X.\n  Or, if X and Y are both BLOBs, then instr(X,Y) returns one\n  more than the number bytes prior to the first occurrence of Y, or 0 if\n  Y does not occur anywhere within X.\n  If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs\n  then both are interpreted as strings.\n  If either X or Y are NULL in instr(X,Y) then the result is NULL.\n",
                "examples": [
                    "SELECT instr('Hello World', 'World'); -- Returns 7",
                    "SELECT instr('abcdefg', 'x'); -- Returns 0 (not found)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "positionCaseInsensitive",
                "explanation": "positionCaseInsensitive\nA case insensitive invariant of position.",
                "examples": [
                    "SELECT positionCaseInsensitive('Hello, world!', 'hello');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `weather`\nColumns:\n(`date`, text)\n(`max_temperature_f`, integer)\n(`mean_temperature_f`, integer)\n(`min_temperature_f`, integer)\n(`max_dew_point_f`, integer)\n(`mean_dew_point_f`, integer)\n(`min_dew_point_f`, integer)\n(`max_humidity`, integer)\n(`mean_humidity`, integer)\n(`min_humidity`, integer)\n(`max_sea_level_pressure_inches`, real)\n(`mean_sea_level_pressure_inches`, real)\n(`min_sea_level_pressure_inches`, real)\n(`max_visibility_miles`, integer)\n(`mean_visibility_miles`, integer)\n(`min_visibility_miles`, integer)\n(`max_wind_Speed_mph`, integer)\n(`mean_wind_speed_mph`, integer)\n(`max_gust_speed_mph`, integer)\n(`precipitation_inches`, text)\n(`cloud_cover`, integer)\n(`events`, text)\n(`wind_dir_degrees`, integer)\n(`zip_code`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `weather`\nColumns:\n(`date`, String)\n(`max_temperature_f`, Int64)\n(`mean_temperature_f`, Int64)\n(`min_temperature_f`, Int64)\n(`max_dew_point_f`, Int64)\n(`mean_dew_point_f`, Int64)\n(`min_dew_point_f`, Int64)\n(`max_humidity`, Int64)\n(`mean_humidity`, Int64)\n(`min_humidity`, Int64)\n(`max_sea_level_pressure_inches`, Float64)\n(`mean_sea_level_pressure_inches`, Float64)\n(`min_sea_level_pressure_inches`, Float64)\n(`max_visibility_miles`, Int64)\n(`mean_visibility_miles`, Int64)\n(`min_visibility_miles`, Int64)\n(`max_wind_Speed_mph`, Int64)\n(`mean_wind_speed_mph`, Int64)\n(`max_gust_speed_mph`, Int64)\n(`precipitation_inches`, String)\n(`cloud_cover`, Int64)\n(`events`, String)\n(`wind_dir_degrees`, Int64)\n(`zip_code`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 646,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(subscription_type = 'Subscriber', 1, 0)) AS REAL) / SUM(IIF(subscription_type = 'Customer', 1, 0)) FROM trip WHERE start_station_name = '2nd at South Park' AND end_station_name = '2nd at South Park'",
        "target_query": "SELECT if(SUM(if(`subscription_type` = 'Customer', 1, 0)) = 0, NULL, SUM(if(`subscription_type` = 'Subscriber', 1, 0)) / SUM(if(`subscription_type` = 'Customer', 1, 0))) FROM `trip` WHERE `start_station_name` = '2nd at South Park' AND `end_station_name` = '2nd at South Park';",
        "semantic_equivalent_type": "Approximate equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 59,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 76,
                "end_index": 117,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 56,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 73,
                "end_index": 117,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 125,
                "end_index": 167,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `trip`\nColumns:\n(`id`, integer, primary key)\n(`duration`, integer)\n(`start_date`, text)\n(`start_station_name`, text)\n(`start_station_id`, integer)\n(`end_date`, text)\n(`end_station_name`, text)\n(`end_station_id`, integer)\n(`bike_id`, integer)\n(`subscription_type`, text)\n(`zip_code`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `trip`\nColumns:\n(`id`, Int64, primary key)\n(`duration`, Int64)\n(`start_date`, String)\n(`start_station_name`, String)\n(`start_station_id`, Int64)\n(`end_date`, String)\n(`end_station_name`, String)\n(`end_station_id`, Int64)\n(`bike_id`, Int64)\n(`subscription_type`, String)\n(`zip_code`, Int64)\n"
        ]
    },
    {
        "sql_id": 627,
        "database_name": "bike_share_1",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(CASE WHEN city = 'San Jose' AND SUBSTR(installation_date, -4) = '2014' THEN 1 ELSE 0 END) FROM station UNION SELECT name FROM station WHERE city = 'San Jose' AND SUBSTR(installation_date, -4) = '2014'",
        "target_query": "SELECT toString(SUM(CASE WHEN `city` = 'San Jose' AND substring(`installation_date`, -4) = '2014' THEN 1 ELSE 0 END)) FROM `station` UNION ALL SELECT `name` FROM `station` WHERE `city` = 'San Jose' AND substring(`installation_date`, -4) = '2014';",
        "semantic_equivalent_type": "Approximate equivalence",
        "source_dialect_locations": [
            {
                "start_index": 43,
                "end_index": 72,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 173,
                "end_index": 202,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 54,
                "end_index": 88,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            },
            {
                "start_index": 202,
                "end_index": 236,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `station`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`lat`, real)\n(`long`, real)\n(`dock_count`, integer)\n(`city`, text)\n(`installation_date`, text)\n",
            "Table: `station`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`lat`, real)\n(`long`, real)\n(`dock_count`, integer)\n(`city`, text)\n(`installation_date`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `station`\nColumns:\n(`id`, Int64, primary key)\n(`name`, String)\n(`lat`, Float64)\n(`long`, Float64)\n(`dock_count`, Int64)\n(`city`, String)\n(`installation_date`, String)\n",
            "Table: `station`\nColumns:\n(`id`, Int64, primary key)\n(`name`, String)\n(`lat`, Float64)\n(`long`, Float64)\n(`dock_count`, Int64)\n(`city`, String)\n(`installation_date`, String)\n"
        ]
    },
    {
        "sql_id": 394,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT title FROM book WHERE STRFTIME('%Y', publication_date) = '1900' ORDER BY publication_date LIMIT 1",
        "target_query": "SELECT `title` FROM `book` WHERE formatDateTime(`publication_date`, '%Y') = '1900' ORDER BY `publication_date` LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 29,
                "end_index": 61,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 33,
                "end_index": 73,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, integer, primary key)\n(`title`, text)\n(`isbn13`, text)\n(`language_id`, integer)\n(`num_pages`, integer)\n(`publication_date`, date)\n(`publisher_id`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, Int64, primary key)\n(`title`, String)\n(`isbn13`, String)\n(`language_id`, Int64)\n(`num_pages`, Int64)\n(`publication_date`, Date32)\n(`publisher_id`, Int64)\n"
        ]
    },
    {
        "sql_id": 395,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(*) FROM country AS T1 INNER JOIN address AS T2 ON T1.country_id = T2.country_id INNER JOIN cust_order AS T3 ON T3.dest_address_id = T2.address_id WHERE T1.country_name = 'Iran' AND STRFTIME('%Y', T3.order_date) = '2022'",
        "target_query": "SELECT COUNT(*) FROM `country` AS T1 INNER JOIN `address` AS T2 ON T1.`country_id` = T2.`country_id` INNER JOIN `cust_order` AS T3 ON T3.`dest_address_id` = T2.`address_id` WHERE T1.`country_name` = 'Iran' AND formatDateTime(T3.`order_date`, '%Y') = '2022';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 194,
                "end_index": 223,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 210,
                "end_index": 247,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `country`\nColumns:\n(`country_id`, integer, primary key)\n(`country_name`, text)\n",
            "Table: `address`\nColumns:\n(`address_id`, integer, primary key)\n(`street_number`, text)\n(`street_name`, text)\n(`city`, text)\n(`country_id`, integer)\n",
            "Table: `cust_order`\nColumns:\n(`order_id`, integer, primary key)\n(`order_date`, datetime)\n(`customer_id`, integer)\n(`shipping_method_id`, integer)\n(`dest_address_id`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `country`\nColumns:\n(`country_id`, Int64, primary key)\n(`country_name`, String)\n",
            "Table: `address`\nColumns:\n(`address_id`, Int64, primary key)\n(`street_number`, String)\n(`street_name`, String)\n(`city`, String)\n(`country_id`, Int64)\n",
            "Table: `cust_order`\nColumns:\n(`order_id`, Int64, primary key)\n(`order_date`, DateTime)\n(`customer_id`, Int64)\n(`shipping_method_id`, Int64)\n(`dest_address_id`, Int64)\n"
        ]
    },
    {
        "sql_id": 396,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(*) FROM order_status AS T1 INNER JOIN order_history AS T2 ON T1.status_id = T2.status_id WHERE T1.status_value = 'Delivered' AND STRFTIME('%Y', T2.status_date) = '2021'",
        "target_query": "SELECT COUNT(*) FROM `order_status` AS T1 INNER JOIN `order_history` AS T2 ON T1.`status_id` = T2.`status_id` WHERE T1.`status_value` = 'Delivered' AND formatDateTime(T2.`status_date`, '%Y') = '2021';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 142,
                "end_index": 172,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 152,
                "end_index": 190,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `order_status`\nColumns:\n(`status_id`, integer, primary key)\n(`status_value`, text)\n",
            "Table: `order_history`\nColumns:\n(`history_id`, integer, primary key)\n(`order_id`, integer)\n(`status_id`, integer)\n(`status_date`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `order_status`\nColumns:\n(`status_id`, Int64, primary key)\n(`status_value`, String)\n",
            "Table: `order_history`\nColumns:\n(`history_id`, Int64, primary key)\n(`order_id`, Int64)\n(`status_id`, Int64)\n(`status_date`, DateTime)\n"
        ]
    },
    {
        "sql_id": 397,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(T3.cost) FROM customer AS T1 INNER JOIN cust_order AS T2 ON T1.customer_id = T2.customer_id INNER JOIN shipping_method AS T3 ON T3.method_id = T2.shipping_method_id WHERE T1.first_name = 'Page' AND T1.last_name = 'Holsey' AND STRFTIME('%Y', T2.order_date) = '2022'",
        "target_query": "SELECT SUM(`T3`.`cost`) \nFROM `customer` AS `T1` \nINNER JOIN `cust_order` AS `T2` ON `T1`.`customer_id` = `T2`.`customer_id` \nINNER JOIN `shipping_method` AS `T3` ON `T3`.`method_id` = `T2`.`shipping_method_id` \nWHERE `T1`.`first_name` = 'Page' \nAND `T1`.`last_name` = 'Holsey' \nAND formatDateTime(`T2`.`order_date`, '%Y') = '2022';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 237,
                "end_index": 266,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 283,
                "end_index": 322,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n",
            "Table: `cust_order`\nColumns:\n(`order_id`, integer, primary key)\n(`order_date`, datetime)\n(`customer_id`, integer)\n(`shipping_method_id`, integer)\n(`dest_address_id`, integer)\n",
            "Table: `shipping_method`\nColumns:\n(`method_id`, integer, primary key)\n(`method_name`, text)\n(`cost`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, Int64, primary key)\n(`first_name`, String)\n(`last_name`, String)\n(`email`, String)\n",
            "Table: `cust_order`\nColumns:\n(`order_id`, Int64, primary key)\n(`order_date`, DateTime)\n(`customer_id`, Int64)\n(`shipping_method_id`, Int64)\n(`dest_address_id`, Int64)\n",
            "Table: `shipping_method`\nColumns:\n(`method_id`, Int64, primary key)\n(`method_name`, String)\n(`cost`, Float64)\n"
        ]
    },
    {
        "sql_id": 398,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(CASE WHEN STRFTIME('%Y', T1.publication_date) = '1992' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM book AS T1 INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE T3.author_name = 'Abraham Lincoln'",
        "target_query": "SELECT CAST(SUM(CASE WHEN formatDateTime(`T1`.`publication_date`, '%Y') = '1992' THEN 1 ELSE 0 END) AS Float64) * 100 / COUNT(*) \nFROM `book` AS `T1` \nINNER JOIN `book_author` AS `T2` ON `T1`.`book_id` = `T2`.`book_id` \nINNER JOIN `author` AS `T3` ON `T3`.`author_id` = `T2`.`author_id` \nWHERE `T3`.`author_name` = 'Abraham Lincoln';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 26,
                "end_index": 61,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 26,
                "end_index": 71,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, integer, primary key)\n(`title`, text)\n(`isbn13`, text)\n(`language_id`, integer)\n(`num_pages`, integer)\n(`publication_date`, date)\n(`publisher_id`, integer)\n",
            "Table: `book_author`\nColumns:\n(`book_id`, integer, primary key)\n(`author_id`, integer, primary key)\n",
            "Table: `author`\nColumns:\n(`author_id`, integer, primary key)\n(`author_name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, Int64, primary key)\n(`title`, String)\n(`isbn13`, String)\n(`language_id`, Int64)\n(`num_pages`, Int64)\n(`publication_date`, Date32)\n(`publisher_id`, Int64)\n",
            "Table: `book_author`\nColumns:\n(`book_id`, Int64, primary key)\n(`author_id`, Int64, primary key)\n",
            "Table: `author`\nColumns:\n(`author_id`, Int64, primary key)\n(`author_name`, String)\n"
        ]
    },
    {
        "sql_id": 399,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.title, T2.publisher_name FROM book AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE STRFTIME('%Y', T1.publication_date) = '2004' AND T1.num_pages * 100 > ( SELECT AVG(num_pages) FROM book ) * 70",
        "target_query": "SELECT T1.`title`, T2.`publisher_name` FROM `book` AS T1 INNER JOIN `publisher` AS T2 ON T1.`publisher_id` = T2.`publisher_id` WHERE formatDateTime(T1.`publication_date`, '%Y') = '2004' AND T1.`num_pages` * 100 > ( SELECT AVG(`num_pages`) FROM `book` ) * 70;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 121,
                "end_index": 156,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 133,
                "end_index": 176,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, integer, primary key)\n(`title`, text)\n(`isbn13`, text)\n(`language_id`, integer)\n(`num_pages`, integer)\n(`publication_date`, date)\n(`publisher_id`, integer)\n",
            "Table: `publisher`\nColumns:\n(`publisher_id`, integer, primary key)\n(`publisher_name`, text)\n",
            "Table: `book`\nColumns:\n(`book_id`, integer, primary key)\n(`title`, text)\n(`isbn13`, text)\n(`language_id`, integer)\n(`num_pages`, integer)\n(`publication_date`, date)\n(`publisher_id`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, Int64, primary key)\n(`title`, String)\n(`isbn13`, String)\n(`language_id`, Int64)\n(`num_pages`, Int64)\n(`publication_date`, Date32)\n(`publisher_id`, Int64)\n",
            "Table: `publisher`\nColumns:\n(`publisher_id`, Int64, primary key)\n(`publisher_name`, String)\n",
            "Table: `book`\nColumns:\n(`book_id`, Int64, primary key)\n(`title`, String)\n(`isbn13`, String)\n(`language_id`, Int64)\n(`num_pages`, Int64)\n(`publication_date`, Date32)\n(`publisher_id`, Int64)\n"
        ]
    },
    {
        "sql_id": 400,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.title FROM book AS T1 INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE T3.author_name = 'Orson Scott Card' AND STRFTIME('%Y', T1.publication_date) = '2001'",
        "target_query": "SELECT `T1`.`title` FROM `book` AS `T1` INNER JOIN `book_author` AS `T2` ON `T1`.`book_id` = `T2`.`book_id` INNER JOIN `author` AS `T3` ON `T3`.`author_id` = `T2`.`author_id` WHERE `T3`.`author_name` = 'Orson Scott Card' AND formatDateTime(`T1`.`publication_date`, '%Y') = '2001';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 189,
                "end_index": 224,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 225,
                "end_index": 270,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, integer, primary key)\n(`title`, text)\n(`isbn13`, text)\n(`language_id`, integer)\n(`num_pages`, integer)\n(`publication_date`, date)\n(`publisher_id`, integer)\n",
            "Table: `book_author`\nColumns:\n(`book_id`, integer, primary key)\n(`author_id`, integer, primary key)\n",
            "Table: `author`\nColumns:\n(`author_id`, integer, primary key)\n(`author_name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, Int64, primary key)\n(`title`, String)\n(`isbn13`, String)\n(`language_id`, Int64)\n(`num_pages`, Int64)\n(`publication_date`, Date32)\n(`publisher_id`, Int64)\n",
            "Table: `book_author`\nColumns:\n(`book_id`, Int64, primary key)\n(`author_id`, Int64, primary key)\n",
            "Table: `author`\nColumns:\n(`author_id`, Int64, primary key)\n(`author_name`, String)\n"
        ]
    },
    {
        "sql_id": 401,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(*) FROM cust_order AS T1 INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id WHERE T2.first_name = 'Daisey' AND T2.last_name = 'Lamball' AND STRFTIME('%Y', T1.order_date) = '2021'",
        "target_query": "SELECT COUNT(*) FROM `cust_order` AS T1 INNER JOIN `customer` AS T2 ON T1.`customer_id` = T2.`customer_id` WHERE T2.`first_name` = 'Daisey' AND T2.`last_name` = 'Lamball' AND formatDateTime(T1.`order_date`, '%Y') = '2021';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 163,
                "end_index": 192,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 175,
                "end_index": 212,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `cust_order`\nColumns:\n(`order_id`, integer, primary key)\n(`order_date`, datetime)\n(`customer_id`, integer)\n(`shipping_method_id`, integer)\n(`dest_address_id`, integer)\n",
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `cust_order`\nColumns:\n(`order_id`, Int64, primary key)\n(`order_date`, DateTime)\n(`customer_id`, Int64)\n(`shipping_method_id`, Int64)\n(`dest_address_id`, Int64)\n",
            "Table: `customer`\nColumns:\n(`customer_id`, Int64, primary key)\n(`first_name`, String)\n(`last_name`, String)\n(`email`, String)\n"
        ]
    },
    {
        "sql_id": 402,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(*) FROM order_status AS T1 INNER JOIN order_history AS T2 ON T1.status_id = T2.status_id WHERE T1.status_value = 'Delivered' AND STRFTIME('%Y', T2.status_date) = '2019'",
        "target_query": "SELECT COUNT(*) FROM `order_status` AS T1 INNER JOIN `order_history` AS T2 ON T1.`status_id` = T2.`status_id` WHERE T1.`status_value` = 'Delivered' AND formatDateTime(T2.`status_date`, '%Y') = '2019';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 142,
                "end_index": 172,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 152,
                "end_index": 190,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `order_status`\nColumns:\n(`status_id`, integer, primary key)\n(`status_value`, text)\n",
            "Table: `order_history`\nColumns:\n(`history_id`, integer, primary key)\n(`order_id`, integer)\n(`status_id`, integer)\n(`status_date`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `order_status`\nColumns:\n(`status_id`, Int64, primary key)\n(`status_value`, String)\n",
            "Table: `order_history`\nColumns:\n(`history_id`, Int64, primary key)\n(`order_id`, Int64)\n(`status_id`, Int64)\n(`status_date`, DateTime)\n"
        ]
    },
    {
        "sql_id": 403,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(CASE WHEN T2.method_name = 'International' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM cust_order AS T1 INNER JOIN shipping_method AS T2 ON T1.shipping_method_id = T2.method_id WHERE STRFTIME('%Y', T1.order_date) = '2020'",
        "target_query": "SELECT SUM(CASE WHEN `T2`.`method_name` = 'International' THEN 1 ELSE 0 END) * 100 / COUNT(*) FROM `cust_order` AS `T1` INNER JOIN `shipping_method` AS `T2` ON `T1`.`shipping_method_id` = `T2`.`method_id` WHERE formatDateTime(`T1`.`order_date`, '%Y') = '2020';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 205,
                "end_index": 234,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 211,
                "end_index": 250,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `cust_order`\nColumns:\n(`order_id`, integer, primary key)\n(`order_date`, datetime)\n(`customer_id`, integer)\n(`shipping_method_id`, integer)\n(`dest_address_id`, integer)\n",
            "Table: `shipping_method`\nColumns:\n(`method_id`, integer, primary key)\n(`method_name`, text)\n(`cost`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `cust_order`\nColumns:\n(`order_id`, Int64, primary key)\n(`order_date`, DateTime)\n(`customer_id`, Int64)\n(`shipping_method_id`, Int64)\n(`dest_address_id`, Int64)\n",
            "Table: `shipping_method`\nColumns:\n(`method_id`, Int64, primary key)\n(`method_name`, String)\n(`cost`, Float64)\n"
        ]
    },
    {
        "sql_id": 404,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT strftime('%Y', order_date) FROM cust_order GROUP BY strftime('%Y', order_date) ORDER BY COUNT(strftime('%Y', order_date)) DESC LIMIT 1",
        "target_query": "SELECT formatDateTime(`order_date`, '%Y') FROM `cust_order` GROUP BY formatDateTime(`order_date`, '%Y') ORDER BY COUNT(formatDateTime(`order_date`, '%Y')) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 33,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 59,
                "end_index": 85,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 101,
                "end_index": 127,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 41,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            },
            {
                "start_index": 69,
                "end_index": 103,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            },
            {
                "start_index": 119,
                "end_index": 153,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `cust_order`\nColumns:\n(`order_id`, integer, primary key)\n(`order_date`, datetime)\n(`customer_id`, integer)\n(`shipping_method_id`, integer)\n(`dest_address_id`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `cust_order`\nColumns:\n(`order_id`, Int64, primary key)\n(`order_date`, DateTime)\n(`customer_id`, Int64)\n(`shipping_method_id`, Int64)\n(`dest_address_id`, Int64)\n"
        ]
    },
    {
        "sql_id": 405,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT title FROM book WHERE STRFTIME('%Y', publication_date) = '1995'",
        "target_query": "SELECT `title` FROM `book` WHERE formatDateTime(`publication_date`, '%Y') = '1995';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 29,
                "end_index": 61,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 33,
                "end_index": 73,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, integer, primary key)\n(`title`, text)\n(`isbn13`, text)\n(`language_id`, integer)\n(`num_pages`, integer)\n(`publication_date`, date)\n(`publisher_id`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, Int64, primary key)\n(`title`, String)\n(`isbn13`, String)\n(`language_id`, Int64)\n(`num_pages`, Int64)\n(`publication_date`, Date32)\n(`publisher_id`, Int64)\n"
        ]
    },
    {
        "sql_id": 406,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUBSTR(email, INSTR(email, '@') + 1, LENGTH(email) - INSTR(email, '@')) AS ym FROM customer GROUP BY SUBSTR(email, INSTR(email, '@') + 1, LENGTH(email) - INSTR(email, '@')) ORDER BY COUNT(*) DESC LIMIT 1",
        "target_query": "SELECT substring(`email`, positionCaseInsensitive(`email`, '@') + 1, length(`email`) - positionCaseInsensitive(`email`, '@')) AS `ym` FROM `customer` GROUP BY substring(`email`, positionCaseInsensitive(`email`, '@') + 1, length(`email`) - positionCaseInsensitive(`email`, '@')) ORDER BY COUNT(*) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 38,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 108,
                "end_index": 139,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 63,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            },
            {
                "start_index": 159,
                "end_index": 215,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            },
            {
                "feature": "instr(X,Y)",
                "explanation": "The instr(X,Y) function finds the first occurrence of string Y within \n  string X and returns the number of prior characters plus 1, or 0 if\n  Y is nowhere found within X.\n  Or, if X and Y are both BLOBs, then instr(X,Y) returns one\n  more than the number bytes prior to the first occurrence of Y, or 0 if\n  Y does not occur anywhere within X.\n  If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs\n  then both are interpreted as strings.\n  If either X or Y are NULL in instr(X,Y) then the result is NULL.\n",
                "examples": [
                    "SELECT instr('Hello World', 'World'); -- Returns 7",
                    "SELECT instr('abcdefg', 'x'); -- Returns 0 (not found)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(str)",
                "explanation": "The length(str) function returns the number of bytes in the given string str. Unlike SQLite, which counts Unicode code points for strings, ClickHouse measures the length in bytes. For multibyte characters (UTF-8 encoded), the byte count may be larger than the character count. If str is NULL, the function returns NULL.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(unhex('68656C6C6F')); -- Returns 5 (Hexadecimal BLOB)"
                ]
            },
            {
                "feature": "positionCaseInsensitive",
                "explanation": "positionCaseInsensitive\nA case insensitive invariant of position.",
                "examples": [
                    "SELECT positionCaseInsensitive('Hello, world!', 'hello');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, Int64, primary key)\n(`first_name`, String)\n(`last_name`, String)\n(`email`, String)\n"
        ]
    },
    {
        "sql_id": 407,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(*) FROM order_status AS T1 INNER JOIN order_history AS T2 ON T1.status_id = T2.status_id WHERE T1.status_value = 'Returned' AND STRFTIME('%Y', T2.status_date) = '2020'",
        "target_query": "SELECT COUNT(*) FROM `order_status` AS T1 INNER JOIN `order_history` AS T2 ON T1.`status_id` = T2.`status_id` WHERE T1.`status_value` = 'Returned' AND formatDateTime(T2.`status_date`, '%Y') = '2020';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 141,
                "end_index": 171,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 151,
                "end_index": 189,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `order_status`\nColumns:\n(`status_id`, integer, primary key)\n(`status_value`, text)\n",
            "Table: `order_history`\nColumns:\n(`history_id`, integer, primary key)\n(`order_id`, integer)\n(`status_id`, integer)\n(`status_date`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `order_status`\nColumns:\n(`status_id`, Int64, primary key)\n(`status_value`, String)\n",
            "Table: `order_history`\nColumns:\n(`history_id`, Int64, primary key)\n(`order_id`, Int64)\n(`status_id`, Int64)\n(`status_date`, DateTime)\n"
        ]
    },
    {
        "sql_id": 408,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT strftime('%J', T2.status_date) - strftime('%J', T1.order_date) FROM cust_order AS T1 INNER JOIN order_history AS T2 ON T1.order_id = T2.order_id WHERE T1.order_id = 2398",
        "target_query": "SELECT dateDiff('day', `T1`.`order_date`, `T2`.`status_date`) FROM `cust_order` AS `T1` INNER JOIN `order_history` AS `T2` ON `T1`.`order_id` = `T2`.`order_id` WHERE `T1`.`order_id` = 2398;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 37,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 40,
                "end_index": 69,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `cust_order`\nColumns:\n(`order_id`, integer, primary key)\n(`order_date`, datetime)\n(`customer_id`, integer)\n(`shipping_method_id`, integer)\n(`dest_address_id`, integer)\n",
            "Table: `order_history`\nColumns:\n(`history_id`, integer, primary key)\n(`order_id`, integer)\n(`status_id`, integer)\n(`status_date`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `cust_order`\nColumns:\n(`order_id`, Int64, primary key)\n(`order_date`, DateTime)\n(`customer_id`, Int64)\n(`shipping_method_id`, Int64)\n(`dest_address_id`, Int64)\n",
            "Table: `order_history`\nColumns:\n(`history_id`, Int64, primary key)\n(`order_id`, Int64)\n(`status_id`, Int64)\n(`status_date`, DateTime)\n"
        ]
    },
    {
        "sql_id": 409,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(*) FROM customer AS T1 INNER JOIN cust_order AS T2 ON T1.customer_id = T2.customer_id INNER JOIN shipping_method AS T3 ON T3.method_id = T2.shipping_method_id WHERE T1.first_name = 'Marcelia' AND T1.last_name = 'Goering' AND STRFTIME('%Y', T2.order_date) = '2021' AND T3.method_name = 'Priority'",
        "target_query": "SELECT COUNT(*) FROM `customer` AS T1 INNER JOIN `cust_order` AS T2 ON T1.`customer_id` = T2.`customer_id` INNER JOIN `shipping_method` AS T3 ON T3.`method_id` = T2.`shipping_method_id` WHERE T1.`first_name` = 'Marcelia' AND T1.`last_name` = 'Goering' AND formatDateTime(T2.`order_date`, '%Y') = '2021' AND T3.`method_name` = 'Priority';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 238,
                "end_index": 267,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 256,
                "end_index": 293,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n",
            "Table: `cust_order`\nColumns:\n(`order_id`, integer, primary key)\n(`order_date`, datetime)\n(`customer_id`, integer)\n(`shipping_method_id`, integer)\n(`dest_address_id`, integer)\n",
            "Table: `shipping_method`\nColumns:\n(`method_id`, integer, primary key)\n(`method_name`, text)\n(`cost`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, Int64, primary key)\n(`first_name`, String)\n(`last_name`, String)\n(`email`, String)\n",
            "Table: `cust_order`\nColumns:\n(`order_id`, Int64, primary key)\n(`order_date`, DateTime)\n(`customer_id`, Int64)\n(`shipping_method_id`, Int64)\n(`dest_address_id`, Int64)\n",
            "Table: `shipping_method`\nColumns:\n(`method_id`, Int64, primary key)\n(`method_name`, String)\n(`cost`, Float64)\n"
        ]
    },
    {
        "sql_id": 410,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(*) FROM order_status AS T1 INNER JOIN order_history AS T2 ON T1.status_id = T2.status_id WHERE T1.status_value = 'Cancelled' AND STRFTIME('%Y', T2.status_date) = '2022'",
        "target_query": "SELECT COUNT(*) FROM `order_status` AS T1 INNER JOIN `order_history` AS T2 ON T1.`status_id` = T2.`status_id` WHERE T1.`status_value` = 'Cancelled' AND formatDateTime(T2.`status_date`, '%Y') = '2022';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 142,
                "end_index": 172,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 152,
                "end_index": 190,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `order_status`\nColumns:\n(`status_id`, integer, primary key)\n(`status_value`, text)\n",
            "Table: `order_history`\nColumns:\n(`history_id`, integer, primary key)\n(`order_id`, integer)\n(`status_id`, integer)\n(`status_date`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `order_status`\nColumns:\n(`status_id`, Int64, primary key)\n(`status_value`, String)\n",
            "Table: `order_history`\nColumns:\n(`history_id`, Int64, primary key)\n(`order_id`, Int64)\n(`status_id`, Int64)\n(`status_date`, DateTime)\n"
        ]
    },
    {
        "sql_id": 411,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(*) FROM book WHERE STRFTIME('%Y', publication_date) = '2017'",
        "target_query": "SELECT COUNT(*) FROM `book` WHERE formatDateTime(`publication_date`, '%Y') = '2017';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 32,
                "end_index": 64,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 34,
                "end_index": 74,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, integer, primary key)\n(`title`, text)\n(`isbn13`, text)\n(`language_id`, integer)\n(`num_pages`, integer)\n(`publication_date`, date)\n(`publisher_id`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, Int64, primary key)\n(`title`, String)\n(`isbn13`, String)\n(`language_id`, Int64)\n(`num_pages`, Int64)\n(`publication_date`, Date32)\n(`publisher_id`, Int64)\n"
        ]
    },
    {
        "sql_id": 413,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.title FROM book AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE T2.publisher_name = 'Free Press' AND STRFTIME('%Y', T1.publication_date) BETWEEN '1990' AND '2000' ORDER BY T1.num_pages DESC LIMIT 1",
        "target_query": "SELECT `T1`.`title` FROM `book` AS `T1` INNER JOIN `publisher` AS `T2` ON `T1`.`publisher_id` = `T2`.`publisher_id` WHERE `T2`.`publisher_name` = 'Free Press' AND formatDateTime(`T1`.`publication_date`, '%Y') BETWEEN '1990' AND '2000' ORDER BY `T1`.`num_pages` DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 139,
                "end_index": 174,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 163,
                "end_index": 208,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, integer, primary key)\n(`title`, text)\n(`isbn13`, text)\n(`language_id`, integer)\n(`num_pages`, integer)\n(`publication_date`, date)\n(`publisher_id`, integer)\n",
            "Table: `publisher`\nColumns:\n(`publisher_id`, integer, primary key)\n(`publisher_name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, Int64, primary key)\n(`title`, String)\n(`isbn13`, String)\n(`language_id`, Int64)\n(`num_pages`, Int64)\n(`publication_date`, Date32)\n(`publisher_id`, Int64)\n",
            "Table: `publisher`\nColumns:\n(`publisher_id`, Int64, primary key)\n(`publisher_name`, String)\n"
        ]
    },
    {
        "sql_id": 414,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.price FROM book AS T1 INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id WHERE T1.title = 'The Servant Leader' AND STRFTIME('%Y', T1.publication_date) = '2003'",
        "target_query": "SELECT T2.`price` FROM `book` AS T1 INNER JOIN `order_line` AS T2 ON T1.`book_id` = T2.`book_id` WHERE T1.`title` = 'The Servant Leader' AND formatDateTime(T1.`publication_date`, '%Y') = '2003';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 129,
                "end_index": 164,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 141,
                "end_index": 184,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, integer, primary key)\n(`title`, text)\n(`isbn13`, text)\n(`language_id`, integer)\n(`num_pages`, integer)\n(`publication_date`, date)\n(`publisher_id`, integer)\n",
            "Table: `order_line`\nColumns:\n(`line_id`, integer, primary key)\n(`order_id`, integer)\n(`book_id`, integer)\n(`price`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, Int64, primary key)\n(`title`, String)\n(`isbn13`, String)\n(`language_id`, Int64)\n(`num_pages`, Int64)\n(`publication_date`, Date32)\n(`publisher_id`, Int64)\n",
            "Table: `order_line`\nColumns:\n(`line_id`, Int64, primary key)\n(`order_id`, Int64)\n(`book_id`, Int64)\n(`price`, Float64)\n"
        ]
    },
    {
        "sql_id": 415,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(*) FROM order_status AS T1 INNER JOIN order_history AS T2 ON T1.status_id = T2.status_id WHERE T1.status_value = 'Returned' AND STRFTIME('%Y', T2.status_date) = '2022'",
        "target_query": "SELECT COUNT(*) FROM `order_status` AS T1 INNER JOIN `order_history` AS T2 ON T1.`status_id` = T2.`status_id` WHERE T1.`status_value` = 'Returned' AND formatDateTime(T2.`status_date`, '%Y') = '2022';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 141,
                "end_index": 171,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 151,
                "end_index": 189,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `order_status`\nColumns:\n(`status_id`, integer, primary key)\n(`status_value`, text)\n",
            "Table: `order_history`\nColumns:\n(`history_id`, integer, primary key)\n(`order_id`, integer)\n(`status_id`, integer)\n(`status_date`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `order_status`\nColumns:\n(`status_id`, Int64, primary key)\n(`status_value`, String)\n",
            "Table: `order_history`\nColumns:\n(`history_id`, Int64, primary key)\n(`order_id`, Int64)\n(`status_id`, Int64)\n(`status_date`, DateTime)\n"
        ]
    },
    {
        "sql_id": 416,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(*) FROM book AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE T2.publisher_name = 'Birlinn' AND STRFTIME('%Y', T1.publication_date) = '2008' AND T1.num_pages BETWEEN 600 AND 700",
        "target_query": "SELECT COUNT(*) FROM `book` AS T1 INNER JOIN `publisher` AS T2 ON T1.`publisher_id` = T2.`publisher_id` WHERE T2.`publisher_name` = 'Birlinn' AND formatDateTime(T1.`publication_date`, '%Y') = '2008' AND T1.`num_pages` BETWEEN 600 AND 700;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 136,
                "end_index": 171,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 146,
                "end_index": 189,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, integer, primary key)\n(`title`, text)\n(`isbn13`, text)\n(`language_id`, integer)\n(`num_pages`, integer)\n(`publication_date`, date)\n(`publisher_id`, integer)\n",
            "Table: `publisher`\nColumns:\n(`publisher_id`, integer, primary key)\n(`publisher_name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, Int64, primary key)\n(`title`, String)\n(`isbn13`, String)\n(`language_id`, Int64)\n(`num_pages`, Int64)\n(`publication_date`, Date32)\n(`publisher_id`, Int64)\n",
            "Table: `publisher`\nColumns:\n(`publisher_id`, Int64, primary key)\n(`publisher_name`, String)\n"
        ]
    },
    {
        "sql_id": 417,
        "database_name": "books",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(*) FROM book AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE T2.publisher_name = 'Brava' AND STRFTIME('%Y', T1.publication_date) = '2006'",
        "target_query": "SELECT COUNT(*) FROM `book` AS T1 INNER JOIN `publisher` AS T2 ON T1.`publisher_id` = T2.`publisher_id` WHERE T2.`publisher_name` = 'Brava' AND formatDateTime(T1.`publication_date`, '%Y') = '2006';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 134,
                "end_index": 169,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 144,
                "end_index": 187,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, integer, primary key)\n(`title`, text)\n(`isbn13`, text)\n(`language_id`, integer)\n(`num_pages`, integer)\n(`publication_date`, date)\n(`publisher_id`, integer)\n",
            "Table: `publisher`\nColumns:\n(`publisher_id`, integer, primary key)\n(`publisher_name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `book`\nColumns:\n(`book_id`, Int64, primary key)\n(`title`, String)\n(`isbn13`, String)\n(`language_id`, Int64)\n(`num_pages`, Int64)\n(`publication_date`, Date32)\n(`publisher_id`, Int64)\n",
            "Table: `publisher`\nColumns:\n(`publisher_id`, Int64, primary key)\n(`publisher_name`, String)\n"
        ]
    },
    {
        "sql_id": 11,
        "database_name": "book_publishing_company",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT fname, lname FROM employee WHERE STRFTIME('%Y', hire_date) < '1990'",
        "target_query": "SELECT `fname`, `lname` FROM `employee` WHERE formatDateTime(`hire_date`, '%Y') < '1990';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 40,
                "end_index": 65,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 46,
                "end_index": 79,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`emp_id`, text, primary key)\n(`fname`, text)\n(`minit`, text)\n(`lname`, text)\n(`job_id`, integer)\n(`job_lvl`, integer)\n(`pub_id`, text)\n(`hire_date`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `employee`\nColumns:\n(`emp_id`, String, primary key)\n(`fname`, String)\n(`minit`, String)\n(`lname`, String)\n(`job_id`, Int64)\n(`job_lvl`, Int64)\n(`pub_id`, String)\n(`hire_date`, DateTime)\n"
        ]
    },
    {
        "sql_id": 12,
        "database_name": "book_publishing_company",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT STRFTIME('%Y', hire_date) FROM employee GROUP BY STRFTIME('%Y', hire_date) ORDER BY COUNT(emp_id) DESC LIMIT 1",
        "target_query": "SELECT formatDateTime(`hire_date`, '%Y') FROM `employee` GROUP BY formatDateTime(`hire_date`, '%Y') ORDER BY COUNT(`emp_id`) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 32,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 56,
                "end_index": 81,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 40,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            },
            {
                "start_index": 66,
                "end_index": 99,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`emp_id`, text, primary key)\n(`fname`, text)\n(`minit`, text)\n(`lname`, text)\n(`job_id`, integer)\n(`job_lvl`, integer)\n(`pub_id`, text)\n(`hire_date`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `employee`\nColumns:\n(`emp_id`, String, primary key)\n(`fname`, String)\n(`minit`, String)\n(`lname`, String)\n(`job_id`, Int64)\n(`job_lvl`, Int64)\n(`pub_id`, String)\n(`hire_date`, DateTime)\n"
        ]
    },
    {
        "sql_id": 14,
        "database_name": "book_publishing_company",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.notes FROM titles AS T1 INNER JOIN sales AS T2 ON T1.title_id = T2.title_id WHERE STRFTIME('%Y-%m-%d', T2.ord_date) = '1994-09-14'",
        "target_query": "SELECT `T1`.`notes` FROM `titles` AS `T1` INNER JOIN `sales` AS `T2` ON `T1`.`title_id` = `T2`.`title_id` WHERE formatDateTime(`T2`.`ord_date`, '%Y-%m-%d') = '1994-09-14';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 92,
                "end_index": 125,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 112,
                "end_index": 155,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `titles`\nColumns:\n(`title_id`, text, primary key)\n(`title`, text)\n(`type`, text)\n(`pub_id`, text)\n(`price`, real)\n(`advance`, real)\n(`royalty`, integer)\n(`ytd_sales`, integer)\n(`notes`, text)\n(`pubdate`, datetime)\n",
            "Table: `sales`\nColumns:\n(`stor_id`, text, primary key)\n(`ord_num`, text, primary key)\n(`ord_date`, datetime)\n(`qty`, integer)\n(`payterms`, text)\n(`title_id`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `titles`\nColumns:\n(`title_id`, String, primary key)\n(`title`, String)\n(`_type`, String)\n(`pub_id`, String)\n(`price`, Float64)\n(`advance`, Float64)\n(`royalty`, Int64)\n(`ytd_sales`, Int64)\n(`notes`, String)\n(`pubdate`, DateTime)\n",
            "Table: `sales`\nColumns:\n(`stor_id`, String, primary key)\n(`ord_num`, String, primary key)\n(`ord_date`, DateTime)\n(`qty`, Int64)\n(`payterms`, String)\n(`title_id`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 15,
        "database_name": "book_publishing_company",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT T1.type FROM titles AS T1 INNER JOIN sales AS T2 ON T1.title_id = T2.title_id WHERE STRFTIME('%Y-%m-%d', T2.ord_date) = '1993-05-29'",
        "target_query": "SELECT DISTINCT `T1`._type FROM `titles` AS `T1` INNER JOIN `sales` AS `T2` ON `T1`.title_id = `T2`.title_id WHERE formatDateTime(`T2`.ord_date, '%Y-%m-%d') = '1993-05-29';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 100,
                "end_index": 133,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 115,
                "end_index": 156,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `titles`\nColumns:\n(`title_id`, text, primary key)\n(`title`, text)\n(`type`, text)\n(`pub_id`, text)\n(`price`, real)\n(`advance`, real)\n(`royalty`, integer)\n(`ytd_sales`, integer)\n(`notes`, text)\n(`pubdate`, datetime)\n",
            "Table: `sales`\nColumns:\n(`stor_id`, text, primary key)\n(`ord_num`, text, primary key)\n(`ord_date`, datetime)\n(`qty`, integer)\n(`payterms`, text)\n(`title_id`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `titles`\nColumns:\n(`title_id`, String, primary key)\n(`title`, String)\n(`_type`, String)\n(`pub_id`, String)\n(`price`, Float64)\n(`advance`, Float64)\n(`royalty`, Int64)\n(`ytd_sales`, Int64)\n(`notes`, String)\n(`pubdate`, DateTime)\n",
            "Table: `sales`\nColumns:\n(`stor_id`, String, primary key)\n(`ord_num`, String, primary key)\n(`ord_date`, DateTime)\n(`qty`, Int64)\n(`payterms`, String)\n(`title_id`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 16,
        "database_name": "book_publishing_company",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(CASE WHEN T2.city = 'Fremont' THEN qty END) - SUM(CASE WHEN T2.city = 'Portland' THEN qty END) AS REAL) * 100 / SUM(CASE WHEN T2.city = 'Fremont' THEN qty END) FROM sales AS T1 INNER JOIN stores AS T2 ON T1.stor_id = T2.stor_id WHERE STRFTIME('%Y', T1.ord_date) = '1993'",
        "target_query": "SELECT CAST(SUM(CASE WHEN `T2`.`city` = 'Fremont' THEN `qty` END) - SUM(CASE WHEN `T2`.`city` = 'Portland' THEN `qty` END) AS Float64) * 100 / SUM(CASE WHEN `T2`.`city` = 'Fremont' THEN `qty` END) \nFROM `sales` AS `T1` \nINNER JOIN `stores` AS `T2` ON `T1`.`stor_id` = `T2`.`stor_id` \nWHERE formatDateTime(`T1`.`ord_date`, '%Y') = '1993';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 250,
                "end_index": 277,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 290,
                "end_index": 327,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `sales`\nColumns:\n(`stor_id`, text, primary key)\n(`ord_num`, text, primary key)\n(`ord_date`, datetime)\n(`qty`, integer)\n(`payterms`, text)\n(`title_id`, text, primary key)\n",
            "Table: `stores`\nColumns:\n(`stor_id`, text, primary key)\n(`stor_name`, text)\n(`stor_address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `sales`\nColumns:\n(`stor_id`, String, primary key)\n(`ord_num`, String, primary key)\n(`ord_date`, DateTime)\n(`qty`, Int64)\n(`payterms`, String)\n(`title_id`, String, primary key)\n",
            "Table: `stores`\nColumns:\n(`stor_id`, String, primary key)\n(`stor_name`, String)\n(`stor_address`, String)\n(`city`, String)\n(`state`, String)\n(`zip`, String)\n"
        ]
    },
    {
        "sql_id": 17,
        "database_name": "book_publishing_company",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT fname, minit, lname FROM employee WHERE STRFTIME('%Y', hire_date) BETWEEN '1990' AND '1995' ORDER BY job_lvl DESC",
        "target_query": "SELECT `fname`, `minit`, `lname` FROM `employee` WHERE formatDateTime(`hire_date`, '%Y') BETWEEN '1990' AND '1995' ORDER BY `job_lvl` DESC;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 47,
                "end_index": 72,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 55,
                "end_index": 88,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`emp_id`, text, primary key)\n(`fname`, text)\n(`minit`, text)\n(`lname`, text)\n(`job_id`, integer)\n(`job_lvl`, integer)\n(`pub_id`, text)\n(`hire_date`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `employee`\nColumns:\n(`emp_id`, String, primary key)\n(`fname`, String)\n(`minit`, String)\n(`lname`, String)\n(`job_id`, Int64)\n(`job_lvl`, Int64)\n(`pub_id`, String)\n(`hire_date`, DateTime)\n"
        ]
    },
    {
        "sql_id": 9,
        "database_name": "book_publishing_company",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.title FROM sales AS T1 INNER JOIN titles AS T2 ON T1.title_id = T2.title_id WHERE STRFTIME('%Y', T1.ord_date) = '1992' ORDER BY T1.qty DESC LIMIT 1",
        "target_query": "SELECT T2.`title` FROM `sales` AS T1 INNER JOIN `titles` AS T2 ON T1.`title_id` = T2.`title_id` WHERE formatDateTime(T1.`ord_date`, '%Y') = '1992' ORDER BY T1.`qty` DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 92,
                "end_index": 119,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 102,
                "end_index": 137,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `sales`\nColumns:\n(`stor_id`, text, primary key)\n(`ord_num`, text, primary key)\n(`ord_date`, datetime)\n(`qty`, integer)\n(`payterms`, text)\n(`title_id`, text, primary key)\n",
            "Table: `titles`\nColumns:\n(`title_id`, text, primary key)\n(`title`, text)\n(`type`, text)\n(`pub_id`, text)\n(`price`, real)\n(`advance`, real)\n(`royalty`, integer)\n(`ytd_sales`, integer)\n(`notes`, text)\n(`pubdate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `sales`\nColumns:\n(`stor_id`, String, primary key)\n(`ord_num`, String, primary key)\n(`ord_date`, DateTime)\n(`qty`, Int64)\n(`payterms`, String)\n(`title_id`, String, primary key)\n",
            "Table: `titles`\nColumns:\n(`title_id`, String, primary key)\n(`title`, String)\n(`_type`, String)\n(`pub_id`, String)\n(`price`, Float64)\n(`advance`, Float64)\n(`royalty`, Int64)\n(`ytd_sales`, Int64)\n(`notes`, String)\n(`pubdate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 10,
        "database_name": "book_publishing_company",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.title, T1.notes, T2.pub_name FROM titles AS T1 INNER JOIN publishers AS T2 ON T1.pub_id = T2.pub_id WHERE STRFTIME('%Y', T1.pubdate) = '1991'",
        "target_query": "SELECT `T1`.`title`, `T1`.`notes`, `T2`.`pub_name` FROM `titles` AS `T1` INNER JOIN `publishers` AS `T2` ON `T1`.`pub_id` = `T2`.`pub_id` WHERE formatDateTime(`T1`.`pubdate`, '%Y') = '1991';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 116,
                "end_index": 142,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 144,
                "end_index": 180,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `titles`\nColumns:\n(`title_id`, text, primary key)\n(`title`, text)\n(`type`, text)\n(`pub_id`, text)\n(`price`, real)\n(`advance`, real)\n(`royalty`, integer)\n(`ytd_sales`, integer)\n(`notes`, text)\n(`pubdate`, datetime)\n",
            "Table: `publishers`\nColumns:\n(`pub_id`, text, primary key)\n(`pub_name`, text)\n(`city`, text)\n(`state`, text)\n(`country`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `titles`\nColumns:\n(`title_id`, String, primary key)\n(`title`, String)\n(`_type`, String)\n(`pub_id`, String)\n(`price`, Float64)\n(`advance`, Float64)\n(`royalty`, Int64)\n(`ytd_sales`, Int64)\n(`notes`, String)\n(`pubdate`, DateTime)\n",
            "Table: `publishers`\nColumns:\n(`pub_id`, String, primary key)\n(`pub_name`, String)\n(`city`, String)\n(`state`, String)\n(`country`, String)\n"
        ]
    },
    {
        "sql_id": 13,
        "database_name": "book_publishing_company",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.pub_name FROM titles AS T1 INNER JOIN publishers AS T2 ON T1.pub_id = T2.pub_id WHERE STRFTIME('%Y', T1.pubdate) = '1991' GROUP BY T1.pub_id, T2.pub_name ORDER BY COUNT(T1.title_id) DESC LIMIT 1",
        "target_query": "SELECT T2.`pub_name` FROM `titles` AS T1 INNER JOIN `publishers` AS T2 ON T1.`pub_id` = T2.`pub_id` WHERE formatDateTime(T1.`pubdate`, '%Y') = '1991' GROUP BY T1.`pub_id`, T2.`pub_name` ORDER BY COUNT(T1.`title_id`) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 96,
                "end_index": 122,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 106,
                "end_index": 140,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `titles`\nColumns:\n(`title_id`, text, primary key)\n(`title`, text)\n(`type`, text)\n(`pub_id`, text)\n(`price`, real)\n(`advance`, real)\n(`royalty`, integer)\n(`ytd_sales`, integer)\n(`notes`, text)\n(`pubdate`, datetime)\n",
            "Table: `publishers`\nColumns:\n(`pub_id`, text, primary key)\n(`pub_name`, text)\n(`city`, text)\n(`state`, text)\n(`country`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `titles`\nColumns:\n(`title_id`, String, primary key)\n(`title`, String)\n(`_type`, String)\n(`pub_id`, String)\n(`price`, Float64)\n(`advance`, Float64)\n(`royalty`, Int64)\n(`ytd_sales`, Int64)\n(`notes`, String)\n(`pubdate`, DateTime)\n",
            "Table: `publishers`\nColumns:\n(`pub_id`, String, primary key)\n(`pub_name`, String)\n(`city`, String)\n(`state`, String)\n(`country`, String)\n"
        ]
    },
    {
        "sql_id": 140,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T3.priceEach * T3.quantityOrdered FROM customers AS T1 INNER JOIN orders AS T2 ON T1.customerNumber = T2.customerNumber INNER JOIN orderdetails AS T3 ON T2.orderNumber = T3.orderNumber WHERE T1.customerName = 'Rovelli Gifts' AND T2.status = 'Shipped' AND STRFTIME('%Y', T2.shippedDate) = '2003'",
        "target_query": "SELECT `T3`.`priceEach` * `T3`.`quantityOrdered` FROM `customers` AS `T1` INNER JOIN `orders` AS `T2` ON `T1`.`customerNumber` = `T2`.`customerNumber` INNER JOIN `orderdetails` AS `T3` ON `T2`.`orderNumber` = `T3`.`orderNumber` WHERE `T1`.`customerName` = 'Rovelli Gifts' AND `T2`.`status` = 'Shipped' AND formatDateTime(`T2`.`shippedDate`, '%Y') = '2003';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 262,
                "end_index": 292,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 306,
                "end_index": 346,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customers`\nColumns:\n(`customerNumber`, integer, primary key)\n(`customerName`, text)\n(`contactLastName`, text)\n(`contactFirstName`, text)\n(`phone`, text)\n(`addressLine1`, text)\n(`addressLine2`, text)\n(`city`, text)\n(`state`, text)\n(`postalCode`, text)\n(`country`, text)\n(`salesRepEmployeeNumber`, integer)\n(`creditLimit`, real)\n",
            "Table: `orders`\nColumns:\n(`orderNumber`, integer, primary key)\n(`orderDate`, date)\n(`requiredDate`, date)\n(`shippedDate`, date)\n(`status`, text)\n(`comments`, text)\n(`customerNumber`, integer)\n",
            "Table: `orderdetails`\nColumns:\n(`orderNumber`, integer, primary key)\n(`productCode`, text, primary key)\n(`quantityOrdered`, integer)\n(`priceEach`, real)\n(`orderLineNumber`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `customers`\nColumns:\n(`customerNumber`, Int64, primary key)\n(`customerName`, String)\n(`contactLastName`, String)\n(`contactFirstName`, String)\n(`phone`, String)\n(`addressLine1`, String)\n(`addressLine2`, String)\n(`city`, String)\n(`state`, String)\n(`postalCode`, String)\n(`country`, String)\n(`salesRepEmployeeNumber`, Int64)\n(`creditLimit`, Float64)\n",
            "Table: `orders`\nColumns:\n(`orderNumber`, Int64, primary key)\n(`orderDate`, Date32)\n(`requiredDate`, Date32)\n(`shippedDate`, Date32)\n(`status`, String)\n(`comments`, String)\n(`customerNumber`, Int64)\n",
            "Table: `orderdetails`\nColumns:\n(`orderNumber`, Int64, primary key)\n(`productCode`, String, primary key)\n(`quantityOrdered`, Int64)\n(`priceEach`, Float64)\n(`orderLineNumber`, Int64)\n"
        ]
    },
    {
        "sql_id": 141,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T1.checkNumber) FROM payments AS T1 INNER JOIN customers AS T2 ON T1.customerNumber = T2.customerNumber WHERE customerName = 'Euro+ Shopping Channel' AND STRFTIME('%Y', T1.paymentDate) = '2004'",
        "target_query": "SELECT COUNT(`T1`.`checkNumber`) FROM `payments` AS `T1` INNER JOIN `customers` AS `T2` ON `T1`.`customerNumber` = `T2`.`customerNumber` WHERE `T2`.`customerName` = 'Euro+ Shopping Channel' AND formatDateTime(`T1`.`paymentDate`, '%Y') = '2004';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 167,
                "end_index": 197,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 194,
                "end_index": 234,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `payments`\nColumns:\n(`customerNumber`, integer, primary key)\n(`checkNumber`, text, primary key)\n(`paymentDate`, date)\n(`amount`, real)\n",
            "Table: `customers`\nColumns:\n(`customerNumber`, integer, primary key)\n(`customerName`, text)\n(`contactLastName`, text)\n(`contactFirstName`, text)\n(`phone`, text)\n(`addressLine1`, text)\n(`addressLine2`, text)\n(`city`, text)\n(`state`, text)\n(`postalCode`, text)\n(`country`, text)\n(`salesRepEmployeeNumber`, integer)\n(`creditLimit`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `payments`\nColumns:\n(`customerNumber`, Int64, primary key)\n(`checkNumber`, String, primary key)\n(`paymentDate`, Date32)\n(`amount`, Float64)\n",
            "Table: `customers`\nColumns:\n(`customerNumber`, Int64, primary key)\n(`customerName`, String)\n(`contactLastName`, String)\n(`contactFirstName`, String)\n(`phone`, String)\n(`addressLine1`, String)\n(`addressLine2`, String)\n(`city`, String)\n(`state`, String)\n(`postalCode`, String)\n(`country`, String)\n(`salesRepEmployeeNumber`, Int64)\n(`creditLimit`, Float64)\n"
        ]
    },
    {
        "sql_id": 142,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT ( SELECT COUNT(customerNumber) FROM customers WHERE creditLimit <= 100000 AND customerNumber IN ( SELECT customerNumber FROM payments WHERE STRFTIME('%Y', paymentDate) = '2004' ) ), T1.customerName FROM customers AS T1 INNER JOIN payments AS T2 ON T1.customerNumber = T2.customerNumber WHERE T1.creditLimit <= 100000 AND STRFTIME('%Y', T2.paymentDate) = '2004' GROUP BY T1.customerNumber, T1.customerName ORDER BY SUM(T2.amount) DESC LIMIT 1",
        "target_query": "SELECT ( SELECT COUNT(`customerNumber`) FROM `customers` WHERE `creditLimit` <= 100000 AND `customerNumber` IN ( SELECT `customerNumber` FROM `payments` WHERE formatDateTime(`paymentDate`, '%Y') = '2004' ) ), T1.`customerName` FROM `customers` AS T1 INNER JOIN `payments` AS T2 ON T1.`customerNumber` = T2.`customerNumber` WHERE T1.`creditLimit` <= 100000 AND formatDateTime(T2.`paymentDate`, '%Y') = '2004' GROUP BY T1.`customerNumber`, T1.`customerName` ORDER BY SUM(T2.`amount`) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 147,
                "end_index": 174,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 328,
                "end_index": 358,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 159,
                "end_index": 194,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            },
            {
                "start_index": 360,
                "end_index": 398,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customers`\nColumns:\n(`customerNumber`, integer, primary key)\n(`customerName`, text)\n(`contactLastName`, text)\n(`contactFirstName`, text)\n(`phone`, text)\n(`addressLine1`, text)\n(`addressLine2`, text)\n(`city`, text)\n(`state`, text)\n(`postalCode`, text)\n(`country`, text)\n(`salesRepEmployeeNumber`, integer)\n(`creditLimit`, real)\n",
            "Table: `payments`\nColumns:\n(`customerNumber`, integer, primary key)\n(`checkNumber`, text, primary key)\n(`paymentDate`, date)\n(`amount`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `customers`\nColumns:\n(`customerNumber`, Int64, primary key)\n(`customerName`, String)\n(`contactLastName`, String)\n(`contactFirstName`, String)\n(`phone`, String)\n(`addressLine1`, String)\n(`addressLine2`, String)\n(`city`, String)\n(`state`, String)\n(`postalCode`, String)\n(`country`, String)\n(`salesRepEmployeeNumber`, Int64)\n(`creditLimit`, Float64)\n",
            "Table: `payments`\nColumns:\n(`customerNumber`, Int64, primary key)\n(`checkNumber`, String, primary key)\n(`paymentDate`, Date32)\n(`amount`, Float64)\n"
        ]
    },
    {
        "sql_id": 143,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(DISTINCT T1.orderNumber) FROM orderdetails AS T1 INNER JOIN orders AS T2 ON T1.orderNumber = T2.orderNumber WHERE T1.quantityOrdered < 30 AND STRFTIME('%Y', T2.orderDate) = '2003'",
        "target_query": "SELECT COUNT(DISTINCT `T1`.`orderNumber`) FROM `orderdetails` AS `T1` INNER JOIN `orders` AS `T2` ON `T1`.`orderNumber` = `T2`.`orderNumber` WHERE `T1`.`quantityOrdered` < 30 AND formatDateTime(`T2`.`orderDate`, '%Y') = '2003';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 155,
                "end_index": 183,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 179,
                "end_index": 217,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `orderdetails`\nColumns:\n(`orderNumber`, integer, primary key)\n(`productCode`, text, primary key)\n(`quantityOrdered`, integer)\n(`priceEach`, real)\n(`orderLineNumber`, integer)\n",
            "Table: `orders`\nColumns:\n(`orderNumber`, integer, primary key)\n(`orderDate`, date)\n(`requiredDate`, date)\n(`shippedDate`, date)\n(`status`, text)\n(`comments`, text)\n(`customerNumber`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `orderdetails`\nColumns:\n(`orderNumber`, Int64, primary key)\n(`productCode`, String, primary key)\n(`quantityOrdered`, Int64)\n(`priceEach`, Float64)\n(`orderLineNumber`, Int64)\n",
            "Table: `orders`\nColumns:\n(`orderNumber`, Int64, primary key)\n(`orderDate`, Date32)\n(`requiredDate`, Date32)\n(`shippedDate`, Date32)\n(`status`, String)\n(`comments`, String)\n(`customerNumber`, Int64)\n"
        ]
    },
    {
        "sql_id": 144,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(T2.quantityOrdered * T2.priceEach) / COUNT(T3.orderNumber) FROM products AS T1 INNER JOIN orderdetails AS T2 ON T1.productCode = T2.productCode INNER JOIN orders AS T3 ON T2.orderNumber = T3.orderNumber WHERE T1.productVendor = 'Exoto Designs' AND STRFTIME('%Y', T3.orderDate) = '2005'",
        "target_query": "SELECT SUM(T2.`quantityOrdered` * T2.`priceEach`) / COUNT(T3.`orderNumber`) \nFROM `products` AS T1 \nINNER JOIN `orderdetails` AS T2 ON T1.`productCode` = T2.`productCode` \nINNER JOIN `orders` AS T3 ON T2.`orderNumber` = T3.`orderNumber` \nWHERE T1.`productVendor` = 'Exoto Designs' AND formatDateTime(T3.`orderDate`, '%Y') = '2005';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 259,
                "end_index": 287,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 285,
                "end_index": 321,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `products`\nColumns:\n(`productCode`, text, primary key)\n(`productName`, text)\n(`productLine`, text)\n(`productScale`, text)\n(`productVendor`, text)\n(`productDescription`, text)\n(`quantityInStock`, integer)\n(`buyPrice`, real)\n(`MSRP`, real)\n",
            "Table: `orderdetails`\nColumns:\n(`orderNumber`, integer, primary key)\n(`productCode`, text, primary key)\n(`quantityOrdered`, integer)\n(`priceEach`, real)\n(`orderLineNumber`, integer)\n",
            "Table: `orders`\nColumns:\n(`orderNumber`, integer, primary key)\n(`orderDate`, date)\n(`requiredDate`, date)\n(`shippedDate`, date)\n(`status`, text)\n(`comments`, text)\n(`customerNumber`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `products`\nColumns:\n(`productCode`, String, primary key)\n(`productName`, String)\n(`productLine`, String)\n(`productScale`, String)\n(`productVendor`, String)\n(`productDescription`, String)\n(`quantityInStock`, Int64)\n(`buyPrice`, Float64)\n(`MSRP`, Float64)\n",
            "Table: `orderdetails`\nColumns:\n(`orderNumber`, Int64, primary key)\n(`productCode`, String, primary key)\n(`quantityOrdered`, Int64)\n(`priceEach`, Float64)\n(`orderLineNumber`, Int64)\n",
            "Table: `orders`\nColumns:\n(`orderNumber`, Int64, primary key)\n(`orderDate`, Date32)\n(`requiredDate`, Date32)\n(`shippedDate`, Date32)\n(`status`, String)\n(`comments`, String)\n(`customerNumber`, Int64)\n"
        ]
    },
    {
        "sql_id": 145,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(amount) FROM payments WHERE STRFTIME('%Y', paymentDate) = '2003' AND customerNumber IN ( SELECT customerNumber FROM customers WHERE creditLimit = 0 )",
        "target_query": "SELECT SUM(`amount`) FROM `payments` WHERE formatDateTime(`paymentDate`, '%Y') = '2003' AND `customerNumber` IN ( SELECT `customerNumber` FROM `customers` WHERE `creditLimit` = 0 );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 39,
                "end_index": 66,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 43,
                "end_index": 78,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `payments`\nColumns:\n(`customerNumber`, integer, primary key)\n(`checkNumber`, text, primary key)\n(`paymentDate`, date)\n(`amount`, real)\n",
            "Table: `customers`\nColumns:\n(`customerNumber`, integer, primary key)\n(`customerName`, text)\n(`contactLastName`, text)\n(`contactFirstName`, text)\n(`phone`, text)\n(`addressLine1`, text)\n(`addressLine2`, text)\n(`city`, text)\n(`state`, text)\n(`postalCode`, text)\n(`country`, text)\n(`salesRepEmployeeNumber`, integer)\n(`creditLimit`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `payments`\nColumns:\n(`customerNumber`, Int64, primary key)\n(`checkNumber`, String, primary key)\n(`paymentDate`, Date32)\n(`amount`, Float64)\n",
            "Table: `customers`\nColumns:\n(`customerNumber`, Int64, primary key)\n(`customerName`, String)\n(`contactLastName`, String)\n(`contactFirstName`, String)\n(`phone`, String)\n(`addressLine1`, String)\n(`addressLine2`, String)\n(`city`, String)\n(`state`, String)\n(`postalCode`, String)\n(`country`, String)\n(`salesRepEmployeeNumber`, Int64)\n(`creditLimit`, Float64)\n"
        ]
    },
    {
        "sql_id": 146,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(customernumber) FROM ( SELECT customernumber FROM payments WHERE STRFTIME('%Y', paymentDate) >= '2003' AND STRFTIME('%Y', paymentDate) <= '2004' GROUP BY customernumber HAVING COUNT(customernumber) > 3 ) T",
        "target_query": "SELECT COUNT(`customerNumber`) FROM ( SELECT `customerNumber` FROM `payments` WHERE formatDateTime(`paymentDate`, '%Y') >= '2003' AND formatDateTime(`paymentDate`, '%Y') <= '2004' GROUP BY `customerNumber` HAVING COUNT(`customerNumber`) > 3 ) AS T;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 78,
                "end_index": 105,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 120,
                "end_index": 147,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 84,
                "end_index": 119,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            },
            {
                "start_index": 134,
                "end_index": 169,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `payments`\nColumns:\n(`customerNumber`, integer, primary key)\n(`checkNumber`, text, primary key)\n(`paymentDate`, date)\n(`amount`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `payments`\nColumns:\n(`customerNumber`, Int64, primary key)\n(`checkNumber`, String, primary key)\n(`paymentDate`, Date32)\n(`amount`, Float64)\n"
        ]
    },
    {
        "sql_id": 147,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T3.addressLine1, T3.addressLine2, T3.phone FROM orderdetails AS T1 INNER JOIN orders AS T2 ON T1.orderNumber = T2.orderNumber INNER JOIN customers AS T3 ON T2.customerNumber = T3.customerNumber INNER JOIN employees AS T4 ON T3.salesRepEmployeeNumber = T4.employeeNumber INNER JOIN offices AS T5 ON T4.officeCode = T5.officeCode WHERE STRFTIME('%Y', T2.orderDate) = '2005' AND T4.jobTitle = 'Sales Rep' ORDER BY T1.quantityOrdered DESC LIMIT 1",
        "target_query": "SELECT T3.`addressLine1`, T3.`addressLine2`, T3.`phone` \nFROM `orderdetails` AS T1 \nINNER JOIN `orders` AS T2 ON T1.`orderNumber` = T2.`orderNumber` \nINNER JOIN `customers` AS T3 ON T2.`customerNumber` = T3.`customerNumber` \nINNER JOIN `employees` AS T4 ON T3.`salesRepEmployeeNumber` = T4.`employeeNumber` \nINNER JOIN `offices` AS T5 ON T4.`officeCode` = T5.`officeCode` \nWHERE formatDateTime(T2.`orderDate`, '%Y') = '2005' AND T4.`jobTitle` = 'Sales Rep' \nORDER BY T1.`quantityOrdered` DESC \nLIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 341,
                "end_index": 369,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 379,
                "end_index": 415,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `orderdetails`\nColumns:\n(`orderNumber`, integer, primary key)\n(`productCode`, text, primary key)\n(`quantityOrdered`, integer)\n(`priceEach`, real)\n(`orderLineNumber`, integer)\n",
            "Table: `orders`\nColumns:\n(`orderNumber`, integer, primary key)\n(`orderDate`, date)\n(`requiredDate`, date)\n(`shippedDate`, date)\n(`status`, text)\n(`comments`, text)\n(`customerNumber`, integer)\n",
            "Table: `customers`\nColumns:\n(`customerNumber`, integer, primary key)\n(`customerName`, text)\n(`contactLastName`, text)\n(`contactFirstName`, text)\n(`phone`, text)\n(`addressLine1`, text)\n(`addressLine2`, text)\n(`city`, text)\n(`state`, text)\n(`postalCode`, text)\n(`country`, text)\n(`salesRepEmployeeNumber`, integer)\n(`creditLimit`, real)\n",
            "Table: `employees`\nColumns:\n(`employeeNumber`, integer, primary key)\n(`lastName`, text)\n(`firstName`, text)\n(`extension`, text)\n(`email`, text)\n(`officeCode`, text)\n(`reportsTo`, integer)\n(`jobTitle`, text)\n",
            "Table: `offices`\nColumns:\n(`officeCode`, text, primary key)\n(`city`, text)\n(`phone`, text)\n(`addressLine1`, text)\n(`addressLine2`, text)\n(`state`, text)\n(`country`, text)\n(`postalCode`, text)\n(`territory`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `orderdetails`\nColumns:\n(`orderNumber`, Int64, primary key)\n(`productCode`, String, primary key)\n(`quantityOrdered`, Int64)\n(`priceEach`, Float64)\n(`orderLineNumber`, Int64)\n",
            "Table: `orders`\nColumns:\n(`orderNumber`, Int64, primary key)\n(`orderDate`, Date32)\n(`requiredDate`, Date32)\n(`shippedDate`, Date32)\n(`status`, String)\n(`comments`, String)\n(`customerNumber`, Int64)\n",
            "Table: `customers`\nColumns:\n(`customerNumber`, Int64, primary key)\n(`customerName`, String)\n(`contactLastName`, String)\n(`contactFirstName`, String)\n(`phone`, String)\n(`addressLine1`, String)\n(`addressLine2`, String)\n(`city`, String)\n(`state`, String)\n(`postalCode`, String)\n(`country`, String)\n(`salesRepEmployeeNumber`, Int64)\n(`creditLimit`, Float64)\n",
            "Table: `employees`\nColumns:\n(`employeeNumber`, Int64, primary key)\n(`lastName`, String)\n(`firstName`, String)\n(`extension`, String)\n(`email`, String)\n(`officeCode`, String)\n(`reportsTo`, Int64)\n(`jobTitle`, String)\n",
            "Table: `offices`\nColumns:\n(`officeCode`, String, primary key)\n(`city`, String)\n(`phone`, String)\n(`addressLine1`, String)\n(`addressLine2`, String)\n(`state`, String)\n(`country`, String)\n(`postalCode`, String)\n(`territory`, String)\n"
        ]
    },
    {
        "sql_id": 148,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.orderDate FROM orderdetails AS T1 INNER JOIN orders AS T2 ON T1.orderNumber = T2.orderNumber WHERE STRFTIME('%Y-%m-%d', T2.orderDate) = '2005-04-08' OR STRFTIME('%Y-%m-%d', T2.orderDate) = '2005-04-10' ORDER BY T1.quantityOrdered * T1.priceEach DESC LIMIT 1",
        "target_query": "SELECT T2.`orderDate` FROM `orderdetails` AS T1 INNER JOIN `orders` AS T2 ON T1.`orderNumber` = T2.`orderNumber` WHERE formatDateTime(T2.`orderDate`, '%Y-%m-%d') = '2005-04-08' OR formatDateTime(T2.`orderDate`, '%Y-%m-%d') = '2005-04-10' ORDER BY T1.`quantityOrdered` * T1.`priceEach` DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 109,
                "end_index": 143,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 162,
                "end_index": 196,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 119,
                "end_index": 161,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            },
            {
                "start_index": 180,
                "end_index": 222,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `orderdetails`\nColumns:\n(`orderNumber`, integer, primary key)\n(`productCode`, text, primary key)\n(`quantityOrdered`, integer)\n(`priceEach`, real)\n(`orderLineNumber`, integer)\n",
            "Table: `orders`\nColumns:\n(`orderNumber`, integer, primary key)\n(`orderDate`, date)\n(`requiredDate`, date)\n(`shippedDate`, date)\n(`status`, text)\n(`comments`, text)\n(`customerNumber`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `orderdetails`\nColumns:\n(`orderNumber`, Int64, primary key)\n(`productCode`, String, primary key)\n(`quantityOrdered`, Int64)\n(`priceEach`, Float64)\n(`orderLineNumber`, Int64)\n",
            "Table: `orders`\nColumns:\n(`orderNumber`, Int64, primary key)\n(`orderDate`, Date32)\n(`requiredDate`, Date32)\n(`shippedDate`, Date32)\n(`status`, String)\n(`comments`, String)\n(`customerNumber`, Int64)\n"
        ]
    },
    {
        "sql_id": 149,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(CASE WHEN JULIANDAY(t1.shippeddate) - JULIANDAY(t1.requireddate) > 3 THEN T1.customerNumber ELSE NULL END) FROM orders AS T1 INNER JOIN orderdetails AS T2 ON T1.orderNumber = T2.orderNumber WHERE T1.status = 'Shipped'",
        "target_query": "SELECT COUNT(CASE WHEN (toUInt32(toDateTime(`t1`.`shippedDate`)) / 86400 + 2440587.5) - (toUInt32(toDateTime(`t1`.`requiredDate`)) / 86400 + 2440587.5) > 3 THEN `t1`.`customerNumber` ELSE NULL END) FROM `orders` AS `t1` INNER JOIN `orderdetails` AS `t2` ON `t1`.`orderNumber` = `t2`.`orderNumber` WHERE `t1`.`status` = 'Shipped';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 23,
                "end_index": 48,
                "dialect_content": "The julianday(time-value, modifier, modifier, ...) function returns the Julian day number - the fractional number of days since noon in Greenwich on November 24, 4714 B.C. (Proleptic Gregorian calendar). It accepts a time-value and zero or more modifiers.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day').\nReturns: A real number representing the Julian day number.",
                "feature": "julianday(time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 51,
                "end_index": 77,
                "dialect_content": "The julianday(time-value, modifier, modifier, ...) function returns the Julian day number - the fractional number of days since noon in Greenwich on November 24, 4714 B.C. (Proleptic Gregorian calendar). It accepts a time-value and zero or more modifiers.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day').\nReturns: A real number representing the Julian day number.",
                "feature": "julianday(time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 24,
                "end_index": 63,
                "dialect_content": "ClickHouse does not have a built-in `julianday()` function like SQLite. However, you can compute the Julian day number using the formula: `toUInt32(toDateTime(time_value)) / 86400 + 2440587.5`. This expression converts a `DateTime` value to Julian day number by converting it to seconds since the Unix epoch (1970-01-01), dividing by the number of seconds in a day, and adjusting by adding the Julian day number of the Unix epoch (2440587.5).",
                "feature": "toUInt32(toDateTime(time_value)) / 86400 + 2440587.5"
            },
            {
                "start_index": 89,
                "end_index": 129,
                "dialect_content": "ClickHouse does not have a built-in `julianday()` function like SQLite. However, you can compute the Julian day number using the formula: `toUInt32(toDateTime(time_value)) / 86400 + 2440587.5`. This expression converts a `DateTime` value to Julian day number by converting it to seconds since the Unix epoch (1970-01-01), dividing by the number of seconds in a day, and adjusting by adding the Julian day number of the Unix epoch (2440587.5).",
                "feature": "toUInt32(toDateTime(time_value)) / 86400 + 2440587.5"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "julianday(time-value, modifier, modifier, ...)",
                "explanation": "The julianday(time-value, modifier, modifier, ...) function returns the Julian day number - the fractional number of days since noon in Greenwich on November 24, 4714 B.C. (Proleptic Gregorian calendar). It accepts a time-value and zero or more modifiers.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day').\nReturns: A real number representing the Julian day number.",
                "examples": [
                    "SELECT julianday(); -- Returns the current Julian day number.",
                    "SELECT julianday('2024-08-21'); -- Returns the Julian day number for August 21, 2024.",
                    "SELECT julianday('now', '+1 day'); -- Returns the Julian day number for one day after the current date."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "toUInt32(toDateTime(time_value)) / 86400 + 2440587.5",
                "explanation": "ClickHouse does not have a built-in `julianday()` function like SQLite. However, you can compute the Julian day number using the formula: `toUInt32(toDateTime(time_value)) / 86400 + 2440587.5`. This expression converts a `DateTime` value to Julian day number by converting it to seconds since the Unix epoch (1970-01-01), dividing by the number of seconds in a day, and adjusting by adding the Julian day number of the Unix epoch (2440587.5).",
                "examples": [
                    "SELECT toUInt32(toDateTime(now())) / 86400 + 2440587.5; -- Returns the current Julian day number.",
                    "SELECT toUInt32(toDateTime('2024-08-21')) / 86400 + 2440587.5; -- Returns the Julian day number for August 21, 2024.",
                    "SELECT toUInt32(toDateTime(now() + INTERVAL 1 DAY)) / 86400 + 2440587.5; -- Returns the Julian day number for one day after the current date."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `orders`\nColumns:\n(`orderNumber`, integer, primary key)\n(`orderDate`, date)\n(`requiredDate`, date)\n(`shippedDate`, date)\n(`status`, text)\n(`comments`, text)\n(`customerNumber`, integer)\n",
            "Table: `orderdetails`\nColumns:\n(`orderNumber`, integer, primary key)\n(`productCode`, text, primary key)\n(`quantityOrdered`, integer)\n(`priceEach`, real)\n(`orderLineNumber`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `orders`\nColumns:\n(`orderNumber`, Int64, primary key)\n(`orderDate`, Date32)\n(`requiredDate`, Date32)\n(`shippedDate`, Date32)\n(`status`, String)\n(`comments`, String)\n(`customerNumber`, Int64)\n",
            "Table: `orderdetails`\nColumns:\n(`orderNumber`, Int64, primary key)\n(`productCode`, String, primary key)\n(`quantityOrdered`, Int64)\n(`priceEach`, Float64)\n(`orderLineNumber`, Int64)\n"
        ]
    },
    {
        "sql_id": 150,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT t2.customerName FROM payments AS t1 INNER JOIN customers AS t2 ON t1.customerNumber = t2.customerNumber WHERE STRFTIME('%Y', t1.paymentDate) = '2005' GROUP BY t2.customerNumber, t2.customerName ORDER BY SUM(t1.amount) DESC LIMIT 1",
        "target_query": "SELECT `t2`.`customerName` FROM `payments` AS `t1` INNER JOIN `customers` AS `t2` ON `t1`.`customerNumber` = `t2`.`customerNumber` WHERE formatDateTime(`t1`.`paymentDate`, '%Y') = '2005' GROUP BY `t2`.`customerNumber`, `t2`.`customerName` ORDER BY SUM(`t1`.`amount`) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 117,
                "end_index": 147,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 137,
                "end_index": 177,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `payments`\nColumns:\n(`customerNumber`, integer, primary key)\n(`checkNumber`, text, primary key)\n(`paymentDate`, date)\n(`amount`, real)\n",
            "Table: `customers`\nColumns:\n(`customerNumber`, integer, primary key)\n(`customerName`, text)\n(`contactLastName`, text)\n(`contactFirstName`, text)\n(`phone`, text)\n(`addressLine1`, text)\n(`addressLine2`, text)\n(`city`, text)\n(`state`, text)\n(`postalCode`, text)\n(`country`, text)\n(`salesRepEmployeeNumber`, integer)\n(`creditLimit`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `payments`\nColumns:\n(`customerNumber`, Int64, primary key)\n(`checkNumber`, String, primary key)\n(`paymentDate`, Date32)\n(`amount`, Float64)\n",
            "Table: `customers`\nColumns:\n(`customerNumber`, Int64, primary key)\n(`customerName`, String)\n(`contactLastName`, String)\n(`contactFirstName`, String)\n(`phone`, String)\n(`addressLine1`, String)\n(`addressLine2`, String)\n(`city`, String)\n(`state`, String)\n(`postalCode`, String)\n(`country`, String)\n(`salesRepEmployeeNumber`, Int64)\n(`creditLimit`, Float64)\n"
        ]
    },
    {
        "sql_id": 151,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(CASE WHEN t1.customerName = 'Atelier graphique' THEN t2.amount ELSE 0 END) * 100 / SUM(t2.amount) FROM customers AS t1 INNER JOIN payments AS t2 ON t1.customerNumber = t2.customerNumber WHERE STRFTIME('%Y', t2.paymentDate) = '2004'",
        "target_query": "SELECT SUM(CASE WHEN `t1`.`customerName` = 'Atelier graphique' THEN `t2`.`amount` ELSE 0 END) * 100 / SUM(`t2`.`amount`) FROM `customers` AS `t1` INNER JOIN `payments` AS `t2` ON `t1`.`customerNumber` = `t2`.`customerNumber` WHERE formatDateTime(`t2`.`paymentDate`, '%Y') = '2004';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 203,
                "end_index": 233,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 231,
                "end_index": 271,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customers`\nColumns:\n(`customerNumber`, integer, primary key)\n(`customerName`, text)\n(`contactLastName`, text)\n(`contactFirstName`, text)\n(`phone`, text)\n(`addressLine1`, text)\n(`addressLine2`, text)\n(`city`, text)\n(`state`, text)\n(`postalCode`, text)\n(`country`, text)\n(`salesRepEmployeeNumber`, integer)\n(`creditLimit`, real)\n",
            "Table: `payments`\nColumns:\n(`customerNumber`, integer, primary key)\n(`checkNumber`, text, primary key)\n(`paymentDate`, date)\n(`amount`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `customers`\nColumns:\n(`customerNumber`, Int64, primary key)\n(`customerName`, String)\n(`contactLastName`, String)\n(`contactFirstName`, String)\n(`phone`, String)\n(`addressLine1`, String)\n(`addressLine2`, String)\n(`city`, String)\n(`state`, String)\n(`postalCode`, String)\n(`country`, String)\n(`salesRepEmployeeNumber`, Int64)\n(`creditLimit`, Float64)\n",
            "Table: `payments`\nColumns:\n(`customerNumber`, Int64, primary key)\n(`checkNumber`, String, primary key)\n(`paymentDate`, Date32)\n(`amount`, Float64)\n"
        ]
    },
    {
        "sql_id": 152,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(t2.quantityOrdered) FROM orders AS t1 INNER JOIN orderdetails AS t2 ON t1.orderNumber = t2.orderNumber INNER JOIN products AS t3 ON t2.productCode = t3.productCode WHERE t3.productLine = 'motorcycles' AND STRFTIME('%Y', t1.orderDate) = '2004'",
        "target_query": "SELECT SUM(`t2`.`quantityOrdered`) \nFROM `orders` AS `t1` \nINNER JOIN `orderdetails` AS `t2` ON `t1`.`orderNumber` = `t2`.`orderNumber` \nINNER JOIN `products` AS `t3` ON `t2`.`productCode` = `t3`.`productCode` \nWHERE `t3`.`productLine` = 'motorcycles' \nAND formatDateTime(`t1`.`orderDate`, '%Y') = '2004';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 216,
                "end_index": 244,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 257,
                "end_index": 295,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `orders`\nColumns:\n(`orderNumber`, integer, primary key)\n(`orderDate`, date)\n(`requiredDate`, date)\n(`shippedDate`, date)\n(`status`, text)\n(`comments`, text)\n(`customerNumber`, integer)\n",
            "Table: `orderdetails`\nColumns:\n(`orderNumber`, integer, primary key)\n(`productCode`, text, primary key)\n(`quantityOrdered`, integer)\n(`priceEach`, real)\n(`orderLineNumber`, integer)\n",
            "Table: `products`\nColumns:\n(`productCode`, text, primary key)\n(`productName`, text)\n(`productLine`, text)\n(`productScale`, text)\n(`productVendor`, text)\n(`productDescription`, text)\n(`quantityInStock`, integer)\n(`buyPrice`, real)\n(`MSRP`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `orders`\nColumns:\n(`orderNumber`, Int64, primary key)\n(`orderDate`, Date32)\n(`requiredDate`, Date32)\n(`shippedDate`, Date32)\n(`status`, String)\n(`comments`, String)\n(`customerNumber`, Int64)\n",
            "Table: `orderdetails`\nColumns:\n(`orderNumber`, Int64, primary key)\n(`productCode`, String, primary key)\n(`quantityOrdered`, Int64)\n(`priceEach`, Float64)\n(`orderLineNumber`, Int64)\n",
            "Table: `products`\nColumns:\n(`productCode`, String, primary key)\n(`productName`, String)\n(`productLine`, String)\n(`productScale`, String)\n(`productVendor`, String)\n(`productDescription`, String)\n(`quantityInStock`, Int64)\n(`buyPrice`, Float64)\n(`MSRP`, Float64)\n"
        ]
    },
    {
        "sql_id": 153,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT STRFTIME('%Y', t1.paymentDate), COUNT(t1.customerNumber) FROM payments AS t1 WHERE t1.amount < 10000 GROUP BY STRFTIME('%Y', t1.paymentDate)",
        "target_query": "SELECT formatDateTime(`t1`.`paymentDate`, '%Y'), COUNT(`t1`.`customerNumber`) FROM `payments` AS `t1` WHERE `t1`.`amount` < 10000 GROUP BY formatDateTime(`t1`.`paymentDate`, '%Y');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 37,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 117,
                "end_index": 147,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 47,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            },
            {
                "start_index": 139,
                "end_index": 179,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `payments`\nColumns:\n(`customerNumber`, integer, primary key)\n(`checkNumber`, text, primary key)\n(`paymentDate`, date)\n(`amount`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `payments`\nColumns:\n(`customerNumber`, Int64, primary key)\n(`checkNumber`, String, primary key)\n(`paymentDate`, Date32)\n(`amount`, Float64)\n"
        ]
    },
    {
        "sql_id": 154,
        "database_name": "car_retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT t3.productName, SUM(t2.quantityOrdered) FROM orders AS t1 INNER JOIN orderdetails AS t2 ON t1.orderNumber = t2.orderNumber INNER JOIN products AS t3 ON t2.productCode = t3.productCode WHERE STRFTIME('%Y', t1.orderDate) = '2003' GROUP BY t3.productName ORDER BY SUM(t2.quantityOrdered) DESC LIMIT 3",
        "target_query": "SELECT `t3`.`productName`, SUM(`t2`.`quantityOrdered`) \nFROM `orders` AS `t1` \nINNER JOIN `orderdetails` AS `t2` ON `t1`.`orderNumber` = `t2`.`orderNumber` \nINNER JOIN `products` AS `t3` ON `t2`.`productCode` = `t3`.`productCode` \nWHERE formatDateTime(`t1`.`orderDate`, '%Y') = '2003' \nGROUP BY `t3`.`productName` \nORDER BY SUM(`t2`.`quantityOrdered`) DESC \nLIMIT 3;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 197,
                "end_index": 225,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 237,
                "end_index": 275,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `orders`\nColumns:\n(`orderNumber`, integer, primary key)\n(`orderDate`, date)\n(`requiredDate`, date)\n(`shippedDate`, date)\n(`status`, text)\n(`comments`, text)\n(`customerNumber`, integer)\n",
            "Table: `orderdetails`\nColumns:\n(`orderNumber`, integer, primary key)\n(`productCode`, text, primary key)\n(`quantityOrdered`, integer)\n(`priceEach`, real)\n(`orderLineNumber`, integer)\n",
            "Table: `products`\nColumns:\n(`productCode`, text, primary key)\n(`productName`, text)\n(`productLine`, text)\n(`productScale`, text)\n(`productVendor`, text)\n(`productDescription`, text)\n(`quantityInStock`, integer)\n(`buyPrice`, real)\n(`MSRP`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `orders`\nColumns:\n(`orderNumber`, Int64, primary key)\n(`orderDate`, Date32)\n(`requiredDate`, Date32)\n(`shippedDate`, Date32)\n(`status`, String)\n(`comments`, String)\n(`customerNumber`, Int64)\n",
            "Table: `orderdetails`\nColumns:\n(`orderNumber`, Int64, primary key)\n(`productCode`, String, primary key)\n(`quantityOrdered`, Int64)\n(`priceEach`, Float64)\n(`orderLineNumber`, Int64)\n",
            "Table: `products`\nColumns:\n(`productCode`, String, primary key)\n(`productName`, String)\n(`productLine`, String)\n(`productScale`, String)\n(`productVendor`, String)\n(`productDescription`, String)\n(`quantityInStock`, Int64)\n(`buyPrice`, Float64)\n(`MSRP`, Float64)\n"
        ]
    },
    {
        "sql_id": 588,
        "database_name": "chicago_crime",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(COUNT(T1.fbi_code_no) AS REAL) / 4 FROM FBI_Code AS T1 INNER JOIN Crime AS T2 ON T1.fbi_code_no = T2.fbi_code_no WHERE SUBSTR(T2.date, 1, 1) = '1' AND SUBSTR(T2.date, 5, 4) = '2018'",
        "target_query": "SELECT CAST(COUNT(`T1`.`fbi_code_no`) AS Float64) / 4 FROM `FBI_Code` AS `T1` INNER JOIN `Crime` AS `T2` ON `T1`.`fbi_code_no` = `T2`.`fbi_code_no` WHERE substring(`T2`.`date`, 1, 1) = '1' AND substring(`T2`.`date`, 5, 4) = '2018';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 131,
                "end_index": 152,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 163,
                "end_index": 184,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 154,
                "end_index": 182,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            },
            {
                "start_index": 193,
                "end_index": 221,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `FBI_Code`\nColumns:\n(`fbi_code_no`, text, primary key)\n(`title`, text)\n(`description`, text)\n(`crime_against`, text)\n",
            "Table: `Crime`\nColumns:\n(`report_no`, integer, primary key)\n(`case_number`, text)\n(`date`, text)\n(`block`, text)\n(`iucr_no`, text)\n(`location_description`, text)\n(`arrest`, text)\n(`domestic`, text)\n(`beat`, integer)\n(`district_no`, integer)\n(`ward_no`, integer)\n(`community_area_no`, integer)\n(`fbi_code_no`, text)\n(`latitude`, text)\n(`longitude`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `FBI_Code`\nColumns:\n(`fbi_code_no`, String, primary key)\n(`title`, String)\n(`description`, String)\n(`crime_against`, String)\n",
            "Table: `Crime`\nColumns:\n(`report_no`, Int64, primary key)\n(`case_number`, String)\n(`date`, String)\n(`block`, String)\n(`iucr_no`, String)\n(`location_description`, String)\n(`arrest`, String)\n(`domestic`, String)\n(`beat`, Int64)\n(`district_no`, Int64)\n(`ward_no`, Int64)\n(`community_area_no`, Int64)\n(`fbi_code_no`, String)\n(`latitude`, String)\n(`longitude`, String)\n"
        ]
    },
    {
        "sql_id": 591,
        "database_name": "chicago_crime",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(CASE WHEN SUBSTR(T2.date, 5, 4) = '2018' THEN 1 ELSE 0 END) FROM FBI_Code AS T1 INNER JOIN Crime AS T2 ON T1.fbi_code_no = T2.fbi_code_no WHERE T1.crime_against = 'Property' AND SUBSTR(T2.date, 1, 1) = '1'",
        "target_query": "SELECT SUM(CASE WHEN substring(T2.`date`, 5, 4) = '2018' THEN 1 ELSE 0 END) FROM `FBI_Code` AS T1 INNER JOIN `Crime` AS T2 ON T1.`fbi_code_no` = T2.`fbi_code_no` WHERE T1.`crime_against` = 'Property' AND substring(T2.`date`, 1, 1) = '1';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 42,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 189,
                "end_index": 210,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 47,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            },
            {
                "start_index": 204,
                "end_index": 230,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `FBI_Code`\nColumns:\n(`fbi_code_no`, text, primary key)\n(`title`, text)\n(`description`, text)\n(`crime_against`, text)\n",
            "Table: `Crime`\nColumns:\n(`report_no`, integer, primary key)\n(`case_number`, text)\n(`date`, text)\n(`block`, text)\n(`iucr_no`, text)\n(`location_description`, text)\n(`arrest`, text)\n(`domestic`, text)\n(`beat`, integer)\n(`district_no`, integer)\n(`ward_no`, integer)\n(`community_area_no`, integer)\n(`fbi_code_no`, text)\n(`latitude`, text)\n(`longitude`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `FBI_Code`\nColumns:\n(`fbi_code_no`, String, primary key)\n(`title`, String)\n(`description`, String)\n(`crime_against`, String)\n",
            "Table: `Crime`\nColumns:\n(`report_no`, Int64, primary key)\n(`case_number`, String)\n(`date`, String)\n(`block`, String)\n(`iucr_no`, String)\n(`location_description`, String)\n(`arrest`, String)\n(`domestic`, String)\n(`beat`, Int64)\n(`district_no`, Int64)\n(`ward_no`, Int64)\n(`community_area_no`, Int64)\n(`fbi_code_no`, String)\n(`latitude`, String)\n(`longitude`, String)\n"
        ]
    },
    {
        "sql_id": 592,
        "database_name": "chicago_crime",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(CASE WHEN SUBSTR(T2.date, 5, 4) = '2018' THEN 1 ELSE 0 END) FROM District AS T1 INNER JOIN Crime AS T2 ON T1.district_no = T2.district_no WHERE T1.commander = 'Robert A. Rubio' AND SUBSTR(T2.date, 1, 1) = '1'",
        "target_query": "SELECT SUM(CASE WHEN substring(T2.`date`, 5, 4) = '2018' THEN 1 ELSE 0 END) FROM `District` AS T1 INNER JOIN `Crime` AS T2 ON T1.`district_no` = T2.`district_no` WHERE T1.`commander` = 'Robert A. Rubio' AND substring(T2.`date`, 1, 1) = '1';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 42,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 192,
                "end_index": 213,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 47,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            },
            {
                "start_index": 207,
                "end_index": 233,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `District`\nColumns:\n(`district_no`, integer, primary key)\n(`district_name`, text)\n(`address`, text)\n(`zip_code`, integer)\n(`commander`, text)\n(`email`, text)\n(`phone`, text)\n(`fax`, text)\n(`tty`, text)\n(`twitter`, text)\n",
            "Table: `Crime`\nColumns:\n(`report_no`, integer, primary key)\n(`case_number`, text)\n(`date`, text)\n(`block`, text)\n(`iucr_no`, text)\n(`location_description`, text)\n(`arrest`, text)\n(`domestic`, text)\n(`beat`, integer)\n(`district_no`, integer)\n(`ward_no`, integer)\n(`community_area_no`, integer)\n(`fbi_code_no`, text)\n(`latitude`, text)\n(`longitude`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `District`\nColumns:\n(`district_no`, Int64, primary key)\n(`district_name`, String)\n(`address`, String)\n(`zip_code`, Int64)\n(`commander`, String)\n(`email`, String)\n(`phone`, String)\n(`fax`, String)\n(`tty`, String)\n(`twitter`, String)\n",
            "Table: `Crime`\nColumns:\n(`report_no`, Int64, primary key)\n(`case_number`, String)\n(`date`, String)\n(`block`, String)\n(`iucr_no`, String)\n(`location_description`, String)\n(`arrest`, String)\n(`domestic`, String)\n(`beat`, Int64)\n(`district_no`, Int64)\n(`ward_no`, Int64)\n(`community_area_no`, Int64)\n(`fbi_code_no`, String)\n(`latitude`, String)\n(`longitude`, String)\n"
        ]
    },
    {
        "sql_id": 593,
        "database_name": "chicago_crime",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.commander FROM District AS T1 INNER JOIN Crime AS T2 ON T1.district_no = T2.district_no WHERE T1.commander IN ('Robert A. Rubio', 'Glenn White') AND SUBSTR(T2.date, 1, 1) = '1' AND SUBSTR(T2.date, 5, 4) = '2018' GROUP BY T1.commander",
        "target_query": "SELECT `T1`.`commander` FROM `District` AS `T1` INNER JOIN `Crime` AS `T2` ON `T1`.`district_no` = `T2`.`district_no` WHERE `T1`.`commander` IN ('Robert A. Rubio', 'Glenn White') AND substring(`T2`.`date`, 1, 1) = '1' AND substring(`T2`.`date`, 5, 4) = '2018' GROUP BY `T1`.`commander`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 159,
                "end_index": 180,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 191,
                "end_index": 212,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 183,
                "end_index": 211,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            },
            {
                "start_index": 222,
                "end_index": 250,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `District`\nColumns:\n(`district_no`, integer, primary key)\n(`district_name`, text)\n(`address`, text)\n(`zip_code`, integer)\n(`commander`, text)\n(`email`, text)\n(`phone`, text)\n(`fax`, text)\n(`tty`, text)\n(`twitter`, text)\n",
            "Table: `Crime`\nColumns:\n(`report_no`, integer, primary key)\n(`case_number`, text)\n(`date`, text)\n(`block`, text)\n(`iucr_no`, text)\n(`location_description`, text)\n(`arrest`, text)\n(`domestic`, text)\n(`beat`, integer)\n(`district_no`, integer)\n(`ward_no`, integer)\n(`community_area_no`, integer)\n(`fbi_code_no`, text)\n(`latitude`, text)\n(`longitude`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `District`\nColumns:\n(`district_no`, Int64, primary key)\n(`district_name`, String)\n(`address`, String)\n(`zip_code`, Int64)\n(`commander`, String)\n(`email`, String)\n(`phone`, String)\n(`fax`, String)\n(`tty`, String)\n(`twitter`, String)\n",
            "Table: `Crime`\nColumns:\n(`report_no`, Int64, primary key)\n(`case_number`, String)\n(`date`, String)\n(`block`, String)\n(`iucr_no`, String)\n(`location_description`, String)\n(`arrest`, String)\n(`domestic`, String)\n(`beat`, Int64)\n(`district_no`, Int64)\n(`ward_no`, Int64)\n(`community_area_no`, Int64)\n(`fbi_code_no`, String)\n(`latitude`, String)\n(`longitude`, String)\n"
        ]
    },
    {
        "sql_id": 49,
        "database_name": "codebase_comments",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUBSTR(SUBSTR(Name, INSTR(Name, '.') + 1), 1, INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.') - 1) task FROM Method WHERE NameTokenized = 'html parser feed'",
        "target_query": "SELECT substring(substring(`Name`, positionCaseInsensitive(`Name`, '.') + 1), 1, positionCaseInsensitive(substring(`Name`, positionCaseInsensitive(`Name`, '.') + 1), '.') - 1) AS `task` FROM `Method` WHERE `NameTokenized` = 'html parser feed';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 43,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 59,
                "end_index": 88,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 71,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            },
            {
                "start_index": 105,
                "end_index": 159,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "instr(X,Y)",
                "explanation": "The instr(X,Y) function finds the first occurrence of string Y within \n  string X and returns the number of prior characters plus 1, or 0 if\n  Y is nowhere found within X.\n  Or, if X and Y are both BLOBs, then instr(X,Y) returns one\n  more than the number bytes prior to the first occurrence of Y, or 0 if\n  Y does not occur anywhere within X.\n  If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs\n  then both are interpreted as strings.\n  If either X or Y are NULL in instr(X,Y) then the result is NULL.\n",
                "examples": [
                    "SELECT instr('Hello World', 'World'); -- Returns 7",
                    "SELECT instr('abcdefg', 'x'); -- Returns 0 (not found)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "positionCaseInsensitive",
                "explanation": "positionCaseInsensitive\nA case insensitive invariant of position.",
                "examples": [
                    "SELECT positionCaseInsensitive('Hello, world!', 'hello');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Method`\nColumns:\n(`Id`, integer, primary key)\n(`Name`, text)\n(`FullComment`, text)\n(`Summary`, text)\n(`ApiCalls`, text)\n(`CommentIsXml`, integer)\n(`SampledAt`, integer)\n(`SolutionId`, integer)\n(`Lang`, text)\n(`NameTokenized`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Method`\nColumns:\n(`Id`, Int64, primary key)\n(`Name`, String)\n(`FullComment`, String)\n(`Summary`, String)\n(`ApiCalls`, String)\n(`CommentIsXml`, Int64)\n(`SampledAt`, Int64)\n(`SolutionId`, Int64)\n(`Lang`, String)\n(`NameTokenized`, String)\n"
        ]
    },
    {
        "sql_id": 50,
        "database_name": "codebase_comments",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUBSTR(SUBSTR(Name, INSTR(Name, '.') + 1), 1, INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.') - 1) task FROM Method WHERE Id = 2",
        "target_query": "SELECT substring(substring(`Name`, positionCaseInsensitive(`Name`, '.') + 1), 1, positionCaseInsensitive(substring(`Name`, positionCaseInsensitive(`Name`, '.') + 1), '.') - 1) AS `task` FROM `Method` WHERE `Id` = 2;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 43,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 59,
                "end_index": 88,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 71,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            },
            {
                "start_index": 105,
                "end_index": 159,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "instr(X,Y)",
                "explanation": "The instr(X,Y) function finds the first occurrence of string Y within \n  string X and returns the number of prior characters plus 1, or 0 if\n  Y is nowhere found within X.\n  Or, if X and Y are both BLOBs, then instr(X,Y) returns one\n  more than the number bytes prior to the first occurrence of Y, or 0 if\n  Y does not occur anywhere within X.\n  If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs\n  then both are interpreted as strings.\n  If either X or Y are NULL in instr(X,Y) then the result is NULL.\n",
                "examples": [
                    "SELECT instr('Hello World', 'World'); -- Returns 7",
                    "SELECT instr('abcdefg', 'x'); -- Returns 0 (not found)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "positionCaseInsensitive",
                "explanation": "positionCaseInsensitive\nA case insensitive invariant of position.",
                "examples": [
                    "SELECT positionCaseInsensitive('Hello, world!', 'hello');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Method`\nColumns:\n(`Id`, integer, primary key)\n(`Name`, text)\n(`FullComment`, text)\n(`Summary`, text)\n(`ApiCalls`, text)\n(`CommentIsXml`, integer)\n(`SampledAt`, integer)\n(`SolutionId`, integer)\n(`Lang`, text)\n(`NameTokenized`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Method`\nColumns:\n(`Id`, Int64, primary key)\n(`Name`, String)\n(`FullComment`, String)\n(`Summary`, String)\n(`ApiCalls`, String)\n(`CommentIsXml`, Int64)\n(`SampledAt`, Int64)\n(`SolutionId`, Int64)\n(`Lang`, String)\n(`NameTokenized`, String)\n"
        ]
    },
    {
        "sql_id": 52,
        "database_name": "codebase_comments",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT SUBSTR(SUBSTR(Name, INSTR(Name, '.') + 1), 1, INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.') - 1) task FROM Method WHERE NameTokenized = 'string extensions to pascal case'",
        "target_query": "SELECT DISTINCT substring(substring(`Name`, positionCaseInsensitive(`Name`, '.') + 1), 1, positionCaseInsensitive(substring(`Name`, positionCaseInsensitive(`Name`, '.') + 1), '.') - 1) AS `task` FROM `Method` WHERE `NameTokenized` = 'string extensions to pascal case';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 52,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 68,
                "end_index": 97,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 80,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            },
            {
                "start_index": 114,
                "end_index": 168,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "instr(X,Y)",
                "explanation": "The instr(X,Y) function finds the first occurrence of string Y within \n  string X and returns the number of prior characters plus 1, or 0 if\n  Y is nowhere found within X.\n  Or, if X and Y are both BLOBs, then instr(X,Y) returns one\n  more than the number bytes prior to the first occurrence of Y, or 0 if\n  Y does not occur anywhere within X.\n  If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs\n  then both are interpreted as strings.\n  If either X or Y are NULL in instr(X,Y) then the result is NULL.\n",
                "examples": [
                    "SELECT instr('Hello World', 'World'); -- Returns 7",
                    "SELECT instr('abcdefg', 'x'); -- Returns 0 (not found)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "positionCaseInsensitive",
                "explanation": "positionCaseInsensitive\nA case insensitive invariant of position.",
                "examples": [
                    "SELECT positionCaseInsensitive('Hello, world!', 'hello');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Method`\nColumns:\n(`Id`, integer, primary key)\n(`Name`, text)\n(`FullComment`, text)\n(`Summary`, text)\n(`ApiCalls`, text)\n(`CommentIsXml`, integer)\n(`SampledAt`, integer)\n(`SolutionId`, integer)\n(`Lang`, text)\n(`NameTokenized`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Method`\nColumns:\n(`Id`, Int64, primary key)\n(`Name`, String)\n(`FullComment`, String)\n(`Summary`, String)\n(`ApiCalls`, String)\n(`CommentIsXml`, Int64)\n(`SampledAt`, Int64)\n(`SolutionId`, Int64)\n(`Lang`, String)\n(`NameTokenized`, String)\n"
        ]
    },
    {
        "sql_id": 48,
        "database_name": "codebase_comments",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUBSTR(SUBSTR(Name, INSTR(Name, '.') + 1), 1, INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.') - 1) task FROM Method WHERE NameTokenized = 'online median filter test median window filling'",
        "target_query": "SELECT substring(substring(`Name`, positionCaseInsensitive(`Name`, '.') + 1), 1, positionCaseInsensitive(substring(`Name`, positionCaseInsensitive(`Name`, '.') + 1), '.') - 1) AS `task` FROM `Method` WHERE `NameTokenized` = 'online median filter test median window filling';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 43,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 59,
                "end_index": 88,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 71,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            },
            {
                "start_index": 105,
                "end_index": 159,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "instr(X,Y)",
                "explanation": "The instr(X,Y) function finds the first occurrence of string Y within \n  string X and returns the number of prior characters plus 1, or 0 if\n  Y is nowhere found within X.\n  Or, if X and Y are both BLOBs, then instr(X,Y) returns one\n  more than the number bytes prior to the first occurrence of Y, or 0 if\n  Y does not occur anywhere within X.\n  If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs\n  then both are interpreted as strings.\n  If either X or Y are NULL in instr(X,Y) then the result is NULL.\n",
                "examples": [
                    "SELECT instr('Hello World', 'World'); -- Returns 7",
                    "SELECT instr('abcdefg', 'x'); -- Returns 0 (not found)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "positionCaseInsensitive",
                "explanation": "positionCaseInsensitive\nA case insensitive invariant of position.",
                "examples": [
                    "SELECT positionCaseInsensitive('Hello, world!', 'hello');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Method`\nColumns:\n(`Id`, integer, primary key)\n(`Name`, text)\n(`FullComment`, text)\n(`Summary`, text)\n(`ApiCalls`, text)\n(`CommentIsXml`, integer)\n(`SampledAt`, integer)\n(`SolutionId`, integer)\n(`Lang`, text)\n(`NameTokenized`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Method`\nColumns:\n(`Id`, Int64, primary key)\n(`Name`, String)\n(`FullComment`, String)\n(`Summary`, String)\n(`ApiCalls`, String)\n(`CommentIsXml`, Int64)\n(`SampledAt`, Int64)\n(`SolutionId`, Int64)\n(`Lang`, String)\n(`NameTokenized`, String)\n"
        ]
    },
    {
        "sql_id": 443,
        "database_name": "coinmarketcap",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.time_high, T2.time_low, T2.date FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T1.name = 'WARP' AND STRFTIME('%Y-%m', T2.date) = '2016-08'",
        "target_query": "SELECT T2.`time_high`, T2.`time_low`, T2.`date` FROM `coins` AS T1 INNER JOIN `historical` AS T2 ON T1.`id` = T2.`coin_id` WHERE T1.`name` = 'WARP' AND formatDateTime(T2.`date`, '%Y-%m') = '2016-08';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 136,
                "end_index": 162,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 152,
                "end_index": 186,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `coins`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`slug`, text)\n(`symbol`, text)\n(`status`, text)\n(`category`, text)\n(`description`, text)\n(`subreddit`, text)\n(`notice`, text)\n(`tags`, text)\n(`tag_names`, text)\n(`website`, text)\n(`platform_id`, integer)\n(`date_added`, text)\n(`date_launched`, text)\n",
            "Table: `historical`\nColumns:\n(`date`, date)\n(`coin_id`, integer)\n(`cmc_rank`, integer)\n(`market_cap`, real)\n(`price`, real)\n(`open`, real)\n(`high`, real)\n(`low`, real)\n(`close`, real)\n(`time_high`, text)\n(`time_low`, text)\n(`volume_24h`, real)\n(`percent_change_1h`, real)\n(`percent_change_24h`, real)\n(`percent_change_7d`, real)\n(`circulating_supply`, real)\n(`total_supply`, real)\n(`max_supply`, real)\n(`num_market_pairs`, integer)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `coins`\nColumns:\n(`id`, Int64, primary key)\n(`name`, String)\n(`slug`, String)\n(`symbol`, String)\n(`status`, String)\n(`category`, String)\n(`description`, String)\n(`subreddit`, String)\n(`notice`, String)\n(`tags`, String)\n(`tag_names`, String)\n(`website`, String)\n(`platform_id`, Int64)\n(`date_added`, String)\n(`date_launched`, String)\n",
            "Table: `historical`\nColumns:\n(`date`, Date32)\n(`coin_id`, Int64)\n(`cmc_rank`, Int64)\n(`market_cap`, Float64)\n(`price`, Float64)\n(`open`, Float64)\n(`high`, Float64)\n(`low`, Float64)\n(`close`, Float64)\n(`time_high`, String)\n(`time_low`, String)\n(`volume_24h`, Float64)\n(`percent_change_1h`, Float64)\n(`percent_change_24h`, Float64)\n(`percent_change_7d`, Float64)\n(`circulating_supply`, Float64)\n(`total_supply`, Float64)\n(`max_supply`, Float64)\n(`num_market_pairs`, Int64)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 444,
        "database_name": "coinmarketcap",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(T2.circulating_supply) AS REAL) / 12 FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T1.name = 'Frozen' AND STRFTIME('%Y', T2.date) = '2014'",
        "target_query": "SELECT SUM(`T2`.`circulating_supply`) / 12 FROM `coins` AS `T1` INNER JOIN `historical` AS `T2` ON `T1`.`id` = `T2`.`coin_id` WHERE `T1`.`name` = 'Frozen' AND formatDateTime(`T2`.`date`, '%Y') = '2014';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 149,
                "end_index": 172,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 159,
                "end_index": 192,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `coins`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`slug`, text)\n(`symbol`, text)\n(`status`, text)\n(`category`, text)\n(`description`, text)\n(`subreddit`, text)\n(`notice`, text)\n(`tags`, text)\n(`tag_names`, text)\n(`website`, text)\n(`platform_id`, integer)\n(`date_added`, text)\n(`date_launched`, text)\n",
            "Table: `historical`\nColumns:\n(`date`, date)\n(`coin_id`, integer)\n(`cmc_rank`, integer)\n(`market_cap`, real)\n(`price`, real)\n(`open`, real)\n(`high`, real)\n(`low`, real)\n(`close`, real)\n(`time_high`, text)\n(`time_low`, text)\n(`volume_24h`, real)\n(`percent_change_1h`, real)\n(`percent_change_24h`, real)\n(`percent_change_7d`, real)\n(`circulating_supply`, real)\n(`total_supply`, real)\n(`max_supply`, real)\n(`num_market_pairs`, integer)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `coins`\nColumns:\n(`id`, Int64, primary key)\n(`name`, String)\n(`slug`, String)\n(`symbol`, String)\n(`status`, String)\n(`category`, String)\n(`description`, String)\n(`subreddit`, String)\n(`notice`, String)\n(`tags`, String)\n(`tag_names`, String)\n(`website`, String)\n(`platform_id`, Int64)\n(`date_added`, String)\n(`date_launched`, String)\n",
            "Table: `historical`\nColumns:\n(`date`, Date32)\n(`coin_id`, Int64)\n(`cmc_rank`, Int64)\n(`market_cap`, Float64)\n(`price`, Float64)\n(`open`, Float64)\n(`high`, Float64)\n(`low`, Float64)\n(`close`, Float64)\n(`time_high`, String)\n(`time_low`, String)\n(`volume_24h`, Float64)\n(`percent_change_1h`, Float64)\n(`percent_change_24h`, Float64)\n(`percent_change_7d`, Float64)\n(`circulating_supply`, Float64)\n(`total_supply`, Float64)\n(`max_supply`, Float64)\n(`num_market_pairs`, Int64)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 445,
        "database_name": "coinmarketcap",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT AVG(T2.price) FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T1.name = 'Bitcoin' AND STRFTIME('%Y', T2.date) = '2016'",
        "target_query": "SELECT AVG(`T2`.`price`) FROM `coins` AS `T1` INNER JOIN `historical` AS `T2` ON `T1`.`id` = `T2`.`coin_id` WHERE `T1`.`name` = 'Bitcoin' AND formatDateTime(`T2`.`date`, '%Y') = '2016';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 118,
                "end_index": 141,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 142,
                "end_index": 175,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `coins`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`slug`, text)\n(`symbol`, text)\n(`status`, text)\n(`category`, text)\n(`description`, text)\n(`subreddit`, text)\n(`notice`, text)\n(`tags`, text)\n(`tag_names`, text)\n(`website`, text)\n(`platform_id`, integer)\n(`date_added`, text)\n(`date_launched`, text)\n",
            "Table: `historical`\nColumns:\n(`date`, date)\n(`coin_id`, integer)\n(`cmc_rank`, integer)\n(`market_cap`, real)\n(`price`, real)\n(`open`, real)\n(`high`, real)\n(`low`, real)\n(`close`, real)\n(`time_high`, text)\n(`time_low`, text)\n(`volume_24h`, real)\n(`percent_change_1h`, real)\n(`percent_change_24h`, real)\n(`percent_change_7d`, real)\n(`circulating_supply`, real)\n(`total_supply`, real)\n(`max_supply`, real)\n(`num_market_pairs`, integer)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `coins`\nColumns:\n(`id`, Int64, primary key)\n(`name`, String)\n(`slug`, String)\n(`symbol`, String)\n(`status`, String)\n(`category`, String)\n(`description`, String)\n(`subreddit`, String)\n(`notice`, String)\n(`tags`, String)\n(`tag_names`, String)\n(`website`, String)\n(`platform_id`, Int64)\n(`date_added`, String)\n(`date_launched`, String)\n",
            "Table: `historical`\nColumns:\n(`date`, Date32)\n(`coin_id`, Int64)\n(`cmc_rank`, Int64)\n(`market_cap`, Float64)\n(`price`, Float64)\n(`open`, Float64)\n(`high`, Float64)\n(`low`, Float64)\n(`close`, Float64)\n(`time_high`, String)\n(`time_low`, String)\n(`volume_24h`, Float64)\n(`percent_change_1h`, Float64)\n(`percent_change_24h`, Float64)\n(`percent_change_7d`, Float64)\n(`circulating_supply`, Float64)\n(`total_supply`, Float64)\n(`max_supply`, Float64)\n(`num_market_pairs`, Int64)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 446,
        "database_name": "coinmarketcap",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT AVG(T2.price) FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE STRFTIME('%Y', T2.date) = '2013' AND T1.name = 'Bitcoin'",
        "target_query": "SELECT AVG(`T2`.`price`) FROM `coins` AS `T1` INNER JOIN `historical` AS `T2` ON `T1`.`id` = `T2`.`coin_id` WHERE formatDateTime(`T2`.`date`, '%Y') = '2013' AND `T1`.`name` = 'Bitcoin';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 94,
                "end_index": 117,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 114,
                "end_index": 147,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `coins`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`slug`, text)\n(`symbol`, text)\n(`status`, text)\n(`category`, text)\n(`description`, text)\n(`subreddit`, text)\n(`notice`, text)\n(`tags`, text)\n(`tag_names`, text)\n(`website`, text)\n(`platform_id`, integer)\n(`date_added`, text)\n(`date_launched`, text)\n",
            "Table: `historical`\nColumns:\n(`date`, date)\n(`coin_id`, integer)\n(`cmc_rank`, integer)\n(`market_cap`, real)\n(`price`, real)\n(`open`, real)\n(`high`, real)\n(`low`, real)\n(`close`, real)\n(`time_high`, text)\n(`time_low`, text)\n(`volume_24h`, real)\n(`percent_change_1h`, real)\n(`percent_change_24h`, real)\n(`percent_change_7d`, real)\n(`circulating_supply`, real)\n(`total_supply`, real)\n(`max_supply`, real)\n(`num_market_pairs`, integer)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `coins`\nColumns:\n(`id`, Int64, primary key)\n(`name`, String)\n(`slug`, String)\n(`symbol`, String)\n(`status`, String)\n(`category`, String)\n(`description`, String)\n(`subreddit`, String)\n(`notice`, String)\n(`tags`, String)\n(`tag_names`, String)\n(`website`, String)\n(`platform_id`, Int64)\n(`date_added`, String)\n(`date_launched`, String)\n",
            "Table: `historical`\nColumns:\n(`date`, Date32)\n(`coin_id`, Int64)\n(`cmc_rank`, Int64)\n(`market_cap`, Float64)\n(`price`, Float64)\n(`open`, Float64)\n(`high`, Float64)\n(`low`, Float64)\n(`close`, Float64)\n(`time_high`, String)\n(`time_low`, String)\n(`volume_24h`, Float64)\n(`percent_change_1h`, Float64)\n(`percent_change_24h`, Float64)\n(`percent_change_7d`, Float64)\n(`circulating_supply`, Float64)\n(`total_supply`, Float64)\n(`max_supply`, Float64)\n(`num_market_pairs`, Int64)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 448,
        "database_name": "coinmarketcap",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT name FROM coins WHERE LENGTH(tag_names) - LENGTH(replace(tag_names, ',', '')) = 2",
        "target_query": "SELECT `name` FROM `coins` WHERE length(`tag_names`) - length(replace(`tag_names`, ',', '')) = 2;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 29,
                "end_index": 46,
                "dialect_content": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "feature": "length(X)"
            },
            {
                "start_index": 49,
                "end_index": 83,
                "dialect_content": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "feature": "length(X)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 33,
                "end_index": 52,
                "dialect_content": "The length(str) function returns the number of bytes in the given string str. Unlike SQLite, which counts Unicode code points for strings, ClickHouse measures the length in bytes. For multibyte characters (UTF-8 encoded), the byte count may be larger than the character count. If str is NULL, the function returns NULL.",
                "feature": "length(str)"
            },
            {
                "start_index": 55,
                "end_index": 91,
                "dialect_content": "The length(str) function returns the number of bytes in the given string str. Unlike SQLite, which counts Unicode code points for strings, ClickHouse measures the length in bytes. For multibyte characters (UTF-8 encoded), the byte count may be larger than the character count. If str is NULL, the function returns NULL.",
                "feature": "length(str)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "length(str)",
                "explanation": "The length(str) function returns the number of bytes in the given string str. Unlike SQLite, which counts Unicode code points for strings, ClickHouse measures the length in bytes. For multibyte characters (UTF-8 encoded), the byte count may be larger than the character count. If str is NULL, the function returns NULL.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(unhex('68656C6C6F')); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `coins`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`slug`, text)\n(`symbol`, text)\n(`status`, text)\n(`category`, text)\n(`description`, text)\n(`subreddit`, text)\n(`notice`, text)\n(`tags`, text)\n(`tag_names`, text)\n(`website`, text)\n(`platform_id`, integer)\n(`date_added`, text)\n(`date_launched`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `coins`\nColumns:\n(`id`, Int64, primary key)\n(`name`, String)\n(`slug`, String)\n(`symbol`, String)\n(`status`, String)\n(`category`, String)\n(`description`, String)\n(`subreddit`, String)\n(`notice`, String)\n(`tags`, String)\n(`tag_names`, String)\n(`website`, String)\n(`platform_id`, Int64)\n(`date_added`, String)\n(`date_launched`, String)\n"
        ]
    },
    {
        "sql_id": 449,
        "database_name": "coinmarketcap",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.name FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE STRFTIME('%Y-%m', T2.date) = '2013-05' AND T2.open IS NULL",
        "target_query": "SELECT `T1`.`name` FROM `coins` AS `T1` INNER JOIN `historical` AS `T2` ON `T1`.`id` = `T2`.`coin_id` WHERE formatDateTime(`T2`.`date`, '%Y-%m') = '2013-05' AND `T2`.`open` IS NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 88,
                "end_index": 114,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 108,
                "end_index": 144,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `coins`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`slug`, text)\n(`symbol`, text)\n(`status`, text)\n(`category`, text)\n(`description`, text)\n(`subreddit`, text)\n(`notice`, text)\n(`tags`, text)\n(`tag_names`, text)\n(`website`, text)\n(`platform_id`, integer)\n(`date_added`, text)\n(`date_launched`, text)\n",
            "Table: `historical`\nColumns:\n(`date`, date)\n(`coin_id`, integer)\n(`cmc_rank`, integer)\n(`market_cap`, real)\n(`price`, real)\n(`open`, real)\n(`high`, real)\n(`low`, real)\n(`close`, real)\n(`time_high`, text)\n(`time_low`, text)\n(`volume_24h`, real)\n(`percent_change_1h`, real)\n(`percent_change_24h`, real)\n(`percent_change_7d`, real)\n(`circulating_supply`, real)\n(`total_supply`, real)\n(`max_supply`, real)\n(`num_market_pairs`, integer)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `coins`\nColumns:\n(`id`, Int64, primary key)\n(`name`, String)\n(`slug`, String)\n(`symbol`, String)\n(`status`, String)\n(`category`, String)\n(`description`, String)\n(`subreddit`, String)\n(`notice`, String)\n(`tags`, String)\n(`tag_names`, String)\n(`website`, String)\n(`platform_id`, Int64)\n(`date_added`, String)\n(`date_launched`, String)\n",
            "Table: `historical`\nColumns:\n(`date`, Date32)\n(`coin_id`, Int64)\n(`cmc_rank`, Int64)\n(`market_cap`, Float64)\n(`price`, Float64)\n(`open`, Float64)\n(`high`, Float64)\n(`low`, Float64)\n(`close`, Float64)\n(`time_high`, String)\n(`time_low`, String)\n(`volume_24h`, Float64)\n(`percent_change_1h`, Float64)\n(`percent_change_24h`, Float64)\n(`percent_change_7d`, Float64)\n(`circulating_supply`, Float64)\n(`total_supply`, Float64)\n(`max_supply`, Float64)\n(`num_market_pairs`, Int64)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 450,
        "database_name": "coinmarketcap",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T2.coin_id) FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T1.name = 'Bytecoin' AND STRFTIME('%Y-%m', T2.date) = '2013-06'",
        "target_query": "SELECT COUNT(`T2`.`coin_id`) FROM `coins` AS `T1` INNER JOIN `historical` AS `T2` ON `T1`.`id` = `T2`.`coin_id` WHERE `T1`.`name` = 'Bytecoin' AND formatDateTime(`T2`.`date`, '%Y-%m') = '2013-06';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 123,
                "end_index": 149,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 147,
                "end_index": 183,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `coins`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`slug`, text)\n(`symbol`, text)\n(`status`, text)\n(`category`, text)\n(`description`, text)\n(`subreddit`, text)\n(`notice`, text)\n(`tags`, text)\n(`tag_names`, text)\n(`website`, text)\n(`platform_id`, integer)\n(`date_added`, text)\n(`date_launched`, text)\n",
            "Table: `historical`\nColumns:\n(`date`, date)\n(`coin_id`, integer)\n(`cmc_rank`, integer)\n(`market_cap`, real)\n(`price`, real)\n(`open`, real)\n(`high`, real)\n(`low`, real)\n(`close`, real)\n(`time_high`, text)\n(`time_low`, text)\n(`volume_24h`, real)\n(`percent_change_1h`, real)\n(`percent_change_24h`, real)\n(`percent_change_7d`, real)\n(`circulating_supply`, real)\n(`total_supply`, real)\n(`max_supply`, real)\n(`num_market_pairs`, integer)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `coins`\nColumns:\n(`id`, Int64, primary key)\n(`name`, String)\n(`slug`, String)\n(`symbol`, String)\n(`status`, String)\n(`category`, String)\n(`description`, String)\n(`subreddit`, String)\n(`notice`, String)\n(`tags`, String)\n(`tag_names`, String)\n(`website`, String)\n(`platform_id`, Int64)\n(`date_added`, String)\n(`date_launched`, String)\n",
            "Table: `historical`\nColumns:\n(`date`, Date32)\n(`coin_id`, Int64)\n(`cmc_rank`, Int64)\n(`market_cap`, Float64)\n(`price`, Float64)\n(`open`, Float64)\n(`high`, Float64)\n(`low`, Float64)\n(`close`, Float64)\n(`time_high`, String)\n(`time_low`, String)\n(`volume_24h`, Float64)\n(`percent_change_1h`, Float64)\n(`percent_change_24h`, Float64)\n(`percent_change_7d`, Float64)\n(`circulating_supply`, Float64)\n(`total_supply`, Float64)\n(`max_supply`, Float64)\n(`num_market_pairs`, Int64)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 609,
        "database_name": "craftbeer",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T1.style = 'American Adjunct Lager', 1, 0)) AS REAL) * 100 / COUNT(T1.brewery_id) FROM beers AS T1 INNER JOIN breweries AS T2 ON T1.brewery_id = T2.id WHERE T2.name = 'Stevens Point Brewery'",
        "target_query": "SELECT CAST(SUM(if(T1.style = 'American Adjunct Lager', 1, 0)) AS Float64) * 100 / COUNT(T1.brewery_id) FROM `beers` AS T1 INNER JOIN `breweries` AS T2 ON T1.brewery_id = T2.id WHERE T2.name = 'Stevens Point Brewery';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 62,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 61,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `beers`\nColumns:\n(`id`, integer, primary key)\n(`brewery_id`, integer)\n(`abv`, real)\n(`ibu`, real)\n(`name`, text)\n(`style`, text)\n(`ounces`, real)\n",
            "Table: `breweries`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`city`, text)\n(`state`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `beers`\nColumns:\n(`id`, Int64, primary key)\n(`brewery_id`, Int64)\n(`abv`, Float64)\n(`ibu`, Float64)\n(`name`, String)\n(`style`, String)\n(`ounces`, Float64)\n",
            "Table: `breweries`\nColumns:\n(`id`, Int64, primary key)\n(`name`, String)\n(`city`, String)\n(`state`, String)\n"
        ]
    },
    {
        "sql_id": 610,
        "database_name": "craftbeer",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T2.state = 'WI', 1, 0)) AS REAL) * 100 / COUNT(T1.id) FROM beers AS T1 INNER JOIN breweries AS T2 ON T1.brewery_id = T2.id WHERE T1.style = 'American Blonde Ale'",
        "target_query": "SELECT CAST(SUM(if(T2.state = 'WI', 1, 0)) AS Float64) * 100 / COUNT(T1.id) FROM `beers` AS T1 INNER JOIN `breweries` AS T2 ON T1.brewery_id = T2.id WHERE T1.style = 'American Blonde Ale';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 42,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 41,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `beers`\nColumns:\n(`id`, integer, primary key)\n(`brewery_id`, integer)\n(`abv`, real)\n(`ibu`, real)\n(`name`, text)\n(`style`, text)\n(`ounces`, real)\n",
            "Table: `breweries`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`city`, text)\n(`state`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `beers`\nColumns:\n(`id`, Int64, primary key)\n(`brewery_id`, Int64)\n(`abv`, Float64)\n(`ibu`, Float64)\n(`name`, String)\n(`style`, String)\n(`ounces`, Float64)\n",
            "Table: `breweries`\nColumns:\n(`id`, Int64, primary key)\n(`name`, String)\n(`city`, String)\n(`state`, String)\n"
        ]
    },
    {
        "sql_id": 309,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(movie_title) FROM characters AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE SUBSTR(release_date, INSTR(release_date, '-') + 1, 3) = 'Dec' AND T2.director = 'Wolfgang Reitherman'",
        "target_query": "SELECT COUNT(`movie_title`) FROM `characters` AS T1 INNER JOIN `director` AS T2 ON T1.`movie_title` = T2.`name` WHERE substring(`release_date`, positionCaseInsensitive(`release_date`, '-') + 1, 3) = 'Dec' AND T2.`director` = 'Wolfgang Reitherman';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 108,
                "end_index": 153,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 118,
                "end_index": 188,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "instr(X,Y)",
                "explanation": "The instr(X,Y) function finds the first occurrence of string Y within \n  string X and returns the number of prior characters plus 1, or 0 if\n  Y is nowhere found within X.\n  Or, if X and Y are both BLOBs, then instr(X,Y) returns one\n  more than the number bytes prior to the first occurrence of Y, or 0 if\n  Y does not occur anywhere within X.\n  If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs\n  then both are interpreted as strings.\n  If either X or Y are NULL in instr(X,Y) then the result is NULL.\n",
                "examples": [
                    "SELECT instr('Hello World', 'World'); -- Returns 7",
                    "SELECT instr('abcdefg', 'x'); -- Returns 0 (not found)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "positionCaseInsensitive",
                "explanation": "positionCaseInsensitive\nA case insensitive invariant of position.",
                "examples": [
                    "SELECT positionCaseInsensitive('Hello, world!', 'hello');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `characters`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text)\n(`hero`, text)\n(`villian`, text)\n(`song`, text)\n",
            "Table: `director`\nColumns:\n(`name`, text, primary key)\n(`director`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `characters`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String)\n(`hero`, String)\n(`villian`, String)\n(`song`, String)\n",
            "Table: `director`\nColumns:\n(`name`, String, primary key)\n(`director`, String)\n"
        ]
    },
    {
        "sql_id": 311,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.song FROM movies_total_gross AS T1 INNER JOIN characters AS T2 ON T1.movie_title = T2.movie_title WHERE CAST(SUBSTR(T1.release_date, INSTR(T1.release_date, ', ') + 1) AS int) BETWEEN 1970 AND 1979 ORDER BY CAST(REPLACE(SUBSTR(T1.total_gross, 2), ',', '') AS float) DESC LIMIT 1",
        "target_query": "SELECT T2.`song` FROM `movies_total_gross` AS T1 INNER JOIN `characters` AS T2 ON T1.`movie_title` = T2.`movie_title` WHERE toInt32(substring(T1.`release_date`, positionCaseInsensitive(T1.`release_date`, ', ') + 2)) BETWEEN 1970 AND 1979 ORDER BY toFloat64(REPLACE(substring(T1.`total_gross`, 2), ',', '')) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 119,
                "end_index": 171,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 229,
                "end_index": 254,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 132,
                "end_index": 209,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            },
            {
                "start_index": 265,
                "end_index": 295,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "instr(X,Y)",
                "explanation": "The instr(X,Y) function finds the first occurrence of string Y within \n  string X and returns the number of prior characters plus 1, or 0 if\n  Y is nowhere found within X.\n  Or, if X and Y are both BLOBs, then instr(X,Y) returns one\n  more than the number bytes prior to the first occurrence of Y, or 0 if\n  Y does not occur anywhere within X.\n  If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs\n  then both are interpreted as strings.\n  If either X or Y are NULL in instr(X,Y) then the result is NULL.\n",
                "examples": [
                    "SELECT instr('Hello World', 'World'); -- Returns 7",
                    "SELECT instr('abcdefg', 'x'); -- Returns 0 (not found)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "positionCaseInsensitive",
                "explanation": "positionCaseInsensitive\nA case insensitive invariant of position.",
                "examples": [
                    "SELECT positionCaseInsensitive('Hello, world!', 'hello');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n",
            "Table: `characters`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text)\n(`hero`, text)\n(`villian`, text)\n(`song`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String, primary key)\n(`genre`, String)\n(`MPAA_rating`, String)\n(`total_gross`, String)\n(`inflation_adjusted_gross`, String)\n",
            "Table: `characters`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String)\n(`hero`, String)\n(`villian`, String)\n(`song`, String)\n"
        ]
    },
    {
        "sql_id": 313,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.movie_title FROM movies_total_gross AS T1 INNER JOIN characters AS T2 ON T1.movie_title = T2.movie_title WHERE T2.hero = 'Donald Duck' ORDER BY CAST(REPLACE(SUBSTR(total_gross, 2), ',', '') AS REAL) DESC LIMIT 1",
        "target_query": "SELECT `T1`.`movie_title` FROM `movies_total_gross` AS `T1` INNER JOIN `characters` AS `T2` ON `T1`.`movie_title` = `T2`.`movie_title` WHERE `T2`.`hero` = 'Donald Duck' ORDER BY CAST(REPLACE(substring(`T1`.`total_gross`, 2), ',', '') AS Float64) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 167,
                "end_index": 189,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 191,
                "end_index": 223,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n",
            "Table: `characters`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text)\n(`hero`, text)\n(`villian`, text)\n(`song`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String, primary key)\n(`genre`, String)\n(`MPAA_rating`, String)\n(`total_gross`, String)\n(`inflation_adjusted_gross`, String)\n",
            "Table: `characters`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String)\n(`hero`, String)\n(`villian`, String)\n(`song`, String)\n"
        ]
    },
    {
        "sql_id": 314,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(movie_title) FROM movies_total_gross WHERE MPAA_rating = 'R' AND genre = 'Horror' AND CAST(SUBSTR(release_date, INSTR(release_date, ', ') + 1) AS int) BETWEEN 1990 AND 2015",
        "target_query": "SELECT COUNT(`movie_title`) FROM `movies_total_gross` WHERE `MPAA_rating` = 'R' AND `genre` = 'Horror' AND toInt32(substring(`release_date`, positionCaseInsensitive(`release_date`, ', ') + 2)) BETWEEN 1990 AND 2015;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 104,
                "end_index": 150,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 115,
                "end_index": 186,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "instr(X,Y)",
                "explanation": "The instr(X,Y) function finds the first occurrence of string Y within \n  string X and returns the number of prior characters plus 1, or 0 if\n  Y is nowhere found within X.\n  Or, if X and Y are both BLOBs, then instr(X,Y) returns one\n  more than the number bytes prior to the first occurrence of Y, or 0 if\n  Y does not occur anywhere within X.\n  If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs\n  then both are interpreted as strings.\n  If either X or Y are NULL in instr(X,Y) then the result is NULL.\n",
                "examples": [
                    "SELECT instr('Hello World', 'World'); -- Returns 7",
                    "SELECT instr('abcdefg', 'x'); -- Returns 0 (not found)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "positionCaseInsensitive",
                "explanation": "positionCaseInsensitive\nA case insensitive invariant of position.",
                "examples": [
                    "SELECT positionCaseInsensitive('Hello, world!', 'hello');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String, primary key)\n(`genre`, String)\n(`MPAA_rating`, String)\n(`total_gross`, String)\n(`inflation_adjusted_gross`, String)\n"
        ]
    },
    {
        "sql_id": 315,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.name FROM movies_total_gross AS T1 INNER JOIN director AS T2 ON T2.name = T1.movie_title WHERE T2.director = 'Ron Clements' ORDER BY CAST(REPLACE(SUBSTR(total_gross, 2), ',', '') AS int) DESC LIMIT 1",
        "target_query": "SELECT `T2`.`name` FROM `movies_total_gross` AS `T1` INNER JOIN `director` AS `T2` ON `T2`.`name` = `T1`.`movie_title` WHERE `T2`.`director` = 'Ron Clements' ORDER BY toInt32(REPLACE(substring(`T1`.`total_gross`, 2), ',', '')) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 156,
                "end_index": 178,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 183,
                "end_index": 215,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n",
            "Table: `director`\nColumns:\n(`name`, text, primary key)\n(`director`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String, primary key)\n(`genre`, String)\n(`MPAA_rating`, String)\n(`total_gross`, String)\n(`inflation_adjusted_gross`, String)\n",
            "Table: `director`\nColumns:\n(`name`, String, primary key)\n(`director`, String)\n"
        ]
    },
    {
        "sql_id": 316,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.director FROM movies_total_gross AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name AND CAST(SUBSTR(release_date, INSTR(release_date, ', ') + 1) AS int) BETWEEN 1990 AND 2000 GROUP BY T2.director",
        "target_query": "SELECT T2.`director` FROM `movies_total_gross` AS T1 INNER JOIN `director` AS T2 ON T1.`movie_title` = T2.`name` AND toInt32(substring(T1.`release_date`, positionCaseInsensitive(T1.`release_date`, ', ') + 2)) BETWEEN 1990 AND 2000 GROUP BY T2.`director`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 112,
                "end_index": 158,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 125,
                "end_index": 202,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "instr(X,Y)",
                "explanation": "The instr(X,Y) function finds the first occurrence of string Y within \n  string X and returns the number of prior characters plus 1, or 0 if\n  Y is nowhere found within X.\n  Or, if X and Y are both BLOBs, then instr(X,Y) returns one\n  more than the number bytes prior to the first occurrence of Y, or 0 if\n  Y does not occur anywhere within X.\n  If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs\n  then both are interpreted as strings.\n  If either X or Y are NULL in instr(X,Y) then the result is NULL.\n",
                "examples": [
                    "SELECT instr('Hello World', 'World'); -- Returns 7",
                    "SELECT instr('abcdefg', 'x'); -- Returns 0 (not found)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "positionCaseInsensitive",
                "explanation": "positionCaseInsensitive\nA case insensitive invariant of position.",
                "examples": [
                    "SELECT positionCaseInsensitive('Hello, world!', 'hello');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n",
            "Table: `director`\nColumns:\n(`name`, text, primary key)\n(`director`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String, primary key)\n(`genre`, String)\n(`MPAA_rating`, String)\n(`total_gross`, String)\n(`inflation_adjusted_gross`, String)\n",
            "Table: `director`\nColumns:\n(`name`, String, primary key)\n(`director`, String)\n"
        ]
    },
    {
        "sql_id": 317,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.movie_title FROM movies_total_gross AS T1 INNER JOIN characters AS T2 ON T2.movie_title = T1.movie_title WHERE T2.song IS NULL ORDER BY CAST(REPLACE(trim(T1.total_gross, '$'), ',', '') AS REAL) DESC LIMIT 1",
        "target_query": "SELECT `T1`.`movie_title` FROM `movies_total_gross` AS `T1` INNER JOIN `characters` AS `T2` ON `T2`.`movie_title` = `T1`.`movie_title` WHERE `T2`.`song` IS NULL ORDER BY CAST(REPLACE(TRIM(BOTH '$' FROM `T1`.`total_gross`), ',', '') AS Float64) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 159,
                "end_index": 184,
                "dialect_content": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "feature": "trim(X)trim(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 183,
                "end_index": 221,
                "dialect_content": "The TRIM() function in ClickHouse removes specific leading and/or trailing characters from a string. By default, it trims spaces from both ends of the string. The function supports specifying whether to remove characters from the beginning (LEADING), end (TRAILING), or both sides (BOTH).",
                "feature": "TRIM([BOTH | LEADING | TRAILING] characters FROM X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "trim(X)trim(X,Y)",
                "explanation": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "TRIM([BOTH | LEADING | TRAILING] characters FROM X)",
                "explanation": "The TRIM() function in ClickHouse removes specific leading and/or trailing characters from a string. By default, it trims spaces from both ends of the string. The function supports specifying whether to remove characters from the beginning (LEADING), end (TRAILING), or both sides (BOTH).",
                "examples": [
                    "SELECT TRIM('   Hello   '); -- Returns 'Hello'",
                    "SELECT TRIM(BOTH 'xy' FROM 'xyxyHelloxyxy'); -- Returns 'Hello'",
                    "SELECT TRIM(LEADING '0' FROM '000123'); -- Returns '123'",
                    "SELECT TRIM(TRAILING '.' FROM 'filename....'); -- Returns 'filename'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n",
            "Table: `characters`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text)\n(`hero`, text)\n(`villian`, text)\n(`song`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String, primary key)\n(`genre`, String)\n(`MPAA_rating`, String)\n(`total_gross`, String)\n(`inflation_adjusted_gross`, String)\n",
            "Table: `characters`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String)\n(`hero`, String)\n(`villian`, String)\n(`song`, String)\n"
        ]
    },
    {
        "sql_id": 321,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT movie_title, genre FROM movies_total_gross WHERE SUBSTR(release_date, LENGTH(release_date) - 3, LENGTH(release_date)) = '2016'",
        "target_query": "SELECT `movie_title`, `genre` FROM `movies_total_gross` WHERE substring(`release_date`, -4) = '2016';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 56,
                "end_index": 97,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 62,
                "end_index": 91,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(str)",
                "explanation": "The length(str) function returns the number of bytes in the given string str. Unlike SQLite, which counts Unicode code points for strings, ClickHouse measures the length in bytes. For multibyte characters (UTF-8 encoded), the byte count may be larger than the character count. If str is NULL, the function returns NULL.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(unhex('68656C6C6F')); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String, primary key)\n(`genre`, String)\n(`MPAA_rating`, String)\n(`total_gross`, String)\n(`inflation_adjusted_gross`, String)\n"
        ]
    },
    {
        "sql_id": 322,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT movie_title, CAST(REPLACE(trim(inflation_adjusted_gross, '$'), ',', '') AS REAL) / CAST(REPLACE(trim(total_gross, '$'), ',', '') AS REAL) FROM movies_total_gross ORDER BY CAST(REPLACE(trim(total_gross, '$'), ',', '') AS REAL) DESC LIMIT 1",
        "target_query": "SELECT `movie_title`, CAST(REPLACE(TRIM(BOTH '$' FROM `inflation_adjusted_gross`), ',', '') AS Float64) / CAST(REPLACE(TRIM(BOTH '$' FROM `total_gross`), ',', '') AS Float64) FROM `movies_total_gross` ORDER BY CAST(REPLACE(TRIM(BOTH '$' FROM `total_gross`), ',', '') AS Float64) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 33,
                "end_index": 68,
                "dialect_content": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "feature": "trim(X)trim(X,Y)"
            },
            {
                "start_index": 103,
                "end_index": 125,
                "dialect_content": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "feature": "trim(X)trim(X,Y)"
            },
            {
                "start_index": 191,
                "end_index": 213,
                "dialect_content": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "feature": "trim(X)trim(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 35,
                "end_index": 81,
                "dialect_content": "The TRIM() function in ClickHouse removes specific leading and/or trailing characters from a string. By default, it trims spaces from both ends of the string. The function supports specifying whether to remove characters from the beginning (LEADING), end (TRAILING), or both sides (BOTH).",
                "feature": "TRIM([BOTH | LEADING | TRAILING] characters FROM X)"
            },
            {
                "start_index": 119,
                "end_index": 152,
                "dialect_content": "The TRIM() function in ClickHouse removes specific leading and/or trailing characters from a string. By default, it trims spaces from both ends of the string. The function supports specifying whether to remove characters from the beginning (LEADING), end (TRAILING), or both sides (BOTH).",
                "feature": "TRIM([BOTH | LEADING | TRAILING] characters FROM X)"
            },
            {
                "start_index": 223,
                "end_index": 256,
                "dialect_content": "The TRIM() function in ClickHouse removes specific leading and/or trailing characters from a string. By default, it trims spaces from both ends of the string. The function supports specifying whether to remove characters from the beginning (LEADING), end (TRAILING), or both sides (BOTH).",
                "feature": "TRIM([BOTH | LEADING | TRAILING] characters FROM X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "trim(X)trim(X,Y)",
                "explanation": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "TRIM([BOTH | LEADING | TRAILING] characters FROM X)",
                "explanation": "The TRIM() function in ClickHouse removes specific leading and/or trailing characters from a string. By default, it trims spaces from both ends of the string. The function supports specifying whether to remove characters from the beginning (LEADING), end (TRAILING), or both sides (BOTH).",
                "examples": [
                    "SELECT TRIM('   Hello   '); -- Returns 'Hello'",
                    "SELECT TRIM(BOTH 'xy' FROM 'xyxyHelloxyxy'); -- Returns 'Hello'",
                    "SELECT TRIM(LEADING '0' FROM '000123'); -- Returns '123'",
                    "SELECT TRIM(TRAILING '.' FROM 'filename....'); -- Returns 'filename'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String, primary key)\n(`genre`, String)\n(`MPAA_rating`, String)\n(`total_gross`, String)\n(`inflation_adjusted_gross`, String)\n"
        ]
    },
    {
        "sql_id": 323,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.movie_title, T2.hero, T2.song FROM movies_total_gross AS T1 INNER JOIN characters AS T2 ON T1.movie_title = T2.movie_title INNER JOIN director AS T3 ON T1.movie_title = T3.name WHERE T3.director = 'Wolfgang Reitherman' AND SUBSTR(T1.release_date, LENGTH(T1.release_date) - 3, LENGTH(T1.release_date)) = '1977'",
        "target_query": "SELECT `T1`.`movie_title`, `T2`.`hero`, `T2`.`song` \nFROM `movies_total_gross` AS `T1` \nINNER JOIN `characters` AS `T2` ON `T1`.`movie_title` = `T2`.`movie_title` \nINNER JOIN `director` AS `T3` ON `T1`.`movie_title` = `T3`.`name` \nWHERE `T3`.`director` = 'Wolfgang Reitherman' \nAND substring(`T1`.`release_date`, length(`T1`.`release_date`) - 3) = '1977';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 233,
                "end_index": 280,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 282,
                "end_index": 340,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(str)",
                "explanation": "The length(str) function returns the number of bytes in the given string str. Unlike SQLite, which counts Unicode code points for strings, ClickHouse measures the length in bytes. For multibyte characters (UTF-8 encoded), the byte count may be larger than the character count. If str is NULL, the function returns NULL.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(unhex('68656C6C6F')); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n",
            "Table: `characters`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text)\n(`hero`, text)\n(`villian`, text)\n(`song`, text)\n",
            "Table: `director`\nColumns:\n(`name`, text, primary key)\n(`director`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String, primary key)\n(`genre`, String)\n(`MPAA_rating`, String)\n(`total_gross`, String)\n(`inflation_adjusted_gross`, String)\n",
            "Table: `characters`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String)\n(`hero`, String)\n(`villian`, String)\n(`song`, String)\n",
            "Table: `director`\nColumns:\n(`name`, String, primary key)\n(`director`, String)\n"
        ]
    },
    {
        "sql_id": 324,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.movie_title, T1.total_gross FROM movies_total_gross AS T1 INNER JOIN `voice-actors` AS T2 ON T1.movie_title = T2.movie WHERE T2.`voice-actor` = 'Frank Welker' AND CAST(REPLACE(trim(T1.inflation_adjusted_gross, '$'), ',', '') AS REAL) * 1.0 / CAST(REPLACE(trim(T1.total_gross, '$'), ',', '') AS REAL) * 1.0 < 2",
        "target_query": "SELECT T1.`movie_title`, T1.`total_gross` \nFROM `movies_total_gross` AS T1 \nINNER JOIN `voice_actors` AS T2 \nON T1.`movie_title` = T2.`movie` \nWHERE T2.`voice_actor` = 'Frank Welker' \nAND CAST(REPLACE(TRIM(BOTH ' ' FROM REPLACE(TRIM(BOTH ' ' FROM T1.`inflation_adjusted_gross`), '$', '')), ',', '') AS Float64) \n* 1.0 / CAST(REPLACE(TRIM(BOTH ' ' FROM REPLACE(TRIM(BOTH ' ' FROM T1.`total_gross`), '$', '')), ',', '') AS Float64) \n* 1.0 < 2;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 186,
                "end_index": 224,
                "dialect_content": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "feature": "trim(X)trim(X,Y)"
            },
            {
                "start_index": 265,
                "end_index": 290,
                "dialect_content": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "feature": "trim(X)trim(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 201,
                "end_index": 277,
                "dialect_content": "The TRIM() function in ClickHouse removes specific leading and/or trailing characters from a string. By default, it trims spaces from both ends of the string. The function supports specifying whether to remove characters from the beginning (LEADING), end (TRAILING), or both sides (BOTH).",
                "feature": "TRIM([BOTH | LEADING | TRAILING] characters FROM X)"
            },
            {
                "start_index": 333,
                "end_index": 396,
                "dialect_content": "The TRIM() function in ClickHouse removes specific leading and/or trailing characters from a string. By default, it trims spaces from both ends of the string. The function supports specifying whether to remove characters from the beginning (LEADING), end (TRAILING), or both sides (BOTH).",
                "feature": "TRIM([BOTH | LEADING | TRAILING] characters FROM X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "trim(X)trim(X,Y)",
                "explanation": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "TRIM([BOTH | LEADING | TRAILING] characters FROM X)",
                "explanation": "The TRIM() function in ClickHouse removes specific leading and/or trailing characters from a string. By default, it trims spaces from both ends of the string. The function supports specifying whether to remove characters from the beginning (LEADING), end (TRAILING), or both sides (BOTH).",
                "examples": [
                    "SELECT TRIM('   Hello   '); -- Returns 'Hello'",
                    "SELECT TRIM(BOTH 'xy' FROM 'xyxyHelloxyxy'); -- Returns 'Hello'",
                    "SELECT TRIM(LEADING '0' FROM '000123'); -- Returns '123'",
                    "SELECT TRIM(TRAILING '.' FROM 'filename....'); -- Returns 'filename'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n",
            "Table: `voice-actors`\nColumns:\n(`character`, text, primary key)\n(`voice-actor`, text)\n(`movie`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String, primary key)\n(`genre`, String)\n(`MPAA_rating`, String)\n(`total_gross`, String)\n(`inflation_adjusted_gross`, String)\n",
            "Table: `voice_actors`\nColumns:\n(`character`, String, primary key)\n(`voice_actor`, String)\n(`movie`, String)\n"
        ]
    },
    {
        "sql_id": 325,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.director FROM movies_total_gross AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name ORDER BY CAST(REPLACE(trim(T1.total_gross, '$'), ',', '') AS REAL) DESC LIMIT 1",
        "target_query": "SELECT T2.`director` FROM `movies_total_gross` AS T1 INNER JOIN `director` AS T2 ON T1.`movie_title` = T2.`name` ORDER BY CAST(REPLACE(TRIM(BOTH '$' FROM T1.`total_gross`), ',', '') AS Float64) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 125,
                "end_index": 150,
                "dialect_content": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "feature": "trim(X)trim(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 135,
                "end_index": 171,
                "dialect_content": "The TRIM() function in ClickHouse removes specific leading and/or trailing characters from a string. By default, it trims spaces from both ends of the string. The function supports specifying whether to remove characters from the beginning (LEADING), end (TRAILING), or both sides (BOTH).",
                "feature": "TRIM([BOTH | LEADING | TRAILING] characters FROM X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "trim(X)trim(X,Y)",
                "explanation": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "TRIM([BOTH | LEADING | TRAILING] characters FROM X)",
                "explanation": "The TRIM() function in ClickHouse removes specific leading and/or trailing characters from a string. By default, it trims spaces from both ends of the string. The function supports specifying whether to remove characters from the beginning (LEADING), end (TRAILING), or both sides (BOTH).",
                "examples": [
                    "SELECT TRIM('   Hello   '); -- Returns 'Hello'",
                    "SELECT TRIM(BOTH 'xy' FROM 'xyxyHelloxyxy'); -- Returns 'Hello'",
                    "SELECT TRIM(LEADING '0' FROM '000123'); -- Returns '123'",
                    "SELECT TRIM(TRAILING '.' FROM 'filename....'); -- Returns 'filename'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n",
            "Table: `director`\nColumns:\n(`name`, text, primary key)\n(`director`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String, primary key)\n(`genre`, String)\n(`MPAA_rating`, String)\n(`total_gross`, String)\n(`inflation_adjusted_gross`, String)\n",
            "Table: `director`\nColumns:\n(`name`, String, primary key)\n(`director`, String)\n"
        ]
    },
    {
        "sql_id": 326,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.director, T1.MPAA_rating FROM movies_total_gross AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE T1.genre = 'Musical' AND SUBSTR(T1.release_date, LENGTH(T1.release_date) - 3, LENGTH(T1.release_date)) = '1993'",
        "target_query": "SELECT `T2`.`director`, `T1`.`MPAA_rating` FROM `movies_total_gross` AS `T1` INNER JOIN `director` AS `T2` ON `T1`.`movie_title` = `T2`.`name` WHERE `T1`.`genre` = 'Musical' AND substring(`T1`.`release_date`, length(`T1`.`release_date`) - 3, 4) = '1993';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 150,
                "end_index": 197,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 178,
                "end_index": 236,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(str)",
                "explanation": "The length(str) function returns the number of bytes in the given string str. Unlike SQLite, which counts Unicode code points for strings, ClickHouse measures the length in bytes. For multibyte characters (UTF-8 encoded), the byte count may be larger than the character count. If str is NULL, the function returns NULL.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(unhex('68656C6C6F')); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n",
            "Table: `director`\nColumns:\n(`name`, text, primary key)\n(`director`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String, primary key)\n(`genre`, String)\n(`MPAA_rating`, String)\n(`total_gross`, String)\n(`inflation_adjusted_gross`, String)\n",
            "Table: `director`\nColumns:\n(`name`, String, primary key)\n(`director`, String)\n"
        ]
    },
    {
        "sql_id": 329,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(movie_title) FROM characters WHERE SUBSTR(release_date, LENGTH(release_date) - 1, LENGTH(release_date)) BETWEEN '37' AND '50'",
        "target_query": "SELECT COUNT(`movie_title`) FROM `characters` WHERE substring(`release_date`, length(`release_date`) - 1, length(`release_date`)) BETWEEN '37' AND '50';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 48,
                "end_index": 89,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 52,
                "end_index": 100,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(str)",
                "explanation": "The length(str) function returns the number of bytes in the given string str. Unlike SQLite, which counts Unicode code points for strings, ClickHouse measures the length in bytes. For multibyte characters (UTF-8 encoded), the byte count may be larger than the character count. If str is NULL, the function returns NULL.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(unhex('68656C6C6F')); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `characters`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text)\n(`hero`, text)\n(`villian`, text)\n(`song`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `characters`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String)\n(`hero`, String)\n(`villian`, String)\n(`song`, String)\n"
        ]
    },
    {
        "sql_id": 330,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.movie_title FROM characters AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE T2.director = 'Jack Kinney' AND SUBSTR(T1.release_date, LENGTH(T1.release_date) - 1, LENGTH(T1.release_date)) < '47'",
        "target_query": "SELECT `T1`.`movie_title` FROM `characters` AS `T1` INNER JOIN `director` AS `T2` ON `T1`.`movie_title` = `T2`.`name` WHERE `T2`.`director` = 'Jack Kinney' AND substring(`T1`.`release_date`, -2, 2) < '47';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 136,
                "end_index": 183,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 160,
                "end_index": 197,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(str)",
                "explanation": "The length(str) function returns the number of bytes in the given string str. Unlike SQLite, which counts Unicode code points for strings, ClickHouse measures the length in bytes. For multibyte characters (UTF-8 encoded), the byte count may be larger than the character count. If str is NULL, the function returns NULL.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(unhex('68656C6C6F')); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `characters`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text)\n(`hero`, text)\n(`villian`, text)\n(`song`, text)\n",
            "Table: `director`\nColumns:\n(`name`, text, primary key)\n(`director`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `characters`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String)\n(`hero`, String)\n(`villian`, String)\n(`song`, String)\n",
            "Table: `director`\nColumns:\n(`name`, String, primary key)\n(`director`, String)\n"
        ]
    },
    {
        "sql_id": 331,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT T2.director FROM characters AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name INNER JOIN movies_total_gross AS T3 ON T1.movie_title = T3.movie_title WHERE CAST(REPLACE(trim(T3.total_gross, '$'), ',', '') AS REAL) > 100000000",
        "target_query": "SELECT DISTINCT `T2`.`director` FROM `characters` AS `T1` INNER JOIN `director` AS `T2` ON `T1`.`movie_title` = `T2`.`name` INNER JOIN `movies_total_gross` AS `T3` ON `T1`.`movie_title` = `T3`.`movie_title` WHERE toFloat64(REPLACE(TRIM(BOTH '$' FROM TRIM(`T3`.`total_gross`)), ',', '')) > 100000000;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 194,
                "end_index": 219,
                "dialect_content": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "feature": "trim(X)trim(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 231,
                "end_index": 274,
                "dialect_content": "The TRIM() function in ClickHouse removes specific leading and/or trailing characters from a string. By default, it trims spaces from both ends of the string. The function supports specifying whether to remove characters from the beginning (LEADING), end (TRAILING), or both sides (BOTH).",
                "feature": "TRIM([BOTH | LEADING | TRAILING] characters FROM X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "trim(X)trim(X,Y)",
                "explanation": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "TRIM([BOTH | LEADING | TRAILING] characters FROM X)",
                "explanation": "The TRIM() function in ClickHouse removes specific leading and/or trailing characters from a string. By default, it trims spaces from both ends of the string. The function supports specifying whether to remove characters from the beginning (LEADING), end (TRAILING), or both sides (BOTH).",
                "examples": [
                    "SELECT TRIM('   Hello   '); -- Returns 'Hello'",
                    "SELECT TRIM(BOTH 'xy' FROM 'xyxyHelloxyxy'); -- Returns 'Hello'",
                    "SELECT TRIM(LEADING '0' FROM '000123'); -- Returns '123'",
                    "SELECT TRIM(TRAILING '.' FROM 'filename....'); -- Returns 'filename'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `characters`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text)\n(`hero`, text)\n(`villian`, text)\n(`song`, text)\n",
            "Table: `director`\nColumns:\n(`name`, text, primary key)\n(`director`, text)\n",
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `characters`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String)\n(`hero`, String)\n(`villian`, String)\n(`song`, String)\n",
            "Table: `director`\nColumns:\n(`name`, String, primary key)\n(`director`, String)\n",
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String, primary key)\n(`genre`, String)\n(`MPAA_rating`, String)\n(`total_gross`, String)\n(`inflation_adjusted_gross`, String)\n"
        ]
    },
    {
        "sql_id": 332,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.song FROM movies_total_gross AS T1 INNER JOIN characters AS T2 ON T1.movie_title = T2.movie_title ORDER BY CAST(REPLACE(trim(T1.total_gross, '$'), ',', '') AS REAL) DESC LIMIT 1",
        "target_query": "SELECT T2.`song` FROM `movies_total_gross` AS T1 INNER JOIN `characters` AS T2 ON T1.`movie_title` = T2.`movie_title` ORDER BY CAST(REPLACE(TRIM(BOTH '$' FROM T1.`total_gross`), ',', '') AS Float64) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 130,
                "end_index": 155,
                "dialect_content": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "feature": "trim(X)trim(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 140,
                "end_index": 176,
                "dialect_content": "The TRIM() function in ClickHouse removes specific leading and/or trailing characters from a string. By default, it trims spaces from both ends of the string. The function supports specifying whether to remove characters from the beginning (LEADING), end (TRAILING), or both sides (BOTH).",
                "feature": "TRIM([BOTH | LEADING | TRAILING] characters FROM X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "trim(X)trim(X,Y)",
                "explanation": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "TRIM([BOTH | LEADING | TRAILING] characters FROM X)",
                "explanation": "The TRIM() function in ClickHouse removes specific leading and/or trailing characters from a string. By default, it trims spaces from both ends of the string. The function supports specifying whether to remove characters from the beginning (LEADING), end (TRAILING), or both sides (BOTH).",
                "examples": [
                    "SELECT TRIM('   Hello   '); -- Returns 'Hello'",
                    "SELECT TRIM(BOTH 'xy' FROM 'xyxyHelloxyxy'); -- Returns 'Hello'",
                    "SELECT TRIM(LEADING '0' FROM '000123'); -- Returns '123'",
                    "SELECT TRIM(TRAILING '.' FROM 'filename....'); -- Returns 'filename'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n",
            "Table: `characters`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text)\n(`hero`, text)\n(`villian`, text)\n(`song`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String, primary key)\n(`genre`, String)\n(`MPAA_rating`, String)\n(`total_gross`, String)\n(`inflation_adjusted_gross`, String)\n",
            "Table: `characters`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String)\n(`hero`, String)\n(`villian`, String)\n(`song`, String)\n"
        ]
    },
    {
        "sql_id": 333,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.director FROM characters AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name INNER JOIN movies_total_gross AS T3 ON T3.movie_title = T1.movie_title WHERE SUBSTR(T3.release_date, LENGTH(T3.release_date) - 3, LENGTH(T3.release_date)) BETWEEN '1937' AND '1990' ORDER BY CAST(REPLACE(trim(T3.total_gross, '$'), ',', '') AS REAL) DESC LIMIT 1",
        "target_query": "SELECT `T2`.`director` FROM `characters` AS `T1` INNER JOIN `director` AS `T2` ON `T1`.`movie_title` = `T2`.`name` INNER JOIN `movies_total_gross` AS `T3` ON `T3`.`movie_title` = `T1`.`movie_title` WHERE substring(`T3`.`release_date`, length(`T3`.`release_date`) - 3, 4) BETWEEN '1937' AND '1990' ORDER BY toFloat64(REPLACE(TRIM(BOTH '$' FROM `T3`.`total_gross`), ',', '')) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 172,
                "end_index": 219,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 204,
                "end_index": 262,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            },
            {
                "feature": "trim(X)trim(X,Y)",
                "explanation": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(str)",
                "explanation": "The length(str) function returns the number of bytes in the given string str. Unlike SQLite, which counts Unicode code points for strings, ClickHouse measures the length in bytes. For multibyte characters (UTF-8 encoded), the byte count may be larger than the character count. If str is NULL, the function returns NULL.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(unhex('68656C6C6F')); -- Returns 5 (Hexadecimal BLOB)"
                ]
            },
            {
                "feature": "TRIM([BOTH | LEADING | TRAILING] characters FROM X)",
                "explanation": "The TRIM() function in ClickHouse removes specific leading and/or trailing characters from a string. By default, it trims spaces from both ends of the string. The function supports specifying whether to remove characters from the beginning (LEADING), end (TRAILING), or both sides (BOTH).",
                "examples": [
                    "SELECT TRIM('   Hello   '); -- Returns 'Hello'",
                    "SELECT TRIM(BOTH 'xy' FROM 'xyxyHelloxyxy'); -- Returns 'Hello'",
                    "SELECT TRIM(LEADING '0' FROM '000123'); -- Returns '123'",
                    "SELECT TRIM(TRAILING '.' FROM 'filename....'); -- Returns 'filename'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `characters`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text)\n(`hero`, text)\n(`villian`, text)\n(`song`, text)\n",
            "Table: `director`\nColumns:\n(`name`, text, primary key)\n(`director`, text)\n",
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `characters`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String)\n(`hero`, String)\n(`villian`, String)\n(`song`, String)\n",
            "Table: `director`\nColumns:\n(`name`, String, primary key)\n(`director`, String)\n",
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String, primary key)\n(`genre`, String)\n(`MPAA_rating`, String)\n(`total_gross`, String)\n(`inflation_adjusted_gross`, String)\n"
        ]
    },
    {
        "sql_id": 335,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT movie_title FROM characters ORDER BY SUBSTR(release_date, LENGTH(release_date) - 1, LENGTH(release_date)) ASC LIMIT 1",
        "target_query": "SELECT `movie_title` FROM `characters` ORDER BY substring(`release_date`, length(`release_date`) - 1, length(`release_date`)) ASC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 44,
                "end_index": 85,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 48,
                "end_index": 96,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(str)",
                "explanation": "The length(str) function returns the number of bytes in the given string str. Unlike SQLite, which counts Unicode code points for strings, ClickHouse measures the length in bytes. For multibyte characters (UTF-8 encoded), the byte count may be larger than the character count. If str is NULL, the function returns NULL.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(unhex('68656C6C6F')); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `characters`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text)\n(`hero`, text)\n(`villian`, text)\n(`song`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `characters`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String)\n(`hero`, String)\n(`villian`, String)\n(`song`, String)\n"
        ]
    },
    {
        "sql_id": 336,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(movie_title) FROM characters WHERE SUBSTR(release_date, LENGTH(release_date) - 1, LENGTH(release_date)) BETWEEN '10' AND '16'",
        "target_query": "SELECT COUNT(`movie_title`) FROM `characters` WHERE substring(`release_date`, length(`release_date`) - 1, length(`release_date`)) BETWEEN '10' AND '16';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 48,
                "end_index": 89,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 52,
                "end_index": 100,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(str)",
                "explanation": "The length(str) function returns the number of bytes in the given string str. Unlike SQLite, which counts Unicode code points for strings, ClickHouse measures the length in bytes. For multibyte characters (UTF-8 encoded), the byte count may be larger than the character count. If str is NULL, the function returns NULL.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(unhex('68656C6C6F')); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `characters`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text)\n(`hero`, text)\n(`villian`, text)\n(`song`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `characters`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String)\n(`hero`, String)\n(`villian`, String)\n(`song`, String)\n"
        ]
    },
    {
        "sql_id": 337,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT villian FROM characters ORDER BY SUBSTR(release_date, LENGTH(release_date) - 1, LENGTH(release_date)) DESC LIMIT 1",
        "target_query": "SELECT `villian` FROM `characters` ORDER BY substring(`release_date`, length(`release_date`) - 1, 1) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 40,
                "end_index": 81,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 44,
                "end_index": 92,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            },
            {
                "feature": "length(str)",
                "explanation": "The length(str) function returns the number of bytes in the given string str. Unlike SQLite, which counts Unicode code points for strings, ClickHouse measures the length in bytes. For multibyte characters (UTF-8 encoded), the byte count may be larger than the character count. If str is NULL, the function returns NULL.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(unhex('68656C6C6F')); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `characters`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text)\n(`hero`, text)\n(`villian`, text)\n(`song`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `characters`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String)\n(`hero`, String)\n(`villian`, String)\n(`song`, String)\n"
        ]
    },
    {
        "sql_id": 338,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT movie_title FROM movies_total_gross WHERE genre = 'Action' ORDER BY CAST(REPLACE(trim(total_gross, '$'), ',', '') AS REAL) DESC LIMIT 1",
        "target_query": "SELECT `movie_title` FROM `movies_total_gross` WHERE `genre` = 'Action' ORDER BY toFloat64(REPLACE(TRIM(BOTH '$' FROM `total_gross`), ',', '')) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 88,
                "end_index": 110,
                "dialect_content": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "feature": "trim(X)trim(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 99,
                "end_index": 132,
                "dialect_content": "The TRIM() function in ClickHouse removes specific leading and/or trailing characters from a string. By default, it trims spaces from both ends of the string. The function supports specifying whether to remove characters from the beginning (LEADING), end (TRAILING), or both sides (BOTH).",
                "feature": "TRIM([BOTH | LEADING | TRAILING] characters FROM X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "trim(X)trim(X,Y)",
                "explanation": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "TRIM([BOTH | LEADING | TRAILING] characters FROM X)",
                "explanation": "The TRIM() function in ClickHouse removes specific leading and/or trailing characters from a string. By default, it trims spaces from both ends of the string. The function supports specifying whether to remove characters from the beginning (LEADING), end (TRAILING), or both sides (BOTH).",
                "examples": [
                    "SELECT TRIM('   Hello   '); -- Returns 'Hello'",
                    "SELECT TRIM(BOTH 'xy' FROM 'xyxyHelloxyxy'); -- Returns 'Hello'",
                    "SELECT TRIM(LEADING '0' FROM '000123'); -- Returns '123'",
                    "SELECT TRIM(TRAILING '.' FROM 'filename....'); -- Returns 'filename'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String, primary key)\n(`genre`, String)\n(`MPAA_rating`, String)\n(`total_gross`, String)\n(`inflation_adjusted_gross`, String)\n"
        ]
    },
    {
        "sql_id": 339,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.hero FROM movies_total_gross AS T1 INNER JOIN characters AS T2 ON T1.movie_title = T2.movie_title WHERE T1.genre = 'Adventure' ORDER BY CAST(REPLACE(trim(T1.inflation_adjusted_gross, '$'), ',', '') AS REAL) DESC LIMIT 1",
        "target_query": "SELECT T2.`hero` FROM `movies_total_gross` AS T1 INNER JOIN `characters` AS T2 ON T1.`movie_title` = T2.`movie_title` WHERE T1.`genre` = 'Adventure' ORDER BY toFloat64(REPLACE(TRIM(BOTH '$' FROM T1.`inflation_adjusted_gross`), ',', '')) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 159,
                "end_index": 197,
                "dialect_content": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "feature": "trim(X)trim(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 176,
                "end_index": 225,
                "dialect_content": "The TRIM() function in ClickHouse removes specific leading and/or trailing characters from a string. By default, it trims spaces from both ends of the string. The function supports specifying whether to remove characters from the beginning (LEADING), end (TRAILING), or both sides (BOTH).",
                "feature": "TRIM([BOTH | LEADING | TRAILING] characters FROM X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "trim(X)trim(X,Y)",
                "explanation": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "TRIM([BOTH | LEADING | TRAILING] characters FROM X)",
                "explanation": "The TRIM() function in ClickHouse removes specific leading and/or trailing characters from a string. By default, it trims spaces from both ends of the string. The function supports specifying whether to remove characters from the beginning (LEADING), end (TRAILING), or both sides (BOTH).",
                "examples": [
                    "SELECT TRIM('   Hello   '); -- Returns 'Hello'",
                    "SELECT TRIM(BOTH 'xy' FROM 'xyxyHelloxyxy'); -- Returns 'Hello'",
                    "SELECT TRIM(LEADING '0' FROM '000123'); -- Returns '123'",
                    "SELECT TRIM(TRAILING '.' FROM 'filename....'); -- Returns 'filename'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n",
            "Table: `characters`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text)\n(`hero`, text)\n(`villian`, text)\n(`song`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String, primary key)\n(`genre`, String)\n(`MPAA_rating`, String)\n(`total_gross`, String)\n(`inflation_adjusted_gross`, String)\n",
            "Table: `characters`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String)\n(`hero`, String)\n(`villian`, String)\n(`song`, String)\n"
        ]
    },
    {
        "sql_id": 340,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.director FROM movies_total_gross AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name ORDER BY CAST(REPLACE(trim(T1.total_gross, '$'), ',', '') AS REAL) ASC LIMIT 1",
        "target_query": "SELECT T2.`director` FROM `movies_total_gross` AS T1 INNER JOIN `director` AS T2 ON T1.`movie_title` = T2.`name` ORDER BY CAST(REPLACE(TRIM(BOTH '$' FROM T1.`total_gross`), ',', '') AS Float64) ASC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 125,
                "end_index": 150,
                "dialect_content": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "feature": "trim(X)trim(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 135,
                "end_index": 171,
                "dialect_content": "The TRIM() function in ClickHouse removes specific leading and/or trailing characters from a string. By default, it trims spaces from both ends of the string. The function supports specifying whether to remove characters from the beginning (LEADING), end (TRAILING), or both sides (BOTH).",
                "feature": "TRIM([BOTH | LEADING | TRAILING] characters FROM X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "trim(X)trim(X,Y)",
                "explanation": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "TRIM([BOTH | LEADING | TRAILING] characters FROM X)",
                "explanation": "The TRIM() function in ClickHouse removes specific leading and/or trailing characters from a string. By default, it trims spaces from both ends of the string. The function supports specifying whether to remove characters from the beginning (LEADING), end (TRAILING), or both sides (BOTH).",
                "examples": [
                    "SELECT TRIM('   Hello   '); -- Returns 'Hello'",
                    "SELECT TRIM(BOTH 'xy' FROM 'xyxyHelloxyxy'); -- Returns 'Hello'",
                    "SELECT TRIM(LEADING '0' FROM '000123'); -- Returns '123'",
                    "SELECT TRIM(TRAILING '.' FROM 'filename....'); -- Returns 'filename'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n",
            "Table: `director`\nColumns:\n(`name`, text, primary key)\n(`director`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String, primary key)\n(`genre`, String)\n(`MPAA_rating`, String)\n(`total_gross`, String)\n(`inflation_adjusted_gross`, String)\n",
            "Table: `director`\nColumns:\n(`name`, String, primary key)\n(`director`, String)\n"
        ]
    },
    {
        "sql_id": 341,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(CAST(REPLACE(trim(total_gross, '$'), ',', '') AS REAL)) / COUNT(movie_title) FROM movies_total_gross WHERE MPAA_rating = 'PG-13'",
        "target_query": "SELECT SUM(CAST(REPLACE(REPLACE(TRIM(`total_gross`), '$', ''), ',', '') AS Float64)) / COUNT(`movie_title`) FROM `movies_total_gross` WHERE `MPAA_rating` = 'PG-13';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 24,
                "end_index": 46,
                "dialect_content": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "feature": "trim(X)trim(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 32,
                "end_index": 51,
                "dialect_content": "The TRIM() function in ClickHouse removes specific leading and/or trailing characters from a string. By default, it trims spaces from both ends of the string. The function supports specifying whether to remove characters from the beginning (LEADING), end (TRAILING), or both sides (BOTH).",
                "feature": "TRIM([BOTH | LEADING | TRAILING] characters FROM X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "trim(X)trim(X,Y)",
                "explanation": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "TRIM([BOTH | LEADING | TRAILING] characters FROM X)",
                "explanation": "The TRIM() function in ClickHouse removes specific leading and/or trailing characters from a string. By default, it trims spaces from both ends of the string. The function supports specifying whether to remove characters from the beginning (LEADING), end (TRAILING), or both sides (BOTH).",
                "examples": [
                    "SELECT TRIM('   Hello   '); -- Returns 'Hello'",
                    "SELECT TRIM(BOTH 'xy' FROM 'xyxyHelloxyxy'); -- Returns 'Hello'",
                    "SELECT TRIM(LEADING '0' FROM '000123'); -- Returns '123'",
                    "SELECT TRIM(TRAILING '.' FROM 'filename....'); -- Returns 'filename'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String, primary key)\n(`genre`, String)\n(`MPAA_rating`, String)\n(`total_gross`, String)\n(`inflation_adjusted_gross`, String)\n"
        ]
    },
    {
        "sql_id": 344,
        "database_name": "disney",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(CASE WHEN CAST(REPLACE(trim(inflation_adjusted_gross, '$'), ',', '') AS REAL) > 1236035515 THEN CAST(REPLACE(trim(inflation_adjusted_gross, '$'), ',', '') AS REAL) ELSE 0 END) * 100 / SUM(CAST(REPLACE(trim(inflation_adjusted_gross, '$'), ',', '') AS REAL)) FROM movies_total_gross",
        "target_query": "SELECT SUM(CASE WHEN toFloat64OrZero(REPLACE(REPLACE(TRIM(`inflation_adjusted_gross`), '$', ''), ',', '')) > 1236035515 THEN toFloat64OrZero(REPLACE(REPLACE(TRIM(`inflation_adjusted_gross`), '$', ''), ',', '')) ELSE 0 END) * 100 / SUM(toFloat64OrZero(REPLACE(REPLACE(TRIM(`inflation_adjusted_gross`), '$', ''), ',', ''))) FROM `movies_total_gross`;",
        "semantic_equivalent_type": "Approximate equivalence",
        "source_dialect_locations": [
            {
                "start_index": 34,
                "end_index": 69,
                "dialect_content": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "feature": "trim(X)trim(X,Y)"
            },
            {
                "start_index": 120,
                "end_index": 155,
                "dialect_content": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "feature": "trim(X)trim(X,Y)"
            },
            {
                "start_index": 212,
                "end_index": 247,
                "dialect_content": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "feature": "trim(X)trim(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 53,
                "end_index": 85,
                "dialect_content": "The TRIM() function in ClickHouse removes specific leading and/or trailing characters from a string. By default, it trims spaces from both ends of the string. The function supports specifying whether to remove characters from the beginning (LEADING), end (TRAILING), or both sides (BOTH).",
                "feature": "TRIM([BOTH | LEADING | TRAILING] characters FROM X)"
            },
            {
                "start_index": 157,
                "end_index": 189,
                "dialect_content": "The TRIM() function in ClickHouse removes specific leading and/or trailing characters from a string. By default, it trims spaces from both ends of the string. The function supports specifying whether to remove characters from the beginning (LEADING), end (TRAILING), or both sides (BOTH).",
                "feature": "TRIM([BOTH | LEADING | TRAILING] characters FROM X)"
            },
            {
                "start_index": 267,
                "end_index": 299,
                "dialect_content": "The TRIM() function in ClickHouse removes specific leading and/or trailing characters from a string. By default, it trims spaces from both ends of the string. The function supports specifying whether to remove characters from the beginning (LEADING), end (TRAILING), or both sides (BOTH).",
                "feature": "TRIM([BOTH | LEADING | TRAILING] characters FROM X)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "trim(X)trim(X,Y)",
                "explanation": "The trim(X,Y) function returns a string formed by removing any and all\n  characters that appear in Y from both ends of X.\n  If the Y argument is omitted, trim(X) removes spaces from both ends of X.\n",
                "examples": [
                    "SELECT trim('   Hello   '); -- Returns 'Hello'",
                    "SELECT trim('xyxyHelloxyxy', 'xy'); -- Returns 'Hello'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "TRIM([BOTH | LEADING | TRAILING] characters FROM X)",
                "explanation": "The TRIM() function in ClickHouse removes specific leading and/or trailing characters from a string. By default, it trims spaces from both ends of the string. The function supports specifying whether to remove characters from the beginning (LEADING), end (TRAILING), or both sides (BOTH).",
                "examples": [
                    "SELECT TRIM('   Hello   '); -- Returns 'Hello'",
                    "SELECT TRIM(BOTH 'xy' FROM 'xyxyHelloxyxy'); -- Returns 'Hello'",
                    "SELECT TRIM(LEADING '0' FROM '000123'); -- Returns '123'",
                    "SELECT TRIM(TRAILING '.' FROM 'filename....'); -- Returns 'filename'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, text, primary key)\n(`release_date`, text, primary key)\n(`genre`, text)\n(`MPAA_rating`, text)\n(`total_gross`, text)\n(`inflation_adjusted_gross`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `movies_total_gross`\nColumns:\n(`movie_title`, String, primary key)\n(`release_date`, String, primary key)\n(`genre`, String)\n(`MPAA_rating`, String)\n(`total_gross`, String)\n(`inflation_adjusted_gross`, String)\n"
        ]
    },
    {
        "sql_id": 247,
        "database_name": "donor",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT teacher_ny_teaching_fellow end FROM projects WHERE teacher_acctid = '42d43fa6f37314365d08692e08680973'",
        "target_query": "SELECT `teacher_ny_teaching_fellow` FROM `projects` WHERE `teacher_acctid` = '42d43fa6f37314365d08692e08680973';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [],
        "target_dialect_knowledge": [],
        "source_related_schemas": [
            "Table: `projects`\nColumns:\n(`projectid`, text, primary key)\n(`teacher_acctid`, text)\n(`schoolid`, text)\n(`school_ncesid`, text)\n(`school_latitude`, real)\n(`school_longitude`, real)\n(`school_city`, text)\n(`school_state`, text)\n(`school_zip`, integer)\n(`school_metro`, text)\n(`school_district`, text)\n(`school_county`, text)\n(`school_charter`, text)\n(`school_magnet`, text)\n(`school_year_round`, text)\n(`school_nlns`, text)\n(`school_kipp`, text)\n(`school_charter_ready_promise`, text)\n(`teacher_prefix`, text)\n(`teacher_teach_for_america`, text)\n(`teacher_ny_teaching_fellow`, text)\n(`primary_focus_subject`, text)\n(`primary_focus_area`, text)\n(`secondary_focus_subject`, text)\n(`secondary_focus_area`, text)\n(`resource_type`, text)\n(`poverty_level`, text)\n(`grade_level`, text)\n(`fulfillment_labor_materials`, real)\n(`total_price_excluding_optional_support`, real)\n(`total_price_including_optional_support`, real)\n(`students_reached`, integer)\n(`eligible_double_your_impact_match`, text)\n(`eligible_almost_home_match`, text)\n(`date_posted`, date)\n"
        ],
        "target_related_schemas": [
            "Table: `projects`\nColumns:\n(`projectid`, String, primary key)\n(`teacher_acctid`, String)\n(`schoolid`, String)\n(`school_ncesid`, String)\n(`school_latitude`, Float64)\n(`school_longitude`, Float64)\n(`school_city`, String)\n(`school_state`, String)\n(`school_zip`, Int64)\n(`school_metro`, String)\n(`school_district`, String)\n(`school_county`, String)\n(`school_charter`, String)\n(`school_magnet`, String)\n(`school_year_round`, String)\n(`school_nlns`, String)\n(`school_kipp`, String)\n(`school_charter_ready_promise`, String)\n(`teacher_prefix`, String)\n(`teacher_teach_for_america`, String)\n(`teacher_ny_teaching_fellow`, String)\n(`primary_focus_subject`, String)\n(`primary_focus_area`, String)\n(`secondary_focus_subject`, String)\n(`secondary_focus_area`, String)\n(`resource_type`, String)\n(`poverty_level`, String)\n(`grade_level`, String)\n(`fulfillment_labor_materials`, Float64)\n(`total_price_excluding_optional_support`, Float64)\n(`total_price_including_optional_support`, Float64)\n(`students_reached`, Int64)\n(`eligible_double_your_impact_match`, String)\n(`eligible_almost_home_match`, String)\n(`date_posted`, Date32)\n"
        ]
    },
    {
        "sql_id": 594,
        "database_name": "food_inspection",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(`date`) FROM inspections WHERE STRFTIME('%Y', `date`) = '2016' AND type = 'Routine - Unscheduled'",
        "target_query": "SELECT COUNT(`date`) FROM `inspections` WHERE formatDateTime(`date`, '%Y') = '2016' AND `_type` = 'Routine - Unscheduled';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 44,
                "end_index": 66,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 46,
                "end_index": 74,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspections`\nColumns:\n(`business_id`, integer)\n(`score`, integer)\n(`date`, date)\n(`type`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `inspections`\nColumns:\n(`business_id`, Int64)\n(`score`, Int64)\n(`date`, Date32)\n(`_type`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 595,
        "database_name": "food_inspection",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(DISTINCT T2.business_id) FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE STRFTIME('%Y', T1.`date`) = '2016' AND T2.city IN ('San Francisco', 'SAN FRANCISCO', 'SF', 'S.F.')",
        "target_query": "SELECT COUNT(DISTINCT T2.`business_id`) FROM `inspections` AS T1 INNER JOIN `businesses` AS T2 ON T1.`business_id` = T2.`business_id` WHERE formatDateTime(T1.`date`, '%Y') = '2016' AND T2.`city` IN ('San Francisco', 'SAN FRANCISCO', 'SF', 'S.F.');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 130,
                "end_index": 155,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 140,
                "end_index": 171,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspections`\nColumns:\n(`business_id`, integer)\n(`score`, integer)\n(`date`, date)\n(`type`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `businesses`\nColumns:\n(`business_id`, integer, primary key)\n(`name`, text)\n(`address`, text)\n(`city`, text)\n(`postal_code`, text)\n(`latitude`, real)\n(`longitude`, real)\n(`phone_number`, integer)\n(`tax_code`, text)\n(`business_certificate`, integer)\n(`application_date`, date)\n(`owner_name`, text)\n(`owner_address`, text)\n(`owner_city`, text)\n(`owner_state`, text)\n(`owner_zip`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `inspections`\nColumns:\n(`business_id`, Int64)\n(`score`, Int64)\n(`date`, Date32)\n(`_type`, String)\n(`rowid`, Int64, primary key)\n",
            "Table: `businesses`\nColumns:\n(`business_id`, Int64, primary key)\n(`name`, String)\n(`address`, String)\n(`city`, String)\n(`postal_code`, String)\n(`latitude`, Float64)\n(`longitude`, Float64)\n(`phone_number`, Int64)\n(`tax_code`, String)\n(`business_certificate`, Int64)\n(`application_date`, Date32)\n(`owner_name`, String)\n(`owner_address`, String)\n(`owner_city`, String)\n(`owner_state`, String)\n(`owner_zip`, String)\n"
        ]
    },
    {
        "sql_id": 596,
        "database_name": "food_inspection",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT T2.name FROM violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE STRFTIME('%Y', T1.`date`) = '2014' AND T1.risk_category = 'Low Risk'",
        "target_query": "SELECT DISTINCT T2.`name` FROM `violations` AS T1 INNER JOIN `businesses` AS T2 ON T1.`business_id` = T2.`business_id` WHERE formatDateTime(T1.`date`, '%Y') = '2014' AND T1.`risk_category` = 'Low Risk';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 115,
                "end_index": 140,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 125,
                "end_index": 156,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `violations`\nColumns:\n(`business_id`, integer)\n(`date`, date)\n(`violation_type_id`, text)\n(`risk_category`, text)\n(`description`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `businesses`\nColumns:\n(`business_id`, integer, primary key)\n(`name`, text)\n(`address`, text)\n(`city`, text)\n(`postal_code`, text)\n(`latitude`, real)\n(`longitude`, real)\n(`phone_number`, integer)\n(`tax_code`, text)\n(`business_certificate`, integer)\n(`application_date`, date)\n(`owner_name`, text)\n(`owner_address`, text)\n(`owner_city`, text)\n(`owner_state`, text)\n(`owner_zip`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `violations`\nColumns:\n(`business_id`, Int64)\n(`date`, Date32)\n(`violation_type_id`, String)\n(`risk_category`, String)\n(`description`, String)\n(`rowid`, Int64, primary key)\n",
            "Table: `businesses`\nColumns:\n(`business_id`, Int64, primary key)\n(`name`, String)\n(`address`, String)\n(`city`, String)\n(`postal_code`, String)\n(`latitude`, Float64)\n(`longitude`, Float64)\n(`phone_number`, Int64)\n(`tax_code`, String)\n(`business_certificate`, Int64)\n(`application_date`, Date32)\n(`owner_name`, String)\n(`owner_address`, String)\n(`owner_city`, String)\n(`owner_state`, String)\n(`owner_zip`, String)\n"
        ]
    },
    {
        "sql_id": 597,
        "database_name": "food_inspection",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(business_id) FROM businesses WHERE STRFTIME('%Y', application_date) = '2012'",
        "target_query": "SELECT COUNT(`business_id`) FROM `businesses` WHERE formatDateTime(`application_date`, '%Y') = '2012';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 48,
                "end_index": 80,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 52,
                "end_index": 92,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `businesses`\nColumns:\n(`business_id`, integer, primary key)\n(`name`, text)\n(`address`, text)\n(`city`, text)\n(`postal_code`, text)\n(`latitude`, real)\n(`longitude`, real)\n(`phone_number`, integer)\n(`tax_code`, text)\n(`business_certificate`, integer)\n(`application_date`, date)\n(`owner_name`, text)\n(`owner_address`, text)\n(`owner_city`, text)\n(`owner_state`, text)\n(`owner_zip`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `businesses`\nColumns:\n(`business_id`, Int64, primary key)\n(`name`, String)\n(`address`, String)\n(`city`, String)\n(`postal_code`, String)\n(`latitude`, Float64)\n(`longitude`, Float64)\n(`phone_number`, Int64)\n(`tax_code`, String)\n(`business_certificate`, Int64)\n(`application_date`, Date32)\n(`owner_name`, String)\n(`owner_address`, String)\n(`owner_city`, String)\n(`owner_state`, String)\n(`owner_zip`, String)\n"
        ]
    },
    {
        "sql_id": 598,
        "database_name": "food_inspection",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(business_id) FROM inspections WHERE STRFTIME('%Y', `date`) = '2014' AND type = 'Foodborne Illness Investigation'",
        "target_query": "SELECT COUNT(`business_id`) FROM `inspections` WHERE toYear(`date`) = 2014 AND `_type` = 'Foodborne Illness Investigation';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 49,
                "end_index": 71,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspections`\nColumns:\n(`business_id`, integer)\n(`score`, integer)\n(`date`, date)\n(`type`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `inspections`\nColumns:\n(`business_id`, Int64)\n(`score`, Int64)\n(`date`, Date32)\n(`_type`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 599,
        "database_name": "food_inspection",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT T2.name FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE STRFTIME('%Y', T1.`date`) = '2013' AND T1.score = 100",
        "target_query": "SELECT DISTINCT T2.`name` FROM `inspections` AS T1 INNER JOIN `businesses` AS T2 ON T1.`business_id` = T2.`business_id` WHERE formatDateTime(T1.`date`, '%Y') = '2013' AND T1.`score` = 100;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 116,
                "end_index": 141,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 126,
                "end_index": 157,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspections`\nColumns:\n(`business_id`, integer)\n(`score`, integer)\n(`date`, date)\n(`type`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `businesses`\nColumns:\n(`business_id`, integer, primary key)\n(`name`, text)\n(`address`, text)\n(`city`, text)\n(`postal_code`, text)\n(`latitude`, real)\n(`longitude`, real)\n(`phone_number`, integer)\n(`tax_code`, text)\n(`business_certificate`, integer)\n(`application_date`, date)\n(`owner_name`, text)\n(`owner_address`, text)\n(`owner_city`, text)\n(`owner_state`, text)\n(`owner_zip`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `inspections`\nColumns:\n(`business_id`, Int64)\n(`score`, Int64)\n(`date`, Date32)\n(`_type`, String)\n(`rowid`, Int64, primary key)\n",
            "Table: `businesses`\nColumns:\n(`business_id`, Int64, primary key)\n(`name`, String)\n(`address`, String)\n(`city`, String)\n(`postal_code`, String)\n(`latitude`, Float64)\n(`longitude`, Float64)\n(`phone_number`, Int64)\n(`tax_code`, String)\n(`business_certificate`, Int64)\n(`application_date`, Date32)\n(`owner_name`, String)\n(`owner_address`, String)\n(`owner_city`, String)\n(`owner_state`, String)\n(`owner_zip`, String)\n"
        ]
    },
    {
        "sql_id": 600,
        "database_name": "food_inspection",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.city FROM violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE STRFTIME('%Y', T1.`date`) = '2016' AND T1.risk_category = 'High Risk' GROUP BY T2.city ORDER BY COUNT(T2.city) DESC LIMIT 1",
        "target_query": "SELECT T2.`city` FROM `violations` AS T1 INNER JOIN `businesses` AS T2 ON T1.`business_id` = T2.`business_id` WHERE formatDateTime(T1.`date`, '%Y') = '2016' AND T1.`risk_category` = 'High Risk' GROUP BY T2.`city` ORDER BY COUNT(T2.`city`) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 106,
                "end_index": 131,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 116,
                "end_index": 147,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `violations`\nColumns:\n(`business_id`, integer)\n(`date`, date)\n(`violation_type_id`, text)\n(`risk_category`, text)\n(`description`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `businesses`\nColumns:\n(`business_id`, integer, primary key)\n(`name`, text)\n(`address`, text)\n(`city`, text)\n(`postal_code`, text)\n(`latitude`, real)\n(`longitude`, real)\n(`phone_number`, integer)\n(`tax_code`, text)\n(`business_certificate`, integer)\n(`application_date`, date)\n(`owner_name`, text)\n(`owner_address`, text)\n(`owner_city`, text)\n(`owner_state`, text)\n(`owner_zip`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `violations`\nColumns:\n(`business_id`, Int64)\n(`date`, Date32)\n(`violation_type_id`, String)\n(`risk_category`, String)\n(`description`, String)\n(`rowid`, Int64, primary key)\n",
            "Table: `businesses`\nColumns:\n(`business_id`, Int64, primary key)\n(`name`, String)\n(`address`, String)\n(`city`, String)\n(`postal_code`, String)\n(`latitude`, Float64)\n(`longitude`, Float64)\n(`phone_number`, Int64)\n(`tax_code`, String)\n(`business_certificate`, Int64)\n(`application_date`, Date32)\n(`owner_name`, String)\n(`owner_address`, String)\n(`owner_city`, String)\n(`owner_state`, String)\n(`owner_zip`, String)\n"
        ]
    },
    {
        "sql_id": 601,
        "database_name": "food_inspection",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.name FROM violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE STRFTIME('%Y', T1.`date`) = '2013' AND T1.description = 'Contaminated or adulterated food'",
        "target_query": "SELECT T2.`name` FROM `violations` AS T1 INNER JOIN `businesses` AS T2 ON T1.`business_id` = T2.`business_id` WHERE formatDateTime(T1.`date`, '%Y') = '2013' AND T1.`description` = 'Contaminated or adulterated food';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 106,
                "end_index": 131,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 116,
                "end_index": 147,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `violations`\nColumns:\n(`business_id`, integer)\n(`date`, date)\n(`violation_type_id`, text)\n(`risk_category`, text)\n(`description`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `businesses`\nColumns:\n(`business_id`, integer, primary key)\n(`name`, text)\n(`address`, text)\n(`city`, text)\n(`postal_code`, text)\n(`latitude`, real)\n(`longitude`, real)\n(`phone_number`, integer)\n(`tax_code`, text)\n(`business_certificate`, integer)\n(`application_date`, date)\n(`owner_name`, text)\n(`owner_address`, text)\n(`owner_city`, text)\n(`owner_state`, text)\n(`owner_zip`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `violations`\nColumns:\n(`business_id`, Int64)\n(`date`, Date32)\n(`violation_type_id`, String)\n(`risk_category`, String)\n(`description`, String)\n(`rowid`, Int64, primary key)\n",
            "Table: `businesses`\nColumns:\n(`business_id`, Int64, primary key)\n(`name`, String)\n(`address`, String)\n(`city`, String)\n(`postal_code`, String)\n(`latitude`, Float64)\n(`longitude`, Float64)\n(`phone_number`, Int64)\n(`tax_code`, String)\n(`business_certificate`, Int64)\n(`application_date`, Date32)\n(`owner_name`, String)\n(`owner_address`, String)\n(`owner_city`, String)\n(`owner_state`, String)\n(`owner_zip`, String)\n"
        ]
    },
    {
        "sql_id": 602,
        "database_name": "food_inspection",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(DISTINCT T2.business_id) FROM violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id INNER JOIN inspections AS T3 ON T2.business_id = T3.business_id WHERE STRFTIME('%Y', T1.`date`) = '2015' AND T2.postal_code = '94102' AND T3.score > 90",
        "target_query": "SELECT COUNT(DISTINCT T2.`business_id`) FROM `violations` AS T1 INNER JOIN `businesses` AS T2 ON T1.`business_id` = T2.`business_id` INNER JOIN `inspections` AS T3 ON T2.`business_id` = T3.`business_id` WHERE formatDateTime(T1.`date`, '%Y') = '2015' AND T2.`postal_code` = '94102' AND T3.`score` > 90;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 193,
                "end_index": 218,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 209,
                "end_index": 240,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `violations`\nColumns:\n(`business_id`, integer)\n(`date`, date)\n(`violation_type_id`, text)\n(`risk_category`, text)\n(`description`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `businesses`\nColumns:\n(`business_id`, integer, primary key)\n(`name`, text)\n(`address`, text)\n(`city`, text)\n(`postal_code`, text)\n(`latitude`, real)\n(`longitude`, real)\n(`phone_number`, integer)\n(`tax_code`, text)\n(`business_certificate`, integer)\n(`application_date`, date)\n(`owner_name`, text)\n(`owner_address`, text)\n(`owner_city`, text)\n(`owner_state`, text)\n(`owner_zip`, text)\n",
            "Table: `inspections`\nColumns:\n(`business_id`, integer)\n(`score`, integer)\n(`date`, date)\n(`type`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `violations`\nColumns:\n(`business_id`, Int64)\n(`date`, Date32)\n(`violation_type_id`, String)\n(`risk_category`, String)\n(`description`, String)\n(`rowid`, Int64, primary key)\n",
            "Table: `businesses`\nColumns:\n(`business_id`, Int64, primary key)\n(`name`, String)\n(`address`, String)\n(`city`, String)\n(`postal_code`, String)\n(`latitude`, Float64)\n(`longitude`, Float64)\n(`phone_number`, Int64)\n(`tax_code`, String)\n(`business_certificate`, Int64)\n(`application_date`, Date32)\n(`owner_name`, String)\n(`owner_address`, String)\n(`owner_city`, String)\n(`owner_state`, String)\n(`owner_zip`, String)\n",
            "Table: `inspections`\nColumns:\n(`business_id`, Int64)\n(`score`, Int64)\n(`date`, Date32)\n(`_type`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 603,
        "database_name": "food_inspection",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT T4.name FROM ( SELECT T3.name, T3.years, row_number() OVER (PARTITION BY T3.name ORDER BY T3.years) AS rowNumber FROM ( SELECT DISTINCT name, STRFTIME('%Y', `date`) AS years FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T1.score = 100 ) AS T3 ) AS T4 GROUP BY T4.name, date(T4.years || '-01-01', '-' || (T4.rowNumber - 1) || ' years') HAVING COUNT(T4.years) = 4",
        "target_query": "SELECT DISTINCT T4.`name` \nFROM ( \n    SELECT T3.`name`, T3.`years`, rowNumberInAllBlocks() AS rowNumber \n    FROM ( \n        SELECT DISTINCT `name`, formatDateTime(`date`, '%Y') AS `years` \n        FROM `inspections` AS T1 \n        INNER JOIN `businesses` AS T2 ON T1.`business_id` = T2.`business_id` \n        WHERE T1.`score` = 100 \n    ) AS T3 \n) AS T4 \nGROUP BY T4.`name`, toDate(T4.`years` || '-01-01') + INTERVAL (T4.rowNumber) YEAR \nHAVING COUNT(T4.`years`) = 4;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 57,
                "end_index": 69,
                "dialect_content": " The number of the row within the current partition. Rows are\n       numbered starting from 1 in the order defined by the ORDER BY clause in\n       the window definition, or in arbitrary order otherwise.\n  ",
                "feature": "row_number()"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 69,
                "end_index": 91,
                "dialect_content": "rowNumberInAllBlocks\nReturns a unique row number for each row processed by rowNumberInAllBlocks. The returned numbers start at 0.\nSyntax\nrowNumberInAllBlocks()\nReturned value\nOrdinal number of the row in the data block starting from 0. UInt64.",
                "feature": "rowNumberInAllBlocks()"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "row_number()",
                "explanation": " The number of the row within the current partition. Rows are\n       numbered starting from 1 in the order defined by the ORDER BY clause in\n       the window definition, or in arbitrary order otherwise.\n  ",
                "examples": [
                    "SELECT id, name, score, ROW_NUMBER() OVER (ORDER BY score DESC) AS row_num FROM students;"
                ]
            },
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "rowNumberInAllBlocks()",
                "explanation": "rowNumberInAllBlocks\nReturns a unique row number for each row processed by rowNumberInAllBlocks. The returned numbers start at 0.\nSyntax\nrowNumberInAllBlocks()\nReturned value\nOrdinal number of the row in the data block starting from 0. UInt64.",
                "examples": [
                    "SELECT rowNumberInAllBlocks()FROM(    SELECT *    FROM system.numbers_mt    LIMIT 10)SETTINGS max_block_size = 2"
                ]
            },
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspections`\nColumns:\n(`business_id`, integer)\n(`score`, integer)\n(`date`, date)\n(`type`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `businesses`\nColumns:\n(`business_id`, integer, primary key)\n(`name`, text)\n(`address`, text)\n(`city`, text)\n(`postal_code`, text)\n(`latitude`, real)\n(`longitude`, real)\n(`phone_number`, integer)\n(`tax_code`, text)\n(`business_certificate`, integer)\n(`application_date`, date)\n(`owner_name`, text)\n(`owner_address`, text)\n(`owner_city`, text)\n(`owner_state`, text)\n(`owner_zip`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `inspections`\nColumns:\n(`business_id`, Int64)\n(`score`, Int64)\n(`date`, Date32)\n(`_type`, String)\n(`rowid`, Int64, primary key)\n",
            "Table: `businesses`\nColumns:\n(`business_id`, Int64, primary key)\n(`name`, String)\n(`address`, String)\n(`city`, String)\n(`postal_code`, String)\n(`latitude`, Float64)\n(`longitude`, Float64)\n(`phone_number`, Int64)\n(`tax_code`, String)\n(`business_certificate`, Int64)\n(`application_date`, Date32)\n(`owner_name`, String)\n(`owner_address`, String)\n(`owner_city`, String)\n(`owner_state`, String)\n(`owner_zip`, String)\n"
        ]
    },
    {
        "sql_id": 604,
        "database_name": "food_inspection",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT AVG(T1.score) FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE STRFTIME('%Y', T1.`date`) BETWEEN '2014' AND '2016' AND T2.owner_name = 'Yiu Tim Chan' AND T2.address = '808 Pacific Ave' AND T2.city = 'San Francisco'",
        "target_query": "SELECT AVG(`T1`.`score`) FROM `inspections` AS `T1` INNER JOIN `businesses` AS `T2` ON `T1`.`business_id` = `T2`.`business_id` WHERE formatDateTime(`T1`.`date`, '%Y') BETWEEN '2014' AND '2016' AND `T2`.`owner_name` = 'Yiu Tim Chan' AND `T2`.`address` = '808 Pacific Ave' AND `T2`.`city` = 'San Francisco';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 113,
                "end_index": 138,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 133,
                "end_index": 166,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspections`\nColumns:\n(`business_id`, integer)\n(`score`, integer)\n(`date`, date)\n(`type`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `businesses`\nColumns:\n(`business_id`, integer, primary key)\n(`name`, text)\n(`address`, text)\n(`city`, text)\n(`postal_code`, text)\n(`latitude`, real)\n(`longitude`, real)\n(`phone_number`, integer)\n(`tax_code`, text)\n(`business_certificate`, integer)\n(`application_date`, date)\n(`owner_name`, text)\n(`owner_address`, text)\n(`owner_city`, text)\n(`owner_state`, text)\n(`owner_zip`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `inspections`\nColumns:\n(`business_id`, Int64)\n(`score`, Int64)\n(`date`, Date32)\n(`_type`, String)\n(`rowid`, Int64, primary key)\n",
            "Table: `businesses`\nColumns:\n(`business_id`, Int64, primary key)\n(`name`, String)\n(`address`, String)\n(`city`, String)\n(`postal_code`, String)\n(`latitude`, Float64)\n(`longitude`, Float64)\n(`phone_number`, Int64)\n(`tax_code`, String)\n(`business_certificate`, Int64)\n(`application_date`, Date32)\n(`owner_name`, String)\n(`owner_address`, String)\n(`owner_city`, String)\n(`owner_state`, String)\n(`owner_zip`, String)\n"
        ]
    },
    {
        "sql_id": 606,
        "database_name": "food_inspection",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(DISTINCT business_id) FROM inspections WHERE STRFTIME('%Y', `date`) = '2013' AND score = ( SELECT MAX(score) FROM inspections WHERE STRFTIME('%Y', `date`) = '2013' )",
        "target_query": "SELECT COUNT(DISTINCT `business_id`) FROM `inspections` WHERE formatDateTime(`date`, '%Y') = '2013' AND `score` = ( SELECT MAX(`score`) FROM `inspections` WHERE formatDateTime(`date`, '%Y') = '2013' );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 58,
                "end_index": 80,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 145,
                "end_index": 167,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 62,
                "end_index": 90,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            },
            {
                "start_index": 161,
                "end_index": 189,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspections`\nColumns:\n(`business_id`, integer)\n(`score`, integer)\n(`date`, date)\n(`type`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `inspections`\nColumns:\n(`business_id`, Int64)\n(`score`, Int64)\n(`date`, Date32)\n(`_type`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 607,
        "database_name": "food_inspection",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(risk_category) FROM violations WHERE STRFTIME('%Y', `date`) = '2014' AND risk_category = 'Low Risk'",
        "target_query": "SELECT COUNT(`risk_category`) FROM `violations` WHERE formatDateTime(`date`, '%Y') = '2014' AND `risk_category` = 'Low Risk';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 50,
                "end_index": 72,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 54,
                "end_index": 82,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `violations`\nColumns:\n(`business_id`, integer)\n(`date`, date)\n(`violation_type_id`, text)\n(`risk_category`, text)\n(`description`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `violations`\nColumns:\n(`business_id`, Int64)\n(`date`, Date32)\n(`violation_type_id`, String)\n(`risk_category`, String)\n(`description`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 608,
        "database_name": "food_inspection",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T2.business_id) FROM violations AS T1 INNER JOIN inspections AS T2 ON T1.business_id = T2.business_id WHERE STRFTIME('%Y', T1.`date`) = '2016' AND T2.type = 'Routine - Unscheduled'",
        "target_query": "SELECT COUNT(T2.`business_id`) FROM `violations` AS T1 INNER JOIN `inspections` AS T2 ON T1.`business_id` = T2.`business_id` WHERE formatDateTime(T1.`date`, '%Y') = '2016' AND T2.`_type` = 'Routine - Unscheduled';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 121,
                "end_index": 146,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 131,
                "end_index": 162,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `violations`\nColumns:\n(`business_id`, integer)\n(`date`, date)\n(`violation_type_id`, text)\n(`risk_category`, text)\n(`description`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `inspections`\nColumns:\n(`business_id`, integer)\n(`score`, integer)\n(`date`, date)\n(`type`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `violations`\nColumns:\n(`business_id`, Int64)\n(`date`, Date32)\n(`violation_type_id`, String)\n(`risk_category`, String)\n(`description`, String)\n(`rowid`, Int64, primary key)\n",
            "Table: `inspections`\nColumns:\n(`business_id`, Int64)\n(`score`, Int64)\n(`date`, Date32)\n(`_type`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 418,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT T1.first_name, T1.last_name FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE strftime('%Y-%m', T2.inspection_date) = '2010-05' AND T1.title = 'Sanitarian'",
        "target_query": "SELECT DISTINCT `T1`.`first_name`, `T1`.`last_name` FROM `employee` AS `T1` INNER JOIN `inspection` AS `T2` ON `T1`.`employee_id` = `T2`.`employee_id` WHERE formatDateTime(`T2`.`inspection_date`, '%Y-%m') = '2010-05' AND `T1`.`title` = 'Sanitarian';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 133,
                "end_index": 170,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 157,
                "end_index": 204,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`employee_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`phone`, text)\n(`title`, text)\n(`salary`, integer)\n(`supervisor`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `employee`\nColumns:\n(`employee_id`, Int64, primary key)\n(`first_name`, String)\n(`last_name`, String)\n(`address`, String)\n(`city`, String)\n(`state`, String)\n(`zip`, Int64)\n(`phone`, String)\n(`title`, String)\n(`salary`, Int64)\n(`supervisor`, Int64)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, Int64, primary key)\n(`inspection_date`, Date32)\n(`inspection_type`, String)\n(`results`, String)\n(`employee_id`, Int64)\n(`license_no`, Int64)\n(`followup_to`, Int64)\n"
        ]
    },
    {
        "sql_id": 419,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T2.inspection_id) FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE strftime('%Y', T2.inspection_date) = '2010' AND T1.first_name = 'Joshua' AND T1.last_name = 'Rosa'",
        "target_query": "SELECT COUNT(`T2`.`inspection_id`) FROM `employee` AS `T1` INNER JOIN `inspection` AS `T2` ON `T1`.`employee_id` = `T2`.`employee_id` WHERE formatDateTime(`T2`.`inspection_date`, '%Y') = '2010' AND `T1`.`first_name` = 'Joshua' AND `T1`.`last_name` = 'Rosa';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 120,
                "end_index": 154,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 140,
                "end_index": 184,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`employee_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`phone`, text)\n(`title`, text)\n(`salary`, integer)\n(`supervisor`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `employee`\nColumns:\n(`employee_id`, Int64, primary key)\n(`first_name`, String)\n(`last_name`, String)\n(`address`, String)\n(`city`, String)\n(`state`, String)\n(`zip`, Int64)\n(`phone`, String)\n(`title`, String)\n(`salary`, Int64)\n(`supervisor`, Int64)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, Int64, primary key)\n(`inspection_date`, Date32)\n(`inspection_type`, String)\n(`results`, String)\n(`employee_id`, Int64)\n(`license_no`, Int64)\n(`followup_to`, Int64)\n"
        ]
    },
    {
        "sql_id": 420,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(DISTINCT T1.license_no) FROM inspection AS T1 INNER JOIN establishment AS T2 ON T1.license_no = T2.license_no WHERE strftime('%Y', T1.inspection_date) = '2010' AND T2.facility_type = 'Restaurant'",
        "target_query": "SELECT COUNT(DISTINCT `T1`.`license_no`) FROM `inspection` AS `T1` INNER JOIN `establishment` AS `T2` ON `T1`.`license_no` = `T2`.`license_no` WHERE formatDateTime(`T1`.`inspection_date`, '%Y') = '2010' AND `T2`.`facility_type` = 'Restaurant';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 129,
                "end_index": 163,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 149,
                "end_index": 193,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n",
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `inspection`\nColumns:\n(`inspection_id`, Int64, primary key)\n(`inspection_date`, Date32)\n(`inspection_type`, String)\n(`results`, String)\n(`employee_id`, Int64)\n(`license_no`, Int64)\n(`followup_to`, Int64)\n",
            "Table: `establishment`\nColumns:\n(`license_no`, Int64, primary key)\n(`dba_name`, String)\n(`aka_name`, String)\n(`facility_type`, String)\n(`risk_level`, Int64)\n(`address`, String)\n(`city`, String)\n(`state`, String)\n(`zip`, Int64)\n(`latitude`, Float64)\n(`longitude`, Float64)\n(`ward`, Int64)\n"
        ]
    },
    {
        "sql_id": 421,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(DISTINCT T1.license_no) FROM inspection AS T1 INNER JOIN establishment AS T2 ON T1.license_no = T2.license_no WHERE strftime('%Y', T1.inspection_date) = '2010' AND T2.ward = 42",
        "target_query": "SELECT COUNT(DISTINCT T1.`license_no`) FROM `inspection` AS T1 INNER JOIN `establishment` AS T2 ON T1.`license_no` = T2.`license_no` WHERE formatDateTime(T1.`inspection_date`, '%Y') = '2010' AND T2.`ward` = 42;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 129,
                "end_index": 163,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 139,
                "end_index": 181,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n",
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `inspection`\nColumns:\n(`inspection_id`, Int64, primary key)\n(`inspection_date`, Date32)\n(`inspection_type`, String)\n(`results`, String)\n(`employee_id`, Int64)\n(`license_no`, Int64)\n(`followup_to`, Int64)\n",
            "Table: `establishment`\nColumns:\n(`license_no`, Int64, primary key)\n(`dba_name`, String)\n(`aka_name`, String)\n(`facility_type`, String)\n(`risk_level`, Int64)\n(`address`, String)\n(`city`, String)\n(`state`, String)\n(`zip`, Int64)\n(`latitude`, Float64)\n(`longitude`, Float64)\n(`ward`, Int64)\n"
        ]
    },
    {
        "sql_id": 422,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT T2.dba_name FROM inspection AS T1 INNER JOIN establishment AS T2 ON T1.license_no = T2.license_no WHERE T1.results = 'Fail' AND strftime('%Y', T1.inspection_date) = '2010'",
        "target_query": "SELECT DISTINCT `T2`.`dba_name` FROM `inspection` AS `T1` INNER JOIN `establishment` AS `T2` ON `T1`.`license_no` = `T2`.`license_no` WHERE `T1`.`results` = 'Fail' AND formatDateTime(`T1`.`inspection_date`, '%Y') = '2010';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 144,
                "end_index": 178,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 168,
                "end_index": 212,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n",
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `inspection`\nColumns:\n(`inspection_id`, Int64, primary key)\n(`inspection_date`, Date32)\n(`inspection_type`, String)\n(`results`, String)\n(`employee_id`, Int64)\n(`license_no`, Int64)\n(`followup_to`, Int64)\n",
            "Table: `establishment`\nColumns:\n(`license_no`, Int64, primary key)\n(`dba_name`, String)\n(`aka_name`, String)\n(`facility_type`, String)\n(`risk_level`, Int64)\n(`address`, String)\n(`city`, String)\n(`state`, String)\n(`zip`, Int64)\n(`latitude`, Float64)\n(`longitude`, Float64)\n(`ward`, Int64)\n"
        ]
    },
    {
        "sql_id": 423,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(DISTINCT T2.license_no) FROM inspection AS T1 INNER JOIN establishment AS T2 ON T1.license_no = T2.license_no WHERE strftime('%Y', T1.inspection_date) = '2010' AND T2.risk_level = 3",
        "target_query": "SELECT COUNT(DISTINCT `T2`.`license_no`) FROM `inspection` AS `T1` INNER JOIN `establishment` AS `T2` ON `T1`.`license_no` = `T2`.`license_no` WHERE formatDateTime(`T1`.`inspection_date`, '%Y') = '2010' AND `T2`.`risk_level` = 3;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 129,
                "end_index": 163,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 149,
                "end_index": 193,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n",
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `inspection`\nColumns:\n(`inspection_id`, Int64, primary key)\n(`inspection_date`, Date32)\n(`inspection_type`, String)\n(`results`, String)\n(`employee_id`, Int64)\n(`license_no`, Int64)\n(`followup_to`, Int64)\n",
            "Table: `establishment`\nColumns:\n(`license_no`, Int64, primary key)\n(`dba_name`, String)\n(`aka_name`, String)\n(`facility_type`, String)\n(`risk_level`, Int64)\n(`address`, String)\n(`city`, String)\n(`state`, String)\n(`zip`, Int64)\n(`latitude`, Float64)\n(`longitude`, Float64)\n(`ward`, Int64)\n"
        ]
    },
    {
        "sql_id": 424,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T1.inspection_id) FROM inspection AS T1 INNER JOIN employee AS T2 ON T1.employee_id = T2.employee_id WHERE T2.address = '5000 N Wolcott Ave' AND T2.title = 'Sanitarian' AND strftime('%Y-%m', T1.inspection_date) = '2011-05'",
        "target_query": "SELECT COUNT(`T1`.`inspection_id`) FROM `inspection` AS `T1` INNER JOIN `employee` AS `T2` ON `T1`.`employee_id` = `T2`.`employee_id` WHERE `T2`.`address` = '5000 N Wolcott Ave' AND `T2`.`title` = 'Sanitarian' AND formatDateTime(`T1`.`inspection_date`, '%Y-%m') = '2011-05';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 186,
                "end_index": 223,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 214,
                "end_index": 261,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n",
            "Table: `employee`\nColumns:\n(`employee_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`phone`, text)\n(`title`, text)\n(`salary`, integer)\n(`supervisor`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `inspection`\nColumns:\n(`inspection_id`, Int64, primary key)\n(`inspection_date`, Date32)\n(`inspection_type`, String)\n(`results`, String)\n(`employee_id`, Int64)\n(`license_no`, Int64)\n(`followup_to`, Int64)\n",
            "Table: `employee`\nColumns:\n(`employee_id`, Int64, primary key)\n(`first_name`, String)\n(`last_name`, String)\n(`address`, String)\n(`city`, String)\n(`state`, String)\n(`zip`, Int64)\n(`phone`, String)\n(`title`, String)\n(`salary`, Int64)\n(`supervisor`, Int64)\n"
        ]
    },
    {
        "sql_id": 425,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T3.first_name, T3.last_name FROM ( SELECT T1.employee_id, COUNT(T1.inspection_id) FROM inspection AS T1 WHERE strftime('%Y-%m', T1.inspection_date) = '2016-03' GROUP BY T1.employee_id ORDER BY COUNT(T1.inspection_id) DESC LIMIT 1 ) AS T2 INNER JOIN employee AS T3 ON T2.employee_id = T3.employee_id",
        "target_query": "SELECT T3.`first_name`, T3.`last_name` \nFROM ( \n    SELECT T1.`employee_id`, COUNT(T1.`inspection_id`) \n    FROM `inspection` AS T1 \n    WHERE formatDateTime(T1.`inspection_date`, '%Y-%m') = '2016-03' \n    GROUP BY T1.`employee_id` \n    ORDER BY COUNT(T1.`inspection_id`) DESC \n    LIMIT 1 \n) AS T2 \nINNER JOIN `employee` AS T3 ON T2.`employee_id` = T3.`employee_id`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 117,
                "end_index": 154,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 143,
                "end_index": 188,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`employee_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`phone`, text)\n(`title`, text)\n(`salary`, integer)\n(`supervisor`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `employee`\nColumns:\n(`employee_id`, Int64, primary key)\n(`first_name`, String)\n(`last_name`, String)\n(`address`, String)\n(`city`, String)\n(`state`, String)\n(`zip`, Int64)\n(`phone`, String)\n(`title`, String)\n(`salary`, Int64)\n(`supervisor`, Int64)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, Int64, primary key)\n(`inspection_date`, Date32)\n(`inspection_type`, String)\n(`results`, String)\n(`employee_id`, Int64)\n(`license_no`, Int64)\n(`followup_to`, Int64)\n"
        ]
    },
    {
        "sql_id": 426,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT T2.dba_name FROM inspection AS T1 INNER JOIN establishment AS T2 ON T1.license_no = T2.license_no WHERE strftime('%Y-%m', T1.inspection_date) = '2012-05' AND T1.results = 'Pass w/ Conditions'",
        "target_query": "SELECT DISTINCT `T2`.`dba_name` FROM `inspection` AS `T1` INNER JOIN `establishment` AS `T2` ON `T1`.`license_no` = `T2`.`license_no` WHERE formatDateTime(`T1`.`inspection_date`, '%Y-%m') = '2012-05' AND `T1`.`results` = 'Pass w/ Conditions';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 120,
                "end_index": 157,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 140,
                "end_index": 187,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n",
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `inspection`\nColumns:\n(`inspection_id`, Int64, primary key)\n(`inspection_date`, Date32)\n(`inspection_type`, String)\n(`results`, String)\n(`employee_id`, Int64)\n(`license_no`, Int64)\n(`followup_to`, Int64)\n",
            "Table: `establishment`\nColumns:\n(`license_no`, Int64, primary key)\n(`dba_name`, String)\n(`aka_name`, String)\n(`facility_type`, String)\n(`risk_level`, Int64)\n(`address`, String)\n(`city`, String)\n(`state`, String)\n(`zip`, Int64)\n(`latitude`, Float64)\n(`longitude`, Float64)\n(`ward`, Int64)\n"
        ]
    },
    {
        "sql_id": 427,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T.dba_name FROM ( SELECT T1.dba_name, SUM(T3.fine) FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no INNER JOIN violation AS T3 ON T2.inspection_id = T3.inspection_id WHERE strftime('%Y', T2.inspection_date) = '2014' GROUP BY T1.dba_name ORDER BY SUM(T3.fine) DESC LIMIT 1 ) AS T",
        "target_query": "SELECT T.`dba_name` FROM ( SELECT T1.`dba_name`, SUM(T3.`fine`) FROM `establishment` AS T1 INNER JOIN `inspection` AS T2 ON T1.`license_no` = T2.`license_no` INNER JOIN `violation` AS T3 ON T2.`inspection_id` = T3.`inspection_id` WHERE formatDateTime(T2.`inspection_date`, '%Y') = '2014' GROUP BY T1.`dba_name` ORDER BY SUM(T3.`fine`) DESC LIMIT 1 ) AS T;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 216,
                "end_index": 250,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 236,
                "end_index": 278,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n",
            "Table: `violation`\nColumns:\n(`inspection_id`, integer, primary key)\n(`point_id`, integer, primary key)\n(`fine`, integer)\n(`inspector_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `establishment`\nColumns:\n(`license_no`, Int64, primary key)\n(`dba_name`, String)\n(`aka_name`, String)\n(`facility_type`, String)\n(`risk_level`, Int64)\n(`address`, String)\n(`city`, String)\n(`state`, String)\n(`zip`, Int64)\n(`latitude`, Float64)\n(`longitude`, Float64)\n(`ward`, Int64)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, Int64, primary key)\n(`inspection_date`, Date32)\n(`inspection_type`, String)\n(`results`, String)\n(`employee_id`, Int64)\n(`license_no`, Int64)\n(`followup_to`, Int64)\n",
            "Table: `violation`\nColumns:\n(`inspection_id`, Int64, primary key)\n(`point_id`, Int64, primary key)\n(`fine`, Int64)\n(`inspector_comment`, String)\n"
        ]
    },
    {
        "sql_id": 428,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(T3.fine) FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no INNER JOIN violation AS T3 ON T2.inspection_id = T3.inspection_id WHERE strftime('%Y-%m', T2.inspection_date) = '2014-02' AND T1.dba_name = 'RON OF JAPAN INC'",
        "target_query": "SELECT SUM(`T3`.`fine`) FROM `establishment` AS `T1` INNER JOIN `inspection` AS `T2` ON `T1`.`license_no` = `T2`.`license_no` INNER JOIN `violation` AS `T3` ON `T2`.`inspection_id` = `T3`.`inspection_id` WHERE formatDateTime(`T2`.`inspection_date`, '%Y-%m') = '2014-02' AND `T1`.`dba_name` = 'RON OF JAPAN INC';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 178,
                "end_index": 215,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 210,
                "end_index": 257,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n",
            "Table: `violation`\nColumns:\n(`inspection_id`, integer, primary key)\n(`point_id`, integer, primary key)\n(`fine`, integer)\n(`inspector_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `establishment`\nColumns:\n(`license_no`, Int64, primary key)\n(`dba_name`, String)\n(`aka_name`, String)\n(`facility_type`, String)\n(`risk_level`, Int64)\n(`address`, String)\n(`city`, String)\n(`state`, String)\n(`zip`, Int64)\n(`latitude`, Float64)\n(`longitude`, Float64)\n(`ward`, Int64)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, Int64, primary key)\n(`inspection_date`, Date32)\n(`inspection_type`, String)\n(`results`, String)\n(`employee_id`, Int64)\n(`license_no`, Int64)\n(`followup_to`, Int64)\n",
            "Table: `violation`\nColumns:\n(`inspection_id`, Int64, primary key)\n(`point_id`, Int64, primary key)\n(`fine`, Int64)\n(`inspector_comment`, String)\n"
        ]
    },
    {
        "sql_id": 429,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT T1.address FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE strftime('%Y-%m', T2.inspection_date) = '2010-03' AND T2.results = 'Pass' AND T1.facility_type = 'School'",
        "target_query": "SELECT DISTINCT `T1`.`address` FROM `establishment` AS `T1` INNER JOIN `inspection` AS `T2` ON `T1`.`license_no` = `T2`.`license_no` WHERE formatDateTime(`T2`.`inspection_date`, '%Y-%m') = '2010-03' AND `T2`.`results` = 'Pass' AND `T1`.`facility_type` = 'School';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 119,
                "end_index": 156,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 139,
                "end_index": 186,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `establishment`\nColumns:\n(`license_no`, Int64, primary key)\n(`dba_name`, String)\n(`aka_name`, String)\n(`facility_type`, String)\n(`risk_level`, Int64)\n(`address`, String)\n(`city`, String)\n(`state`, String)\n(`zip`, Int64)\n(`latitude`, Float64)\n(`longitude`, Float64)\n(`ward`, Int64)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, Int64, primary key)\n(`inspection_date`, Date32)\n(`inspection_type`, String)\n(`results`, String)\n(`employee_id`, Int64)\n(`license_no`, Int64)\n(`followup_to`, Int64)\n"
        ]
    },
    {
        "sql_id": 430,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(inspection_id) FROM inspection WHERE strftime('%Y-%m', inspection_date) = '2011-01'",
        "target_query": "SELECT COUNT(`inspection_id`) FROM `inspection` WHERE formatDateTime(`inspection_date`, '%Y-%m') = '2011-01';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 50,
                "end_index": 84,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 54,
                "end_index": 96,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `inspection`\nColumns:\n(`inspection_id`, Int64, primary key)\n(`inspection_date`, Date32)\n(`inspection_type`, String)\n(`results`, String)\n(`employee_id`, Int64)\n(`license_no`, Int64)\n(`followup_to`, Int64)\n"
        ]
    },
    {
        "sql_id": 431,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(inspection_id) FROM inspection WHERE strftime('%Y', inspection_date) = '2014' AND results = 'Fail'",
        "target_query": "SELECT COUNT(`inspection_id`) FROM `inspection` WHERE formatDateTime(`inspection_date`, '%Y') = '2014' AND `results` = 'Fail';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 50,
                "end_index": 81,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 54,
                "end_index": 93,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `inspection`\nColumns:\n(`inspection_id`, Int64, primary key)\n(`inspection_date`, Date32)\n(`inspection_type`, String)\n(`results`, String)\n(`employee_id`, Int64)\n(`license_no`, Int64)\n(`followup_to`, Int64)\n"
        ]
    },
    {
        "sql_id": 432,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT T4.category, T3.fine FROM inspection AS T1 INNER JOIN employee AS T2 ON T1.employee_id = T2.employee_id INNER JOIN violation AS T3 ON T1.inspection_id = T3.inspection_id INNER JOIN inspection_point AS T4 ON T3.point_id = T4.point_id WHERE T2.first_name = 'Lisa' AND T2.last_name = 'Tillman' AND strftime('%Y-%m', T1.inspection_date) = '2014-01'",
        "target_query": "SELECT DISTINCT `inspection_point`.`category`, `violation`.`fine` FROM `inspection` AS `T1` INNER JOIN `employee` AS `T2` ON `T1`.`employee_id` = `T2`.`employee_id` INNER JOIN `violation` AS `T3` ON `T1`.`inspection_id` = `T3`.`inspection_id` INNER JOIN `inspection_point` AS `T4` ON `T3`.`point_id` = `T4`.`point_id` WHERE `T2`.`first_name` = 'Lisa' AND `T2`.`last_name` = 'Tillman' AND formatDateTime(`T1`.`inspection_date`, '%Y-%m') = '2014-01';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 311,
                "end_index": 348,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 388,
                "end_index": 435,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n",
            "Table: `employee`\nColumns:\n(`employee_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`phone`, text)\n(`title`, text)\n(`salary`, integer)\n(`supervisor`, integer)\n",
            "Table: `violation`\nColumns:\n(`inspection_id`, integer, primary key)\n(`point_id`, integer, primary key)\n(`fine`, integer)\n(`inspector_comment`, text)\n",
            "Table: `inspection_point`\nColumns:\n(`point_id`, integer, primary key)\n(`Description`, text)\n(`category`, text)\n(`code`, text)\n(`fine`, integer)\n(`point_level`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `inspection`\nColumns:\n(`inspection_id`, Int64, primary key)\n(`inspection_date`, Date32)\n(`inspection_type`, String)\n(`results`, String)\n(`employee_id`, Int64)\n(`license_no`, Int64)\n(`followup_to`, Int64)\n",
            "Table: `employee`\nColumns:\n(`employee_id`, Int64, primary key)\n(`first_name`, String)\n(`last_name`, String)\n(`address`, String)\n(`city`, String)\n(`state`, String)\n(`zip`, Int64)\n(`phone`, String)\n(`title`, String)\n(`salary`, Int64)\n(`supervisor`, Int64)\n",
            "Table: `violation`\nColumns:\n(`inspection_id`, Int64, primary key)\n(`point_id`, Int64, primary key)\n(`fine`, Int64)\n(`inspector_comment`, String)\n",
            "Table: `inspection_point`\nColumns:\n(`point_id`, Int64, primary key)\n(`Description`, String)\n(`category`, String)\n(`code`, String)\n(`fine`, Int64)\n(`point_level`, String)\n"
        ]
    },
    {
        "sql_id": 433,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(COUNT(CASE WHEN T1.first_name = 'Jessica' AND T1.last_name = 'Anthony' THEN T2.inspection_id ELSE 0 END) AS REAL) / 8 FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE strftime('%Y', T2.inspection_date) BETWEEN '2010' AND '2017'",
        "target_query": "SELECT toFloat64(COUNT(CASE WHEN `T1`.`first_name` = 'Jessica' AND `T1`.`last_name` = 'Anthony' THEN `T2`.`inspection_id` ELSE 0 END)) / 8 FROM `employee` AS `T1` INNER JOIN `inspection` AS `T2` ON `T1`.`employee_id` = `T2`.`employee_id` WHERE formatDateTime(`T2`.`inspection_date`, '%Y') BETWEEN '2010' AND '2017';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 219,
                "end_index": 253,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 244,
                "end_index": 288,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`employee_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`phone`, text)\n(`title`, text)\n(`salary`, integer)\n(`supervisor`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `employee`\nColumns:\n(`employee_id`, Int64, primary key)\n(`first_name`, String)\n(`last_name`, String)\n(`address`, String)\n(`city`, String)\n(`state`, String)\n(`zip`, Int64)\n(`phone`, String)\n(`title`, String)\n(`salary`, Int64)\n(`supervisor`, Int64)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, Int64, primary key)\n(`inspection_date`, Date32)\n(`inspection_type`, String)\n(`results`, String)\n(`employee_id`, Int64)\n(`license_no`, Int64)\n(`followup_to`, Int64)\n"
        ]
    },
    {
        "sql_id": 434,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T2.inspection_id) FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE strftime('%Y', T2.inspection_date) = '2010' AND T1.risk_level = 3",
        "target_query": "SELECT COUNT(`T2`.`inspection_id`) FROM `establishment` AS `T1` INNER JOIN `inspection` AS `T2` ON `T1`.`license_no` = `T2`.`license_no` WHERE formatDateTime(`T2`.`inspection_date`, '%Y') = '2010' AND `T1`.`risk_level` = 3;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 123,
                "end_index": 157,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 143,
                "end_index": 187,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `establishment`\nColumns:\n(`license_no`, Int64, primary key)\n(`dba_name`, String)\n(`aka_name`, String)\n(`facility_type`, String)\n(`risk_level`, Int64)\n(`address`, String)\n(`city`, String)\n(`state`, String)\n(`zip`, Int64)\n(`latitude`, Float64)\n(`longitude`, Float64)\n(`ward`, Int64)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, Int64, primary key)\n(`inspection_date`, Date32)\n(`inspection_type`, String)\n(`results`, String)\n(`employee_id`, Int64)\n(`license_no`, Int64)\n(`followup_to`, Int64)\n"
        ]
    },
    {
        "sql_id": 435,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT MIN(T2.inspection_date) FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE T1.dba_name = 'JOHN SCHALLER' AND strftime('%Y', T2.inspection_date) = '2010'",
        "target_query": "SELECT MIN(T2.`inspection_date`) FROM `establishment` AS T1 INNER JOIN `inspection` AS T2 ON T1.`license_no` = T2.`license_no` WHERE T1.`dba_name` = 'JOHN SCHALLER' AND formatDateTime(T2.`inspection_date`, '%Y') = '2010';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 157,
                "end_index": 191,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 169,
                "end_index": 211,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `establishment`\nColumns:\n(`license_no`, Int64, primary key)\n(`dba_name`, String)\n(`aka_name`, String)\n(`facility_type`, String)\n(`risk_level`, Int64)\n(`address`, String)\n(`city`, String)\n(`state`, String)\n(`zip`, Int64)\n(`latitude`, Float64)\n(`longitude`, Float64)\n(`ward`, Int64)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, Int64, primary key)\n(`inspection_date`, Date32)\n(`inspection_type`, String)\n(`results`, String)\n(`employee_id`, Int64)\n(`license_no`, Int64)\n(`followup_to`, Int64)\n"
        ]
    },
    {
        "sql_id": 436,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT T1.dba_name FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE strftime('%Y', T2.inspection_date) = '2010' AND T2.results = 'Pass' AND T1.facility_type = 'Liquor'",
        "target_query": "SELECT DISTINCT T1.`dba_name` FROM `establishment` AS T1 INNER JOIN `inspection` AS T2 ON T1.`license_no` = T2.`license_no` WHERE formatDateTime(T2.`inspection_date`, '%Y') = '2010' AND T2.`results` = 'Pass' AND T1.`facility_type` = 'Liquor';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 120,
                "end_index": 154,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 130,
                "end_index": 172,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `establishment`\nColumns:\n(`license_no`, Int64, primary key)\n(`dba_name`, String)\n(`aka_name`, String)\n(`facility_type`, String)\n(`risk_level`, Int64)\n(`address`, String)\n(`city`, String)\n(`state`, String)\n(`zip`, Int64)\n(`latitude`, Float64)\n(`longitude`, Float64)\n(`ward`, Int64)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, Int64, primary key)\n(`inspection_date`, Date32)\n(`inspection_type`, String)\n(`results`, String)\n(`employee_id`, Int64)\n(`license_no`, Int64)\n(`followup_to`, Int64)\n"
        ]
    },
    {
        "sql_id": 437,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(DISTINCT T1.license_no) FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE strftime('%Y-%m', T2.inspection_date) = '2010-07' AND T2.results = 'Fail' AND T1.facility_type = 'Restaurant'",
        "target_query": "SELECT COUNT(DISTINCT `T1`.`license_no`) FROM `establishment` AS `T1` INNER JOIN `inspection` AS `T2` ON `T1`.`license_no` = `T2`.`license_no` WHERE formatDateTime(`T2`.`inspection_date`, '%Y-%m') = '2010-07' AND `T2`.`results` = 'Fail' AND `T1`.`facility_type` = 'Restaurant';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 129,
                "end_index": 166,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 149,
                "end_index": 196,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `establishment`\nColumns:\n(`license_no`, Int64, primary key)\n(`dba_name`, String)\n(`aka_name`, String)\n(`facility_type`, String)\n(`risk_level`, Int64)\n(`address`, String)\n(`city`, String)\n(`state`, String)\n(`zip`, Int64)\n(`latitude`, Float64)\n(`longitude`, Float64)\n(`ward`, Int64)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, Int64, primary key)\n(`inspection_date`, Date32)\n(`inspection_type`, String)\n(`results`, String)\n(`employee_id`, Int64)\n(`license_no`, Int64)\n(`followup_to`, Int64)\n"
        ]
    },
    {
        "sql_id": 438,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT T3.dba_name, T2.results FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id INNER JOIN establishment AS T3 ON T2.license_no = T3.license_no WHERE T1.first_name = 'Bob' AND T1.last_name = 'Benson' AND strftime('%Y', T2.inspection_date) = '2010'",
        "target_query": "SELECT DISTINCT `T3`.`dba_name`, `T2`.`results` \nFROM `employee` AS `T1` \nINNER JOIN `inspection` AS `T2` ON `T1`.`employee_id` = `T2`.`employee_id` \nINNER JOIN `establishment` AS `T3` ON `T2`.`license_no` = `T3`.`license_no` \nWHERE `T1`.`first_name` = 'Bob' \nAND `T1`.`last_name` = 'Benson' \nAND formatDateTime(`T2`.`inspection_date`, '%Y') = '2010';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 247,
                "end_index": 281,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 297,
                "end_index": 341,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`employee_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`phone`, text)\n(`title`, text)\n(`salary`, integer)\n(`supervisor`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n",
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `employee`\nColumns:\n(`employee_id`, Int64, primary key)\n(`first_name`, String)\n(`last_name`, String)\n(`address`, String)\n(`city`, String)\n(`state`, String)\n(`zip`, Int64)\n(`phone`, String)\n(`title`, String)\n(`salary`, Int64)\n(`supervisor`, Int64)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, Int64, primary key)\n(`inspection_date`, Date32)\n(`inspection_type`, String)\n(`results`, String)\n(`employee_id`, Int64)\n(`license_no`, Int64)\n(`followup_to`, Int64)\n",
            "Table: `establishment`\nColumns:\n(`license_no`, Int64, primary key)\n(`dba_name`, String)\n(`aka_name`, String)\n(`facility_type`, String)\n(`risk_level`, Int64)\n(`address`, String)\n(`city`, String)\n(`state`, String)\n(`zip`, Int64)\n(`latitude`, Float64)\n(`longitude`, Float64)\n(`ward`, Int64)\n"
        ]
    },
    {
        "sql_id": 439,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(DISTINCT T1.license_no) FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE strftime('%Y-%m', T2.inspection_date) = '2010-04' AND T1.facility_type = 'Restaurant' AND T2.results = 'Fail'",
        "target_query": "SELECT COUNT(DISTINCT `T1`.`license_no`) FROM `establishment` AS `T1` INNER JOIN `inspection` AS `T2` ON `T1`.`license_no` = `T2`.`license_no` WHERE formatDateTime(`T2`.`inspection_date`, '%Y-%m') = '2010-04' AND `T1`.`facility_type` = 'Restaurant' AND `T2`.`results` = 'Fail';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 129,
                "end_index": 166,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 149,
                "end_index": 196,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `establishment`\nColumns:\n(`license_no`, Int64, primary key)\n(`dba_name`, String)\n(`aka_name`, String)\n(`facility_type`, String)\n(`risk_level`, Int64)\n(`address`, String)\n(`city`, String)\n(`state`, String)\n(`zip`, Int64)\n(`latitude`, Float64)\n(`longitude`, Float64)\n(`ward`, Int64)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, Int64, primary key)\n(`inspection_date`, Date32)\n(`inspection_type`, String)\n(`results`, String)\n(`employee_id`, Int64)\n(`license_no`, Int64)\n(`followup_to`, Int64)\n"
        ]
    },
    {
        "sql_id": 440,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT T1.dba_name FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no INNER JOIN violation AS T3 ON T2.inspection_id = T3.inspection_id WHERE strftime('%Y-%m', T2.inspection_date) = '2010-01' AND T2.results = 'Fail' AND T1.facility_type = 'TAVERN'",
        "target_query": "SELECT DISTINCT `T1`.`dba_name` FROM `establishment` AS `T1` INNER JOIN `inspection` AS `T2` ON `T1`.`license_no` = `T2`.`license_no` INNER JOIN `violation` AS `T3` ON `T2`.`inspection_id` = `T3`.`inspection_id` WHERE formatDateTime(`T2`.`inspection_date`, '%Y-%m') = '2010-01' AND `T2`.`results` = 'Fail' AND `T1`.`facility_type` = 'TAVERN';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 186,
                "end_index": 223,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 218,
                "end_index": 265,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `establishment`\nColumns:\n(`license_no`, integer, primary key)\n(`dba_name`, text)\n(`aka_name`, text)\n(`facility_type`, text)\n(`risk_level`, integer)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`latitude`, real)\n(`longitude`, real)\n(`ward`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n",
            "Table: `violation`\nColumns:\n(`inspection_id`, integer, primary key)\n(`point_id`, integer, primary key)\n(`fine`, integer)\n(`inspector_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `establishment`\nColumns:\n(`license_no`, Int64, primary key)\n(`dba_name`, String)\n(`aka_name`, String)\n(`facility_type`, String)\n(`risk_level`, Int64)\n(`address`, String)\n(`city`, String)\n(`state`, String)\n(`zip`, Int64)\n(`latitude`, Float64)\n(`longitude`, Float64)\n(`ward`, Int64)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, Int64, primary key)\n(`inspection_date`, Date32)\n(`inspection_type`, String)\n(`results`, String)\n(`employee_id`, Int64)\n(`license_no`, Int64)\n(`followup_to`, Int64)\n",
            "Table: `violation`\nColumns:\n(`inspection_id`, Int64, primary key)\n(`point_id`, Int64, primary key)\n(`fine`, Int64)\n(`inspector_comment`, String)\n"
        ]
    },
    {
        "sql_id": 441,
        "database_name": "food_inspection_2",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT T1.employee_id FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE T2.results = 'Fail' AND strftime('%Y-%m', T2.inspection_date) = '2010-02' AND T1.salary > 0.7 * ( SELECT AVG(salary) FROM employee )",
        "target_query": "SELECT DISTINCT `T1`.`employee_id` FROM `employee` AS `T1` INNER JOIN `inspection` AS `T2` ON `T1`.`employee_id` = `T2`.`employee_id` WHERE `T2`.`results` = 'Fail' AND formatDateTime(`T2`.`inspection_date`, '%Y-%m') = '2010-02' AND `T1`.`salary` > 0.7 * ( SELECT AVG(`salary`) FROM `employee` );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 144,
                "end_index": 181,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 168,
                "end_index": 215,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`employee_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`phone`, text)\n(`title`, text)\n(`salary`, integer)\n(`supervisor`, integer)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, integer, primary key)\n(`inspection_date`, date)\n(`inspection_type`, text)\n(`results`, text)\n(`employee_id`, integer)\n(`license_no`, integer)\n(`followup_to`, integer)\n",
            "Table: `employee`\nColumns:\n(`employee_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`address`, text)\n(`city`, text)\n(`state`, text)\n(`zip`, integer)\n(`phone`, text)\n(`title`, text)\n(`salary`, integer)\n(`supervisor`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `employee`\nColumns:\n(`employee_id`, Int64, primary key)\n(`first_name`, String)\n(`last_name`, String)\n(`address`, String)\n(`city`, String)\n(`state`, String)\n(`zip`, Int64)\n(`phone`, String)\n(`title`, String)\n(`salary`, Int64)\n(`supervisor`, Int64)\n",
            "Table: `inspection`\nColumns:\n(`inspection_id`, Int64, primary key)\n(`inspection_date`, Date32)\n(`inspection_type`, String)\n(`results`, String)\n(`employee_id`, Int64)\n(`license_no`, Int64)\n(`followup_to`, Int64)\n",
            "Table: `employee`\nColumns:\n(`employee_id`, Int64, primary key)\n(`first_name`, String)\n(`last_name`, String)\n(`address`, String)\n(`city`, String)\n(`state`, String)\n(`zip`, Int64)\n(`phone`, String)\n(`title`, String)\n(`salary`, Int64)\n(`supervisor`, Int64)\n"
        ]
    },
    {
        "sql_id": 212,
        "database_name": "genes",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T1.Chromosome > 10 AND T3.Chromosome > 10, 1, 0)) AS REAL) * 100 / COUNT(T1.GeneID) FROM Genes AS T1 INNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1 INNER JOIN Genes AS T3 ON T3.GeneID = T2.GeneID2 WHERE T2.Expression_Corr > 0",
        "target_query": "SELECT CAST(SUM(if(`T1`.`Chromosome` > 10 AND `T3`.`Chromosome` > 10, 1, 0)) AS Float64) * 100 / COUNT(`T1`.`GeneID`) FROM `Genes` AS `T1` INNER JOIN `Interactions` AS `T2` ON `T1`.`GeneID` = `T2`.`GeneID1` INNER JOIN `Genes` AS `T3` ON `T3`.`GeneID` = `T2`.`GeneID2` WHERE `T2`.`Expression_Corr` > 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 68,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 75,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Genes`\nColumns:\n(`GeneID`, text)\n(`Essential`, text)\n(`Class`, text)\n(`Complex`, text)\n(`Phenotype`, text)\n(`Motif`, text)\n(`Chromosome`, integer)\n(`Function`, text)\n(`Localization`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `Interactions`\nColumns:\n(`GeneID1`, text, primary key)\n(`GeneID2`, text, primary key)\n(`Type`, text)\n(`Expression_Corr`, real)\n",
            "Table: `Genes`\nColumns:\n(`GeneID`, text)\n(`Essential`, text)\n(`Class`, text)\n(`Complex`, text)\n(`Phenotype`, text)\n(`Motif`, text)\n(`Chromosome`, integer)\n(`Function`, text)\n(`Localization`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `Genes`\nColumns:\n(`GeneID`, String)\n(`Essential`, String)\n(`Class`, String)\n(`Complex`, String)\n(`Phenotype`, String)\n(`Motif`, String)\n(`Chromosome`, Int64)\n(`Function`, String)\n(`Localization`, String)\n(`rowid`, Int64, primary key)\n",
            "Table: `Interactions`\nColumns:\n(`GeneID1`, String, primary key)\n(`GeneID2`, String, primary key)\n(`_Type`, String)\n(`Expression_Corr`, Float64)\n",
            "Table: `Genes`\nColumns:\n(`GeneID`, String)\n(`Essential`, String)\n(`Class`, String)\n(`Complex`, String)\n(`Phenotype`, String)\n(`Motif`, String)\n(`Chromosome`, Int64)\n(`Function`, String)\n(`Localization`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 213,
        "database_name": "genes",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T2.Expression_Corr > 0, 1, 0)) AS REAL) * 100 / COUNT(T2.GeneID1) FROM Genes AS T1 INNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1 WHERE T1.Phenotype = 'Nucleic acid metabolism defects' AND T1.Motif = 'PS00107'",
        "target_query": "SELECT toFloat64(SUM(if(T2.Expression_Corr > 0, 1, 0))) * 100 / COUNT(T2.GeneID1) FROM `Genes` AS T1 INNER JOIN `Interactions` AS T2 ON T1.GeneID = T2.GeneID1 WHERE T1.Phenotype = 'Nucleic acid metabolism defects' AND T1.Motif = 'PS00107';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 49,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 53,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Genes`\nColumns:\n(`GeneID`, text)\n(`Essential`, text)\n(`Class`, text)\n(`Complex`, text)\n(`Phenotype`, text)\n(`Motif`, text)\n(`Chromosome`, integer)\n(`Function`, text)\n(`Localization`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `Interactions`\nColumns:\n(`GeneID1`, text, primary key)\n(`GeneID2`, text, primary key)\n(`Type`, text)\n(`Expression_Corr`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `Genes`\nColumns:\n(`GeneID`, String)\n(`Essential`, String)\n(`Class`, String)\n(`Complex`, String)\n(`Phenotype`, String)\n(`Motif`, String)\n(`Chromosome`, Int64)\n(`Function`, String)\n(`Localization`, String)\n(`rowid`, Int64, primary key)\n",
            "Table: `Interactions`\nColumns:\n(`GeneID1`, String, primary key)\n(`GeneID2`, String, primary key)\n(`_Type`, String)\n(`Expression_Corr`, Float64)\n"
        ]
    },
    {
        "sql_id": 556,
        "database_name": "hockey",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT IIF(T1.note = 'posthumous', 'YES', 'NO') FROM AwardsMisc AS T1 RIGHT JOIN Master AS T2 ON T1.ID = T2.playerID WHERE T2.legendsID = 'P194502'",
        "target_query": "SELECT if(`T1`.`note` = 'posthumous', 'YES', 'NO') FROM `AwardsMisc` AS `T1` RIGHT JOIN `Master` AS `T2` ON `T1`.`ID` = `T2`.`playerID` WHERE `T2`.`legendsID` = 'P194502';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 47,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 50,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `AwardsMisc`\nColumns:\n(`name`, text, primary key)\n(`ID`, text)\n(`award`, text)\n(`year`, integer)\n(`lgID`, text)\n(`note`, text)\n",
            "Table: `Master`\nColumns:\n(`playerID`, text)\n(`coachID`, text)\n(`hofID`, text)\n(`firstName`, text)\n(`lastName`, text)\n(`nameNote`, text)\n(`nameGiven`, text)\n(`nameNick`, text)\n(`height`, text)\n(`weight`, text)\n(`shootCatch`, text)\n(`legendsID`, text)\n(`ihdbID`, text)\n(`hrefID`, text)\n(`firstNHL`, text)\n(`lastNHL`, text)\n(`firstWHA`, text)\n(`lastWHA`, text)\n(`pos`, text)\n(`birthYear`, text)\n(`birthMon`, text)\n(`birthDay`, text)\n(`birthCountry`, text)\n(`birthState`, text)\n(`birthCity`, text)\n(`deathYear`, text)\n(`deathMon`, text)\n(`deathDay`, text)\n(`deathCountry`, text)\n(`deathState`, text)\n(`deathCity`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `AwardsMisc`\nColumns:\n(`name`, String, primary key)\n(`ID`, String)\n(`award`, String)\n(`year`, Int64)\n(`lgID`, String)\n(`note`, String)\n",
            "Table: `Master`\nColumns:\n(`playerID`, String)\n(`coachID`, String)\n(`hofID`, String)\n(`firstName`, String)\n(`lastName`, String)\n(`nameNote`, String)\n(`nameGiven`, String)\n(`nameNick`, String)\n(`height`, String)\n(`weight`, String)\n(`shootCatch`, String)\n(`legendsID`, String)\n(`ihdbID`, String)\n(`hrefID`, String)\n(`firstNHL`, String)\n(`lastNHL`, String)\n(`firstWHA`, String)\n(`lastWHA`, String)\n(`pos`, String)\n(`birthYear`, String)\n(`birthMon`, String)\n(`birthDay`, String)\n(`birthCountry`, String)\n(`birthState`, String)\n(`birthCity`, String)\n(`deathYear`, String)\n(`deathMon`, String)\n(`deathDay`, String)\n(`deathCountry`, String)\n(`deathState`, String)\n(`deathCity`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 557,
        "database_name": "hockey",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.firstName, T2.lastName , IIF(T1.tmID = 'BOS', 'YES', 'NO') FROM Goalies AS T1 INNER JOIN Master AS T2 ON T1.playerID = T2.playerID WHERE T1.year = 1972 AND T1.tmID = 'BOS' AND T2.coachID IS NOT NULL AND T2.hofID IS NULL",
        "target_query": "SELECT T2.`firstName`, T2.`lastName`, if(T1.`tmID` = 'BOS', 'YES', 'NO') FROM `Goalies` AS T1 INNER JOIN `Master` AS T2 ON T1.`playerID` = T2.`playerID` WHERE T1.`year` = 1972 AND T1.`tmID` = 'BOS' AND T2.`coachID` IS NOT NULL AND T2.`hofID` IS NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 35,
                "end_index": 68,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 38,
                "end_index": 72,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Goalies`\nColumns:\n(`playerID`, text, primary key)\n(`year`, integer, primary key)\n(`stint`, integer, primary key)\n(`tmID`, text)\n(`lgID`, text)\n(`GP`, text)\n(`Min`, text)\n(`W`, text)\n(`L`, text)\n(`T/OL`, text)\n(`ENG`, text)\n(`SHO`, text)\n(`GA`, text)\n(`SA`, text)\n(`PostGP`, text)\n(`PostMin`, text)\n(`PostW`, text)\n(`PostL`, text)\n(`PostT`, text)\n(`PostENG`, text)\n(`PostSHO`, text)\n(`PostGA`, text)\n(`PostSA`, text)\n",
            "Table: `Master`\nColumns:\n(`playerID`, text)\n(`coachID`, text)\n(`hofID`, text)\n(`firstName`, text)\n(`lastName`, text)\n(`nameNote`, text)\n(`nameGiven`, text)\n(`nameNick`, text)\n(`height`, text)\n(`weight`, text)\n(`shootCatch`, text)\n(`legendsID`, text)\n(`ihdbID`, text)\n(`hrefID`, text)\n(`firstNHL`, text)\n(`lastNHL`, text)\n(`firstWHA`, text)\n(`lastWHA`, text)\n(`pos`, text)\n(`birthYear`, text)\n(`birthMon`, text)\n(`birthDay`, text)\n(`birthCountry`, text)\n(`birthState`, text)\n(`birthCity`, text)\n(`deathYear`, text)\n(`deathMon`, text)\n(`deathDay`, text)\n(`deathCountry`, text)\n(`deathState`, text)\n(`deathCity`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `Goalies`\nColumns:\n(`playerID`, String, primary key)\n(`year`, Int64, primary key)\n(`stint`, Int64, primary key)\n(`tmID`, String)\n(`lgID`, String)\n(`GP`, String)\n(`Min`, String)\n(`W`, String)\n(`L`, String)\n(`T_OL`, String)\n(`ENG`, String)\n(`SHO`, String)\n(`GA`, String)\n(`SA`, String)\n(`PostGP`, String)\n(`PostMin`, String)\n(`PostW`, String)\n(`PostL`, String)\n(`PostT`, String)\n(`PostENG`, String)\n(`PostSHO`, String)\n(`PostGA`, String)\n(`PostSA`, String)\n",
            "Table: `Master`\nColumns:\n(`playerID`, String)\n(`coachID`, String)\n(`hofID`, String)\n(`firstName`, String)\n(`lastName`, String)\n(`nameNote`, String)\n(`nameGiven`, String)\n(`nameNick`, String)\n(`height`, String)\n(`weight`, String)\n(`shootCatch`, String)\n(`legendsID`, String)\n(`ihdbID`, String)\n(`hrefID`, String)\n(`firstNHL`, String)\n(`lastNHL`, String)\n(`firstWHA`, String)\n(`lastWHA`, String)\n(`pos`, String)\n(`birthYear`, String)\n(`birthMon`, String)\n(`birthDay`, String)\n(`birthCountry`, String)\n(`birthState`, String)\n(`birthCity`, String)\n(`deathYear`, String)\n(`deathMon`, String)\n(`deathDay`, String)\n(`deathCountry`, String)\n(`deathState`, String)\n(`deathCity`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 611,
        "database_name": "human_resources",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT ssn FROM employee WHERE gender = 'M' AND CAST(REPLACE(SUBSTR(salary, 4), ',', '') AS REAL) > 70000",
        "target_query": "SELECT `ssn` FROM `employee` WHERE `gender` = 'M' AND CAST(REPLACE(substring(`salary`, 4), ',', '') AS Float64) > 70000;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 61,
                "end_index": 78,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 67,
                "end_index": 89,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`ssn`, text, primary key)\n(`lastname`, text)\n(`firstname`, text)\n(`hiredate`, text)\n(`salary`, text)\n(`gender`, text)\n(`performance`, text)\n(`positionID`, integer)\n(`locationID`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `employee`\nColumns:\n(`ssn`, String, primary key)\n(`lastname`, String)\n(`firstname`, String)\n(`hiredate`, String)\n(`salary`, String)\n(`gender`, String)\n(`performance`, String)\n(`positionID`, Int64)\n(`locationID`, Int64)\n"
        ]
    },
    {
        "sql_id": 612,
        "database_name": "human_resources",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(REPLACE(SUBSTR(T1.salary, 4), ',', '') AS REAL) - CAST(REPLACE(SUBSTR(T2.minsalary, 4), ',', '') AS REAL) AS diff FROM employee AS T1  INNER JOIN position AS T2  ON T1.positionID = T2.positionID WHERE T1.lastname = 'Johnson' AND T1.firstname = 'James'",
        "target_query": "SELECT CAST(REPLACE(substring(`T1`.`salary`, 4), ',', '') AS Float64) - CAST(REPLACE(substring(`T2`.`minsalary`, 4), ',', '') AS Float64) AS `diff` FROM `employee` AS `T1` INNER JOIN `position` AS `T2` ON `T1`.`positionID` = `T2`.`positionID` WHERE `T1`.`lastname` = 'Johnson' AND `T1`.`firstname` = 'James';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 20,
                "end_index": 40,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 75,
                "end_index": 98,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 20,
                "end_index": 47,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            },
            {
                "start_index": 85,
                "end_index": 115,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`ssn`, text, primary key)\n(`lastname`, text)\n(`firstname`, text)\n(`hiredate`, text)\n(`salary`, text)\n(`gender`, text)\n(`performance`, text)\n(`positionID`, integer)\n(`locationID`, integer)\n",
            "Table: `position`\nColumns:\n(`positionID`, integer, primary key)\n(`positiontitle`, text)\n(`educationrequired`, text)\n(`minsalary`, text)\n(`maxsalary`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `employee`\nColumns:\n(`ssn`, String, primary key)\n(`lastname`, String)\n(`firstname`, String)\n(`hiredate`, String)\n(`salary`, String)\n(`gender`, String)\n(`performance`, String)\n(`positionID`, Int64)\n(`locationID`, Int64)\n",
            "Table: `position`\nColumns:\n(`positionID`, Int64, primary key)\n(`positiontitle`, String)\n(`educationrequired`, String)\n(`minsalary`, String)\n(`maxsalary`, String)\n"
        ]
    },
    {
        "sql_id": 613,
        "database_name": "human_resources",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(*) FROM employee AS T1  INNER JOIN position AS T2  ON T1.positionID = T2.positionID WHERE CAST(REPLACE(SUBSTR(T1.salary, 4), ',', '') AS REAL) > 20000 AND T2.positiontitle = 'Trainee'",
        "target_query": "SELECT COUNT(*) FROM `employee` AS T1 INNER JOIN `position` AS T2 ON T1.`positionID` = T2.`positionID` WHERE toFloat64(REPLACE(substring(T1.`salary`, 4), ',', '')) > 20000 AND T2.`positiontitle` = 'Trainee';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 116,
                "end_index": 136,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 127,
                "end_index": 152,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`ssn`, text, primary key)\n(`lastname`, text)\n(`firstname`, text)\n(`hiredate`, text)\n(`salary`, text)\n(`gender`, text)\n(`performance`, text)\n(`positionID`, integer)\n(`locationID`, integer)\n",
            "Table: `position`\nColumns:\n(`positionID`, integer, primary key)\n(`positiontitle`, text)\n(`educationrequired`, text)\n(`minsalary`, text)\n(`maxsalary`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `employee`\nColumns:\n(`ssn`, String, primary key)\n(`lastname`, String)\n(`firstname`, String)\n(`hiredate`, String)\n(`salary`, String)\n(`gender`, String)\n(`performance`, String)\n(`positionID`, Int64)\n(`locationID`, Int64)\n",
            "Table: `position`\nColumns:\n(`positionID`, Int64, primary key)\n(`positiontitle`, String)\n(`educationrequired`, String)\n(`minsalary`, String)\n(`maxsalary`, String)\n"
        ]
    },
    {
        "sql_id": 614,
        "database_name": "human_resources",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT AVG(CAST(REPLACE(SUBSTR(T1.salary, 4), ',', '') AS REAL)) AS avg FROM employee AS T1  INNER JOIN position AS T2  ON T1.positionID = T2.positionID WHERE T2.positiontitle = 'Trainee'",
        "target_query": "SELECT AVG(CAST(REPLACE(substring(`T1`.`salary`, 4) , ',', '') AS Float64)) AS avg FROM `employee` AS `T1` INNER JOIN `position` AS `T2` ON `T1`.`positionID` = `T2`.`positionID` WHERE `T2`.`positiontitle` = 'Trainee';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 24,
                "end_index": 44,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 24,
                "end_index": 51,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`ssn`, text, primary key)\n(`lastname`, text)\n(`firstname`, text)\n(`hiredate`, text)\n(`salary`, text)\n(`gender`, text)\n(`performance`, text)\n(`positionID`, integer)\n(`locationID`, integer)\n",
            "Table: `position`\nColumns:\n(`positionID`, integer, primary key)\n(`positiontitle`, text)\n(`educationrequired`, text)\n(`minsalary`, text)\n(`maxsalary`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `employee`\nColumns:\n(`ssn`, String, primary key)\n(`lastname`, String)\n(`firstname`, String)\n(`hiredate`, String)\n(`salary`, String)\n(`gender`, String)\n(`performance`, String)\n(`positionID`, Int64)\n(`locationID`, Int64)\n",
            "Table: `position`\nColumns:\n(`positionID`, Int64, primary key)\n(`positiontitle`, String)\n(`educationrequired`, String)\n(`minsalary`, String)\n(`maxsalary`, String)\n"
        ]
    },
    {
        "sql_id": 616,
        "database_name": "human_resources",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT 100 * (CAST(REPLACE(SUBSTR(T2.maxsalary, 4), ',', '') AS REAL) - CAST(REPLACE(SUBSTR(T1.salary, 4), ',', '') AS REAL)) / CAST(REPLACE(SUBSTR(T1.salary, 4), ',', '') AS REAL) AS per FROM employee AS T1  INNER JOIN position AS T2  ON T1.positionID = T2.positionID WHERE T1.firstname = 'Jose' AND T1.lastname = 'Rodriguez'",
        "target_query": "SELECT 100 * (CAST(REPLACE(substring(`T2`.`maxsalary`, 4), ',', '') AS Float64) - CAST(REPLACE(substring(`T1`.`salary`, 4), ',', '') AS Float64)) / CAST(REPLACE(substring(`T1`.`salary`, 4), ',', '') AS Float64) AS `per` FROM `employee` AS `T1` INNER JOIN `position` AS `T2` ON `T1`.`positionID` = `T2`.`positionID` WHERE `T1`.`firstname` = 'Jose' AND `T1`.`lastname` = 'Rodriguez';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 27,
                "end_index": 50,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 85,
                "end_index": 105,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 141,
                "end_index": 161,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 27,
                "end_index": 57,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            },
            {
                "start_index": 95,
                "end_index": 122,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            },
            {
                "start_index": 161,
                "end_index": 188,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`ssn`, text, primary key)\n(`lastname`, text)\n(`firstname`, text)\n(`hiredate`, text)\n(`salary`, text)\n(`gender`, text)\n(`performance`, text)\n(`positionID`, integer)\n(`locationID`, integer)\n",
            "Table: `position`\nColumns:\n(`positionID`, integer, primary key)\n(`positiontitle`, text)\n(`educationrequired`, text)\n(`minsalary`, text)\n(`maxsalary`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `employee`\nColumns:\n(`ssn`, String, primary key)\n(`lastname`, String)\n(`firstname`, String)\n(`hiredate`, String)\n(`salary`, String)\n(`gender`, String)\n(`performance`, String)\n(`positionID`, Int64)\n(`locationID`, Int64)\n",
            "Table: `position`\nColumns:\n(`positionID`, Int64, primary key)\n(`positiontitle`, String)\n(`educationrequired`, String)\n(`minsalary`, String)\n(`maxsalary`, String)\n"
        ]
    },
    {
        "sql_id": 617,
        "database_name": "human_resources",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(*) FROM employee WHERE performance = 'Poor' AND CAST(REPLACE(SUBSTR(salary, 4), ',', '') AS REAL) > 50000",
        "target_query": "SELECT COUNT(*) FROM `employee` WHERE `performance` = 'Poor' AND CAST(REPLACE(substring(`salary`, 4), ',', '') AS Float64) > 50000;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 74,
                "end_index": 91,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 78,
                "end_index": 100,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`ssn`, text, primary key)\n(`lastname`, text)\n(`firstname`, text)\n(`hiredate`, text)\n(`salary`, text)\n(`gender`, text)\n(`performance`, text)\n(`positionID`, integer)\n(`locationID`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `employee`\nColumns:\n(`ssn`, String, primary key)\n(`lastname`, String)\n(`firstname`, String)\n(`hiredate`, String)\n(`salary`, String)\n(`gender`, String)\n(`performance`, String)\n(`positionID`, Int64)\n(`locationID`, Int64)\n"
        ]
    },
    {
        "sql_id": 618,
        "database_name": "human_resources",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT firstname, lastname FROM employee WHERE CAST(REPLACE(SUBSTR(salary, 4), ',', '') AS REAL) = ( SELECT MAX(CAST(REPLACE(SUBSTR(salary, 4), ',', '') AS REAL)) FROM employee )",
        "target_query": "SELECT `firstname`, `lastname` FROM `employee` WHERE CAST(REPLACE(substring(`salary`, 4), ',', '') AS Float64) = ( SELECT MAX(CAST(REPLACE(substring(`salary`, 4), ',', '') AS Float64)) FROM `employee` );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 60,
                "end_index": 77,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 125,
                "end_index": 142,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 66,
                "end_index": 88,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            },
            {
                "start_index": 139,
                "end_index": 161,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`ssn`, text, primary key)\n(`lastname`, text)\n(`firstname`, text)\n(`hiredate`, text)\n(`salary`, text)\n(`gender`, text)\n(`performance`, text)\n(`positionID`, integer)\n(`locationID`, integer)\n",
            "Table: `employee`\nColumns:\n(`ssn`, text, primary key)\n(`lastname`, text)\n(`firstname`, text)\n(`hiredate`, text)\n(`salary`, text)\n(`gender`, text)\n(`performance`, text)\n(`positionID`, integer)\n(`locationID`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `employee`\nColumns:\n(`ssn`, String, primary key)\n(`lastname`, String)\n(`firstname`, String)\n(`hiredate`, String)\n(`salary`, String)\n(`gender`, String)\n(`performance`, String)\n(`positionID`, Int64)\n(`locationID`, Int64)\n",
            "Table: `employee`\nColumns:\n(`ssn`, String, primary key)\n(`lastname`, String)\n(`firstname`, String)\n(`hiredate`, String)\n(`salary`, String)\n(`gender`, String)\n(`performance`, String)\n(`positionID`, Int64)\n(`locationID`, Int64)\n"
        ]
    },
    {
        "sql_id": 619,
        "database_name": "human_resources",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(*) FROM position WHERE CAST(REPLACE(SUBSTR(maxsalary, 4), ',', '') AS REAL) < 100000",
        "target_query": "SELECT COUNT(*) FROM `position` WHERE CAST(REPLACE(substring(`maxsalary`, 4), ',', '') AS Float64) < 100000;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 49,
                "end_index": 69,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 51,
                "end_index": 76,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `position`\nColumns:\n(`positionID`, integer, primary key)\n(`positiontitle`, text)\n(`educationrequired`, text)\n(`minsalary`, text)\n(`maxsalary`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `position`\nColumns:\n(`positionID`, Int64, primary key)\n(`positiontitle`, String)\n(`educationrequired`, String)\n(`minsalary`, String)\n(`maxsalary`, String)\n"
        ]
    },
    {
        "sql_id": 620,
        "database_name": "human_resources",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT AVG(CAST(REPLACE(SUBSTR(T1.salary, 4), ',', '') AS REAL)) FROM employee AS T1  INNER JOIN position AS T2  ON T1.positionID = T2.positionID WHERE T2.educationrequired = '2 year degree'",
        "target_query": "SELECT AVG(CAST(REPLACE(substring(`T1`.`salary`, 4), ',', '') AS Float64)) FROM `employee` AS `T1` INNER JOIN `position` AS `T2` ON `T1`.`positionID` = `T2`.`positionID` WHERE `T2`.`educationrequired` = '2 year degree';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 24,
                "end_index": 44,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 24,
                "end_index": 51,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`ssn`, text, primary key)\n(`lastname`, text)\n(`firstname`, text)\n(`hiredate`, text)\n(`salary`, text)\n(`gender`, text)\n(`performance`, text)\n(`positionID`, integer)\n(`locationID`, integer)\n",
            "Table: `position`\nColumns:\n(`positionID`, integer, primary key)\n(`positiontitle`, text)\n(`educationrequired`, text)\n(`minsalary`, text)\n(`maxsalary`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `employee`\nColumns:\n(`ssn`, String, primary key)\n(`lastname`, String)\n(`firstname`, String)\n(`hiredate`, String)\n(`salary`, String)\n(`gender`, String)\n(`performance`, String)\n(`positionID`, Int64)\n(`locationID`, Int64)\n",
            "Table: `position`\nColumns:\n(`positionID`, Int64, primary key)\n(`positiontitle`, String)\n(`educationrequired`, String)\n(`minsalary`, String)\n(`maxsalary`, String)\n"
        ]
    },
    {
        "sql_id": 621,
        "database_name": "human_resources",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT AVG(CAST(REPLACE(SUBSTR(T1.salary, 4), ',', '') AS REAL)) FROM employee AS T1 INNER JOIN position AS T2  ON T1.positionID = T2.positionID WHERE T1.performance = 'Poor' AND T2.positiontitle = 'Manager'",
        "target_query": "SELECT AVG(CAST(REPLACE(substring(`T1`.`salary`, 4), ',', '') AS Float64)) FROM `employee` AS `T1` INNER JOIN `position` AS `T2` ON `T1`.`positionID` = `T2`.`positionID` WHERE `T1`.`performance` = 'Poor' AND `T2`.`positiontitle` = 'Manager';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 24,
                "end_index": 44,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 24,
                "end_index": 51,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `employee`\nColumns:\n(`ssn`, text, primary key)\n(`lastname`, text)\n(`firstname`, text)\n(`hiredate`, text)\n(`salary`, text)\n(`gender`, text)\n(`performance`, text)\n(`positionID`, integer)\n(`locationID`, integer)\n",
            "Table: `position`\nColumns:\n(`positionID`, integer, primary key)\n(`positiontitle`, text)\n(`educationrequired`, text)\n(`minsalary`, text)\n(`maxsalary`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `employee`\nColumns:\n(`ssn`, String, primary key)\n(`lastname`, String)\n(`firstname`, String)\n(`hiredate`, String)\n(`salary`, String)\n(`gender`, String)\n(`performance`, String)\n(`positionID`, Int64)\n(`locationID`, Int64)\n",
            "Table: `position`\nColumns:\n(`positionID`, Int64, primary key)\n(`positiontitle`, String)\n(`educationrequired`, String)\n(`minsalary`, String)\n(`maxsalary`, String)\n"
        ]
    },
    {
        "sql_id": 507,
        "database_name": "ice_hockey_draft",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT CAST(COUNT(CASE WHEN T1.nation = 'Sweden' THEN T1.ELITEID ELSE NULL END) OVER (PARTITION BY T2.SEASON) AS REAL) * 100 / COUNT(T1.ELITEID) OVER (PARTITION BY T2.SEASON) FROM PlayerInfo AS T1 INNER JOIN SeasonStatus AS T2 ON T1.ELITEID = T2.ELITEID WHERE T2.SEASON IN ('1997-1998', '1998-1999', '1999-2000')",
        "target_query": "SELECT DISTINCT CAST(COUNT(CASE WHEN `T1`.`nation` = 'Sweden' THEN `T1`.`ELITEID` ELSE NULL END) OVER (PARTITION BY `T2`.`SEASON`) AS Float64) * 100 / COUNT(`T1`.`ELITEID`) OVER (PARTITION BY `T2`.`SEASON`) FROM `PlayerInfo` AS `T1` INNER JOIN `SeasonStatus` AS `T2` ON `T1`.`ELITEID` = `T2`.`ELITEID` WHERE `T2`.`SEASON` IN ('1997-1998', '1998-1999', '1999-2000');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 89,
                "end_index": 118,
                "dialect_content": "SQLite supports window functions, and the `OVER` clause is used to define a window. It can include `PARTITION BY` to divide the result set into partitions and `ORDER BY` to specify the order of rows within each partition. Window functions in SQLite are available from version 3.25.0 onward. However, SQLite does not support window frame specifications such as `ROWS BETWEEN`.",
                "feature": "OVER ( [PARTITION BY column_list] [ORDER BY column_list] )"
            },
            {
                "start_index": 154,
                "end_index": 183,
                "dialect_content": "SQLite supports window functions, and the `OVER` clause is used to define a window. It can include `PARTITION BY` to divide the result set into partitions and `ORDER BY` to specify the order of rows within each partition. Window functions in SQLite are available from version 3.25.0 onward. However, SQLite does not support window frame specifications such as `ROWS BETWEEN`.",
                "feature": "OVER ( [PARTITION BY column_list] [ORDER BY column_list] )"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 97,
                "end_index": 130,
                "dialect_content": "ClickHouse supports window functions and the `OVER` clause, similar to SQLite. The `OVER` clause in ClickHouse defines the window for the window functions, where you can specify `PARTITION BY` to divide the result set into partitions and `ORDER BY` to order rows within each partition. Additionally, ClickHouse supports window frame specifications like `ROWS BETWEEN`.",
                "feature": "OVER ([PARTITION BY column_list] [ORDER BY column_list] [ROWS BETWEEN ...])"
            },
            {
                "start_index": 173,
                "end_index": 206,
                "dialect_content": "ClickHouse supports window functions and the `OVER` clause, similar to SQLite. The `OVER` clause in ClickHouse defines the window for the window functions, where you can specify `PARTITION BY` to divide the result set into partitions and `ORDER BY` to order rows within each partition. Additionally, ClickHouse supports window frame specifications like `ROWS BETWEEN`.",
                "feature": "OVER ([PARTITION BY column_list] [ORDER BY column_list] [ROWS BETWEEN ...])"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "OVER ( [PARTITION BY column_list] [ORDER BY column_list] )",
                "explanation": "SQLite supports window functions, and the `OVER` clause is used to define a window. It can include `PARTITION BY` to divide the result set into partitions and `ORDER BY` to specify the order of rows within each partition. Window functions in SQLite are available from version 3.25.0 onward. However, SQLite does not support window frame specifications such as `ROWS BETWEEN`.",
                "examples": [
                    "SELECT id, value, ROW_NUMBER() OVER (PARTITION BY category ORDER BY value DESC) AS rank FROM items;",
                    "SELECT name, department, AVG(salary) OVER (PARTITION BY department) AS avg_salary FROM employees;",
                    "SELECT customer_id, order_date, SUM(total_amount) OVER (PARTITION BY customer_id ORDER BY order_date) AS running_total FROM orders;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "OVER ([PARTITION BY column_list] [ORDER BY column_list] [ROWS BETWEEN ...])",
                "explanation": "ClickHouse supports window functions and the `OVER` clause, similar to SQLite. The `OVER` clause in ClickHouse defines the window for the window functions, where you can specify `PARTITION BY` to divide the result set into partitions and `ORDER BY` to order rows within each partition. Additionally, ClickHouse supports window frame specifications like `ROWS BETWEEN`.",
                "examples": [
                    "SELECT id, value, ROW_NUMBER() OVER (PARTITION BY category ORDER BY value DESC) AS rank FROM items;",
                    "SELECT name, department, AVG(salary) OVER (PARTITION BY department) AS avg_salary FROM employees;",
                    "SELECT customer_id, order_date, SUM(total_amount) OVER (PARTITION BY customer_id ORDER BY order_date) AS running_total FROM orders;",
                    "SELECT id, value, SUM(value) OVER (PARTITION BY category ORDER BY value ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum FROM items;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `PlayerInfo`\nColumns:\n(`ELITEID`, integer, primary key)\n(`PlayerName`, text)\n(`birthdate`, text)\n(`birthyear`, text)\n(`birthmonth`, integer)\n(`birthday`, integer)\n(`birthplace`, text)\n(`nation`, text)\n(`height`, integer)\n(`weight`, integer)\n(`position_info`, text)\n(`shoots`, text)\n(`draftyear`, integer)\n(`draftround`, integer)\n(`overall`, integer)\n(`overallby`, text)\n(`CSS_rank`, integer)\n(`sum_7yr_GP`, integer)\n(`sum_7yr_TOI`, integer)\n(`GP_greater_than_0`, text)\n",
            "Table: `SeasonStatus`\nColumns:\n(`ELITEID`, integer)\n(`SEASON`, text)\n(`TEAM`, text)\n(`LEAGUE`, text)\n(`GAMETYPE`, text)\n(`GP`, integer)\n(`G`, integer)\n(`A`, integer)\n(`P`, integer)\n(`PIM`, integer)\n(`PLUSMINUS`, integer)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `PlayerInfo`\nColumns:\n(`ELITEID`, Int64, primary key)\n(`PlayerName`, String)\n(`birthdate`, String)\n(`birthyear`, String)\n(`birthmonth`, Int64)\n(`birthday`, Int64)\n(`birthplace`, String)\n(`nation`, String)\n(`height`, Int64)\n(`weight`, Int64)\n(`position_info`, String)\n(`shoots`, String)\n(`draftyear`, Int64)\n(`draftround`, Int64)\n(`overall`, Int64)\n(`overallby`, String)\n(`CSS_rank`, Int64)\n(`sum_7yr_GP`, Int64)\n(`sum_7yr_TOI`, Int64)\n(`GP_greater_than_0`, String)\n",
            "Table: `SeasonStatus`\nColumns:\n(`ELITEID`, Int64)\n(`SEASON`, String)\n(`TEAM`, String)\n(`LEAGUE`, String)\n(`GAMETYPE`, String)\n(`GP`, Int64)\n(`G`, Int64)\n(`A`, Int64)\n(`P`, Int64)\n(`PIM`, Int64)\n(`PLUSMINUS`, Int64)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 553,
        "database_name": "image_and_language",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(T1.IMG_ID = 1, 1, 0)), SUM(IIF(T1.X = 341 AND T1.Y = 27 AND T1.W = 42 AND T1.H = 51, 1, 0)) FROM IMG_OBJ AS T1 INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID",
        "target_query": "SELECT SUM(if(`T1`.`IMG_ID` = 1, 1, 0)), SUM(if(`T1`.`X` = 341 AND `T1`.`Y` = 27 AND `T1`.`W` = 42 AND `T1`.`H` = 51, 1, 0)) FROM `IMG_OBJ` AS `T1` INNER JOIN `OBJ_CLASSES` AS `T2` ON `T1`.`OBJ_CLASS_ID` = `T2`.`OBJ_CLASS_ID`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 35,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 42,
                "end_index": 105,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 38,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 45,
                "end_index": 123,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `IMG_OBJ`\nColumns:\n(`IMG_ID`, integer, primary key)\n(`OBJ_SAMPLE_ID`, integer, primary key)\n(`OBJ_CLASS_ID`, integer)\n(`X`, integer)\n(`Y`, integer)\n(`W`, integer)\n(`H`, integer)\n",
            "Table: `OBJ_CLASSES`\nColumns:\n(`OBJ_CLASS_ID`, integer, primary key)\n(`OBJ_CLASS`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `IMG_OBJ`\nColumns:\n(`IMG_ID`, Int64, primary key)\n(`OBJ_SAMPLE_ID`, Int64, primary key)\n(`OBJ_CLASS_ID`, Int64)\n(`X`, Int64)\n(`Y`, Int64)\n(`W`, Int64)\n(`H`, Int64)\n",
            "Table: `OBJ_CLASSES`\nColumns:\n(`OBJ_CLASS_ID`, Int64, primary key)\n(`OBJ_CLASS`, String)\n"
        ]
    },
    {
        "sql_id": 96,
        "database_name": "law_episode",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T1.episode_id) FROM Episode AS T1 INNER JOIN Award AS T2 ON T1.episode_id = T2.episode_id WHERE strftime('%Y', T1.air_date) = '1998' AND T2.organization = 'International Monitor Awards' AND T2.result = 'Winner'",
        "target_query": "SELECT COUNT(`T1`.`episode_id`) FROM `Episode` AS `T1` INNER JOIN `Award` AS `T2` ON `T1`.`episode_id` = `T2`.`episode_id` WHERE formatDateTime(`T1`.`air_date`, '%Y') = '1998' AND `T2`.`organization` = 'International Monitor Awards' AND `T2`.`result` = 'Winner';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 109,
                "end_index": 136,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 129,
                "end_index": 166,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`series`, text)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, date)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n",
            "Table: `Award`\nColumns:\n(`award_id`, integer, primary key)\n(`organization`, text)\n(`year`, integer)\n(`award_category`, text)\n(`award`, text)\n(`series`, text)\n(`episode_id`, text)\n(`person_id`, text)\n(`role`, text)\n(`result`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, String, primary key)\n(`series`, String)\n(`season`, Int64)\n(`episode`, Int64)\n(`number_in_series`, Int64)\n(`title`, String)\n(`summary`, String)\n(`air_date`, Date32)\n(`episode_image`, String)\n(`rating`, Float64)\n(`votes`, Int64)\n",
            "Table: `Award`\nColumns:\n(`award_id`, Int64, primary key)\n(`organization`, String)\n(`year`, Int64)\n(`award_category`, String)\n(`award`, String)\n(`series`, String)\n(`episode_id`, String)\n(`person_id`, String)\n(`_role`, String)\n(`result`, String)\n"
        ]
    },
    {
        "sql_id": 349,
        "database_name": "legislator",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(CASE WHEN T2.party = 'Independent' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.party) FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.gender_bio = 'M' AND strftime('%Y', T1.birthday_bio) BETWEEN '1955' AND '1965'",
        "target_query": "SELECT CAST(SUM(CASE WHEN T2.party = 'Independent' THEN 1 ELSE 0 END) AS Float64) * 100 / COUNT(T2.party) FROM `current` AS T1 INNER JOIN `current_terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.gender_bio = 'M' AND formatDateTime(T1.birthday_bio, '%Y') BETWEEN '1955' AND '1965';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 217,
                "end_index": 248,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 222,
                "end_index": 259,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `current`\nColumns:\n(`ballotpedia_id`, text)\n(`bioguide_id`, text, primary key)\n(`birthday_bio`, date)\n(`cspan_id`, real, primary key)\n(`fec_id`, text)\n(`first_name`, text)\n(`gender_bio`, text)\n(`google_entity_id_id`, text)\n(`govtrack_id`, integer)\n(`house_history_id`, real)\n(`icpsr_id`, real)\n(`last_name`, text)\n(`lis_id`, text)\n(`maplight_id`, real)\n(`middle_name`, text)\n(`nickname_name`, text)\n(`official_full_name`, text)\n(`opensecrets_id`, text)\n(`religion_bio`, text)\n(`suffix_name`, text)\n(`thomas_id`, integer)\n(`votesmart_id`, real)\n(`wikidata_id`, text)\n(`wikipedia_id`, text)\n",
            "Table: `current-terms`\nColumns:\n(`address`, text)\n(`bioguide`, text, primary key)\n(`caucus`, text)\n(`chamber`, text)\n(`class`, real)\n(`contact_form`, text)\n(`district`, real)\n(`end`, text, primary key)\n(`fax`, text)\n(`last`, text)\n(`name`, text)\n(`office`, text)\n(`party`, text)\n(`party_affiliations`, text)\n(`phone`, text)\n(`relation`, text)\n(`rss_url`, text)\n(`start`, text)\n(`state`, text)\n(`state_rank`, text)\n(`title`, text)\n(`type`, text)\n(`url`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `current`\nColumns:\n(`ballotpedia_id`, String)\n(`bioguide_id`, String, primary key)\n(`birthday_bio`, Date32)\n(`cspan_id`, Float64, primary key)\n(`fec_id`, String)\n(`first_name`, String)\n(`gender_bio`, String)\n(`google_entity_id_id`, String)\n(`govtrack_id`, Int64)\n(`house_history_id`, Float64)\n(`icpsr_id`, Float64)\n(`last_name`, String)\n(`lis_id`, String)\n(`maplight_id`, Float64)\n(`middle_name`, String)\n(`nickname_name`, String)\n(`official_full_name`, String)\n(`opensecrets_id`, String)\n(`religion_bio`, String)\n(`suffix_name`, String)\n(`thomas_id`, Int64)\n(`votesmart_id`, Float64)\n(`wikidata_id`, String)\n(`wikipedia_id`, String)\n",
            "Table: `current_terms`\nColumns:\n(`address`, String)\n(`bioguide`, String, primary key)\n(`caucus`, String)\n(`chamber`, String)\n(`class`, Float64)\n(`contact_form`, String)\n(`district`, Float64)\n(`_end`, String, primary key)\n(`fax`, String)\n(`last`, String)\n(`name`, String)\n(`office`, String)\n(`party`, String)\n(`party_affiliations`, String)\n(`phone`, String)\n(`relation`, String)\n(`rss_url`, String)\n(`start`, String)\n(`state`, String)\n(`state_rank`, String)\n(`title`, String)\n(`_type`, String)\n(`url`, String)\n"
        ]
    },
    {
        "sql_id": 356,
        "database_name": "legislator",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(*) FROM current WHERE strftime('%Y', birthday_bio) > '1960' AND google_entity_id_id IS NULL",
        "target_query": "SELECT COUNT(*) FROM `current` WHERE formatDateTime(`birthday_bio`, '%Y') > '1960' AND `google_entity_id_id` IS NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 35,
                "end_index": 63,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 37,
                "end_index": 73,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `current`\nColumns:\n(`ballotpedia_id`, text)\n(`bioguide_id`, text, primary key)\n(`birthday_bio`, date)\n(`cspan_id`, real, primary key)\n(`fec_id`, text)\n(`first_name`, text)\n(`gender_bio`, text)\n(`google_entity_id_id`, text)\n(`govtrack_id`, integer)\n(`house_history_id`, real)\n(`icpsr_id`, real)\n(`last_name`, text)\n(`lis_id`, text)\n(`maplight_id`, real)\n(`middle_name`, text)\n(`nickname_name`, text)\n(`official_full_name`, text)\n(`opensecrets_id`, text)\n(`religion_bio`, text)\n(`suffix_name`, text)\n(`thomas_id`, integer)\n(`votesmart_id`, real)\n(`wikidata_id`, text)\n(`wikipedia_id`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `current`\nColumns:\n(`ballotpedia_id`, String)\n(`bioguide_id`, String, primary key)\n(`birthday_bio`, Date32)\n(`cspan_id`, Float64, primary key)\n(`fec_id`, String)\n(`first_name`, String)\n(`gender_bio`, String)\n(`google_entity_id_id`, String)\n(`govtrack_id`, Int64)\n(`house_history_id`, Float64)\n(`icpsr_id`, Float64)\n(`last_name`, String)\n(`lis_id`, String)\n(`maplight_id`, Float64)\n(`middle_name`, String)\n(`nickname_name`, String)\n(`official_full_name`, String)\n(`opensecrets_id`, String)\n(`religion_bio`, String)\n(`suffix_name`, String)\n(`thomas_id`, Int64)\n(`votesmart_id`, Float64)\n(`wikidata_id`, String)\n(`wikipedia_id`, String)\n"
        ]
    },
    {
        "sql_id": 372,
        "database_name": "menu",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.name FROM MenuItem AS T1 INNER JOIN Dish AS T2 ON T2.id = T1.dish_id WHERE SUBSTR(T1.created_at, 7, 1) = '4'",
        "target_query": "SELECT `T2`.`name` FROM `MenuItem` AS `T1` INNER JOIN `Dish` AS `T2` ON `T2`.`id` = `T1`.`dish_id` WHERE substring(`T1`.`created_at`, 7, 1) = '4';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 85,
                "end_index": 112,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 105,
                "end_index": 139,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `MenuItem`\nColumns:\n(`id`, integer, primary key)\n(`menu_page_id`, integer)\n(`price`, real)\n(`high_price`, real)\n(`dish_id`, integer)\n(`created_at`, text)\n(`updated_at`, text)\n(`xpos`, real)\n(`ypos`, real)\n",
            "Table: `Dish`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`description`, text)\n(`menus_appeared`, integer)\n(`times_appeared`, integer)\n(`first_appeared`, integer)\n(`last_appeared`, integer)\n(`lowest_price`, real)\n(`highest_price`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `MenuItem`\nColumns:\n(`id`, Int64, primary key)\n(`menu_page_id`, Int64)\n(`price`, Float64)\n(`high_price`, Float64)\n(`dish_id`, Int64)\n(`created_at`, String)\n(`updated_at`, String)\n(`xpos`, Float64)\n(`ypos`, Float64)\n",
            "Table: `Dish`\nColumns:\n(`id`, Int64, primary key)\n(`name`, String)\n(`description`, String)\n(`menus_appeared`, Int64)\n(`times_appeared`, Int64)\n(`first_appeared`, Int64)\n(`last_appeared`, Int64)\n(`lowest_price`, Float64)\n(`highest_price`, Float64)\n"
        ]
    },
    {
        "sql_id": 373,
        "database_name": "menu",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.name FROM Dish AS T1 INNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id WHERE SUBSTR(T2.created_at, 1, 4) = '2011' AND SUBSTR(T2.created_at, 7, 1) = '4' AND T1.highest_price IS NULL",
        "target_query": "SELECT `T1`.`name` FROM `Dish` AS `T1` INNER JOIN `MenuItem` AS `T2` ON `T1`.`id` = `T2`.`dish_id` WHERE substring(`T2`.`created_at`, 1, 4) = '2011' AND substring(`T2`.`created_at`, 7, 1) = '4' AND `T1`.`highest_price` IS NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 85,
                "end_index": 112,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 126,
                "end_index": 153,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 105,
                "end_index": 139,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            },
            {
                "start_index": 153,
                "end_index": 187,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Dish`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`description`, text)\n(`menus_appeared`, integer)\n(`times_appeared`, integer)\n(`first_appeared`, integer)\n(`last_appeared`, integer)\n(`lowest_price`, real)\n(`highest_price`, real)\n",
            "Table: `MenuItem`\nColumns:\n(`id`, integer, primary key)\n(`menu_page_id`, integer)\n(`price`, real)\n(`high_price`, real)\n(`dish_id`, integer)\n(`created_at`, text)\n(`updated_at`, text)\n(`xpos`, real)\n(`ypos`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `Dish`\nColumns:\n(`id`, Int64, primary key)\n(`name`, String)\n(`description`, String)\n(`menus_appeared`, Int64)\n(`times_appeared`, Int64)\n(`first_appeared`, Int64)\n(`last_appeared`, Int64)\n(`lowest_price`, Float64)\n(`highest_price`, Float64)\n",
            "Table: `MenuItem`\nColumns:\n(`id`, Int64, primary key)\n(`menu_page_id`, Int64)\n(`price`, Float64)\n(`high_price`, Float64)\n(`dish_id`, Int64)\n(`created_at`, String)\n(`updated_at`, String)\n(`xpos`, Float64)\n(`ypos`, Float64)\n"
        ]
    },
    {
        "sql_id": 374,
        "database_name": "menu",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(*) FROM Menu WHERE call_number IS NULL AND strftime('%Y', date) < '1950'",
        "target_query": "SELECT COUNT(*) FROM `Menu` WHERE `call_number` IS NULL AND formatDateTime(`date`, '%Y') < '1950';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 56,
                "end_index": 76,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 60,
                "end_index": 88,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Menu`\nColumns:\n(`id`, integer, primary key)\n(`name`, text)\n(`sponsor`, text)\n(`event`, text)\n(`venue`, text)\n(`place`, text)\n(`physical_description`, text)\n(`occasion`, text)\n(`notes`, text)\n(`call_number`, text)\n(`keywords`, text)\n(`language`, text)\n(`date`, date)\n(`location`, text)\n(`location_type`, text)\n(`currency`, text)\n(`currency_symbol`, text)\n(`status`, text)\n(`page_count`, integer)\n(`dish_count`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `Menu`\nColumns:\n(`id`, Int64, primary key)\n(`name`, String)\n(`sponsor`, String)\n(`event`, String)\n(`venue`, String)\n(`place`, String)\n(`physical_description`, String)\n(`occasion`, String)\n(`notes`, String)\n(`call_number`, String)\n(`keywords`, String)\n(`language`, String)\n(`date`, Date32)\n(`location`, String)\n(`location_type`, String)\n(`currency`, String)\n(`currency_symbol`, String)\n(`status`, String)\n(`page_count`, Int64)\n(`dish_count`, Int64)\n"
        ]
    },
    {
        "sql_id": 575,
        "database_name": "mondial_geo",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(CASE WHEN Government = 'republic' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(Country) FROM politics WHERE STRFTIME('%Y', Independence) > '1970'",
        "target_query": "SELECT SUM(CASE WHEN `Government` = 'republic' THEN 1 ELSE 0 END) * 100 / COUNT(`Country`) FROM `politics` WHERE formatDateTime(`Independence`, '%Y') > '1970';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 121,
                "end_index": 149,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 113,
                "end_index": 149,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `politics`\nColumns:\n(`Country`, text, primary key)\n(`Independence`, date)\n(`Dependent`, text)\n(`Government`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `politics`\nColumns:\n(`Country`, String, primary key)\n(`Independence`, Date32)\n(`Dependent`, String)\n(`Government`, String)\n"
        ]
    },
    {
        "sql_id": 576,
        "database_name": "mondial_geo",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.Country, COUNT(T1.Country) FROM economy AS T1 INNER JOIN organization AS T2 ON T1.Country = T2.Country WHERE T1.GDP < 500000 AND STRFTIME('%Y', T2.Established) < '1999' GROUP BY T1.Country",
        "target_query": "SELECT `T1`.`Country`, COUNT(`T1`.`Country`) FROM `economy` AS `T1` INNER JOIN `organization` AS `T2` ON `T1`.`Country` = `T2`.`Country` WHERE `T1`.`GDP` < 500000 AND formatDateTime(`T2`.`Established`, '%Y') < '1999' GROUP BY `T1`.`Country`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 139,
                "end_index": 169,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 167,
                "end_index": 207,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `economy`\nColumns:\n(`Country`, text, primary key)\n(`GDP`, real)\n(`Agriculture`, real)\n(`Service`, real)\n(`Industry`, real)\n(`Inflation`, real)\n",
            "Table: `organization`\nColumns:\n(`Abbreviation`, text, primary key)\n(`Name`, text)\n(`City`, text)\n(`Country`, text)\n(`Province`, text)\n(`Established`, date)\n"
        ],
        "target_related_schemas": [
            "Table: `economy`\nColumns:\n(`Country`, String, primary key)\n(`GDP`, Float64)\n(`Agriculture`, Float64)\n(`Service`, Float64)\n(`Industry`, Float64)\n(`Inflation`, Float64)\n",
            "Table: `organization`\nColumns:\n(`Abbreviation`, String, primary key)\n(`Name`, String)\n(`City`, String)\n(`Country`, String)\n(`Province`, String)\n(`Established`, Date32)\n"
        ]
    },
    {
        "sql_id": 577,
        "database_name": "mondial_geo",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.Country FROM politics AS T1 INNER JOIN population AS T2 ON T1.Country = T2.Country WHERE STRFTIME('%Y', T1.Independence) = '1960' ORDER BY T2.Infant_Mortality DESC LIMIT 1",
        "target_query": "SELECT `T1`.`Country` FROM `politics` AS `T1` INNER JOIN `population` AS `T2` ON `T1`.`Country` = `T2`.`Country` WHERE formatDateTime(`T1`.`Independence`, '%Y') = '1960' ORDER BY `T2`.`Infant_Mortality` DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 99,
                "end_index": 130,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 119,
                "end_index": 160,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `politics`\nColumns:\n(`Country`, text, primary key)\n(`Independence`, date)\n(`Dependent`, text)\n(`Government`, text)\n",
            "Table: `population`\nColumns:\n(`Country`, text, primary key)\n(`Population_Growth`, real)\n(`Infant_Mortality`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `politics`\nColumns:\n(`Country`, String, primary key)\n(`Independence`, Date32)\n(`Dependent`, String)\n(`Government`, String)\n",
            "Table: `population`\nColumns:\n(`Country`, String, primary key)\n(`Population_Growth`, Float64)\n(`Infant_Mortality`, Float64)\n"
        ]
    },
    {
        "sql_id": 579,
        "database_name": "mondial_geo",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.Population / T1.Area FROM country AS T1 INNER JOIN organization AS T2 ON T1.Code = T2.Country WHERE STRFTIME('%Y', T2.Established) = '1947'",
        "target_query": "SELECT `Population` / `Area` FROM `country` AS T1 INNER JOIN `organization` AS T2 ON T1.`Code` = T2.`Country` WHERE formatDateTime(T2.`Established`, '%Y') = '1947';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 110,
                "end_index": 140,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 116,
                "end_index": 154,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `country`\nColumns:\n(`Name`, text)\n(`Code`, text, primary key)\n(`Capital`, text)\n(`Province`, text)\n(`Area`, real)\n(`Population`, integer)\n",
            "Table: `organization`\nColumns:\n(`Abbreviation`, text, primary key)\n(`Name`, text)\n(`City`, text)\n(`Country`, text)\n(`Province`, text)\n(`Established`, date)\n"
        ],
        "target_related_schemas": [
            "Table: `country`\nColumns:\n(`Name`, String)\n(`Code`, String, primary key)\n(`Capital`, String)\n(`Province`, String)\n(`Area`, Float64)\n(`Population`, Int64)\n",
            "Table: `organization`\nColumns:\n(`Abbreviation`, String, primary key)\n(`Name`, String)\n(`City`, String)\n(`Country`, String)\n(`Province`, String)\n(`Established`, Date32)\n"
        ]
    },
    {
        "sql_id": 582,
        "database_name": "mondial_geo",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.Name FROM country AS T1 INNER JOIN organization AS T2 ON T1.Code = T2.Country INNER JOIN politics AS T3 ON T3.Country = T2.Country WHERE STRFTIME('%Y', T2.Established) > '1907' AND T3.Government = 'constitutional monarchy' GROUP BY T1.Name ORDER BY COUNT(DISTINCT T2.Name) DESC LIMIT 1",
        "target_query": "SELECT `T1`.`Name` FROM `country` AS `T1` INNER JOIN `organization` AS `T2` ON `T1`.`Code` = `T2`.`Country` INNER JOIN `politics` AS `T3` ON `T3`.`Country` = `T2`.`Country` WHERE formatDateTime(`T2`.`Established`, '%Y') > '1907' AND `T3`.`Government` = 'constitutional monarchy' GROUP BY `T1`.`Name` ORDER BY COUNT(DISTINCT `T2`.`Name`) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 147,
                "end_index": 177,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 179,
                "end_index": 219,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `country`\nColumns:\n(`Name`, text)\n(`Code`, text, primary key)\n(`Capital`, text)\n(`Province`, text)\n(`Area`, real)\n(`Population`, integer)\n",
            "Table: `organization`\nColumns:\n(`Abbreviation`, text, primary key)\n(`Name`, text)\n(`City`, text)\n(`Country`, text)\n(`Province`, text)\n(`Established`, date)\n",
            "Table: `politics`\nColumns:\n(`Country`, text, primary key)\n(`Independence`, date)\n(`Dependent`, text)\n(`Government`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `country`\nColumns:\n(`Name`, String)\n(`Code`, String, primary key)\n(`Capital`, String)\n(`Province`, String)\n(`Area`, Float64)\n(`Population`, Int64)\n",
            "Table: `organization`\nColumns:\n(`Abbreviation`, String, primary key)\n(`Name`, String)\n(`City`, String)\n(`Country`, String)\n(`Province`, String)\n(`Established`, Date32)\n",
            "Table: `politics`\nColumns:\n(`Country`, String, primary key)\n(`Independence`, Date32)\n(`Dependent`, String)\n(`Government`, String)\n"
        ]
    },
    {
        "sql_id": 583,
        "database_name": "mondial_geo",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(government = 'parliamentary democracy', 1, 0)) , CAST(SUM(IIF(government = 'parliamentary democracy', 1, 0)) AS REAL) * 100 / COUNT(*) FROM politics AS t1 WHERE STRFTIME('%Y', independence) >= '1993'",
        "target_query": "SELECT SUM(if(`Government` = 'parliamentary democracy', 1, 0)), CAST(SUM(if(`Government` = 'parliamentary democracy', 1, 0)) AS Float64) * 100 / COUNT(*) FROM `politics` AS t1 WHERE formatDateTime(`Independence`, '%Y') >= '1993';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 60,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 73,
                "end_index": 122,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 61,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 73,
                "end_index": 123,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            },
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            },
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `politics`\nColumns:\n(`Country`, text, primary key)\n(`Independence`, date)\n(`Dependent`, text)\n(`Government`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `politics`\nColumns:\n(`Country`, String, primary key)\n(`Independence`, Date32)\n(`Dependent`, String)\n(`Government`, String)\n"
        ]
    },
    {
        "sql_id": 584,
        "database_name": "mondial_geo",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT Name FROM organization WHERE STRFTIME('%Y', Established) BETWEEN '1970' AND '1980'",
        "target_query": "SELECT `Name` FROM `organization` WHERE formatDateTime(`Established`, '%Y') BETWEEN '1970' AND '1980';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 36,
                "end_index": 63,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 40,
                "end_index": 75,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `organization`\nColumns:\n(`Abbreviation`, text, primary key)\n(`Name`, text)\n(`City`, text)\n(`Country`, text)\n(`Province`, text)\n(`Established`, date)\n"
        ],
        "target_related_schemas": [
            "Table: `organization`\nColumns:\n(`Abbreviation`, String, primary key)\n(`Name`, String)\n(`City`, String)\n(`Country`, String)\n(`Province`, String)\n(`Established`, Date32)\n"
        ]
    },
    {
        "sql_id": 585,
        "database_name": "mondial_geo",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT STRFTIME('%Y', T4.Established) FROM continent AS T1 INNER JOIN encompasses AS T2 ON T1.Name = T2.Continent INNER JOIN country AS T3 ON T2.Country = T3.Code INNER JOIN organization AS T4 ON T4.Country = T3.Code WHERE T1.Name = 'Europe' GROUP BY STRFTIME('%Y', T4.Established) ORDER BY COUNT(T4.Name) DESC LIMIT 1",
        "target_query": "SELECT formatDateTime(`T4`.`Established`, '%Y') FROM `continent` AS `T1` INNER JOIN `encompasses` AS `T2` ON `T1`.`Name` = `T2`.`Continent` INNER JOIN `country` AS `T3` ON `T2`.`Country` = `T3`.`Code` INNER JOIN `organization` AS `T4` ON `T4`.`Country` = `T3`.`Code` WHERE `T1`.`Name` = 'Europe' GROUP BY formatDateTime(`T4`.`Established`, '%Y') ORDER BY COUNT(`T4`.`Name`) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 37,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 251,
                "end_index": 281,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 47,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            },
            {
                "start_index": 305,
                "end_index": 345,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `continent`\nColumns:\n(`Name`, text, primary key)\n(`Area`, real)\n",
            "Table: `encompasses`\nColumns:\n(`Country`, text, primary key)\n(`Continent`, text, primary key)\n(`Percentage`, real)\n",
            "Table: `country`\nColumns:\n(`Name`, text)\n(`Code`, text, primary key)\n(`Capital`, text)\n(`Province`, text)\n(`Area`, real)\n(`Population`, integer)\n",
            "Table: `organization`\nColumns:\n(`Abbreviation`, text, primary key)\n(`Name`, text)\n(`City`, text)\n(`Country`, text)\n(`Province`, text)\n(`Established`, date)\n"
        ],
        "target_related_schemas": [
            "Table: `continent`\nColumns:\n(`Name`, String, primary key)\n(`Area`, Float64)\n",
            "Table: `encompasses`\nColumns:\n(`Country`, String, primary key)\n(`Continent`, String, primary key)\n(`Percentage`, Float64)\n",
            "Table: `country`\nColumns:\n(`Name`, String)\n(`Code`, String, primary key)\n(`Capital`, String)\n(`Province`, String)\n(`Area`, Float64)\n(`Population`, Int64)\n",
            "Table: `organization`\nColumns:\n(`Abbreviation`, String, primary key)\n(`Name`, String)\n(`City`, String)\n(`Country`, String)\n(`Province`, String)\n(`Established`, Date32)\n"
        ]
    },
    {
        "sql_id": 586,
        "database_name": "mondial_geo",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT * FROM politics WHERE STRFTIME('%Y', Independence) BETWEEN '1950' AND '1999' AND Government = 'parliamentary democracy'",
        "target_query": "SELECT * FROM `politics` WHERE formatDateTime(`Independence`, '%Y') BETWEEN '1950' AND '1999' AND `Government` = 'parliamentary democracy';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 29,
                "end_index": 57,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 31,
                "end_index": 67,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `politics`\nColumns:\n(`Country`, text, primary key)\n(`Independence`, date)\n(`Dependent`, text)\n(`Government`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `politics`\nColumns:\n(`Country`, String, primary key)\n(`Independence`, Date32)\n(`Dependent`, String)\n(`Government`, String)\n"
        ]
    },
    {
        "sql_id": 587,
        "database_name": "mondial_geo",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(CASE WHEN STRFTIME('%Y', Independence) = '1960' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(Country) FROM politics",
        "target_query": "SELECT CAST(SUM(CASE WHEN formatDateTime(`Independence`, '%Y') = '1960' THEN 1 ELSE 0 END) AS Float64) * 100 / COUNT(`Country`) FROM `politics`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 26,
                "end_index": 54,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 26,
                "end_index": 62,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `politics`\nColumns:\n(`Country`, text, primary key)\n(`Independence`, date)\n(`Dependent`, text)\n(`Government`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `politics`\nColumns:\n(`Country`, String, primary key)\n(`Independence`, Date32)\n(`Dependent`, String)\n(`Government`, String)\n"
        ]
    },
    {
        "sql_id": 53,
        "database_name": "movie",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT (MAX(CAST(SUBSTR(T2.screentime, 3, 2) AS REAL)) - MIN(CAST(SUBSTR(T2.screentime, 3, 2) AS REAL))) * 100 / MIN(CAST(SUBSTR(T2.screentime, 3, 2) AS REAL)) FROM movie AS T1 INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID WHERE T1.Title = 'Batman'",
        "target_query": "SELECT (MAX(toFloat64(substring(`T2`.`screentime`, 3, 2))) - MIN(toFloat64(substring(`T2`.`screentime`, 3, 2)))) * 100 / MIN(toFloat64(substring(`T2`.`screentime`, 3, 2))) FROM `movie` AS `T1` INNER JOIN `characters` AS `T2` ON `T1`.`MovieID` = `T2`.`MovieID` WHERE `T1`.`Title` = 'Batman';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 17,
                "end_index": 44,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 66,
                "end_index": 93,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 122,
                "end_index": 149,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 22,
                "end_index": 56,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            },
            {
                "start_index": 75,
                "end_index": 109,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            },
            {
                "start_index": 135,
                "end_index": 169,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movie`\nColumns:\n(`MovieID`, integer, primary key)\n(`Title`, text)\n(`MPAA Rating`, text)\n(`Budget`, integer)\n(`Gross`, integer)\n(`Release Date`, text)\n(`Genre`, text)\n(`Runtime`, integer)\n(`Rating`, real)\n(`Rating Count`, integer)\n(`Summary`, text)\n",
            "Table: `characters`\nColumns:\n(`MovieID`, integer, primary key)\n(`ActorID`, integer, primary key)\n(`Character Name`, text)\n(`creditOrder`, integer)\n(`pay`, text)\n(`screentime`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `movie`\nColumns:\n(`MovieID`, Int64, primary key)\n(`Title`, String)\n(`MPAA_Rating`, String)\n(`Budget`, Int64)\n(`Gross`, Int64)\n(`Release_Date`, String)\n(`Genre`, String)\n(`Runtime`, Int64)\n(`Rating`, Float64)\n(`Rating_Count`, Int64)\n(`Summary`, String)\n",
            "Table: `characters`\nColumns:\n(`MovieID`, Int64, primary key)\n(`ActorID`, Int64, primary key)\n(`Character_Name`, String)\n(`creditOrder`, Int64)\n(`pay`, String)\n(`screentime`, String)\n"
        ]
    },
    {
        "sql_id": 181,
        "database_name": "movielens",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T2.u_gender = 'F', 1, 0)) AS REAL) * 100 / COUNT(T2.userid) FROM u2base AS T1 INNER JOIN users AS T2 ON T1.userid = T2.userid WHERE T1.rating = 2",
        "target_query": "SELECT toFloat64(SUM(if(T2.u_gender = 'F', 1, 0))) * 100 / COUNT(T2.userid) FROM `u2base` AS T1 INNER JOIN `users` AS T2 ON T1.userid = T2.userid WHERE T1.rating = '2';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 44,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 48,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `u2base`\nColumns:\n(`userid`, integer, primary key)\n(`movieid`, integer, primary key)\n(`rating`, text)\n",
            "Table: `users`\nColumns:\n(`userid`, integer, primary key)\n(`age`, text)\n(`u_gender`, text)\n(`occupation`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `u2base`\nColumns:\n(`userid`, Int64, primary key)\n(`movieid`, Int64, primary key)\n(`rating`, String)\n",
            "Table: `users`\nColumns:\n(`userid`, Int64, primary key)\n(`age`, String)\n(`u_gender`, String)\n(`occupation`, String)\n"
        ]
    },
    {
        "sql_id": 183,
        "database_name": "movielens",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T3.a_quality >= 3, 1, 0)) AS REAL) * 100 / COUNT(T1.movieid) FROM movies AS T1 INNER JOIN movies2actors AS T2 ON T1.movieid = T2.movieid INNER JOIN actors AS T3 ON T2.actorid = T3.actorid WHERE T1.country = 'UK'",
        "target_query": "SELECT toFloat64(SUM(if(T3.`a_quality` >= 3, 1, 0))) * 100 / COUNT(T1.`movieid`) FROM `movies` AS T1 INNER JOIN `movies2actors` AS T2 ON T1.`movieid` = T2.`movieid` INNER JOIN `actors` AS T3 ON T2.`actorid` = T3.`actorid` WHERE T1.`country` = 'UK';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 44,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 50,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies`\nColumns:\n(`movieid`, integer, primary key)\n(`year`, integer)\n(`isEnglish`, text)\n(`country`, text)\n(`runningtime`, integer)\n",
            "Table: `movies2actors`\nColumns:\n(`movieid`, integer, primary key)\n(`actorid`, integer, primary key)\n(`cast_num`, integer)\n",
            "Table: `actors`\nColumns:\n(`actorid`, integer, primary key)\n(`a_gender`, text)\n(`a_quality`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `movies`\nColumns:\n(`movieid`, Int64, primary key)\n(`year`, Int64)\n(`isEnglish`, String)\n(`country`, String)\n(`runningtime`, Int64)\n",
            "Table: `movies2actors`\nColumns:\n(`movieid`, Int64, primary key)\n(`actorid`, Int64, primary key)\n(`cast_num`, Int64)\n",
            "Table: `actors`\nColumns:\n(`actorid`, Int64, primary key)\n(`a_gender`, String)\n(`a_quality`, Int64)\n"
        ]
    },
    {
        "sql_id": 184,
        "database_name": "movielens",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T2.avg_revenue > T2.d_quality, 1, 0)) AS REAL) * 100 / COUNT(T1.movieid) FROM movies2directors AS T1 INNER JOIN directors AS T2 ON T1.directorid = T2.directorid WHERE T1.genre = 'Action'",
        "target_query": "SELECT toFloat64(SUM(if(T2.avg_revenue > T2.d_quality, 1, 0))) * 100 / COUNT(T1.movieid) FROM `movies2directors` AS T1 INNER JOIN `directors` AS T2 ON T1.directorid = T2.directorid WHERE T1.genre = 'Action';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 56,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 60,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies2directors`\nColumns:\n(`movieid`, integer, primary key)\n(`directorid`, integer, primary key)\n(`genre`, text)\n",
            "Table: `directors`\nColumns:\n(`directorid`, integer, primary key)\n(`d_quality`, integer)\n(`avg_revenue`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `movies2directors`\nColumns:\n(`movieid`, Int64, primary key)\n(`directorid`, Int64, primary key)\n(`genre`, String)\n",
            "Table: `directors`\nColumns:\n(`directorid`, Int64, primary key)\n(`d_quality`, Int64)\n(`avg_revenue`, Int64)\n"
        ]
    },
    {
        "sql_id": 185,
        "database_name": "movielens",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T1.rating = 1, 1, 0)) AS REAL) * 100 / COUNT(T1.movieid) FROM u2base AS T1 INNER JOIN movies AS T2 ON T1.movieid = T2.movieid WHERE T2.country = 'USA'",
        "target_query": "SELECT SUM(if(`T1`.`rating` = '1', 1, 0)) * 100 / COUNT(`T1`.`movieid`) FROM `u2base` AS `T1` INNER JOIN `movies` AS `T2` ON `T1`.`movieid` = `T2`.`movieid` WHERE `T2`.`country` = 'USA';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 40,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 40,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `u2base`\nColumns:\n(`userid`, integer, primary key)\n(`movieid`, integer, primary key)\n(`rating`, text)\n",
            "Table: `movies`\nColumns:\n(`movieid`, integer, primary key)\n(`year`, integer)\n(`isEnglish`, text)\n(`country`, text)\n(`runningtime`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `u2base`\nColumns:\n(`userid`, Int64, primary key)\n(`movieid`, Int64, primary key)\n(`rating`, String)\n",
            "Table: `movies`\nColumns:\n(`movieid`, Int64, primary key)\n(`year`, Int64)\n(`isEnglish`, String)\n(`country`, String)\n(`runningtime`, Int64)\n"
        ]
    },
    {
        "sql_id": 186,
        "database_name": "movielens",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T3.a_gender = 'M', 1, 0)) AS REAL) / SUM(IIF(T3.a_gender = 'F', 1, 0)) FROM movies AS T1 INNER JOIN movies2actors AS T2 ON T1.movieid = T2.movieid INNER JOIN actors AS T3 ON T2.actorid = T3.actorid WHERE T1.country = 'UK'",
        "target_query": "SELECT CAST(SUM(if(T3.`a_gender` = 'M', 1, 0)) AS Float64) / SUM(if(T3.`a_gender` = 'F', 1, 0)) FROM `movies` AS T1 INNER JOIN `movies2actors` AS T2 ON T1.`movieid` = T2.`movieid` INNER JOIN `actors` AS T3 ON T2.`actorid` = T3.`actorid` WHERE T1.`country` = 'UK';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 44,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 61,
                "end_index": 89,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 45,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 65,
                "end_index": 94,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movies`\nColumns:\n(`movieid`, integer, primary key)\n(`year`, integer)\n(`isEnglish`, text)\n(`country`, text)\n(`runningtime`, integer)\n",
            "Table: `movies2actors`\nColumns:\n(`movieid`, integer, primary key)\n(`actorid`, integer, primary key)\n(`cast_num`, integer)\n",
            "Table: `actors`\nColumns:\n(`actorid`, integer, primary key)\n(`a_gender`, text)\n(`a_quality`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `movies`\nColumns:\n(`movieid`, Int64, primary key)\n(`year`, Int64)\n(`isEnglish`, String)\n(`country`, String)\n(`runningtime`, Int64)\n",
            "Table: `movies2actors`\nColumns:\n(`movieid`, Int64, primary key)\n(`actorid`, Int64, primary key)\n(`cast_num`, Int64)\n",
            "Table: `actors`\nColumns:\n(`actorid`, Int64, primary key)\n(`a_gender`, String)\n(`a_quality`, Int64)\n"
        ]
    },
    {
        "sql_id": 187,
        "database_name": "movielens",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T2.cast_num = 2 AND T1.a_quality = 2, 1, 0)) AS REAL) * 100 / COUNT(T1.actorid) FROM actors AS T1 INNER JOIN movies2actors AS T2 ON T1.actorid = T2.actorid WHERE T2.movieid = 1672580 AND T1.a_gender = 'F'",
        "target_query": "SELECT CAST(SUM(if(T2.cast_num = 2 AND T1.a_quality = 2, 1, 0)) AS Float64) * 100 / COUNT(T1.actorid) FROM `actors` AS T1 INNER JOIN `movies2actors` AS T2 ON T1.actorid = T2.actorid WHERE T2.movieid = 1672580 AND T1.a_gender = 'F';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 63,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 62,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `actors`\nColumns:\n(`actorid`, integer, primary key)\n(`a_gender`, text)\n(`a_quality`, integer)\n",
            "Table: `movies2actors`\nColumns:\n(`movieid`, integer, primary key)\n(`actorid`, integer, primary key)\n(`cast_num`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `actors`\nColumns:\n(`actorid`, Int64, primary key)\n(`a_gender`, String)\n(`a_quality`, Int64)\n",
            "Table: `movies2actors`\nColumns:\n(`movieid`, Int64, primary key)\n(`actorid`, Int64, primary key)\n(`cast_num`, Int64)\n"
        ]
    },
    {
        "sql_id": 188,
        "database_name": "movielens",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(a_gender = 'M', 1, 0)) AS REAL) / SUM(IIF(a_gender = 'F', 1, 0)) FROM actors WHERE a_quality = 0",
        "target_query": "SELECT SUM(if(`a_gender` = 'M', 1, 0)) / SUM(if(`a_gender` = 'F', 1, 0)) FROM `actors` WHERE `a_quality` = 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 41,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 58,
                "end_index": 83,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 37,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 45,
                "end_index": 71,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `actors`\nColumns:\n(`actorid`, integer, primary key)\n(`a_gender`, text)\n(`a_quality`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `actors`\nColumns:\n(`actorid`, Int64, primary key)\n(`a_gender`, String)\n(`a_quality`, Int64)\n"
        ]
    },
    {
        "sql_id": 189,
        "database_name": "movielens",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(T1.a_gender = 'F', 1, 0)) , T3.country, T3.runningtime FROM actors AS T1 INNER JOIN movies2actors AS T2 ON T1.actorid = T2.actorid INNER JOIN movies AS T3 ON T2.movieid = T3.movieid WHERE T2.movieid = 2312852 GROUP BY T3.country, T3.runningtime",
        "target_query": "SELECT SUM(if(`T1`.`a_gender` = 'F', 1, 0)), `T3`.`country`, `T3`.`runningtime` FROM `actors` AS `T1` INNER JOIN `movies2actors` AS `T2` ON `T1`.`actorid` = `T2`.`actorid` INNER JOIN `movies` AS `T3` ON `T2`.`movieid` = `T3`.`movieid` WHERE `T2`.`movieid` = 2312852 GROUP BY `T3`.`country`, `T3`.`runningtime`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 39,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 42,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `actors`\nColumns:\n(`actorid`, integer, primary key)\n(`a_gender`, text)\n(`a_quality`, integer)\n",
            "Table: `movies2actors`\nColumns:\n(`movieid`, integer, primary key)\n(`actorid`, integer, primary key)\n(`cast_num`, integer)\n",
            "Table: `movies`\nColumns:\n(`movieid`, integer, primary key)\n(`year`, integer)\n(`isEnglish`, text)\n(`country`, text)\n(`runningtime`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `actors`\nColumns:\n(`actorid`, Int64, primary key)\n(`a_gender`, String)\n(`a_quality`, Int64)\n",
            "Table: `movies2actors`\nColumns:\n(`movieid`, Int64, primary key)\n(`actorid`, Int64, primary key)\n(`cast_num`, Int64)\n",
            "Table: `movies`\nColumns:\n(`movieid`, Int64, primary key)\n(`year`, Int64)\n(`isEnglish`, String)\n(`country`, String)\n(`runningtime`, Int64)\n"
        ]
    },
    {
        "sql_id": 41,
        "database_name": "movies_4",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT AVG(T1.revenue) FROM movie AS T1 INNER JOIN production_country AS T2 ON T1.movie_id = T2.movie_id INNER JOIN country AS T3 ON T2.country_id = T3.country_id WHERE T3.COUNTry_name = 'United States of America' AND CAST(STRFTIME('%Y', T1.release_date) AS INT) = 2006",
        "target_query": "SELECT AVG(`T1`.`revenue`) \nFROM `movie` AS `T1` \nINNER JOIN `production_country` AS `T2` ON `T1`.`movie_id` = `T2`.`movie_id` \nINNER JOIN `country` AS `T3` ON `T2`.`country_id` = `T3`.`country_id` \nWHERE `T3`.`country_name` = 'United States of America' \nAND formatDateTime(`T1`.`release_date`, '%Y') = '2006';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 223,
                "end_index": 254,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 259,
                "end_index": 300,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movie`\nColumns:\n(`movie_id`, integer, primary key)\n(`title`, text)\n(`budget`, integer)\n(`homepage`, text)\n(`overview`, text)\n(`popularity`, real)\n(`release_date`, date)\n(`revenue`, integer)\n(`runtime`, integer)\n(`movie_status`, text)\n(`tagline`, text)\n(`vote_average`, real)\n(`vote_count`, integer)\n",
            "Table: `production_country`\nColumns:\n(`movie_id`, integer)\n(`country_id`, integer)\n(`rowid`, integer, primary key)\n",
            "Table: `country`\nColumns:\n(`country_id`, integer, primary key)\n(`country_iso_code`, text)\n(`country_name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `movie`\nColumns:\n(`movie_id`, Int64, primary key)\n(`title`, String)\n(`budget`, Int64)\n(`homepage`, String)\n(`overview`, String)\n(`popularity`, Float64)\n(`release_date`, Date32)\n(`revenue`, Int64)\n(`runtime`, Int64)\n(`movie_status`, String)\n(`tagline`, String)\n(`vote_average`, Float64)\n(`vote_count`, Int64)\n",
            "Table: `production_country`\nColumns:\n(`movie_id`, Int64)\n(`country_id`, Int64)\n(`rowid`, Int64, primary key)\n",
            "Table: `country`\nColumns:\n(`country_id`, Int64, primary key)\n(`country_iso_code`, String)\n(`country_name`, String)\n"
        ]
    },
    {
        "sql_id": 45,
        "database_name": "movies_4",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT title FROM movie WHERE CAST(STRFTIME('%Y', release_date) AS INT) = 1945",
        "target_query": "SELECT `title` FROM `movie` WHERE formatDateTime(`release_date`, '%Y') = '1945';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 35,
                "end_index": 63,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 34,
                "end_index": 70,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movie`\nColumns:\n(`movie_id`, integer, primary key)\n(`title`, text)\n(`budget`, integer)\n(`homepage`, text)\n(`overview`, text)\n(`popularity`, real)\n(`release_date`, date)\n(`revenue`, integer)\n(`runtime`, integer)\n(`movie_status`, text)\n(`tagline`, text)\n(`vote_average`, real)\n(`vote_count`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `movie`\nColumns:\n(`movie_id`, Int64, primary key)\n(`title`, String)\n(`budget`, Int64)\n(`homepage`, String)\n(`overview`, String)\n(`popularity`, Float64)\n(`release_date`, Date32)\n(`revenue`, Int64)\n(`runtime`, Int64)\n(`movie_status`, String)\n(`tagline`, String)\n(`vote_average`, Float64)\n(`vote_count`, Int64)\n"
        ]
    },
    {
        "sql_id": 40,
        "database_name": "movies_4",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T1.movie_id) FROM movie AS T1 INNER JOIN movie_cast AS T2 ON T1.movie_id = T2.movie_id INNER JOIN person AS T3 ON T2.person_id = T3.person_id WHERE T3.person_name = 'Quentin Tarantino' AND CAST(STRFTIME('%Y', T1.release_date) AS INT) = 1995",
        "target_query": "SELECT COUNT(`T1`.`movie_id`) FROM `movie` AS `T1` INNER JOIN `movie_cast` AS `T2` ON `T1`.`movie_id` = `T2`.`movie_id` INNER JOIN `person` AS `T3` ON `T2`.`person_id` = `T3`.`person_id` WHERE `T3`.`person_name` = 'Quentin Tarantino' AND formatDateTime(`T1`.`release_date`, '%Y') = '1995';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 207,
                "end_index": 238,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 238,
                "end_index": 279,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movie`\nColumns:\n(`movie_id`, integer, primary key)\n(`title`, text)\n(`budget`, integer)\n(`homepage`, text)\n(`overview`, text)\n(`popularity`, real)\n(`release_date`, date)\n(`revenue`, integer)\n(`runtime`, integer)\n(`movie_status`, text)\n(`tagline`, text)\n(`vote_average`, real)\n(`vote_count`, integer)\n",
            "Table: `movie_cast`\nColumns:\n(`movie_id`, integer)\n(`person_id`, integer)\n(`character_name`, text)\n(`gender_id`, integer)\n(`cast_order`, integer)\n(`rowid`, integer, primary key)\n",
            "Table: `person`\nColumns:\n(`person_id`, integer, primary key)\n(`person_name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `movie`\nColumns:\n(`movie_id`, Int64, primary key)\n(`title`, String)\n(`budget`, Int64)\n(`homepage`, String)\n(`overview`, String)\n(`popularity`, Float64)\n(`release_date`, Date32)\n(`revenue`, Int64)\n(`runtime`, Int64)\n(`movie_status`, String)\n(`tagline`, String)\n(`vote_average`, Float64)\n(`vote_count`, Int64)\n",
            "Table: `movie_cast`\nColumns:\n(`movie_id`, Int64)\n(`person_id`, Int64)\n(`character_name`, String)\n(`gender_id`, Int64)\n(`cast_order`, Int64)\n(`rowid`, Int64, primary key)\n",
            "Table: `person`\nColumns:\n(`person_id`, Int64, primary key)\n(`person_name`, String)\n"
        ]
    },
    {
        "sql_id": 42,
        "database_name": "movies_4",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT AVG(CASE WHEN T3.COUNTry_name = 'United States of America' THEN T1.revenue END) - AVG(CASE WHEN T3.COUNTry_name = 'India' THEN T1.revenue END) AS CALCULATE FROM movie AS T1 INNER JOIN production_country AS T2 ON T1.movie_id = T2.movie_id INNER JOIN country AS T3 ON T2.country_id = T3.country_id WHERE CAST(STRFTIME('%Y', T1.release_date) AS INT) = 2016",
        "target_query": "SELECT AVG(CASE WHEN `T3`.`country_name` = 'United States of America' THEN `T1`.`revenue` END) - AVG(CASE WHEN `T3`.`country_name` = 'India' THEN `T1`.`revenue` END) AS `CALCULATE` FROM `movie` AS `T1` INNER JOIN `production_country` AS `T2` ON `T1`.`movie_id` = `T2`.`movie_id` INNER JOIN `country` AS `T3` ON `T2`.`country_id` = `T3`.`country_id` WHERE formatDateTime(`T1`.`release_date`, '%Y') = '2016';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 314,
                "end_index": 345,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 355,
                "end_index": 396,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movie`\nColumns:\n(`movie_id`, integer, primary key)\n(`title`, text)\n(`budget`, integer)\n(`homepage`, text)\n(`overview`, text)\n(`popularity`, real)\n(`release_date`, date)\n(`revenue`, integer)\n(`runtime`, integer)\n(`movie_status`, text)\n(`tagline`, text)\n(`vote_average`, real)\n(`vote_count`, integer)\n",
            "Table: `production_country`\nColumns:\n(`movie_id`, integer)\n(`country_id`, integer)\n(`rowid`, integer, primary key)\n",
            "Table: `country`\nColumns:\n(`country_id`, integer, primary key)\n(`country_iso_code`, text)\n(`country_name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `movie`\nColumns:\n(`movie_id`, Int64, primary key)\n(`title`, String)\n(`budget`, Int64)\n(`homepage`, String)\n(`overview`, String)\n(`popularity`, Float64)\n(`release_date`, Date32)\n(`revenue`, Int64)\n(`runtime`, Int64)\n(`movie_status`, String)\n(`tagline`, String)\n(`vote_average`, Float64)\n(`vote_count`, Int64)\n",
            "Table: `production_country`\nColumns:\n(`movie_id`, Int64)\n(`country_id`, Int64)\n(`rowid`, Int64, primary key)\n",
            "Table: `country`\nColumns:\n(`country_id`, Int64, primary key)\n(`country_iso_code`, String)\n(`country_name`, String)\n"
        ]
    },
    {
        "sql_id": 44,
        "database_name": "movies_4",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.company_id FROM movie AS T1 INNER JOIN movie_company AS T2 ON T1.movie_id = T2.movie_id WHERE CAST(STRFTIME('%Y', T1.release_date) AS INT) = 1916",
        "target_query": "SELECT T2.`company_id` FROM `movie` AS T1 INNER JOIN `movie_company` AS T2 ON T1.`movie_id` = T2.`movie_id` WHERE formatDateTime(T1.`release_date`, '%Y') = '1916';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 109,
                "end_index": 140,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 114,
                "end_index": 153,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movie`\nColumns:\n(`movie_id`, integer, primary key)\n(`title`, text)\n(`budget`, integer)\n(`homepage`, text)\n(`overview`, text)\n(`popularity`, real)\n(`release_date`, date)\n(`revenue`, integer)\n(`runtime`, integer)\n(`movie_status`, text)\n(`tagline`, text)\n(`vote_average`, real)\n(`vote_count`, integer)\n",
            "Table: `movie_company`\nColumns:\n(`movie_id`, integer)\n(`company_id`, integer)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `movie`\nColumns:\n(`movie_id`, Int64, primary key)\n(`title`, String)\n(`budget`, Int64)\n(`homepage`, String)\n(`overview`, String)\n(`popularity`, Float64)\n(`release_date`, Date32)\n(`revenue`, Int64)\n(`runtime`, Int64)\n(`movie_status`, String)\n(`tagline`, String)\n(`vote_average`, Float64)\n(`vote_count`, Int64)\n",
            "Table: `movie_company`\nColumns:\n(`movie_id`, Int64)\n(`company_id`, Int64)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 46,
        "database_name": "movies_4",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T1.movie_id) FROM movie AS T1 INNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id INNER JOIN genre AS T3 ON T2.genre_id = T3.genre_id WHERE T3.genre_name = 'Adventure' AND CAST(STRFTIME('%Y', T1.release_date) AS INT) = 2000",
        "target_query": "SELECT COUNT(`T1`.`movie_id`) FROM `movie` AS `T1` INNER JOIN `movie_genres` AS `T2` ON `T1`.`movie_id` = `T2`.`movie_id` INNER JOIN `genre` AS `T3` ON `T2`.`genre_id` = `T3`.`genre_id` WHERE `T3`.`genre_name` = 'Adventure' AND formatDateTime(`T1`.`release_date`, '%Y') = '2000';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 197,
                "end_index": 228,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 228,
                "end_index": 269,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `movie`\nColumns:\n(`movie_id`, integer, primary key)\n(`title`, text)\n(`budget`, integer)\n(`homepage`, text)\n(`overview`, text)\n(`popularity`, real)\n(`release_date`, date)\n(`revenue`, integer)\n(`runtime`, integer)\n(`movie_status`, text)\n(`tagline`, text)\n(`vote_average`, real)\n(`vote_count`, integer)\n",
            "Table: `movie_genres`\nColumns:\n(`movie_id`, integer)\n(`genre_id`, integer)\n(`rowid`, integer, primary key)\n",
            "Table: `genre`\nColumns:\n(`genre_id`, integer, primary key)\n(`genre_name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `movie`\nColumns:\n(`movie_id`, Int64, primary key)\n(`title`, String)\n(`budget`, Int64)\n(`homepage`, String)\n(`overview`, String)\n(`popularity`, Float64)\n(`release_date`, Date32)\n(`revenue`, Int64)\n(`runtime`, Int64)\n(`movie_status`, String)\n(`tagline`, String)\n(`vote_average`, Float64)\n(`vote_count`, Int64)\n",
            "Table: `movie_genres`\nColumns:\n(`movie_id`, Int64)\n(`genre_id`, Int64)\n(`rowid`, Int64, primary key)\n",
            "Table: `genre`\nColumns:\n(`genre_id`, Int64, primary key)\n(`genre_name`, String)\n"
        ]
    },
    {
        "sql_id": 47,
        "database_name": "movies_4",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T3.title FROM production_company AS T1 INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id INNER JOIN movie AS T3 ON T2.movie_id = T3.movie_id WHERE T1.company_name = 'Paramount Pictures' AND CAST(STRFTIME('%Y', T3.release_date) AS INT) = 2000",
        "target_query": "SELECT `T3`.`title` FROM `production_company` AS `T1` INNER JOIN `movie_company` AS `T2` ON `T1`.`company_id` = `T2`.`company_id` INNER JOIN `movie` AS `T3` ON `T2`.`movie_id` = `T3`.`movie_id` WHERE `T1`.`company_name` = 'Paramount Pictures' AND formatDateTime(`T3`.`release_date`, '%Y') = '2000';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 216,
                "end_index": 247,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 247,
                "end_index": 288,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `production_company`\nColumns:\n(`company_id`, integer, primary key)\n(`company_name`, text)\n",
            "Table: `movie_company`\nColumns:\n(`movie_id`, integer)\n(`company_id`, integer)\n(`rowid`, integer, primary key)\n",
            "Table: `movie`\nColumns:\n(`movie_id`, integer, primary key)\n(`title`, text)\n(`budget`, integer)\n(`homepage`, text)\n(`overview`, text)\n(`popularity`, real)\n(`release_date`, date)\n(`revenue`, integer)\n(`runtime`, integer)\n(`movie_status`, text)\n(`tagline`, text)\n(`vote_average`, real)\n(`vote_count`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `production_company`\nColumns:\n(`company_id`, Int64, primary key)\n(`company_name`, String)\n",
            "Table: `movie_company`\nColumns:\n(`movie_id`, Int64)\n(`company_id`, Int64)\n(`rowid`, Int64, primary key)\n",
            "Table: `movie`\nColumns:\n(`movie_id`, Int64, primary key)\n(`title`, String)\n(`budget`, Int64)\n(`homepage`, String)\n(`overview`, String)\n(`popularity`, Float64)\n(`release_date`, Date32)\n(`revenue`, Int64)\n(`runtime`, Int64)\n(`movie_status`, String)\n(`tagline`, String)\n(`vote_average`, Float64)\n(`vote_count`, Int64)\n"
        ]
    },
    {
        "sql_id": 647,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T1.customer_id) FROM customer AS T1 INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id WHERE T1.first_name = 'RUTH' AND T1.last_name = 'MARTINEZ' AND STRFTIME('%m',T2.return_date) = '8' AND STRFTIME('%Y', T2.return_date) = '2005'",
        "target_query": "SELECT COUNT(`T1`.`customer_id`) FROM `customer` AS `T1` INNER JOIN `rental` AS `T2` ON `T1`.`customer_id` = `T2`.`customer_id` WHERE `T1`.`first_name` = 'RUTH' AND `T1`.`last_name` = 'MARTINEZ' AND formatDateTime(`T2`.`return_date`, '%m') = '8' AND formatDateTime(`T2`.`return_date`, '%Y') = '2005';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 171,
                "end_index": 200,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 211,
                "end_index": 241,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 199,
                "end_index": 239,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            },
            {
                "start_index": 250,
                "end_index": 290,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`store_id`, integer)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n(`address_id`, integer)\n(`active`, integer)\n(`create_date`, datetime)\n(`last_update`, datetime)\n",
            "Table: `rental`\nColumns:\n(`rental_id`, integer, primary key)\n(`rental_date`, datetime)\n(`inventory_id`, integer)\n(`customer_id`, integer)\n(`return_date`, datetime)\n(`staff_id`, integer)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, Int64, primary key)\n(`store_id`, Int64)\n(`first_name`, String)\n(`last_name`, String)\n(`email`, String)\n(`address_id`, Int64)\n(`active`, Int64)\n(`create_date`, DateTime)\n(`last_update`, DateTime)\n",
            "Table: `rental`\nColumns:\n(`rental_id`, Int64, primary key)\n(`rental_date`, DateTime)\n(`inventory_id`, Int64)\n(`customer_id`, Int64)\n(`return_date`, DateTime)\n(`staff_id`, Int64)\n(`last_update`, DateTime)\n"
        ]
    },
    {
        "sql_id": 648,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T3.name = 'Music', 1, 0)) AS REAL) * 100 / COUNT(T1.film_id) FROM film AS T1 INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id INNER JOIN inventory AS T4 ON T1.film_id = T4.film_id INNER JOIN customer AS T5 ON T4.store_id = T5.store_id INNER JOIN rental AS T6 ON T4.inventory_id = T6.inventory_id WHERE T5.first_name = 'RUTH' AND T5.last_name = 'MARTINEZ'",
        "target_query": "SELECT SUM(if(`T3`.`name` = 'Music', 1, 0)) * 100 / COUNT(`T1`.`film_id`) FROM `film` AS `T1` INNER JOIN `film_category` AS `T2` ON `T1`.`film_id` = `T2`.`film_id` INNER JOIN `category` AS `T3` ON `T2`.`category_id` = `T3`.`category_id` INNER JOIN `inventory` AS `T4` ON `T1`.`film_id` = `T4`.`film_id` INNER JOIN `customer` AS `T5` ON `T4`.`store_id` = `T5`.`store_id` INNER JOIN `rental` AS `T6` ON `T4`.`inventory_id` = `T6`.`inventory_id` WHERE `T5`.`first_name` = 'RUTH' AND `T5`.`last_name` = 'MARTINEZ';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 44,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 42,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `film`\nColumns:\n(`film_id`, integer, primary key)\n(`title`, text)\n(`description`, text)\n(`release_year`, text)\n(`language_id`, integer)\n(`original_language_id`, integer)\n(`rental_duration`, integer)\n(`rental_rate`, real)\n(`length`, integer)\n(`replacement_cost`, real)\n(`rating`, text)\n(`special_features`, text)\n(`last_update`, datetime)\n",
            "Table: `film_category`\nColumns:\n(`film_id`, integer, primary key)\n(`category_id`, integer, primary key)\n(`last_update`, datetime)\n",
            "Table: `category`\nColumns:\n(`category_id`, integer, primary key)\n(`name`, text)\n(`last_update`, datetime)\n",
            "Table: `inventory`\nColumns:\n(`inventory_id`, integer, primary key)\n(`film_id`, integer)\n(`store_id`, integer)\n(`last_update`, datetime)\n",
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`store_id`, integer)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n(`address_id`, integer)\n(`active`, integer)\n(`create_date`, datetime)\n(`last_update`, datetime)\n",
            "Table: `rental`\nColumns:\n(`rental_id`, integer, primary key)\n(`rental_date`, datetime)\n(`inventory_id`, integer)\n(`customer_id`, integer)\n(`return_date`, datetime)\n(`staff_id`, integer)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `film`\nColumns:\n(`film_id`, Int64, primary key)\n(`title`, String)\n(`description`, String)\n(`release_year`, String)\n(`language_id`, Int64)\n(`original_language_id`, Int64)\n(`rental_duration`, Int64)\n(`rental_rate`, Float64)\n(`length`, Int64)\n(`replacement_cost`, Float64)\n(`rating`, String)\n(`special_features`, String)\n(`last_update`, DateTime)\n",
            "Table: `film_category`\nColumns:\n(`film_id`, Int64, primary key)\n(`category_id`, Int64, primary key)\n(`last_update`, DateTime)\n",
            "Table: `category`\nColumns:\n(`category_id`, Int64, primary key)\n(`name`, String)\n(`last_update`, DateTime)\n",
            "Table: `inventory`\nColumns:\n(`inventory_id`, Int64, primary key)\n(`film_id`, Int64)\n(`store_id`, Int64)\n(`last_update`, DateTime)\n",
            "Table: `customer`\nColumns:\n(`customer_id`, Int64, primary key)\n(`store_id`, Int64)\n(`first_name`, String)\n(`last_name`, String)\n(`email`, String)\n(`address_id`, Int64)\n(`active`, Int64)\n(`create_date`, DateTime)\n(`last_update`, DateTime)\n",
            "Table: `rental`\nColumns:\n(`rental_id`, Int64, primary key)\n(`rental_date`, DateTime)\n(`inventory_id`, Int64)\n(`customer_id`, Int64)\n(`return_date`, DateTime)\n(`staff_id`, Int64)\n(`last_update`, DateTime)\n"
        ]
    },
    {
        "sql_id": 649,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST((SUM(IIF(T2.store_id = 2, T1.amount, 0)) - SUM(IIF(T2.store_id = 1, T1.amount, 0))) AS REAL) * 100 / SUM(IIF(T2.store_id = 1, T1.amount, 0)) FROM payment AS T1 INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id INNER JOIN store AS T3 ON T2.store_id = T3.store_id",
        "target_query": "SELECT toFloat64((SUM(if(T2.store_id = 2, T1.amount, 0)) - SUM(if(T2.store_id = 1, T1.amount, 0))) * 100 / SUM(if(T2.store_id = 1, T1.amount, 0))) \nFROM `payment` AS T1 \nINNER JOIN `customer` AS T2 ON T1.customer_id = T2.customer_id \nINNER JOIN `store` AS T3 ON T2.store_id = T3.store_id;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 17,
                "end_index": 51,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 59,
                "end_index": 93,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 117,
                "end_index": 151,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 22,
                "end_index": 55,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 63,
                "end_index": 96,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 111,
                "end_index": 144,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `payment`\nColumns:\n(`payment_id`, integer, primary key)\n(`customer_id`, integer)\n(`staff_id`, integer)\n(`rental_id`, integer)\n(`amount`, real)\n(`payment_date`, datetime)\n(`last_update`, datetime)\n",
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`store_id`, integer)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n(`address_id`, integer)\n(`active`, integer)\n(`create_date`, datetime)\n(`last_update`, datetime)\n",
            "Table: `store`\nColumns:\n(`store_id`, integer, primary key)\n(`manager_staff_id`, integer)\n(`address_id`, integer)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `payment`\nColumns:\n(`payment_id`, Int64, primary key)\n(`customer_id`, Int64)\n(`staff_id`, Int64)\n(`rental_id`, Int64)\n(`amount`, Float64)\n(`payment_date`, DateTime)\n(`last_update`, DateTime)\n",
            "Table: `customer`\nColumns:\n(`customer_id`, Int64, primary key)\n(`store_id`, Int64)\n(`first_name`, String)\n(`last_name`, String)\n(`email`, String)\n(`address_id`, Int64)\n(`active`, Int64)\n(`create_date`, DateTime)\n(`last_update`, DateTime)\n",
            "Table: `store`\nColumns:\n(`store_id`, Int64, primary key)\n(`manager_staff_id`, Int64)\n(`address_id`, Int64)\n(`last_update`, DateTime)\n"
        ]
    },
    {
        "sql_id": 650,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T1.country = 'India', 1, 0)) AS REAL) / SUM(IIF(T1.country = 'Italy', 1, 0)) FROM country AS T1 INNER JOIN city AS T2 ON T1.country_id = T2.country_id",
        "target_query": "SELECT CAST(SUM(if(`T1`.`country` = 'India', 1, 0)) AS Float64) / SUM(if(`T1`.`country` = 'Italy', 1, 0)) FROM `country` AS `T1` INNER JOIN `city` AS `T2` ON `T1`.`country_id` = `T2`.`country_id`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 47,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 64,
                "end_index": 95,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 50,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 70,
                "end_index": 104,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `country`\nColumns:\n(`country_id`, integer, primary key)\n(`country`, text)\n(`last_update`, datetime)\n",
            "Table: `city`\nColumns:\n(`city_id`, integer, primary key)\n(`city`, text)\n(`country_id`, integer)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `country`\nColumns:\n(`country_id`, Int64, primary key)\n(`country`, String)\n(`last_update`, DateTime)\n",
            "Table: `city`\nColumns:\n(`city_id`, Int64, primary key)\n(`city`, String)\n(`country_id`, Int64)\n(`last_update`, DateTime)\n"
        ]
    },
    {
        "sql_id": 651,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T2.first_name = 'GINA' AND T2.last_name = 'DEGENERES', 1, 0)) AS REAL) * 100 / SUM(IIF(T2.first_name = 'PENELOPE' AND T2.last_name = 'GUINESS', 1, 0)) FROM film_actor AS T1 INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id",
        "target_query": "SELECT toFloat64(SUM(if(`T2`.`first_name` = 'GINA' AND `T2`.`last_name` = 'DEGENERES', 1, 0))) * 100 / SUM(if(`T2`.`first_name` = 'PENELOPE' AND `T2`.`last_name` = 'GUINESS', 1, 0)) FROM `film_actor` AS `T1` INNER JOIN `actor` AS `T2` ON `T1`.`actor_id` = `T2`.`actor_id`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 80,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 103,
                "end_index": 169,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 92,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 107,
                "end_index": 180,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `film_actor`\nColumns:\n(`actor_id`, integer, primary key)\n(`film_id`, integer, primary key)\n(`last_update`, datetime)\n",
            "Table: `actor`\nColumns:\n(`actor_id`, integer, primary key)\n(`first_name`, text)\n(`last_name`, text)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `film_actor`\nColumns:\n(`actor_id`, Int64, primary key)\n(`film_id`, Int64, primary key)\n(`last_update`, DateTime)\n",
            "Table: `actor`\nColumns:\n(`actor_id`, Int64, primary key)\n(`first_name`, String)\n(`last_name`, String)\n(`last_update`, DateTime)\n"
        ]
    },
    {
        "sql_id": 652,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(customer_id) FROM payment WHERE SUBSTR(payment_date, 1, 7) LIKE '2005-08'",
        "target_query": "SELECT COUNT(`customer_id`) FROM `payment` WHERE formatDateTime(`payment_date`, '%Y-%m') LIKE '2005-08';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 45,
                "end_index": 71,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `payment`\nColumns:\n(`payment_id`, integer, primary key)\n(`customer_id`, integer)\n(`staff_id`, integer)\n(`rental_id`, integer)\n(`amount`, real)\n(`payment_date`, datetime)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `payment`\nColumns:\n(`payment_id`, Int64, primary key)\n(`customer_id`, Int64)\n(`staff_id`, Int64)\n(`rental_id`, Int64)\n(`amount`, Float64)\n(`payment_date`, DateTime)\n(`last_update`, DateTime)\n"
        ]
    },
    {
        "sql_id": 654,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(DISTINCT rental_id) FROM rental WHERE date(rental_date) BETWEEN '2005-05-26' AND '2005-05-30'",
        "target_query": "SELECT COUNT(DISTINCT `rental_id`) FROM `rental` WHERE toDate(`rental_date`) BETWEEN '2005-05-26' AND '2005-05-30';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 51,
                "end_index": 68,
                "dialect_content": "The date(time-value, modifier, modifier, ...) function returns the date as text in the format: YYYY-MM-DD. The function accepts a time-value and zero or more modifiers to alter the date.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day', 'start of month').\nReturns: A string in the format YYYY-MM-DD.",
                "feature": "date(time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 55,
                "end_index": 76,
                "dialect_content": "The `toDate` function in ClickHouse converts a given time value into a date in the 'YYYY-MM-DD' format. It accepts a time value (e.g., 'now', '2024-08-21') and can handle various time-value expressions. Modifiers such as '+1 day' can be applied to modify the date before conversion.",
                "feature": "toDate(time_value)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "date(time-value, modifier, modifier, ...)",
                "explanation": "The date(time-value, modifier, modifier, ...) function returns the date as text in the format: YYYY-MM-DD. The function accepts a time-value and zero or more modifiers to alter the date.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day', 'start of month').\nReturns: A string in the format YYYY-MM-DD.",
                "examples": [
                    "SELECT date(); -- Returns the current date.",
                    "SELECT date('now', '+1 day'); -- Returns the date one day after the current date.",
                    "SELECT date('2024-08-21'); -- Returns '2024-08-21'."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "toDate(time_value)",
                "explanation": "The `toDate` function in ClickHouse converts a given time value into a date in the 'YYYY-MM-DD' format. It accepts a time value (e.g., 'now', '2024-08-21') and can handle various time-value expressions. Modifiers such as '+1 day' can be applied to modify the date before conversion.",
                "examples": [
                    "SELECT toDate(now()); -- Returns the current date in 'YYYY-MM-DD' format.",
                    "SELECT toDate(now() + INTERVAL 1 DAY); -- Returns the date one day after the current date.",
                    "SELECT toDate('2024-08-21'); -- Returns '2024-08-21'."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `rental`\nColumns:\n(`rental_id`, integer, primary key)\n(`rental_date`, datetime)\n(`inventory_id`, integer)\n(`customer_id`, integer)\n(`return_date`, datetime)\n(`staff_id`, integer)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `rental`\nColumns:\n(`rental_id`, Int64, primary key)\n(`rental_date`, DateTime)\n(`inventory_id`, Int64)\n(`customer_id`, Int64)\n(`return_date`, DateTime)\n(`staff_id`, Int64)\n(`last_update`, DateTime)\n"
        ]
    },
    {
        "sql_id": 655,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(active = 0, 1, 0)) AS REAL) * 100 / COUNT(customer_id) FROM customer",
        "target_query": "SELECT toFloat64(SUM(if(`active` = 0, 1, 0))) * 100 / COUNT(`customer_id`) FROM `customer`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 37,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 43,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`store_id`, integer)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n(`address_id`, integer)\n(`active`, integer)\n(`create_date`, datetime)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, Int64, primary key)\n(`store_id`, Int64)\n(`first_name`, String)\n(`last_name`, String)\n(`email`, String)\n(`address_id`, Int64)\n(`active`, Int64)\n(`create_date`, DateTime)\n(`last_update`, DateTime)\n"
        ]
    },
    {
        "sql_id": 656,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(amount) FROM payment WHERE SUBSTR(payment_date, 1, 7) = '2005-08'",
        "target_query": "SELECT SUM(`amount`) FROM `payment` WHERE formatDateTime(`payment_date`, '%Y-%m') = '2005-08';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 38,
                "end_index": 64,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `payment`\nColumns:\n(`payment_id`, integer, primary key)\n(`customer_id`, integer)\n(`staff_id`, integer)\n(`rental_id`, integer)\n(`amount`, real)\n(`payment_date`, datetime)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `payment`\nColumns:\n(`payment_id`, Int64, primary key)\n(`customer_id`, Int64)\n(`staff_id`, Int64)\n(`rental_id`, Int64)\n(`amount`, Float64)\n(`payment_date`, DateTime)\n(`last_update`, DateTime)\n"
        ]
    },
    {
        "sql_id": 657,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.title FROM film AS T1 INNER JOIN inventory AS T2 ON T1.film_id = T2.film_id INNER JOIN rental AS T3 ON T2.inventory_id = T3.inventory_id WHERE SUBSTR(T3.rental_date, 1, 10) = '2005-05-24'",
        "target_query": "SELECT `T1`.`title` \nFROM `film` AS `T1` \nINNER JOIN `inventory` AS `T2` ON `T1`.`film_id` = `T2`.`film_id` \nINNER JOIN `rental` AS `T3` ON `T2`.`inventory_id` = `T3`.`inventory_id` \nWHERE substring(formatDateTime(`T3`.`rental_date`, '%Y-%m-%d'), 1, 10) = '2005-05-24';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 153,
                "end_index": 182,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 189,
                "end_index": 245,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `film`\nColumns:\n(`film_id`, integer, primary key)\n(`title`, text)\n(`description`, text)\n(`release_year`, text)\n(`language_id`, integer)\n(`original_language_id`, integer)\n(`rental_duration`, integer)\n(`rental_rate`, real)\n(`length`, integer)\n(`replacement_cost`, real)\n(`rating`, text)\n(`special_features`, text)\n(`last_update`, datetime)\n",
            "Table: `inventory`\nColumns:\n(`inventory_id`, integer, primary key)\n(`film_id`, integer)\n(`store_id`, integer)\n(`last_update`, datetime)\n",
            "Table: `rental`\nColumns:\n(`rental_id`, integer, primary key)\n(`rental_date`, datetime)\n(`inventory_id`, integer)\n(`customer_id`, integer)\n(`return_date`, datetime)\n(`staff_id`, integer)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `film`\nColumns:\n(`film_id`, Int64, primary key)\n(`title`, String)\n(`description`, String)\n(`release_year`, String)\n(`language_id`, Int64)\n(`original_language_id`, Int64)\n(`rental_duration`, Int64)\n(`rental_rate`, Float64)\n(`length`, Int64)\n(`replacement_cost`, Float64)\n(`rating`, String)\n(`special_features`, String)\n(`last_update`, DateTime)\n",
            "Table: `inventory`\nColumns:\n(`inventory_id`, Int64, primary key)\n(`film_id`, Int64)\n(`store_id`, Int64)\n(`last_update`, DateTime)\n",
            "Table: `rental`\nColumns:\n(`rental_id`, Int64, primary key)\n(`rental_date`, DateTime)\n(`inventory_id`, Int64)\n(`customer_id`, Int64)\n(`return_date`, DateTime)\n(`staff_id`, Int64)\n(`last_update`, DateTime)\n"
        ]
    },
    {
        "sql_id": 658,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T4.title FROM customer AS T1 INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id INNER JOIN inventory AS T3 ON T2.inventory_id = T3.inventory_id INNER JOIN film AS T4 ON T3.film_id = T4.film_id WHERE T1.first_name = 'BRIAN' AND T1.last_name = 'WYMAN' AND STRFTIME('%Y', T2.rental_date) = '2005' AND STRFTIME('%m',T2.rental_date) = '7'",
        "target_query": "SELECT `T4`.`title` FROM `customer` AS `T1` INNER JOIN `rental` AS `T2` ON `T1`.`customer_id` = `T2`.`customer_id` INNER JOIN `inventory` AS `T3` ON `T2`.`inventory_id` = `T3`.`inventory_id` INNER JOIN `film` AS `T4` ON `T3`.`film_id` = `T4`.`film_id` WHERE `T1`.`first_name` = 'BRIAN' AND `T1`.`last_name` = 'WYMAN' AND formatDateTime(`T2`.`rental_date`, '%Y') = '2005' AND formatDateTime(`T2`.`rental_date`, '%m') = '7';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 269,
                "end_index": 299,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 313,
                "end_index": 342,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 321,
                "end_index": 361,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            },
            {
                "start_index": 375,
                "end_index": 415,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`store_id`, integer)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n(`address_id`, integer)\n(`active`, integer)\n(`create_date`, datetime)\n(`last_update`, datetime)\n",
            "Table: `rental`\nColumns:\n(`rental_id`, integer, primary key)\n(`rental_date`, datetime)\n(`inventory_id`, integer)\n(`customer_id`, integer)\n(`return_date`, datetime)\n(`staff_id`, integer)\n(`last_update`, datetime)\n",
            "Table: `inventory`\nColumns:\n(`inventory_id`, integer, primary key)\n(`film_id`, integer)\n(`store_id`, integer)\n(`last_update`, datetime)\n",
            "Table: `film`\nColumns:\n(`film_id`, integer, primary key)\n(`title`, text)\n(`description`, text)\n(`release_year`, text)\n(`language_id`, integer)\n(`original_language_id`, integer)\n(`rental_duration`, integer)\n(`rental_rate`, real)\n(`length`, integer)\n(`replacement_cost`, real)\n(`rating`, text)\n(`special_features`, text)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, Int64, primary key)\n(`store_id`, Int64)\n(`first_name`, String)\n(`last_name`, String)\n(`email`, String)\n(`address_id`, Int64)\n(`active`, Int64)\n(`create_date`, DateTime)\n(`last_update`, DateTime)\n",
            "Table: `rental`\nColumns:\n(`rental_id`, Int64, primary key)\n(`rental_date`, DateTime)\n(`inventory_id`, Int64)\n(`customer_id`, Int64)\n(`return_date`, DateTime)\n(`staff_id`, Int64)\n(`last_update`, DateTime)\n",
            "Table: `inventory`\nColumns:\n(`inventory_id`, Int64, primary key)\n(`film_id`, Int64)\n(`store_id`, Int64)\n(`last_update`, DateTime)\n",
            "Table: `film`\nColumns:\n(`film_id`, Int64, primary key)\n(`title`, String)\n(`description`, String)\n(`release_year`, String)\n(`language_id`, Int64)\n(`original_language_id`, Int64)\n(`rental_duration`, Int64)\n(`rental_rate`, Float64)\n(`length`, Int64)\n(`replacement_cost`, Float64)\n(`rating`, String)\n(`special_features`, String)\n(`last_update`, DateTime)\n"
        ]
    },
    {
        "sql_id": 659,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T3.title, T2.name FROM film_category AS T1 INNER JOIN category AS T2 ON T1.category_id = T2.category_id INNER JOIN film AS T3 ON T1.film_id = T3.film_id INNER JOIN inventory AS T4 ON T3.film_id = T4.film_id INNER JOIN customer AS T5 ON T4.store_id = T5.store_id INNER JOIN rental AS T6 ON T4.inventory_id = T6.inventory_id WHERE T5.first_name = 'Natalie' AND T5.last_name = 'Meyer' AND STRFTIME('%Y',T3.rental_rate) = '2006' AND STRFTIME('%m',T3.rental_rate) = '2'",
        "target_query": "SELECT T3.`title`, T2.`name` \nFROM `film_category` AS T1 \nINNER JOIN `category` AS T2 ON T1.`category_id` = T2.`category_id` \nINNER JOIN `film` AS T3 ON T1.`film_id` = T3.`film_id` \nINNER JOIN `inventory` AS T4 ON T3.`film_id` = T4.`film_id` \nINNER JOIN `customer` AS T5 ON T4.`store_id` = T5.`store_id` \nINNER JOIN `rental` AS T6 ON T4.`inventory_id` = T6.`inventory_id` \nWHERE T5.`first_name` = 'Natalie' \nAND T5.`last_name` = 'Meyer' \nAND formatDateTime(T6.`rental_date`, '%Y') = '2006' \nAND formatDateTime(T6.`rental_date`, '%m') = '02';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 393,
                "end_index": 422,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 436,
                "end_index": 465,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 442,
                "end_index": 480,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            },
            {
                "start_index": 495,
                "end_index": 533,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `film_category`\nColumns:\n(`film_id`, integer, primary key)\n(`category_id`, integer, primary key)\n(`last_update`, datetime)\n",
            "Table: `category`\nColumns:\n(`category_id`, integer, primary key)\n(`name`, text)\n(`last_update`, datetime)\n",
            "Table: `film`\nColumns:\n(`film_id`, integer, primary key)\n(`title`, text)\n(`description`, text)\n(`release_year`, text)\n(`language_id`, integer)\n(`original_language_id`, integer)\n(`rental_duration`, integer)\n(`rental_rate`, real)\n(`length`, integer)\n(`replacement_cost`, real)\n(`rating`, text)\n(`special_features`, text)\n(`last_update`, datetime)\n",
            "Table: `inventory`\nColumns:\n(`inventory_id`, integer, primary key)\n(`film_id`, integer)\n(`store_id`, integer)\n(`last_update`, datetime)\n",
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`store_id`, integer)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n(`address_id`, integer)\n(`active`, integer)\n(`create_date`, datetime)\n(`last_update`, datetime)\n",
            "Table: `rental`\nColumns:\n(`rental_id`, integer, primary key)\n(`rental_date`, datetime)\n(`inventory_id`, integer)\n(`customer_id`, integer)\n(`return_date`, datetime)\n(`staff_id`, integer)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `film_category`\nColumns:\n(`film_id`, Int64, primary key)\n(`category_id`, Int64, primary key)\n(`last_update`, DateTime)\n",
            "Table: `category`\nColumns:\n(`category_id`, Int64, primary key)\n(`name`, String)\n(`last_update`, DateTime)\n",
            "Table: `film`\nColumns:\n(`film_id`, Int64, primary key)\n(`title`, String)\n(`description`, String)\n(`release_year`, String)\n(`language_id`, Int64)\n(`original_language_id`, Int64)\n(`rental_duration`, Int64)\n(`rental_rate`, Float64)\n(`length`, Int64)\n(`replacement_cost`, Float64)\n(`rating`, String)\n(`special_features`, String)\n(`last_update`, DateTime)\n",
            "Table: `inventory`\nColumns:\n(`inventory_id`, Int64, primary key)\n(`film_id`, Int64)\n(`store_id`, Int64)\n(`last_update`, DateTime)\n",
            "Table: `customer`\nColumns:\n(`customer_id`, Int64, primary key)\n(`store_id`, Int64)\n(`first_name`, String)\n(`last_name`, String)\n(`email`, String)\n(`address_id`, Int64)\n(`active`, Int64)\n(`create_date`, DateTime)\n(`last_update`, DateTime)\n",
            "Table: `rental`\nColumns:\n(`rental_id`, Int64, primary key)\n(`rental_date`, DateTime)\n(`inventory_id`, Int64)\n(`customer_id`, Int64)\n(`return_date`, DateTime)\n(`staff_id`, Int64)\n(`last_update`, DateTime)\n"
        ]
    },
    {
        "sql_id": 660,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T1.country = 'India', 1, 0)) AS REAL) * 100 / COUNT(T4.customer_id) FROM country AS T1 INNER JOIN city AS T2 ON T1.country_id = T2.country_id INNER JOIN address AS T3 ON T2.city_id = T3.city_id INNER JOIN customer AS T4 ON T3.address_id = T4.address_id",
        "target_query": "SELECT toFloat64(SUM(if(`T1`.`country` = 'India', 1, 0))) * 100 / COUNT(`T4`.`customer_id`) \nFROM `country` AS `T1` \nINNER JOIN `city` AS `T2` ON `T1`.`country_id` = `T2`.`country_id` \nINNER JOIN `address` AS `T3` ON `T2`.`city_id` = `T3`.`city_id` \nINNER JOIN `customer` AS `T4` ON `T3`.`address_id` = `T4`.`address_id`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 47,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 55,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `country`\nColumns:\n(`country_id`, integer, primary key)\n(`country`, text)\n(`last_update`, datetime)\n",
            "Table: `city`\nColumns:\n(`city_id`, integer, primary key)\n(`city`, text)\n(`country_id`, integer)\n(`last_update`, datetime)\n",
            "Table: `address`\nColumns:\n(`address_id`, integer, primary key)\n(`address`, text)\n(`address2`, text)\n(`district`, text)\n(`city_id`, integer)\n(`postal_code`, text)\n(`phone`, text)\n(`last_update`, datetime)\n",
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`store_id`, integer)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n(`address_id`, integer)\n(`active`, integer)\n(`create_date`, datetime)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `country`\nColumns:\n(`country_id`, Int64, primary key)\n(`country`, String)\n(`last_update`, DateTime)\n",
            "Table: `city`\nColumns:\n(`city_id`, Int64, primary key)\n(`city`, String)\n(`country_id`, Int64)\n(`last_update`, DateTime)\n",
            "Table: `address`\nColumns:\n(`address_id`, Int64, primary key)\n(`address`, String)\n(`address2`, String)\n(`district`, String)\n(`city_id`, Int64)\n(`postal_code`, String)\n(`phone`, String)\n(`last_update`, DateTime)\n",
            "Table: `customer`\nColumns:\n(`customer_id`, Int64, primary key)\n(`store_id`, Int64)\n(`first_name`, String)\n(`last_name`, String)\n(`email`, String)\n(`address_id`, Int64)\n(`active`, Int64)\n(`create_date`, DateTime)\n(`last_update`, DateTime)\n"
        ]
    },
    {
        "sql_id": 663,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT first_name, last_name, email FROM customer WHERE STRFTIME('%Y',create_date) = '2006' AND active = 0",
        "target_query": "SELECT `first_name`, `last_name`, `email` FROM `customer` WHERE formatDateTime(`create_date`, '%Y') = '2006' AND `active` = 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 56,
                "end_index": 82,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 64,
                "end_index": 99,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`store_id`, integer)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n(`address_id`, integer)\n(`active`, integer)\n(`create_date`, datetime)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, Int64, primary key)\n(`store_id`, Int64)\n(`first_name`, String)\n(`last_name`, String)\n(`email`, String)\n(`address_id`, Int64)\n(`active`, Int64)\n(`create_date`, DateTime)\n(`last_update`, DateTime)\n"
        ]
    },
    {
        "sql_id": 664,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(rating = 'PG-13', 1, 0)) AS REAL) * 100 / COUNT(film_id) FROM film",
        "target_query": "SELECT SUM(if(`rating` = 'PG-13', 1, 0)) * 100 / COUNT(`film_id`) FROM `film`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 43,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 39,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `film`\nColumns:\n(`film_id`, integer, primary key)\n(`title`, text)\n(`description`, text)\n(`release_year`, text)\n(`language_id`, integer)\n(`original_language_id`, integer)\n(`rental_duration`, integer)\n(`rental_rate`, real)\n(`length`, integer)\n(`replacement_cost`, real)\n(`rating`, text)\n(`special_features`, text)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `film`\nColumns:\n(`film_id`, Int64, primary key)\n(`title`, String)\n(`description`, String)\n(`release_year`, String)\n(`language_id`, Int64)\n(`original_language_id`, Int64)\n(`rental_duration`, Int64)\n(`rental_rate`, Float64)\n(`length`, Int64)\n(`replacement_cost`, Float64)\n(`rating`, String)\n(`special_features`, String)\n(`last_update`, DateTime)\n"
        ]
    },
    {
        "sql_id": 665,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T2.name = 'horror', 1, 0)) AS REAL) * 100 / COUNT(T2.category_id) FROM film_category AS T1 INNER JOIN category AS T2 ON T1.category_id = T2.category_id",
        "target_query": "SELECT toFloat64(SUM(if(T2.name = 'horror', 1, 0))) * 100 / COUNT(T2.category_id) FROM `film_category` AS T1 INNER JOIN `category` AS T2 ON T1.category_id = T2.category_id;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 45,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 49,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `film_category`\nColumns:\n(`film_id`, integer, primary key)\n(`category_id`, integer, primary key)\n(`last_update`, datetime)\n",
            "Table: `category`\nColumns:\n(`category_id`, integer, primary key)\n(`name`, text)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `film_category`\nColumns:\n(`film_id`, Int64, primary key)\n(`category_id`, Int64, primary key)\n(`last_update`, DateTime)\n",
            "Table: `category`\nColumns:\n(`category_id`, Int64, primary key)\n(`name`, String)\n(`last_update`, DateTime)\n"
        ]
    },
    {
        "sql_id": 666,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT AVG(IIF(T4.country = 'Australia', 1, 0)) - AVG(IIF(T4.country = 'Canada', 1, 0)) AS diff FROM customer AS T1 INNER JOIN address AS T2 ON T1.address_id = T2.address_id INNER JOIN city AS T3 ON T2.city_id = T3.city_id INNER JOIN country AS T4 ON T3.country_id = T4.country_id",
        "target_query": "SELECT AVG(if(`T4`.`country` = 'Australia', 1, 0)) - AVG(if(`T4`.`country` = 'Canada', 1, 0)) AS `diff` FROM `customer` AS `T1` INNER JOIN `address` AS `T2` ON `T1`.`address_id` = `T2`.`address_id` INNER JOIN `city` AS `T3` ON `T2`.`city_id` = `T3`.`city_id` INNER JOIN `country` AS `T4` ON `T3`.`country_id` = `T4`.`country_id`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 46,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 54,
                "end_index": 86,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 49,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 57,
                "end_index": 92,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`store_id`, integer)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n(`address_id`, integer)\n(`active`, integer)\n(`create_date`, datetime)\n(`last_update`, datetime)\n",
            "Table: `address`\nColumns:\n(`address_id`, integer, primary key)\n(`address`, text)\n(`address2`, text)\n(`district`, text)\n(`city_id`, integer)\n(`postal_code`, text)\n(`phone`, text)\n(`last_update`, datetime)\n",
            "Table: `city`\nColumns:\n(`city_id`, integer, primary key)\n(`city`, text)\n(`country_id`, integer)\n(`last_update`, datetime)\n",
            "Table: `country`\nColumns:\n(`country_id`, integer, primary key)\n(`country`, text)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, Int64, primary key)\n(`store_id`, Int64)\n(`first_name`, String)\n(`last_name`, String)\n(`email`, String)\n(`address_id`, Int64)\n(`active`, Int64)\n(`create_date`, DateTime)\n(`last_update`, DateTime)\n",
            "Table: `address`\nColumns:\n(`address_id`, Int64, primary key)\n(`address`, String)\n(`address2`, String)\n(`district`, String)\n(`city_id`, Int64)\n(`postal_code`, String)\n(`phone`, String)\n(`last_update`, DateTime)\n",
            "Table: `city`\nColumns:\n(`city_id`, Int64, primary key)\n(`city`, String)\n(`country_id`, Int64)\n(`last_update`, DateTime)\n",
            "Table: `country`\nColumns:\n(`country_id`, Int64, primary key)\n(`country`, String)\n(`last_update`, DateTime)\n"
        ]
    },
    {
        "sql_id": 670,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T1.rental_id) FROM rental AS T1 INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id WHERE T2.first_name = 'ELLA' AND T2.last_name = 'ELLA' AND date(T1.rental_date) BETWEEN '2005-06-01' AND '2005-06-30'",
        "target_query": "SELECT COUNT(`T1`.`rental_id`) FROM `rental` AS `T1` INNER JOIN `customer` AS `T2` ON `T1`.`customer_id` = `T2`.`customer_id` WHERE `T2`.`first_name` = 'ELLA' AND `T2`.`last_name` = 'ELLA' AND toDate(`T1`.`rental_date`) BETWEEN '2005-06-01' AND '2005-06-30';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 165,
                "end_index": 185,
                "dialect_content": "The date(time-value, modifier, modifier, ...) function returns the date as text in the format: YYYY-MM-DD. The function accepts a time-value and zero or more modifiers to alter the date.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day', 'start of month').\nReturns: A string in the format YYYY-MM-DD.",
                "feature": "date(time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 193,
                "end_index": 219,
                "dialect_content": "The `toDate` function in ClickHouse converts a given time value into a date in the 'YYYY-MM-DD' format. It accepts a time value (e.g., 'now', '2024-08-21') and can handle various time-value expressions. Modifiers such as '+1 day' can be applied to modify the date before conversion.",
                "feature": "toDate(time_value)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "date(time-value, modifier, modifier, ...)",
                "explanation": "The date(time-value, modifier, modifier, ...) function returns the date as text in the format: YYYY-MM-DD. The function accepts a time-value and zero or more modifiers to alter the date.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day', 'start of month').\nReturns: A string in the format YYYY-MM-DD.",
                "examples": [
                    "SELECT date(); -- Returns the current date.",
                    "SELECT date('now', '+1 day'); -- Returns the date one day after the current date.",
                    "SELECT date('2024-08-21'); -- Returns '2024-08-21'."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "toDate(time_value)",
                "explanation": "The `toDate` function in ClickHouse converts a given time value into a date in the 'YYYY-MM-DD' format. It accepts a time value (e.g., 'now', '2024-08-21') and can handle various time-value expressions. Modifiers such as '+1 day' can be applied to modify the date before conversion.",
                "examples": [
                    "SELECT toDate(now()); -- Returns the current date in 'YYYY-MM-DD' format.",
                    "SELECT toDate(now() + INTERVAL 1 DAY); -- Returns the date one day after the current date.",
                    "SELECT toDate('2024-08-21'); -- Returns '2024-08-21'."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `rental`\nColumns:\n(`rental_id`, integer, primary key)\n(`rental_date`, datetime)\n(`inventory_id`, integer)\n(`customer_id`, integer)\n(`return_date`, datetime)\n(`staff_id`, integer)\n(`last_update`, datetime)\n",
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`store_id`, integer)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n(`address_id`, integer)\n(`active`, integer)\n(`create_date`, datetime)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `rental`\nColumns:\n(`rental_id`, Int64, primary key)\n(`rental_date`, DateTime)\n(`inventory_id`, Int64)\n(`customer_id`, Int64)\n(`return_date`, DateTime)\n(`staff_id`, Int64)\n(`last_update`, DateTime)\n",
            "Table: `customer`\nColumns:\n(`customer_id`, Int64, primary key)\n(`store_id`, Int64)\n(`first_name`, String)\n(`last_name`, String)\n(`email`, String)\n(`address_id`, Int64)\n(`active`, Int64)\n(`create_date`, DateTime)\n(`last_update`, DateTime)\n"
        ]
    },
    {
        "sql_id": 671,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(T2.amount) FROM rental AS T1 INNER JOIN payment AS T2 ON T1.rental_id = T2.rental_id WHERE date(T1.rental_date) = '2005-07-29%'",
        "target_query": "SELECT SUM(T2.`amount`) FROM `rental` AS T1 INNER JOIN `payment` AS T2 ON T1.`rental_id` = T2.`rental_id` WHERE toDate(T1.`rental_date`) = '2005-07-29';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 102,
                "end_index": 122,
                "dialect_content": "The date(time-value, modifier, modifier, ...) function returns the date as text in the format: YYYY-MM-DD. The function accepts a time-value and zero or more modifiers to alter the date.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day', 'start of month').\nReturns: A string in the format YYYY-MM-DD.",
                "feature": "date(time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 112,
                "end_index": 136,
                "dialect_content": "The `toDate` function in ClickHouse converts a given time value into a date in the 'YYYY-MM-DD' format. It accepts a time value (e.g., 'now', '2024-08-21') and can handle various time-value expressions. Modifiers such as '+1 day' can be applied to modify the date before conversion.",
                "feature": "toDate(time_value)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "date(time-value, modifier, modifier, ...)",
                "explanation": "The date(time-value, modifier, modifier, ...) function returns the date as text in the format: YYYY-MM-DD. The function accepts a time-value and zero or more modifiers to alter the date.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day', 'start of month').\nReturns: A string in the format YYYY-MM-DD.",
                "examples": [
                    "SELECT date(); -- Returns the current date.",
                    "SELECT date('now', '+1 day'); -- Returns the date one day after the current date.",
                    "SELECT date('2024-08-21'); -- Returns '2024-08-21'."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "toDate(time_value)",
                "explanation": "The `toDate` function in ClickHouse converts a given time value into a date in the 'YYYY-MM-DD' format. It accepts a time value (e.g., 'now', '2024-08-21') and can handle various time-value expressions. Modifiers such as '+1 day' can be applied to modify the date before conversion.",
                "examples": [
                    "SELECT toDate(now()); -- Returns the current date in 'YYYY-MM-DD' format.",
                    "SELECT toDate(now() + INTERVAL 1 DAY); -- Returns the date one day after the current date.",
                    "SELECT toDate('2024-08-21'); -- Returns '2024-08-21'."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `rental`\nColumns:\n(`rental_id`, integer, primary key)\n(`rental_date`, datetime)\n(`inventory_id`, integer)\n(`customer_id`, integer)\n(`return_date`, datetime)\n(`staff_id`, integer)\n(`last_update`, datetime)\n",
            "Table: `payment`\nColumns:\n(`payment_id`, integer, primary key)\n(`customer_id`, integer)\n(`staff_id`, integer)\n(`rental_id`, integer)\n(`amount`, real)\n(`payment_date`, datetime)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `rental`\nColumns:\n(`rental_id`, Int64, primary key)\n(`rental_date`, DateTime)\n(`inventory_id`, Int64)\n(`customer_id`, Int64)\n(`return_date`, DateTime)\n(`staff_id`, Int64)\n(`last_update`, DateTime)\n",
            "Table: `payment`\nColumns:\n(`payment_id`, Int64, primary key)\n(`customer_id`, Int64)\n(`staff_id`, Int64)\n(`rental_id`, Int64)\n(`amount`, Float64)\n(`payment_date`, DateTime)\n(`last_update`, DateTime)\n"
        ]
    },
    {
        "sql_id": 672,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.first_name FROM customer AS T1 INNER JOIN address AS T2 ON T1.address_id = T2.address_id WHERE SUBSTR(T2.postal_code, 1, 2) = '76'",
        "target_query": "SELECT `T1`.`first_name` FROM `customer` AS `T1` INNER JOIN `address` AS `T2` ON `T1`.`address_id` = `T2`.`address_id` WHERE substring(`T2`.`postal_code`, 1, 2) = '76';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 105,
                "end_index": 133,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 125,
                "end_index": 160,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`store_id`, integer)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n(`address_id`, integer)\n(`active`, integer)\n(`create_date`, datetime)\n(`last_update`, datetime)\n",
            "Table: `address`\nColumns:\n(`address_id`, integer, primary key)\n(`address`, text)\n(`address2`, text)\n(`district`, text)\n(`city_id`, integer)\n(`postal_code`, text)\n(`phone`, text)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, Int64, primary key)\n(`store_id`, Int64)\n(`first_name`, String)\n(`last_name`, String)\n(`email`, String)\n(`address_id`, Int64)\n(`active`, Int64)\n(`create_date`, DateTime)\n(`last_update`, DateTime)\n",
            "Table: `address`\nColumns:\n(`address_id`, Int64, primary key)\n(`address`, String)\n(`address2`, String)\n(`district`, String)\n(`city_id`, Int64)\n(`postal_code`, String)\n(`phone`, String)\n(`last_update`, DateTime)\n"
        ]
    },
    {
        "sql_id": 673,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T2.length < 100 AND T3.name = 'Drama', 1, 0)) AS REAL) * 100 / COUNT(T1.film_id) FROM film_category AS T1 INNER JOIN film AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T1.category_id = T3.category_id",
        "target_query": "SELECT CAST(SUM(if(T2.length < 100 AND T3.name = 'Drama', 1, 0)) AS Float64) * 100 / COUNT(T1.film_id) FROM `film_category` AS T1 INNER JOIN `film` AS T2 ON T1.film_id = T2.film_id INNER JOIN `category` AS T3 ON T1.category_id = T3.category_id;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 64,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 63,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `film_category`\nColumns:\n(`film_id`, integer, primary key)\n(`category_id`, integer, primary key)\n(`last_update`, datetime)\n",
            "Table: `film`\nColumns:\n(`film_id`, integer, primary key)\n(`title`, text)\n(`description`, text)\n(`release_year`, text)\n(`language_id`, integer)\n(`original_language_id`, integer)\n(`rental_duration`, integer)\n(`rental_rate`, real)\n(`length`, integer)\n(`replacement_cost`, real)\n(`rating`, text)\n(`special_features`, text)\n(`last_update`, datetime)\n",
            "Table: `category`\nColumns:\n(`category_id`, integer, primary key)\n(`name`, text)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `film_category`\nColumns:\n(`film_id`, Int64, primary key)\n(`category_id`, Int64, primary key)\n(`last_update`, DateTime)\n",
            "Table: `film`\nColumns:\n(`film_id`, Int64, primary key)\n(`title`, String)\n(`description`, String)\n(`release_year`, String)\n(`language_id`, Int64)\n(`original_language_id`, Int64)\n(`rental_duration`, Int64)\n(`rental_rate`, Float64)\n(`length`, Int64)\n(`replacement_cost`, Float64)\n(`rating`, String)\n(`special_features`, String)\n(`last_update`, DateTime)\n",
            "Table: `category`\nColumns:\n(`category_id`, Int64, primary key)\n(`name`, String)\n(`last_update`, DateTime)\n"
        ]
    },
    {
        "sql_id": 674,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(T2.name = 'Children', 1, 0)) - SUM(IIF(T2.name = 'Action', 1, 0)) AS diff FROM film_category AS T1 INNER JOIN category AS T2 ON T1.category_id = T2.category_id",
        "target_query": "SELECT SUM(if(`T2`.`name` = 'Children', 1, 0)) - SUM(if(`T2`.`name` = 'Action', 1, 0)) AS `diff` FROM `film_category` AS `T1` INNER JOIN `category` AS `T2` ON `T1`.`category_id` = `T2`.`category_id`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 42,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 50,
                "end_index": 79,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 45,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 53,
                "end_index": 85,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `film_category`\nColumns:\n(`film_id`, integer, primary key)\n(`category_id`, integer, primary key)\n(`last_update`, datetime)\n",
            "Table: `category`\nColumns:\n(`category_id`, integer, primary key)\n(`name`, text)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `film_category`\nColumns:\n(`film_id`, Int64, primary key)\n(`category_id`, Int64, primary key)\n(`last_update`, DateTime)\n",
            "Table: `category`\nColumns:\n(`category_id`, Int64, primary key)\n(`name`, String)\n(`last_update`, DateTime)\n"
        ]
    },
    {
        "sql_id": 675,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T2.name = 'Documentary', 1, 0)) AS REAL) * 100 / COUNT(T1.film_id) FROM film_category AS T1 INNER JOIN category AS T2 ON T1.category_id = T2.category_id",
        "target_query": "SELECT SUM(if(T2.`name` = 'Documentary', 1, 0)) * 100 / COUNT(T1.`film_id`) FROM `film_category` AS T1 INNER JOIN `category` AS T2 ON T1.`category_id` = T2.`category_id`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 50,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 46,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `film_category`\nColumns:\n(`film_id`, integer, primary key)\n(`category_id`, integer, primary key)\n(`last_update`, datetime)\n",
            "Table: `category`\nColumns:\n(`category_id`, integer, primary key)\n(`name`, text)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `film_category`\nColumns:\n(`film_id`, Int64, primary key)\n(`category_id`, Int64, primary key)\n(`last_update`, DateTime)\n",
            "Table: `category`\nColumns:\n(`category_id`, Int64, primary key)\n(`name`, String)\n(`last_update`, DateTime)\n"
        ]
    },
    {
        "sql_id": 676,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T2.name = 'Horror', 1, 0)) AS REAL) * 100 / COUNT(T1.film_id) FROM film_category AS T1 INNER JOIN category AS T2 ON T1.category_id = T2.category_id INNER JOIN film AS T3 ON T1.film_id = T3.film_id",
        "target_query": "SELECT toFloat64(SUM(if(`T2`.`name` = 'Horror', 1, 0))) * 100 / COUNT(`T1`.`film_id`) FROM `film_category` AS `T1` INNER JOIN `category` AS `T2` ON `T1`.`category_id` = `T2`.`category_id` INNER JOIN `film` AS `T3` ON `T1`.`film_id` = `T3`.`film_id`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 45,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 53,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `film_category`\nColumns:\n(`film_id`, integer, primary key)\n(`category_id`, integer, primary key)\n(`last_update`, datetime)\n",
            "Table: `category`\nColumns:\n(`category_id`, integer, primary key)\n(`name`, text)\n(`last_update`, datetime)\n",
            "Table: `film`\nColumns:\n(`film_id`, integer, primary key)\n(`title`, text)\n(`description`, text)\n(`release_year`, text)\n(`language_id`, integer)\n(`original_language_id`, integer)\n(`rental_duration`, integer)\n(`rental_rate`, real)\n(`length`, integer)\n(`replacement_cost`, real)\n(`rating`, text)\n(`special_features`, text)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `film_category`\nColumns:\n(`film_id`, Int64, primary key)\n(`category_id`, Int64, primary key)\n(`last_update`, DateTime)\n",
            "Table: `category`\nColumns:\n(`category_id`, Int64, primary key)\n(`name`, String)\n(`last_update`, DateTime)\n",
            "Table: `film`\nColumns:\n(`film_id`, Int64, primary key)\n(`title`, String)\n(`description`, String)\n(`release_year`, String)\n(`language_id`, Int64)\n(`original_language_id`, Int64)\n(`rental_duration`, Int64)\n(`rental_rate`, Float64)\n(`length`, Int64)\n(`replacement_cost`, Float64)\n(`rating`, String)\n(`special_features`, String)\n(`last_update`, DateTime)\n"
        ]
    },
    {
        "sql_id": 677,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T2.first_name = 'MARGARET' AND T2.last_name = 'MOORE', T1.amount, 0)) AS REAL) * 100 / SUM(T1.amount) FROM payment AS T1 INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id",
        "target_query": "SELECT CAST(SUM(if(T2.first_name = 'MARGARET' AND T2.last_name = 'MOORE', T1.amount, 0)) AS Float64) * 100 / SUM(T1.amount) FROM `payment` AS T1 INNER JOIN `customer` AS T2 ON T1.customer_id = T2.customer_id;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 88,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 87,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `payment`\nColumns:\n(`payment_id`, integer, primary key)\n(`customer_id`, integer)\n(`staff_id`, integer)\n(`rental_id`, integer)\n(`amount`, real)\n(`payment_date`, datetime)\n(`last_update`, datetime)\n",
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`store_id`, integer)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n(`address_id`, integer)\n(`active`, integer)\n(`create_date`, datetime)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `payment`\nColumns:\n(`payment_id`, Int64, primary key)\n(`customer_id`, Int64)\n(`staff_id`, Int64)\n(`rental_id`, Int64)\n(`amount`, Float64)\n(`payment_date`, DateTime)\n(`last_update`, DateTime)\n",
            "Table: `customer`\nColumns:\n(`customer_id`, Int64, primary key)\n(`store_id`, Int64)\n(`first_name`, String)\n(`last_name`, String)\n(`email`, String)\n(`address_id`, Int64)\n(`active`, Int64)\n(`create_date`, DateTime)\n(`last_update`, DateTime)\n"
        ]
    },
    {
        "sql_id": 679,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T3.name = 'Horror', 1, 0)) AS REAL) * 100 / COUNT(T1.film_id) FROM film_category AS T1 INNER JOIN film AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T1.category_id = T3.category_id INNER JOIN language AS T4 ON T2.language_id = T4.language_id WHERE T4.name = 'English'",
        "target_query": "SELECT SUM(if(`T3`.`name` = 'Horror', 1, 0)) * 100 / COUNT(`T1`.`film_id`) FROM `film_category` AS `T1` INNER JOIN `film` AS `T2` ON `T1`.`film_id` = `T2`.`film_id` INNER JOIN `category` AS `T3` ON `T1`.`category_id` = `T3`.`category_id` INNER JOIN `language` AS `T4` ON `T2`.`language_id` = `T4`.`language_id` WHERE `T4`.`name` = 'English';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 45,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 43,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `film_category`\nColumns:\n(`film_id`, integer, primary key)\n(`category_id`, integer, primary key)\n(`last_update`, datetime)\n",
            "Table: `film`\nColumns:\n(`film_id`, integer, primary key)\n(`title`, text)\n(`description`, text)\n(`release_year`, text)\n(`language_id`, integer)\n(`original_language_id`, integer)\n(`rental_duration`, integer)\n(`rental_rate`, real)\n(`length`, integer)\n(`replacement_cost`, real)\n(`rating`, text)\n(`special_features`, text)\n(`last_update`, datetime)\n",
            "Table: `category`\nColumns:\n(`category_id`, integer, primary key)\n(`name`, text)\n(`last_update`, datetime)\n",
            "Table: `language`\nColumns:\n(`language_id`, integer, primary key)\n(`name`, text)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `film_category`\nColumns:\n(`film_id`, Int64, primary key)\n(`category_id`, Int64, primary key)\n(`last_update`, DateTime)\n",
            "Table: `film`\nColumns:\n(`film_id`, Int64, primary key)\n(`title`, String)\n(`description`, String)\n(`release_year`, String)\n(`language_id`, Int64)\n(`original_language_id`, Int64)\n(`rental_duration`, Int64)\n(`rental_rate`, Float64)\n(`length`, Int64)\n(`replacement_cost`, Float64)\n(`rating`, String)\n(`special_features`, String)\n(`last_update`, DateTime)\n",
            "Table: `category`\nColumns:\n(`category_id`, Int64, primary key)\n(`name`, String)\n(`last_update`, DateTime)\n",
            "Table: `language`\nColumns:\n(`language_id`, Int64, primary key)\n(`name`, String)\n(`last_update`, DateTime)\n"
        ]
    },
    {
        "sql_id": 683,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T1.customer_id) FROM payment AS T1 INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id WHERE T2.first_name = 'MARY' AND T2.last_name = 'SMITH' AND STRFTIME('%Y',T1.payment_date) = '2005' AND STRFTIME('%Y', T1.payment_date) = '6'",
        "target_query": "SELECT COUNT(`T1`.`customer_id`) FROM `payment` AS `T1` INNER JOIN `customer` AS `T2` ON `T1`.`customer_id` = `T2`.`customer_id` WHERE `T2`.`first_name` = 'MARY' AND `T2`.`last_name` = 'SMITH' AND formatDateTime(`T1`.`payment_date`, '%Y') = '2005' AND formatDateTime(`T1`.`payment_date`, '%Y') = '6';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 169,
                "end_index": 199,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 213,
                "end_index": 244,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 197,
                "end_index": 238,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            },
            {
                "start_index": 252,
                "end_index": 293,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `payment`\nColumns:\n(`payment_id`, integer, primary key)\n(`customer_id`, integer)\n(`staff_id`, integer)\n(`rental_id`, integer)\n(`amount`, real)\n(`payment_date`, datetime)\n(`last_update`, datetime)\n",
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`store_id`, integer)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n(`address_id`, integer)\n(`active`, integer)\n(`create_date`, datetime)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `payment`\nColumns:\n(`payment_id`, Int64, primary key)\n(`customer_id`, Int64)\n(`staff_id`, Int64)\n(`rental_id`, Int64)\n(`amount`, Float64)\n(`payment_date`, DateTime)\n(`last_update`, DateTime)\n",
            "Table: `customer`\nColumns:\n(`customer_id`, Int64, primary key)\n(`store_id`, Int64)\n(`first_name`, String)\n(`last_name`, String)\n(`email`, String)\n(`address_id`, Int64)\n(`active`, Int64)\n(`create_date`, DateTime)\n(`last_update`, DateTime)\n"
        ]
    },
    {
        "sql_id": 668,
        "database_name": "movie_3",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT IIF(SUM(IIF(T5.name = 'Family', 1, 0)) - SUM(IIF(T5.name = 'Sci-Fi', 1, 0)) > 0, T1.first_name, 0) FROM customer AS T1 INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id INNER JOIN inventory AS T3 ON T2.inventory_id = T3.inventory_id INNER JOIN film_category AS T4 ON T4.film_id = T3.film_id INNER JOIN category AS T5 ON T4.category_id = T5.category_id GROUP BY T1.customer_id",
        "target_query": "SELECT if(SUM(if(`T5`.`name` = 'Family', 1, 0)) - SUM(if(`T5`.`name` = 'Sci-Fi', 1, 0)) > 0, `T1`.`first_name`, toString(0)) FROM `customer` AS `T1` INNER JOIN `rental` AS `T2` ON `T1`.`customer_id` = `T2`.`customer_id` INNER JOIN `inventory` AS `T3` ON `T2`.`inventory_id` = `T3`.`inventory_id` INNER JOIN `film_category` AS `T4` ON `T4`.`film_id` = `T3`.`film_id` INNER JOIN `category` AS `T5` ON `T4`.`category_id` = `T5`.`category_id` GROUP BY `T1`.`customer_id`, `T1`.`first_name`;",
        "semantic_equivalent_type": "Approximate equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 53,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 61,
                "end_index": 90,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 46,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 54,
                "end_index": 86,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, integer, primary key)\n(`store_id`, integer)\n(`first_name`, text)\n(`last_name`, text)\n(`email`, text)\n(`address_id`, integer)\n(`active`, integer)\n(`create_date`, datetime)\n(`last_update`, datetime)\n",
            "Table: `rental`\nColumns:\n(`rental_id`, integer, primary key)\n(`rental_date`, datetime)\n(`inventory_id`, integer)\n(`customer_id`, integer)\n(`return_date`, datetime)\n(`staff_id`, integer)\n(`last_update`, datetime)\n",
            "Table: `inventory`\nColumns:\n(`inventory_id`, integer, primary key)\n(`film_id`, integer)\n(`store_id`, integer)\n(`last_update`, datetime)\n",
            "Table: `film_category`\nColumns:\n(`film_id`, integer, primary key)\n(`category_id`, integer, primary key)\n(`last_update`, datetime)\n",
            "Table: `category`\nColumns:\n(`category_id`, integer, primary key)\n(`name`, text)\n(`last_update`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `customer`\nColumns:\n(`customer_id`, Int64, primary key)\n(`store_id`, Int64)\n(`first_name`, String)\n(`last_name`, String)\n(`email`, String)\n(`address_id`, Int64)\n(`active`, Int64)\n(`create_date`, DateTime)\n(`last_update`, DateTime)\n",
            "Table: `rental`\nColumns:\n(`rental_id`, Int64, primary key)\n(`rental_date`, DateTime)\n(`inventory_id`, Int64)\n(`customer_id`, Int64)\n(`return_date`, DateTime)\n(`staff_id`, Int64)\n(`last_update`, DateTime)\n",
            "Table: `inventory`\nColumns:\n(`inventory_id`, Int64, primary key)\n(`film_id`, Int64)\n(`store_id`, Int64)\n(`last_update`, DateTime)\n",
            "Table: `film_category`\nColumns:\n(`film_id`, Int64, primary key)\n(`category_id`, Int64, primary key)\n(`last_update`, DateTime)\n",
            "Table: `category`\nColumns:\n(`category_id`, Int64, primary key)\n(`name`, String)\n(`last_update`, DateTime)\n"
        ]
    },
    {
        "sql_id": 2,
        "database_name": "movie_platform",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.movie_title FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE CAST(SUBSTR(T1.rating_timestamp_utc, 1, 4) AS INTEGER) = 2020 AND CAST(SUBSTR(T1.rating_timestamp_utc, 6, 2) AS INTEGER) > 4",
        "target_query": "SELECT `T2`.`movie_title` FROM `ratings` AS `T1` INNER JOIN `movies` AS `T2` ON `T1`.`movie_id` = `T2`.`movie_id` WHERE CAST(substring(`T1`.`rating_timestamp_utc`, 1, 4) AS Int64) = 2020 AND CAST(substring(`T1`.`rating_timestamp_utc`, 6, 2) AS Int64) > 4;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 105,
                "end_index": 142,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 171,
                "end_index": 208,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 125,
                "end_index": 169,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            },
            {
                "start_index": 196,
                "end_index": 240,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `ratings`\nColumns:\n(`movie_id`, integer)\n(`rating_id`, integer)\n(`rating_url`, text)\n(`rating_score`, integer)\n(`rating_timestamp_utc`, text)\n(`critic`, text)\n(`critic_likes`, integer)\n(`critic_comments`, integer)\n(`user_id`, integer)\n(`user_trialist`, integer)\n(`user_subscriber`, integer)\n(`user_eligible_for_trial`, integer)\n(`user_has_payment_method`, integer)\n(`rowid`, integer, primary key)\n",
            "Table: `movies`\nColumns:\n(`movie_id`, integer, primary key)\n(`movie_title`, text)\n(`movie_release_year`, integer)\n(`movie_url`, text)\n(`movie_title_language`, text)\n(`movie_popularity`, integer)\n(`movie_image_url`, text)\n(`director_id`, text)\n(`director_name`, text)\n(`director_url`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `ratings`\nColumns:\n(`movie_id`, Int64)\n(`rating_id`, Int64)\n(`rating_url`, String)\n(`rating_score`, Int64)\n(`rating_timestamp_utc`, String)\n(`critic`, String)\n(`critic_likes`, Int64)\n(`critic_comments`, Int64)\n(`user_id`, Int64)\n(`user_trialist`, Int64)\n(`user_subscriber`, Int64)\n(`user_eligible_for_trial`, Int64)\n(`user_has_payment_method`, Int64)\n(`rowid`, Int64, primary key)\n",
            "Table: `movies`\nColumns:\n(`movie_id`, Int64, primary key)\n(`movie_title`, String)\n(`movie_release_year`, Int64)\n(`movie_url`, String)\n(`movie_title_language`, String)\n(`movie_popularity`, Int64)\n(`movie_image_url`, String)\n(`director_id`, String)\n(`director_name`, String)\n(`director_url`, String)\n"
        ]
    },
    {
        "sql_id": 563,
        "database_name": "music_platform_2",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.title FROM categories AS T1 INNER JOIN podcasts AS T2 ON T2.podcast_id = T1.podcast_id WHERE T1.category = 'music' ORDER BY LENGTH(T2.title) DESC LIMIT 1",
        "target_query": "SELECT T2.`title` FROM `categories` AS T1 INNER JOIN `podcasts` AS T2 ON T2.`podcast_id` = T1.`podcast_id` WHERE T1.`category` = 'music' ORDER BY length(T2.`title`) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 134,
                "end_index": 150,
                "dialect_content": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "feature": "length(X)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 146,
                "end_index": 164,
                "dialect_content": "The length(str) function returns the number of bytes in the given string str. Unlike SQLite, which counts Unicode code points for strings, ClickHouse measures the length in bytes. For multibyte characters (UTF-8 encoded), the byte count may be larger than the character count. If str is NULL, the function returns NULL.",
                "feature": "length(str)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "length(str)",
                "explanation": "The length(str) function returns the number of bytes in the given string str. Unlike SQLite, which counts Unicode code points for strings, ClickHouse measures the length in bytes. For multibyte characters (UTF-8 encoded), the byte count may be larger than the character count. If str is NULL, the function returns NULL.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(unhex('68656C6C6F')); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `categories`\nColumns:\n(`podcast_id`, text, primary key)\n(`category`, text, primary key)\n",
            "Table: `podcasts`\nColumns:\n(`podcast_id`, text, primary key)\n(`itunes_id`, integer)\n(`slug`, text)\n(`itunes_url`, text)\n(`title`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `categories`\nColumns:\n(`podcast_id`, String, primary key)\n(`category`, String, primary key)\n",
            "Table: `podcasts`\nColumns:\n(`podcast_id`, String, primary key)\n(`itunes_id`, Int64)\n(`slug`, String)\n(`itunes_url`, String)\n(`title`, String)\n"
        ]
    },
    {
        "sql_id": 235,
        "database_name": "professional_basketball",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.firstName, T1.middleName, T1.lastName , 2003 - strftime('%Y', T1.birthDate) FROM awards_players AS T2 JOIN players AS T1 ON T2.playerID = T1.playerID WHERE T2.award = 'Finals MVP' AND T2.year = 2003",
        "target_query": "SELECT T1.`firstName`, T1.`middleName`, T1.`lastName`, 2003 - toInt32(formatDateTime(T1.`birthDate`, '%Y')) FROM `awards_players` AS T2 JOIN `players` AS T1 ON T2.`playerID` = T1.`playerID` WHERE T2.`award` = 'Finals MVP' AND T2.`year` = 2003;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 57,
                "end_index": 85,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 70,
                "end_index": 106,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `awards_players`\nColumns:\n(`playerID`, text, primary key)\n(`award`, text, primary key)\n(`year`, integer, primary key)\n(`lgID`, text)\n(`note`, text)\n(`pos`, text)\n",
            "Table: `players`\nColumns:\n(`playerID`, text, primary key)\n(`useFirst`, text)\n(`firstName`, text)\n(`middleName`, text)\n(`lastName`, text)\n(`nameGiven`, text)\n(`fullGivenName`, text)\n(`nameSuffix`, text)\n(`nameNick`, text)\n(`pos`, text)\n(`firstseason`, integer)\n(`lastseason`, integer)\n(`height`, real)\n(`weight`, integer)\n(`college`, text)\n(`collegeOther`, text)\n(`birthDate`, date)\n(`birthCity`, text)\n(`birthState`, text)\n(`birthCountry`, text)\n(`highSchool`, text)\n(`hsCity`, text)\n(`hsState`, text)\n(`hsCountry`, text)\n(`deathDate`, date)\n(`race`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `awards_players`\nColumns:\n(`playerID`, String, primary key)\n(`award`, String, primary key)\n(`year`, Int64, primary key)\n(`lgID`, String)\n(`note`, String)\n(`pos`, String)\n",
            "Table: `players`\nColumns:\n(`playerID`, String, primary key)\n(`useFirst`, String)\n(`firstName`, String)\n(`middleName`, String)\n(`lastName`, String)\n(`nameGiven`, String)\n(`fullGivenName`, String)\n(`nameSuffix`, String)\n(`nameNick`, String)\n(`pos`, String)\n(`firstseason`, Int64)\n(`lastseason`, Int64)\n(`height`, Float64)\n(`weight`, Int64)\n(`college`, String)\n(`collegeOther`, String)\n(`birthDate`, Date32)\n(`birthCity`, String)\n(`birthState`, String)\n(`birthCountry`, String)\n(`highSchool`, String)\n(`hsCity`, String)\n(`hsState`, String)\n(`hsCountry`, String)\n(`deathDate`, Date32)\n(`race`, String)\n"
        ]
    },
    {
        "sql_id": 237,
        "database_name": "professional_basketball",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T2.steals IS NOT NULL AND T1.tmID = 'LAL', 1, 0)) AS REAL) * 100 / COUNT(T1.tmID) FROM teams AS T1 INNER JOIN players_teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year",
        "target_query": "SELECT CAST(SUM(if(T2.steals IS NOT NULL AND T1.tmID = 'LAL', 1, 0)) AS Float64) * 100 / COUNT(T1.tmID) FROM `teams` AS T1 INNER JOIN `players_teams` AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 68,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 67,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `teams`\nColumns:\n(`year`, integer, primary key)\n(`lgID`, text)\n(`tmID`, text, primary key)\n(`franchID`, text)\n(`confID`, text)\n(`divID`, text)\n(`rank`, integer)\n(`confRank`, integer)\n(`playoff`, text)\n(`name`, text)\n(`o_fgm`, integer)\n(`o_ftm`, integer)\n(`o_pts`, integer)\n(`d_pts`, integer)\n(`homeWon`, integer)\n(`homeLost`, integer)\n(`awayWon`, integer)\n(`awayLost`, integer)\n(`won`, integer)\n(`lost`, integer)\n(`games`, integer)\n(`arena`, text)\n",
            "Table: `players_teams`\nColumns:\n(`id`, integer, primary key)\n(`playerID`, text)\n(`year`, integer)\n(`stint`, integer)\n(`tmID`, text)\n(`lgID`, text)\n(`GP`, integer)\n(`GS`, integer)\n(`minutes`, integer)\n(`points`, integer)\n(`oRebounds`, integer)\n(`dRebounds`, integer)\n(`rebounds`, integer)\n(`assists`, integer)\n(`steals`, integer)\n(`blocks`, integer)\n(`turnovers`, integer)\n(`PF`, integer)\n(`fgAttempted`, integer)\n(`fgMade`, integer)\n(`ftAttempted`, integer)\n(`ftMade`, integer)\n(`threeAttempted`, integer)\n(`threeMade`, integer)\n(`PostGP`, integer)\n(`PostGS`, integer)\n(`PostMinutes`, integer)\n(`PostPoints`, integer)\n(`PostoRebounds`, integer)\n(`PostdRebounds`, integer)\n(`PostRebounds`, integer)\n(`PostAssists`, integer)\n(`PostSteals`, integer)\n(`PostBlocks`, integer)\n(`PostTurnovers`, integer)\n(`PostPF`, integer)\n(`PostfgAttempted`, integer)\n(`PostfgMade`, integer)\n(`PostftAttempted`, integer)\n(`PostftMade`, integer)\n(`PostthreeAttempted`, integer)\n(`PostthreeMade`, integer)\n(`note`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `teams`\nColumns:\n(`year`, Int64, primary key)\n(`lgID`, String)\n(`tmID`, String, primary key)\n(`franchID`, String)\n(`confID`, String)\n(`divID`, String)\n(`rank`, Int64)\n(`confRank`, Int64)\n(`playoff`, String)\n(`name`, String)\n(`o_fgm`, Int64)\n(`o_ftm`, Int64)\n(`o_pts`, Int64)\n(`d_pts`, Int64)\n(`homeWon`, Int64)\n(`homeLost`, Int64)\n(`awayWon`, Int64)\n(`awayLost`, Int64)\n(`won`, Int64)\n(`lost`, Int64)\n(`games`, Int64)\n(`arena`, String)\n",
            "Table: `players_teams`\nColumns:\n(`id`, Int64, primary key)\n(`playerID`, String)\n(`year`, Int64)\n(`stint`, Int64)\n(`tmID`, String)\n(`lgID`, String)\n(`GP`, Int64)\n(`GS`, Int64)\n(`minutes`, Int64)\n(`points`, Int64)\n(`oRebounds`, Int64)\n(`dRebounds`, Int64)\n(`rebounds`, Int64)\n(`assists`, Int64)\n(`steals`, Int64)\n(`blocks`, Int64)\n(`turnovers`, Int64)\n(`PF`, Int64)\n(`fgAttempted`, Int64)\n(`fgMade`, Int64)\n(`ftAttempted`, Int64)\n(`ftMade`, Int64)\n(`threeAttempted`, Int64)\n(`threeMade`, Int64)\n(`PostGP`, Int64)\n(`PostGS`, Int64)\n(`PostMinutes`, Int64)\n(`PostPoints`, Int64)\n(`PostoRebounds`, Int64)\n(`PostdRebounds`, Int64)\n(`PostRebounds`, Int64)\n(`PostAssists`, Int64)\n(`PostSteals`, Int64)\n(`PostBlocks`, Int64)\n(`PostTurnovers`, Int64)\n(`PostPF`, Int64)\n(`PostfgAttempted`, Int64)\n(`PostfgMade`, Int64)\n(`PostftAttempted`, Int64)\n(`PostftMade`, Int64)\n(`PostthreeAttempted`, Int64)\n(`PostthreeMade`, Int64)\n(`note`, String)\n"
        ]
    },
    {
        "sql_id": 252,
        "database_name": "public_review_platform",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(review_stars) / (strftime('%Y', 'now') - T1.user_yelping_since_year) FROM Users AS T1 INNER JOIN Reviews AS T2 ON T1.user_id = T2.user_id WHERE T1.user_id = 3",
        "target_query": "SELECT COUNT(`T2`.`review_stars`) / (toInt32(formatDateTime(now(), '%Y')) - `T1`.`user_yelping_since_year`) FROM `Users` AS `T1` INNER JOIN `Reviews` AS `T2` ON `T1`.`user_id` = `T2`.`user_id` WHERE `T1`.`user_id` = 3 GROUP BY `T1`.`user_yelping_since_year`;",
        "semantic_equivalent_type": "Approximate equivalence",
        "source_dialect_locations": [
            {
                "start_index": 30,
                "end_index": 51,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 45,
                "end_index": 65,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Users`\nColumns:\n(`user_id`, integer, primary key)\n(`user_yelping_since_year`, integer)\n(`user_average_stars`, text)\n(`user_votes_funny`, text)\n(`user_votes_useful`, text)\n(`user_votes_cool`, text)\n(`user_review_count`, text)\n(`user_fans`, text)\n",
            "Table: `Reviews`\nColumns:\n(`business_id`, integer, primary key)\n(`user_id`, integer, primary key)\n(`review_stars`, integer)\n(`review_votes_funny`, text)\n(`review_votes_useful`, text)\n(`review_votes_cool`, text)\n(`review_length`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Users`\nColumns:\n(`user_id`, Int64, primary key)\n(`user_yelping_since_year`, Int64)\n(`user_average_stars`, String)\n(`user_votes_funny`, String)\n(`user_votes_useful`, String)\n(`user_votes_cool`, String)\n(`user_review_count`, String)\n(`user_fans`, String)\n",
            "Table: `Reviews`\nColumns:\n(`business_id`, Int64, primary key)\n(`user_id`, Int64, primary key)\n(`review_stars`, Int64)\n(`review_votes_funny`, String)\n(`review_votes_useful`, String)\n(`review_votes_cool`, String)\n(`review_length`, String)\n"
        ]
    },
    {
        "sql_id": 217,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T FROM ( SELECT IIF(`Customer Names` LIKE '%Group%', `Customer Names`, NULL) AS T FROM Customers ) WHERE T IS NOT NULL",
        "target_query": "SELECT T FROM ( SELECT if(`Customer_Names` LIKE '%Group%', `Customer_Names`, NULL) AS T FROM `Customers` ) WHERE T IS NOT NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 23,
                "end_index": 83,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 23,
                "end_index": 82,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Customers`\nColumns:\n(`CustomerID`, integer, primary key)\n(`Customer Names`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Customers`\nColumns:\n(`CustomerID`, Int64, primary key)\n(`Customer_Names`, String)\n"
        ]
    },
    {
        "sql_id": 218,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT T1.`Customer Names` FROM Customers AS T1 INNER JOIN `Sales Orders` AS T2 ON T2._CustomerID = T1.CustomerID INNER JOIN Products AS T3 ON T3.ProductID = T2._ProductID WHERE T3.`Product Name` = 'Cocktail Glasses' AND SUBSTR(T2.OrderDate, -2) = '20' AND T2.`Discount Applied` = ( SELECT T2.`Discount Applied` FROM Customers AS T1 INNER JOIN `Sales Orders` AS T2 ON T2._CustomerID = T1.CustomerID INNER JOIN Products AS T3 ON T3.ProductID = T2._ProductID WHERE T3.`Product Name` = 'Cocktail Glasses' AND T2.OrderDate LIKE '%/%/20' ORDER BY T2.`Discount Applied` DESC LIMIT 1 )",
        "target_query": "SELECT DISTINCT T1.`Customer_Names` FROM `Customers` AS T1 INNER JOIN `Sales_Orders` AS T2 ON T2.`_CustomerID` = T1.`CustomerID` INNER JOIN `Products` AS T3 ON T3.`ProductID` = T2.`_ProductID` WHERE T3.`Product_Name` = 'Cocktail Glasses' AND substring(T2.`OrderDate`, -2) = '20' AND T2.`Discount_Applied` = ( SELECT T2.`Discount_Applied` FROM `Customers` AS T1 INNER JOIN `Sales_Orders` AS T2 ON T2.`_CustomerID` = T1.`CustomerID` INNER JOIN `Products` AS T3 ON T3.`ProductID` = T2.`_ProductID` WHERE T3.`Product_Name` = 'Cocktail Glasses' AND T2.`OrderDate` LIKE '%/%/20' ORDER BY T2.`Discount_Applied` DESC LIMIT 1 );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 230,
                "end_index": 254,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 242,
                "end_index": 271,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Customers`\nColumns:\n(`CustomerID`, integer, primary key)\n(`Customer Names`, text)\n",
            "Table: `Sales Orders`\nColumns:\n(`OrderNumber`, text, primary key)\n(`Sales Channel`, text)\n(`WarehouseCode`, text)\n(`ProcuredDate`, text)\n(`OrderDate`, text)\n(`ShipDate`, text)\n(`DeliveryDate`, text)\n(`CurrencyCode`, text)\n(`_SalesTeamID`, integer)\n(`_CustomerID`, integer)\n(`_StoreID`, integer)\n(`_ProductID`, integer)\n(`Order Quantity`, integer)\n(`Discount Applied`, real)\n(`Unit Price`, text)\n(`Unit Cost`, text)\n",
            "Table: `Products`\nColumns:\n(`ProductID`, integer, primary key)\n(`Product Name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Customers`\nColumns:\n(`CustomerID`, Int64, primary key)\n(`Customer_Names`, String)\n",
            "Table: `Sales_Orders`\nColumns:\n(`OrderNumber`, String, primary key)\n(`Sales_Channel`, String)\n(`WarehouseCode`, String)\n(`ProcuredDate`, String)\n(`OrderDate`, String)\n(`ShipDate`, String)\n(`DeliveryDate`, String)\n(`CurrencyCode`, String)\n(`_SalesTeamID`, Int64)\n(`_CustomerID`, Int64)\n(`_StoreID`, Int64)\n(`_ProductID`, Int64)\n(`Order_Quantity`, Int64)\n(`Discount_Applied`, Float64)\n(`Unit_Price`, String)\n(`Unit_Cost`, String)\n",
            "Table: `Products`\nColumns:\n(`ProductID`, Int64, primary key)\n(`Product_Name`, String)\n"
        ]
    },
    {
        "sql_id": 219,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(OrderDate = '5/31/18', 1, 0)) FROM `Sales Orders`",
        "target_query": "SELECT SUM(if(`OrderDate` = '5/31/18', 1, 0)) FROM `Sales_Orders`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 43,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 44,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales Orders`\nColumns:\n(`OrderNumber`, text, primary key)\n(`Sales Channel`, text)\n(`WarehouseCode`, text)\n(`ProcuredDate`, text)\n(`OrderDate`, text)\n(`ShipDate`, text)\n(`DeliveryDate`, text)\n(`CurrencyCode`, text)\n(`_SalesTeamID`, integer)\n(`_CustomerID`, integer)\n(`_StoreID`, integer)\n(`_ProductID`, integer)\n(`Order Quantity`, integer)\n(`Discount Applied`, real)\n(`Unit Price`, text)\n(`Unit Cost`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Sales_Orders`\nColumns:\n(`OrderNumber`, String, primary key)\n(`Sales_Channel`, String)\n(`WarehouseCode`, String)\n(`ProcuredDate`, String)\n(`OrderDate`, String)\n(`ShipDate`, String)\n(`DeliveryDate`, String)\n(`CurrencyCode`, String)\n(`_SalesTeamID`, Int64)\n(`_CustomerID`, Int64)\n(`_StoreID`, Int64)\n(`_ProductID`, Int64)\n(`Order_Quantity`, Int64)\n(`Discount_Applied`, Float64)\n(`Unit_Price`, String)\n(`Unit_Cost`, String)\n"
        ]
    },
    {
        "sql_id": 220,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT T FROM ( SELECT IIF(DeliveryDate = '6/13/18', OrderNumber, NULL) AS T FROM `Sales Orders` ) WHERE T IS NOT NULL",
        "target_query": "SELECT DISTINCT T FROM ( SELECT if(`DeliveryDate` = '6/13/18', `OrderNumber`, NULL) AS T FROM `Sales_Orders` ) WHERE T IS NOT NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 32,
                "end_index": 80,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 32,
                "end_index": 83,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales Orders`\nColumns:\n(`OrderNumber`, text, primary key)\n(`Sales Channel`, text)\n(`WarehouseCode`, text)\n(`ProcuredDate`, text)\n(`OrderDate`, text)\n(`ShipDate`, text)\n(`DeliveryDate`, text)\n(`CurrencyCode`, text)\n(`_SalesTeamID`, integer)\n(`_CustomerID`, integer)\n(`_StoreID`, integer)\n(`_ProductID`, integer)\n(`Order Quantity`, integer)\n(`Discount Applied`, real)\n(`Unit Price`, text)\n(`Unit Cost`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Sales_Orders`\nColumns:\n(`OrderNumber`, String, primary key)\n(`Sales_Channel`, String)\n(`WarehouseCode`, String)\n(`ProcuredDate`, String)\n(`OrderDate`, String)\n(`ShipDate`, String)\n(`DeliveryDate`, String)\n(`CurrencyCode`, String)\n(`_SalesTeamID`, Int64)\n(`_CustomerID`, Int64)\n(`_StoreID`, Int64)\n(`_ProductID`, Int64)\n(`Order_Quantity`, Int64)\n(`Discount_Applied`, Float64)\n(`Unit_Price`, String)\n(`Unit_Cost`, String)\n"
        ]
    },
    {
        "sql_id": 221,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(`Order Quantity` > 5, 1, 0)) FROM `Sales Orders`",
        "target_query": "SELECT SUM(if(`Order_Quantity` > 5, 1, 0)) FROM `Sales_Orders`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 42,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 41,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales Orders`\nColumns:\n(`OrderNumber`, text, primary key)\n(`Sales Channel`, text)\n(`WarehouseCode`, text)\n(`ProcuredDate`, text)\n(`OrderDate`, text)\n(`ShipDate`, text)\n(`DeliveryDate`, text)\n(`CurrencyCode`, text)\n(`_SalesTeamID`, integer)\n(`_CustomerID`, integer)\n(`_StoreID`, integer)\n(`_ProductID`, integer)\n(`Order Quantity`, integer)\n(`Discount Applied`, real)\n(`Unit Price`, text)\n(`Unit Cost`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Sales_Orders`\nColumns:\n(`OrderNumber`, String, primary key)\n(`Sales_Channel`, String)\n(`WarehouseCode`, String)\n(`ProcuredDate`, String)\n(`OrderDate`, String)\n(`ShipDate`, String)\n(`DeliveryDate`, String)\n(`CurrencyCode`, String)\n(`_SalesTeamID`, Int64)\n(`_CustomerID`, Int64)\n(`_StoreID`, Int64)\n(`_ProductID`, Int64)\n(`Order_Quantity`, Int64)\n(`Discount_Applied`, Float64)\n(`Unit_Price`, String)\n(`Unit_Cost`, String)\n"
        ]
    },
    {
        "sql_id": 222,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T FROM ( SELECT IIF(StateCode = 'GA', State, NULL) AS T FROM Regions ) WHERE T IS NOT NULL",
        "target_query": "SELECT `T` FROM ( SELECT if(`StateCode` = 'GA', `State`, NULL) AS `T` FROM `Regions` ) WHERE `T` IS NOT NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 23,
                "end_index": 57,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 25,
                "end_index": 62,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Regions`\nColumns:\n(`StateCode`, text, primary key)\n(`State`, text)\n(`Region`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Regions`\nColumns:\n(`StateCode`, String, primary key)\n(`State`, String)\n(`Region`, String)\n"
        ]
    },
    {
        "sql_id": 224,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T FROM ( SELECT DISTINCT IIF(T2.`Product Name` = 'Cookware', T1.DeliveryDate, NULL) AS T FROM `Sales Orders` T1 INNER JOIN Products T2 ON T2.ProductID = T1._ProductID ) WHERE T IS NOT NULL",
        "target_query": "SELECT T FROM ( SELECT DISTINCT if(T2.`Product_Name` = 'Cookware', T1.`DeliveryDate`, NULL) AS T FROM `Sales_Orders` T1 INNER JOIN `Products` T2 ON T2.`ProductID` = T1.`_ProductID` ) WHERE T IS NOT NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 32,
                "end_index": 90,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 32,
                "end_index": 91,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales Orders`\nColumns:\n(`OrderNumber`, text, primary key)\n(`Sales Channel`, text)\n(`WarehouseCode`, text)\n(`ProcuredDate`, text)\n(`OrderDate`, text)\n(`ShipDate`, text)\n(`DeliveryDate`, text)\n(`CurrencyCode`, text)\n(`_SalesTeamID`, integer)\n(`_CustomerID`, integer)\n(`_StoreID`, integer)\n(`_ProductID`, integer)\n(`Order Quantity`, integer)\n(`Discount Applied`, real)\n(`Unit Price`, text)\n(`Unit Cost`, text)\n",
            "Table: `Products`\nColumns:\n(`ProductID`, integer, primary key)\n(`Product Name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Sales_Orders`\nColumns:\n(`OrderNumber`, String, primary key)\n(`Sales_Channel`, String)\n(`WarehouseCode`, String)\n(`ProcuredDate`, String)\n(`OrderDate`, String)\n(`ShipDate`, String)\n(`DeliveryDate`, String)\n(`CurrencyCode`, String)\n(`_SalesTeamID`, Int64)\n(`_CustomerID`, Int64)\n(`_StoreID`, Int64)\n(`_ProductID`, Int64)\n(`Order_Quantity`, Int64)\n(`Discount_Applied`, Float64)\n(`Unit_Price`, String)\n(`Unit_Cost`, String)\n",
            "Table: `Products`\nColumns:\n(`ProductID`, Int64, primary key)\n(`Product_Name`, String)\n"
        ]
    },
    {
        "sql_id": 225,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T FROM ( SELECT DISTINCT IIF(T1.`Discount Applied` = 0.1, T2.`Product Name`, NULL) AS T FROM `Sales Orders` T1 INNER JOIN Products T2 ON T2.ProductID = T1._ProductID ) WHERE T IS NOT NULL",
        "target_query": "SELECT T FROM ( SELECT DISTINCT if(T1.`Discount_Applied` = 0.1, T2.`Product_Name`, NULL) AS T FROM `Sales_Orders` T1 INNER JOIN `Products` T2 ON T2.`ProductID` = T1.`_ProductID` ) WHERE T IS NOT NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 32,
                "end_index": 89,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 32,
                "end_index": 88,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales Orders`\nColumns:\n(`OrderNumber`, text, primary key)\n(`Sales Channel`, text)\n(`WarehouseCode`, text)\n(`ProcuredDate`, text)\n(`OrderDate`, text)\n(`ShipDate`, text)\n(`DeliveryDate`, text)\n(`CurrencyCode`, text)\n(`_SalesTeamID`, integer)\n(`_CustomerID`, integer)\n(`_StoreID`, integer)\n(`_ProductID`, integer)\n(`Order Quantity`, integer)\n(`Discount Applied`, real)\n(`Unit Price`, text)\n(`Unit Cost`, text)\n",
            "Table: `Products`\nColumns:\n(`ProductID`, integer, primary key)\n(`Product Name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Sales_Orders`\nColumns:\n(`OrderNumber`, String, primary key)\n(`Sales_Channel`, String)\n(`WarehouseCode`, String)\n(`ProcuredDate`, String)\n(`OrderDate`, String)\n(`ShipDate`, String)\n(`DeliveryDate`, String)\n(`CurrencyCode`, String)\n(`_SalesTeamID`, Int64)\n(`_CustomerID`, Int64)\n(`_StoreID`, Int64)\n(`_ProductID`, Int64)\n(`Order_Quantity`, Int64)\n(`Discount_Applied`, Float64)\n(`Unit_Price`, String)\n(`Unit_Cost`, String)\n",
            "Table: `Products`\nColumns:\n(`ProductID`, Int64, primary key)\n(`Product_Name`, String)\n"
        ]
    },
    {
        "sql_id": 226,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUBSTR(T1.OrderDate, -2, 2) FROM `Sales Orders` AS T1 INNER JOIN `Sales Team` AS T2 ON T2.SalesTeamID = T1._SalesTeamID WHERE T2.`Sales Team` = 'George Lewis' GROUP BY SUBSTR(T1.OrderDate, -2, 2) ORDER BY COUNT(T1.OrderNumber) DESC LIMIT 1",
        "target_query": "SELECT substring(`T1`.`OrderDate`, -2, 2) FROM `Sales_Orders` AS `T1` INNER JOIN `Sales_Team` AS `T2` ON `T2`.`SalesTeamID` = `T1`.`_SalesTeamID` WHERE `T2`.`Sales_Team` = 'George Lewis' GROUP BY substring(`T1`.`OrderDate`, -2, 2) ORDER BY COUNT(`T1`.`OrderNumber`) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 34,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            },
            {
                "start_index": 175,
                "end_index": 202,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 41,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            },
            {
                "start_index": 196,
                "end_index": 230,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales Orders`\nColumns:\n(`OrderNumber`, text, primary key)\n(`Sales Channel`, text)\n(`WarehouseCode`, text)\n(`ProcuredDate`, text)\n(`OrderDate`, text)\n(`ShipDate`, text)\n(`DeliveryDate`, text)\n(`CurrencyCode`, text)\n(`_SalesTeamID`, integer)\n(`_CustomerID`, integer)\n(`_StoreID`, integer)\n(`_ProductID`, integer)\n(`Order Quantity`, integer)\n(`Discount Applied`, real)\n(`Unit Price`, text)\n(`Unit Cost`, text)\n",
            "Table: `Sales Team`\nColumns:\n(`SalesTeamID`, integer, primary key)\n(`Sales Team`, text)\n(`Region`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Sales_Orders`\nColumns:\n(`OrderNumber`, String, primary key)\n(`Sales_Channel`, String)\n(`WarehouseCode`, String)\n(`ProcuredDate`, String)\n(`OrderDate`, String)\n(`ShipDate`, String)\n(`DeliveryDate`, String)\n(`CurrencyCode`, String)\n(`_SalesTeamID`, Int64)\n(`_CustomerID`, Int64)\n(`_StoreID`, Int64)\n(`_ProductID`, Int64)\n(`Order_Quantity`, Int64)\n(`Discount_Applied`, Float64)\n(`Unit_Price`, String)\n(`Unit_Cost`, String)\n",
            "Table: `Sales_Team`\nColumns:\n(`SalesTeamID`, Int64, primary key)\n(`Sales_Team`, String)\n(`Region`, String)\n"
        ]
    },
    {
        "sql_id": 227,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT T FROM ( SELECT IIF(OrderNumber = 'SO - 000103', `Unit Cost`, NULL) AS T FROM `Sales Orders` ) WHERE T IS NOT NULL",
        "target_query": "SELECT DISTINCT T FROM ( SELECT if(`OrderNumber` = 'SO - 000103', `Unit_Cost`, NULL) AS T FROM `Sales_Orders` ) WHERE T IS NOT NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 32,
                "end_index": 83,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 32,
                "end_index": 84,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales Orders`\nColumns:\n(`OrderNumber`, text, primary key)\n(`Sales Channel`, text)\n(`WarehouseCode`, text)\n(`ProcuredDate`, text)\n(`OrderDate`, text)\n(`ShipDate`, text)\n(`DeliveryDate`, text)\n(`CurrencyCode`, text)\n(`_SalesTeamID`, integer)\n(`_CustomerID`, integer)\n(`_StoreID`, integer)\n(`_ProductID`, integer)\n(`Order Quantity`, integer)\n(`Discount Applied`, real)\n(`Unit Price`, text)\n(`Unit Cost`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Sales_Orders`\nColumns:\n(`OrderNumber`, String, primary key)\n(`Sales_Channel`, String)\n(`WarehouseCode`, String)\n(`ProcuredDate`, String)\n(`OrderDate`, String)\n(`ShipDate`, String)\n(`DeliveryDate`, String)\n(`CurrencyCode`, String)\n(`_SalesTeamID`, Int64)\n(`_CustomerID`, Int64)\n(`_StoreID`, Int64)\n(`_ProductID`, Int64)\n(`Order_Quantity`, Int64)\n(`Discount_Applied`, Float64)\n(`Unit_Price`, String)\n(`Unit_Cost`, String)\n"
        ]
    },
    {
        "sql_id": 229,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(CASE WHEN SUBSTR(T1.OrderDate, -2) IN ('18', '19', '20') AND T2.`Customer Names` = 'Medsep Group' THEN 1 ELSE 0 END) FROM `Sales Orders` AS T1 INNER JOIN Customers AS T2 ON T2.CustomerID = T1._CustomerID",
        "target_query": "SELECT SUM(CASE WHEN substring(T1.`OrderDate`, -2) IN ('18', '19', '20') AND T2.`Customer_Names` = 'Medsep Group' THEN 1 ELSE 0 END) FROM `Sales_Orders` AS T1 INNER JOIN `Customers` AS T2 ON T2.`CustomerID` = T1.`_CustomerID`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 45,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 50,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales Orders`\nColumns:\n(`OrderNumber`, text, primary key)\n(`Sales Channel`, text)\n(`WarehouseCode`, text)\n(`ProcuredDate`, text)\n(`OrderDate`, text)\n(`ShipDate`, text)\n(`DeliveryDate`, text)\n(`CurrencyCode`, text)\n(`_SalesTeamID`, integer)\n(`_CustomerID`, integer)\n(`_StoreID`, integer)\n(`_ProductID`, integer)\n(`Order Quantity`, integer)\n(`Discount Applied`, real)\n(`Unit Price`, text)\n(`Unit Cost`, text)\n",
            "Table: `Customers`\nColumns:\n(`CustomerID`, integer, primary key)\n(`Customer Names`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Sales_Orders`\nColumns:\n(`OrderNumber`, String, primary key)\n(`Sales_Channel`, String)\n(`WarehouseCode`, String)\n(`ProcuredDate`, String)\n(`OrderDate`, String)\n(`ShipDate`, String)\n(`DeliveryDate`, String)\n(`CurrencyCode`, String)\n(`_SalesTeamID`, Int64)\n(`_CustomerID`, Int64)\n(`_StoreID`, Int64)\n(`_ProductID`, Int64)\n(`Order_Quantity`, Int64)\n(`Discount_Applied`, Float64)\n(`Unit_Price`, String)\n(`Unit_Cost`, String)\n",
            "Table: `Customers`\nColumns:\n(`CustomerID`, Int64, primary key)\n(`Customer_Names`, String)\n"
        ]
    },
    {
        "sql_id": 230,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(WarehouseCode = 'WARE-MKL1006', 1, 0)) - SUM(IIF(WarehouseCode = 'WARE-NBV1002', 1, 0)) AS difference FROM `Sales Orders`",
        "target_query": "SELECT SUM(if(`WarehouseCode` = 'WARE-MKL1006', 1, 0)) - SUM(if(`WarehouseCode` = 'WARE-NBV1002', 1, 0)) AS `difference` FROM `Sales_Orders`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 52,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 60,
                "end_index": 101,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 53,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 61,
                "end_index": 103,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales Orders`\nColumns:\n(`OrderNumber`, text, primary key)\n(`Sales Channel`, text)\n(`WarehouseCode`, text)\n(`ProcuredDate`, text)\n(`OrderDate`, text)\n(`ShipDate`, text)\n(`DeliveryDate`, text)\n(`CurrencyCode`, text)\n(`_SalesTeamID`, integer)\n(`_CustomerID`, integer)\n(`_StoreID`, integer)\n(`_ProductID`, integer)\n(`Order Quantity`, integer)\n(`Discount Applied`, real)\n(`Unit Price`, text)\n(`Unit Cost`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Sales_Orders`\nColumns:\n(`OrderNumber`, String, primary key)\n(`Sales_Channel`, String)\n(`WarehouseCode`, String)\n(`ProcuredDate`, String)\n(`OrderDate`, String)\n(`ShipDate`, String)\n(`DeliveryDate`, String)\n(`CurrencyCode`, String)\n(`_SalesTeamID`, Int64)\n(`_CustomerID`, Int64)\n(`_StoreID`, Int64)\n(`_ProductID`, Int64)\n(`Order_Quantity`, Int64)\n(`Discount_Applied`, Float64)\n(`Unit_Price`, String)\n(`Unit_Cost`, String)\n"
        ]
    },
    {
        "sql_id": 231,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT OrderNumber, `Product Name` FROM ( SELECT IIF(T2.OrderDate = '6/6/18', T2.OrderNumber, NULL) AS \"OrderNumber\" , IIF(T2.OrderDate = '6/6/18', T1.`Product Name`, NULL) AS \"Product Name\" FROM Products T1 INNER JOIN `Sales Orders` T2 ON T2._ProductID = T1.ProductID ) WHERE OrderNumber IS NOT NULL AND `Product Name` IS NOT NULL",
        "target_query": "SELECT DISTINCT `OrderNumber`, `Product_Name` FROM ( SELECT if(T2.`OrderDate` = '6/6/18', T2.`OrderNumber`, NULL) AS `OrderNumber`, if(T2.`OrderDate` = '6/6/18', T1.`Product_Name`, NULL) AS `Product_Name` FROM `Products` T1 INNER JOIN `Sales_Orders` T2 ON T2.`_ProductID` = T1.`ProductID` ) WHERE `OrderNumber` IS NOT NULL AND `Product_Name` IS NOT NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 58,
                "end_index": 108,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 128,
                "end_index": 181,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 60,
                "end_index": 113,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 132,
                "end_index": 186,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Products`\nColumns:\n(`ProductID`, integer, primary key)\n(`Product Name`, text)\n",
            "Table: `Sales Orders`\nColumns:\n(`OrderNumber`, text, primary key)\n(`Sales Channel`, text)\n(`WarehouseCode`, text)\n(`ProcuredDate`, text)\n(`OrderDate`, text)\n(`ShipDate`, text)\n(`DeliveryDate`, text)\n(`CurrencyCode`, text)\n(`_SalesTeamID`, integer)\n(`_CustomerID`, integer)\n(`_StoreID`, integer)\n(`_ProductID`, integer)\n(`Order Quantity`, integer)\n(`Discount Applied`, real)\n(`Unit Price`, text)\n(`Unit Cost`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Products`\nColumns:\n(`ProductID`, Int64, primary key)\n(`Product_Name`, String)\n",
            "Table: `Sales_Orders`\nColumns:\n(`OrderNumber`, String, primary key)\n(`Sales_Channel`, String)\n(`WarehouseCode`, String)\n(`ProcuredDate`, String)\n(`OrderDate`, String)\n(`ShipDate`, String)\n(`DeliveryDate`, String)\n(`CurrencyCode`, String)\n(`_SalesTeamID`, Int64)\n(`_CustomerID`, Int64)\n(`_StoreID`, Int64)\n(`_ProductID`, Int64)\n(`Order_Quantity`, Int64)\n(`Discount_Applied`, Float64)\n(`Unit_Price`, String)\n(`Unit_Cost`, String)\n"
        ]
    },
    {
        "sql_id": 232,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT T FROM ( SELECT IIF(_CustomerID = 11, ProcuredDate, NULL) AS T FROM `Sales Orders` ) WHERE T IS NOT NULL",
        "target_query": "SELECT DISTINCT T FROM ( SELECT if(`_CustomerID` = 11, `ProcuredDate`, NULL) AS T FROM `Sales_Orders` ) WHERE T IS NOT NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 32,
                "end_index": 73,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 32,
                "end_index": 76,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales Orders`\nColumns:\n(`OrderNumber`, text, primary key)\n(`Sales Channel`, text)\n(`WarehouseCode`, text)\n(`ProcuredDate`, text)\n(`OrderDate`, text)\n(`ShipDate`, text)\n(`DeliveryDate`, text)\n(`CurrencyCode`, text)\n(`_SalesTeamID`, integer)\n(`_CustomerID`, integer)\n(`_StoreID`, integer)\n(`_ProductID`, integer)\n(`Order Quantity`, integer)\n(`Discount Applied`, real)\n(`Unit Price`, text)\n(`Unit Cost`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Sales_Orders`\nColumns:\n(`OrderNumber`, String, primary key)\n(`Sales_Channel`, String)\n(`WarehouseCode`, String)\n(`ProcuredDate`, String)\n(`OrderDate`, String)\n(`ShipDate`, String)\n(`DeliveryDate`, String)\n(`CurrencyCode`, String)\n(`_SalesTeamID`, Int64)\n(`_CustomerID`, Int64)\n(`_StoreID`, Int64)\n(`_ProductID`, Int64)\n(`Order_Quantity`, Int64)\n(`Discount_Applied`, Float64)\n(`Unit_Price`, String)\n(`Unit_Cost`, String)\n"
        ]
    },
    {
        "sql_id": 233,
        "database_name": "regional_sales",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(ShipDate LIKE '6/%/18' AND `Sales Channel` = 'Online', 1, 0)) FROM `Sales Orders`",
        "target_query": "SELECT SUM(if(`ShipDate` LIKE '6/%/18' AND `Sales_Channel` = 'Online', 1, 0)) FROM `Sales_Orders`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 75,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 76,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales Orders`\nColumns:\n(`OrderNumber`, text, primary key)\n(`Sales Channel`, text)\n(`WarehouseCode`, text)\n(`ProcuredDate`, text)\n(`OrderDate`, text)\n(`ShipDate`, text)\n(`DeliveryDate`, text)\n(`CurrencyCode`, text)\n(`_SalesTeamID`, integer)\n(`_CustomerID`, integer)\n(`_StoreID`, integer)\n(`_ProductID`, integer)\n(`Order Quantity`, integer)\n(`Discount Applied`, real)\n(`Unit Price`, text)\n(`Unit Cost`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Sales_Orders`\nColumns:\n(`OrderNumber`, String, primary key)\n(`Sales_Channel`, String)\n(`WarehouseCode`, String)\n(`ProcuredDate`, String)\n(`OrderDate`, String)\n(`ShipDate`, String)\n(`DeliveryDate`, String)\n(`CurrencyCode`, String)\n(`_SalesTeamID`, Int64)\n(`_CustomerID`, Int64)\n(`_StoreID`, Int64)\n(`_ProductID`, Int64)\n(`Order_Quantity`, Int64)\n(`Discount_Applied`, Float64)\n(`Unit_Price`, String)\n(`Unit_Cost`, String)\n"
        ]
    },
    {
        "sql_id": 155,
        "database_name": "restaurant",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T2.food_type = 'mexican', 1, 0)) AS REAL) * 100 / COUNT(T2.id_restaurant) FROM geographic AS T1 INNER JOIN generalinfo AS T2 ON T1.city = T2.city WHERE T1.county = 'monterey county'",
        "target_query": "SELECT SUM(if(T2.food_type = 'mexican', 1, 0)) * 100 / COUNT(T2.id_restaurant) FROM `geographic` AS T1 INNER JOIN `generalinfo` AS T2 ON T1.city = T2.city WHERE T1.county = 'monterey county';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 51,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 45,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `geographic`\nColumns:\n(`city`, text, primary key)\n(`county`, text)\n(`region`, text)\n",
            "Table: `generalinfo`\nColumns:\n(`id_restaurant`, integer, primary key)\n(`label`, text)\n(`food_type`, text)\n(`city`, text)\n(`review`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `geographic`\nColumns:\n(`city`, String, primary key)\n(`county`, String)\n(`region`, String)\n",
            "Table: `generalinfo`\nColumns:\n(`id_restaurant`, Int64, primary key)\n(`label`, String)\n(`food_type`, String)\n(`city`, String)\n(`review`, Float64)\n"
        ]
    },
    {
        "sql_id": 156,
        "database_name": "restaurant",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T1.street_name = '11th st', 1, 0)) AS REAL) * 100 / COUNT(T1.id_restaurant) FROM location AS T1 INNER JOIN geographic AS T2 ON T1.city = T2.city WHERE T2.County = 'alameda county'",
        "target_query": "SELECT SUM(if(`T1`.`street_name` = '11th st', 1, 0)) * 100 / COUNT(`T1`.`id_restaurant`) FROM `location` AS `T1` INNER JOIN `geographic` AS `T2` ON `T1`.`city` = `T2`.`city` WHERE `T2`.`county` = 'alameda county';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 53,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 51,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `location`\nColumns:\n(`id_restaurant`, integer, primary key)\n(`street_num`, integer)\n(`street_name`, text)\n(`city`, text)\n",
            "Table: `geographic`\nColumns:\n(`city`, text, primary key)\n(`county`, text)\n(`region`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `location`\nColumns:\n(`id_restaurant`, Int64, primary key)\n(`street_num`, Int64)\n(`street_name`, String)\n(`city`, String)\n",
            "Table: `geographic`\nColumns:\n(`city`, String, primary key)\n(`county`, String)\n(`region`, String)\n"
        ]
    },
    {
        "sql_id": 157,
        "database_name": "restaurant",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(food_type = 'american food', 1, 0)) AS REAL) * 100 / COUNT(id_restaurant) FROM generalinfo WHERE city = 'dublin'",
        "target_query": "SELECT SUM(if(`food_type` = 'american food', 1, 0)) * 100 / COUNT(`id_restaurant`) FROM `generalinfo` WHERE `city` = 'dublin';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 54,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 50,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `generalinfo`\nColumns:\n(`id_restaurant`, integer, primary key)\n(`label`, text)\n(`food_type`, text)\n(`city`, text)\n(`review`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `generalinfo`\nColumns:\n(`id_restaurant`, Int64, primary key)\n(`label`, String)\n(`food_type`, String)\n(`city`, String)\n(`review`, Float64)\n"
        ]
    },
    {
        "sql_id": 158,
        "database_name": "restaurant",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T2.review > 4, 1, 0)) AS REAL) * 100 / COUNT(T2.id_restaurant) FROM geographic AS T1 RIGHT JOIN generalinfo AS T2 ON T1.city = T2.city WHERE T1.region = 'bay area'",
        "target_query": "SELECT SUM(if(T2.review > 4, 1, 0)) * 100 / COUNT(T2.id_restaurant) FROM `geographic` AS T1 RIGHT JOIN `generalinfo` AS T2 ON T1.city = T2.city WHERE T1.region = 'bay area';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 40,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 34,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `geographic`\nColumns:\n(`city`, text, primary key)\n(`county`, text)\n(`region`, text)\n",
            "Table: `generalinfo`\nColumns:\n(`id_restaurant`, integer, primary key)\n(`label`, text)\n(`food_type`, text)\n(`city`, text)\n(`review`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `geographic`\nColumns:\n(`city`, String, primary key)\n(`county`, String)\n(`region`, String)\n",
            "Table: `generalinfo`\nColumns:\n(`id_restaurant`, Int64, primary key)\n(`label`, String)\n(`food_type`, String)\n(`city`, String)\n(`review`, Float64)\n"
        ]
    },
    {
        "sql_id": 159,
        "database_name": "restaurant",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T1.region = 'bay area', 1, 0)) AS REAL) * 100 / COUNT(T2.id_restaurant) FROM geographic AS T1 INNER JOIN location AS T2 ON T1.city = T2.city",
        "target_query": "SELECT SUM(if(`T1`.`region` = 'bay area', 1, 0)) * 100 / COUNT(`T2`.`id_restaurant`) FROM `geographic` AS `T1` INNER JOIN `location` AS `T2` ON `T1`.`city` = `T2`.`city`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 49,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 47,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `geographic`\nColumns:\n(`city`, text, primary key)\n(`county`, text)\n(`region`, text)\n",
            "Table: `location`\nColumns:\n(`id_restaurant`, integer, primary key)\n(`street_num`, integer)\n(`street_name`, text)\n(`city`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `geographic`\nColumns:\n(`city`, String, primary key)\n(`county`, String)\n(`region`, String)\n",
            "Table: `location`\nColumns:\n(`id_restaurant`, Int64, primary key)\n(`street_num`, Int64)\n(`street_name`, String)\n(`city`, String)\n"
        ]
    },
    {
        "sql_id": 160,
        "database_name": "restaurant",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(region = 'Napa Valley', 1, 0)) AS REAL) * 100 / COUNT(region) FROM geographic",
        "target_query": "SELECT SUM(if(`region` = 'Napa Valley', 1, 0)) * 100 / COUNT(`region`) FROM `geographic`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 49,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 45,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `geographic`\nColumns:\n(`city`, text, primary key)\n(`county`, text)\n(`region`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `geographic`\nColumns:\n(`city`, String, primary key)\n(`county`, String)\n(`region`, String)\n"
        ]
    },
    {
        "sql_id": 161,
        "database_name": "restaurant",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T2.food_type = 'afghani', 1, 0)) AS REAL) * 100 / COUNT(T1.id_restaurant) FROM location AS T1 INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE 1000 <= T1.street_num <= 2000",
        "target_query": "SELECT CAST(SUM(if(T2.food_type = 'afghani', 1, 0)) AS Float64) * 100 / COUNT(T1.id_restaurant) FROM `location` AS T1 INNER JOIN `generalinfo` AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE T1.street_num >= 1000 AND T1.street_num <= 2000;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 51,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 50,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `location`\nColumns:\n(`id_restaurant`, integer, primary key)\n(`street_num`, integer)\n(`street_name`, text)\n(`city`, text)\n",
            "Table: `generalinfo`\nColumns:\n(`id_restaurant`, integer, primary key)\n(`label`, text)\n(`food_type`, text)\n(`city`, text)\n(`review`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `location`\nColumns:\n(`id_restaurant`, Int64, primary key)\n(`street_num`, Int64)\n(`street_name`, String)\n(`city`, String)\n",
            "Table: `generalinfo`\nColumns:\n(`id_restaurant`, Int64, primary key)\n(`label`, String)\n(`food_type`, String)\n(`city`, String)\n(`review`, Float64)\n"
        ]
    },
    {
        "sql_id": 471,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T2.n_name = 'GERMANY', 1, 0)) AS REAL) * 100 / COUNT(T1.c_custkey) FROM customer AS T1 INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey",
        "target_query": "SELECT CAST(SUM(if(T2.`n_name` = 'GERMANY', 1, 0)) AS Float64) * 100 / COUNT(T1.`c_custkey`) FROM `customer` AS T1 INNER JOIN `nation` AS T2 ON T1.`c_nationkey` = T2.`n_nationkey`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 48,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 49,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`c_custkey`, integer, primary key)\n(`c_mktsegment`, text)\n(`c_nationkey`, integer)\n(`c_name`, text)\n(`c_address`, text)\n(`c_phone`, text)\n(`c_acctbal`, real)\n(`c_comment`, text)\n",
            "Table: `nation`\nColumns:\n(`n_nationkey`, integer, primary key)\n(`n_name`, text)\n(`n_regionkey`, integer)\n(`n_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `customer`\nColumns:\n(`c_custkey`, Int64, primary key)\n(`c_mktsegment`, String)\n(`c_nationkey`, Int64)\n(`c_name`, String)\n(`c_address`, String)\n(`c_phone`, String)\n(`c_acctbal`, Float64)\n(`c_comment`, String)\n",
            "Table: `nation`\nColumns:\n(`n_nationkey`, Int64, primary key)\n(`n_name`, String)\n(`n_regionkey`, Int64)\n(`n_comment`, String)\n"
        ]
    },
    {
        "sql_id": 472,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT JULIANDAY(T2.l_receiptdate) - JULIANDAY(T2.l_commitdate) FROM orders AS T1 INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey WHERE T1.o_custkey = '129301' AND T1.o_orderdate = '1996-07-27'",
        "target_query": "SELECT (toUInt32(toDateTime(T2.`l_receiptdate`)) / 86400 + 2440587.5) - (toUInt32(toDateTime(T2.`l_commitdate`)) / 86400 + 2440587.5) FROM `orders` AS T1 INNER JOIN `lineitem` AS T2 ON T1.`o_orderkey` = T2.`l_orderkey` WHERE T1.`o_custkey` = '129301' AND T1.`o_orderdate` = '1996-07-27';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 34,
                "dialect_content": "The julianday(time-value, modifier, modifier, ...) function returns the Julian day number - the fractional number of days since noon in Greenwich on November 24, 4714 B.C. (Proleptic Gregorian calendar). It accepts a time-value and zero or more modifiers.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day').\nReturns: A real number representing the Julian day number.",
                "feature": "julianday(time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 37,
                "end_index": 63,
                "dialect_content": "The julianday(time-value, modifier, modifier, ...) function returns the Julian day number - the fractional number of days since noon in Greenwich on November 24, 4714 B.C. (Proleptic Gregorian calendar). It accepts a time-value and zero or more modifiers.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day').\nReturns: A real number representing the Julian day number.",
                "feature": "julianday(time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 8,
                "end_index": 47,
                "dialect_content": "ClickHouse does not have a built-in `julianday()` function like SQLite. However, you can compute the Julian day number using the formula: `toUInt32(toDateTime(time_value)) / 86400 + 2440587.5`. This expression converts a `DateTime` value to Julian day number by converting it to seconds since the Unix epoch (1970-01-01), dividing by the number of seconds in a day, and adjusting by adding the Julian day number of the Unix epoch (2440587.5).",
                "feature": "toUInt32(toDateTime(time_value)) / 86400 + 2440587.5"
            },
            {
                "start_index": 73,
                "end_index": 111,
                "dialect_content": "ClickHouse does not have a built-in `julianday()` function like SQLite. However, you can compute the Julian day number using the formula: `toUInt32(toDateTime(time_value)) / 86400 + 2440587.5`. This expression converts a `DateTime` value to Julian day number by converting it to seconds since the Unix epoch (1970-01-01), dividing by the number of seconds in a day, and adjusting by adding the Julian day number of the Unix epoch (2440587.5).",
                "feature": "toUInt32(toDateTime(time_value)) / 86400 + 2440587.5"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "julianday(time-value, modifier, modifier, ...)",
                "explanation": "The julianday(time-value, modifier, modifier, ...) function returns the Julian day number - the fractional number of days since noon in Greenwich on November 24, 4714 B.C. (Proleptic Gregorian calendar). It accepts a time-value and zero or more modifiers.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day').\nReturns: A real number representing the Julian day number.",
                "examples": [
                    "SELECT julianday(); -- Returns the current Julian day number.",
                    "SELECT julianday('2024-08-21'); -- Returns the Julian day number for August 21, 2024.",
                    "SELECT julianday('now', '+1 day'); -- Returns the Julian day number for one day after the current date."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "toUInt32(toDateTime(time_value)) / 86400 + 2440587.5",
                "explanation": "ClickHouse does not have a built-in `julianday()` function like SQLite. However, you can compute the Julian day number using the formula: `toUInt32(toDateTime(time_value)) / 86400 + 2440587.5`. This expression converts a `DateTime` value to Julian day number by converting it to seconds since the Unix epoch (1970-01-01), dividing by the number of seconds in a day, and adjusting by adding the Julian day number of the Unix epoch (2440587.5).",
                "examples": [
                    "SELECT toUInt32(toDateTime(now())) / 86400 + 2440587.5; -- Returns the current Julian day number.",
                    "SELECT toUInt32(toDateTime('2024-08-21')) / 86400 + 2440587.5; -- Returns the Julian day number for August 21, 2024.",
                    "SELECT toUInt32(toDateTime(now() + INTERVAL 1 DAY)) / 86400 + 2440587.5; -- Returns the Julian day number for one day after the current date."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `orders`\nColumns:\n(`o_orderdate`, date)\n(`o_orderkey`, integer, primary key)\n(`o_custkey`, integer)\n(`o_orderpriority`, text)\n(`o_shippriority`, integer)\n(`o_clerk`, text)\n(`o_orderstatus`, text)\n(`o_totalprice`, real)\n(`o_comment`, text)\n",
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, date)\n(`l_orderkey`, integer, primary key)\n(`l_discount`, real)\n(`l_extendedprice`, real)\n(`l_suppkey`, integer)\n(`l_quantity`, integer)\n(`l_returnflag`, text)\n(`l_partkey`, integer)\n(`l_linestatus`, text)\n(`l_tax`, real)\n(`l_commitdate`, date)\n(`l_receiptdate`, date)\n(`l_shipmode`, text)\n(`l_linenumber`, integer, primary key)\n(`l_shipinstruct`, text)\n(`l_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `orders`\nColumns:\n(`o_orderdate`, Date32)\n(`o_orderkey`, Int64, primary key)\n(`o_custkey`, Int64)\n(`o_orderpriority`, String)\n(`o_shippriority`, Int64)\n(`o_clerk`, String)\n(`o_orderstatus`, String)\n(`o_totalprice`, Float64)\n(`o_comment`, String)\n",
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, Date32)\n(`l_orderkey`, Int64, primary key)\n(`l_discount`, Float64)\n(`l_extendedprice`, Float64)\n(`l_suppkey`, Int64)\n(`l_quantity`, Int64)\n(`l_returnflag`, String)\n(`l_partkey`, Int64)\n(`l_linestatus`, String)\n(`l_tax`, Float64)\n(`l_commitdate`, Date32)\n(`l_receiptdate`, Date32)\n(`l_shipmode`, String)\n(`l_linenumber`, Int64, primary key)\n(`l_shipinstruct`, String)\n(`l_comment`, String)\n"
        ]
    },
    {
        "sql_id": 473,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T2.r_name = 'EUROPE', 1, 0)) AS REAL) * 100 / COUNT(T1.n_name) FROM nation AS T1 INNER JOIN region AS T2 ON T1.n_regionkey = T2.r_regionkey",
        "target_query": "SELECT CAST(SUM(if(T2.`r_name` = 'EUROPE', 1, 0)) AS Float64) * 100 / COUNT(T1.`n_name`) FROM `nation` AS T1 INNER JOIN `region` AS T2 ON T1.`n_regionkey` = T2.`r_regionkey`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 47,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 48,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `nation`\nColumns:\n(`n_nationkey`, integer, primary key)\n(`n_name`, text)\n(`n_regionkey`, integer)\n(`n_comment`, text)\n",
            "Table: `region`\nColumns:\n(`r_regionkey`, integer, primary key)\n(`r_name`, text)\n(`r_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `nation`\nColumns:\n(`n_nationkey`, Int64, primary key)\n(`n_name`, String)\n(`n_regionkey`, Int64)\n(`n_comment`, String)\n",
            "Table: `region`\nColumns:\n(`r_regionkey`, Int64, primary key)\n(`r_name`, String)\n(`r_comment`, String)\n"
        ]
    },
    {
        "sql_id": 474,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T2.n_name = 'JAPAN', 1, 0)) AS REAL) * 100 / COUNT(T1.s_name) FROM supplier AS T1 INNER JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey WHERE T1.s_acctbal < 0",
        "target_query": "SELECT toFloat64(SUM(if(T2.`n_name` = 'JAPAN', 1, 0))) * 100 / COUNT(T1.`s_name`) FROM `supplier` AS T1 INNER JOIN `nation` AS T2 ON T1.`s_nationkey` = T2.`n_nationkey` WHERE T1.`s_acctbal` < 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 46,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 52,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `supplier`\nColumns:\n(`s_suppkey`, integer, primary key)\n(`s_nationkey`, integer)\n(`s_comment`, text)\n(`s_name`, text)\n(`s_address`, text)\n(`s_phone`, text)\n(`s_acctbal`, real)\n",
            "Table: `nation`\nColumns:\n(`n_nationkey`, integer, primary key)\n(`n_name`, text)\n(`n_regionkey`, integer)\n(`n_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `supplier`\nColumns:\n(`s_suppkey`, Int64, primary key)\n(`s_nationkey`, Int64)\n(`s_comment`, String)\n(`s_name`, String)\n(`s_address`, String)\n(`s_phone`, String)\n(`s_acctbal`, Float64)\n",
            "Table: `nation`\nColumns:\n(`n_nationkey`, Int64, primary key)\n(`n_name`, String)\n(`n_regionkey`, Int64)\n(`n_comment`, String)\n"
        ]
    },
    {
        "sql_id": 475,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(l_orderkey) FROM lineitem WHERE STRFTIME('%Y', l_shipdate) = '1998'",
        "target_query": "SELECT COUNT(`l_orderkey`) FROM `lineitem` WHERE formatDateTime(`l_shipdate`, '%Y') = '1998';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 45,
                "end_index": 71,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 49,
                "end_index": 83,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, date)\n(`l_orderkey`, integer, primary key)\n(`l_discount`, real)\n(`l_extendedprice`, real)\n(`l_suppkey`, integer)\n(`l_quantity`, integer)\n(`l_returnflag`, text)\n(`l_partkey`, integer)\n(`l_linestatus`, text)\n(`l_tax`, real)\n(`l_commitdate`, date)\n(`l_receiptdate`, date)\n(`l_shipmode`, text)\n(`l_linenumber`, integer, primary key)\n(`l_shipinstruct`, text)\n(`l_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, Date32)\n(`l_orderkey`, Int64, primary key)\n(`l_discount`, Float64)\n(`l_extendedprice`, Float64)\n(`l_suppkey`, Int64)\n(`l_quantity`, Int64)\n(`l_returnflag`, String)\n(`l_partkey`, Int64)\n(`l_linestatus`, String)\n(`l_tax`, Float64)\n(`l_commitdate`, Date32)\n(`l_receiptdate`, Date32)\n(`l_shipmode`, String)\n(`l_linenumber`, Int64, primary key)\n(`l_shipinstruct`, String)\n(`l_comment`, String)\n"
        ]
    },
    {
        "sql_id": 476,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(l_linenumber) FROM lineitem WHERE l_returnflag = 'R' AND l_shipmode = 'AIR' AND STRFTIME('%Y', l_shipdate) = '1994'",
        "target_query": "SELECT COUNT(`l_linenumber`) FROM `lineitem` WHERE `l_returnflag` = 'R' AND `l_shipmode` = 'AIR' AND formatDateTime(`l_shipdate`, '%Y') = '1994';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 93,
                "end_index": 119,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 101,
                "end_index": 135,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, date)\n(`l_orderkey`, integer, primary key)\n(`l_discount`, real)\n(`l_extendedprice`, real)\n(`l_suppkey`, integer)\n(`l_quantity`, integer)\n(`l_returnflag`, text)\n(`l_partkey`, integer)\n(`l_linestatus`, text)\n(`l_tax`, real)\n(`l_commitdate`, date)\n(`l_receiptdate`, date)\n(`l_shipmode`, text)\n(`l_linenumber`, integer, primary key)\n(`l_shipinstruct`, text)\n(`l_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, Date32)\n(`l_orderkey`, Int64, primary key)\n(`l_discount`, Float64)\n(`l_extendedprice`, Float64)\n(`l_suppkey`, Int64)\n(`l_quantity`, Int64)\n(`l_returnflag`, String)\n(`l_partkey`, Int64)\n(`l_linestatus`, String)\n(`l_tax`, Float64)\n(`l_commitdate`, Date32)\n(`l_receiptdate`, Date32)\n(`l_shipmode`, String)\n(`l_linenumber`, Int64, primary key)\n(`l_shipinstruct`, String)\n(`l_comment`, String)\n"
        ]
    },
    {
        "sql_id": 477,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T2.o_orderkey) FROM lineitem AS T1 INNER JOIN orders AS T2 ON T2.o_orderkey = T1.l_orderkey WHERE JULIANDAY(T1.l_shipdate) - JULIANDAY(T2.o_orderdate) = 1 AND T2.o_orderpriority = '1-URGENT'",
        "target_query": "SELECT COUNT(`T2`.`o_orderkey`) FROM `lineitem` AS `T1` INNER JOIN `orders` AS `T2` ON `T2`.`o_orderkey` = `T1`.`l_orderkey` WHERE (toUInt32(toDateTime(`T1`.`l_shipdate`)) / 86400 + 2440587.5) - (toUInt32(toDateTime(`T2`.`o_orderdate`)) / 86400 + 2440587.5) = 1 AND `T2`.`o_orderpriority` = '1-URGENT';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 111,
                "end_index": 135,
                "dialect_content": "The julianday(time-value, modifier, modifier, ...) function returns the Julian day number - the fractional number of days since noon in Greenwich on November 24, 4714 B.C. (Proleptic Gregorian calendar). It accepts a time-value and zero or more modifiers.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day').\nReturns: A real number representing the Julian day number.",
                "feature": "julianday(time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 138,
                "end_index": 163,
                "dialect_content": "The julianday(time-value, modifier, modifier, ...) function returns the Julian day number - the fractional number of days since noon in Greenwich on November 24, 4714 B.C. (Proleptic Gregorian calendar). It accepts a time-value and zero or more modifiers.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day').\nReturns: A real number representing the Julian day number.",
                "feature": "julianday(time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 132,
                "end_index": 170,
                "dialect_content": "ClickHouse does not have a built-in `julianday()` function like SQLite. However, you can compute the Julian day number using the formula: `toUInt32(toDateTime(time_value)) / 86400 + 2440587.5`. This expression converts a `DateTime` value to Julian day number by converting it to seconds since the Unix epoch (1970-01-01), dividing by the number of seconds in a day, and adjusting by adding the Julian day number of the Unix epoch (2440587.5).",
                "feature": "toUInt32(toDateTime(time_value)) / 86400 + 2440587.5"
            },
            {
                "start_index": 196,
                "end_index": 235,
                "dialect_content": "ClickHouse does not have a built-in `julianday()` function like SQLite. However, you can compute the Julian day number using the formula: `toUInt32(toDateTime(time_value)) / 86400 + 2440587.5`. This expression converts a `DateTime` value to Julian day number by converting it to seconds since the Unix epoch (1970-01-01), dividing by the number of seconds in a day, and adjusting by adding the Julian day number of the Unix epoch (2440587.5).",
                "feature": "toUInt32(toDateTime(time_value)) / 86400 + 2440587.5"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "julianday(time-value, modifier, modifier, ...)",
                "explanation": "The julianday(time-value, modifier, modifier, ...) function returns the Julian day number - the fractional number of days since noon in Greenwich on November 24, 4714 B.C. (Proleptic Gregorian calendar). It accepts a time-value and zero or more modifiers.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day').\nReturns: A real number representing the Julian day number.",
                "examples": [
                    "SELECT julianday(); -- Returns the current Julian day number.",
                    "SELECT julianday('2024-08-21'); -- Returns the Julian day number for August 21, 2024.",
                    "SELECT julianday('now', '+1 day'); -- Returns the Julian day number for one day after the current date."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "toUInt32(toDateTime(time_value)) / 86400 + 2440587.5",
                "explanation": "ClickHouse does not have a built-in `julianday()` function like SQLite. However, you can compute the Julian day number using the formula: `toUInt32(toDateTime(time_value)) / 86400 + 2440587.5`. This expression converts a `DateTime` value to Julian day number by converting it to seconds since the Unix epoch (1970-01-01), dividing by the number of seconds in a day, and adjusting by adding the Julian day number of the Unix epoch (2440587.5).",
                "examples": [
                    "SELECT toUInt32(toDateTime(now())) / 86400 + 2440587.5; -- Returns the current Julian day number.",
                    "SELECT toUInt32(toDateTime('2024-08-21')) / 86400 + 2440587.5; -- Returns the Julian day number for August 21, 2024.",
                    "SELECT toUInt32(toDateTime(now() + INTERVAL 1 DAY)) / 86400 + 2440587.5; -- Returns the Julian day number for one day after the current date."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, date)\n(`l_orderkey`, integer, primary key)\n(`l_discount`, real)\n(`l_extendedprice`, real)\n(`l_suppkey`, integer)\n(`l_quantity`, integer)\n(`l_returnflag`, text)\n(`l_partkey`, integer)\n(`l_linestatus`, text)\n(`l_tax`, real)\n(`l_commitdate`, date)\n(`l_receiptdate`, date)\n(`l_shipmode`, text)\n(`l_linenumber`, integer, primary key)\n(`l_shipinstruct`, text)\n(`l_comment`, text)\n",
            "Table: `orders`\nColumns:\n(`o_orderdate`, date)\n(`o_orderkey`, integer, primary key)\n(`o_custkey`, integer)\n(`o_orderpriority`, text)\n(`o_shippriority`, integer)\n(`o_clerk`, text)\n(`o_orderstatus`, text)\n(`o_totalprice`, real)\n(`o_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, Date32)\n(`l_orderkey`, Int64, primary key)\n(`l_discount`, Float64)\n(`l_extendedprice`, Float64)\n(`l_suppkey`, Int64)\n(`l_quantity`, Int64)\n(`l_returnflag`, String)\n(`l_partkey`, Int64)\n(`l_linestatus`, String)\n(`l_tax`, Float64)\n(`l_commitdate`, Date32)\n(`l_receiptdate`, Date32)\n(`l_shipmode`, String)\n(`l_linenumber`, Int64, primary key)\n(`l_shipinstruct`, String)\n(`l_comment`, String)\n",
            "Table: `orders`\nColumns:\n(`o_orderdate`, Date32)\n(`o_orderkey`, Int64, primary key)\n(`o_custkey`, Int64)\n(`o_orderpriority`, String)\n(`o_shippriority`, Int64)\n(`o_clerk`, String)\n(`o_orderstatus`, String)\n(`o_totalprice`, Float64)\n(`o_comment`, String)\n"
        ]
    },
    {
        "sql_id": 478,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(c_acctbal < 0, 1, 0)) AS REAL) * 100 / COUNT(c_custkey) FROM customer",
        "target_query": "SELECT SUM(if(`c_acctbal` < 0, 1, 0)) * 100 / COUNT(`c_custkey`) FROM `customer`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 40,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 36,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`c_custkey`, integer, primary key)\n(`c_mktsegment`, text)\n(`c_nationkey`, integer)\n(`c_name`, text)\n(`c_address`, text)\n(`c_phone`, text)\n(`c_acctbal`, real)\n(`c_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `customer`\nColumns:\n(`c_custkey`, Int64, primary key)\n(`c_mktsegment`, String)\n(`c_nationkey`, Int64)\n(`c_name`, String)\n(`c_address`, String)\n(`c_phone`, String)\n(`c_acctbal`, Float64)\n(`c_comment`, String)\n"
        ]
    },
    {
        "sql_id": 479,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(p_mfgr = 'Manufacturer#3', 1, 0)) AS REAL) * 100 / COUNT(p_partkey) FROM part",
        "target_query": "SELECT CAST(SUM(if(`p_mfgr` = 'Manufacturer#3', 1, 0)) AS Float64) * 100 / COUNT(`p_partkey`) FROM `part`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 52,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 53,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `part`\nColumns:\n(`p_partkey`, integer, primary key)\n(`p_type`, text)\n(`p_size`, integer)\n(`p_brand`, text)\n(`p_name`, text)\n(`p_container`, text)\n(`p_mfgr`, text)\n(`p_retailprice`, real)\n(`p_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `part`\nColumns:\n(`p_partkey`, Int64, primary key)\n(`p_type`, String)\n(`p_size`, Int64)\n(`p_brand`, String)\n(`p_name`, String)\n(`p_container`, String)\n(`p_mfgr`, String)\n(`p_retailprice`, Float64)\n(`p_comment`, String)\n"
        ]
    },
    {
        "sql_id": 481,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T2.n_name = 'GERMANY', 1, 0)) AS REAL) * 100 / COUNT(T1.s_suppkey) FROM supplier AS T1 INNER JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey WHERE T1.s_acctbal < 0",
        "target_query": "SELECT CAST(SUM(if(T2.`n_name` = 'GERMANY', 1, 0)) AS Float64) * 100 / COUNT(T1.`s_suppkey`) FROM `supplier` AS T1 INNER JOIN `nation` AS T2 ON T1.`s_nationkey` = T2.`n_nationkey` WHERE T1.`s_acctbal` < 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 48,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 49,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `supplier`\nColumns:\n(`s_suppkey`, integer, primary key)\n(`s_nationkey`, integer)\n(`s_comment`, text)\n(`s_name`, text)\n(`s_address`, text)\n(`s_phone`, text)\n(`s_acctbal`, real)\n",
            "Table: `nation`\nColumns:\n(`n_nationkey`, integer, primary key)\n(`n_name`, text)\n(`n_regionkey`, integer)\n(`n_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `supplier`\nColumns:\n(`s_suppkey`, Int64, primary key)\n(`s_nationkey`, Int64)\n(`s_comment`, String)\n(`s_name`, String)\n(`s_address`, String)\n(`s_phone`, String)\n(`s_acctbal`, Float64)\n",
            "Table: `nation`\nColumns:\n(`n_nationkey`, Int64, primary key)\n(`n_name`, String)\n(`n_regionkey`, Int64)\n(`n_comment`, String)\n"
        ]
    },
    {
        "sql_id": 482,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(l_orderkey) FROM lineitem WHERE STRFTIME('%Y', l_shipdate) = '1994'",
        "target_query": "SELECT COUNT(`l_orderkey`) FROM `lineitem` WHERE formatDateTime(`l_shipdate`, '%Y') = '1994';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 45,
                "end_index": 71,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 49,
                "end_index": 83,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, date)\n(`l_orderkey`, integer, primary key)\n(`l_discount`, real)\n(`l_extendedprice`, real)\n(`l_suppkey`, integer)\n(`l_quantity`, integer)\n(`l_returnflag`, text)\n(`l_partkey`, integer)\n(`l_linestatus`, text)\n(`l_tax`, real)\n(`l_commitdate`, date)\n(`l_receiptdate`, date)\n(`l_shipmode`, text)\n(`l_linenumber`, integer, primary key)\n(`l_shipinstruct`, text)\n(`l_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, Date32)\n(`l_orderkey`, Int64, primary key)\n(`l_discount`, Float64)\n(`l_extendedprice`, Float64)\n(`l_suppkey`, Int64)\n(`l_quantity`, Int64)\n(`l_returnflag`, String)\n(`l_partkey`, Int64)\n(`l_linestatus`, String)\n(`l_tax`, Float64)\n(`l_commitdate`, Date32)\n(`l_receiptdate`, Date32)\n(`l_shipmode`, String)\n(`l_linenumber`, Int64, primary key)\n(`l_shipinstruct`, String)\n(`l_comment`, String)\n"
        ]
    },
    {
        "sql_id": 483,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T2.n_name = 'United States', 1, 0)) AS REAL) * 100 / COUNT(T1.c_custkey) FROM customer AS T1 INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE T1.c_acctbal < 4000",
        "target_query": "SELECT CAST(SUM(if(T2.`n_name` = 'United States', 1, 0)) AS Float64) * 100 / COUNT(T1.`c_custkey`) FROM `customer` AS T1 INNER JOIN `nation` AS T2 ON T1.`c_nationkey` = T2.`n_nationkey` WHERE T1.`c_acctbal` < 4000;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 54,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 55,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`c_custkey`, integer, primary key)\n(`c_mktsegment`, text)\n(`c_nationkey`, integer)\n(`c_name`, text)\n(`c_address`, text)\n(`c_phone`, text)\n(`c_acctbal`, real)\n(`c_comment`, text)\n",
            "Table: `nation`\nColumns:\n(`n_nationkey`, integer, primary key)\n(`n_name`, text)\n(`n_regionkey`, integer)\n(`n_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `customer`\nColumns:\n(`c_custkey`, Int64, primary key)\n(`c_mktsegment`, String)\n(`c_nationkey`, Int64)\n(`c_name`, String)\n(`c_address`, String)\n(`c_phone`, String)\n(`c_acctbal`, Float64)\n(`c_comment`, String)\n",
            "Table: `nation`\nColumns:\n(`n_nationkey`, Int64, primary key)\n(`n_name`, String)\n(`n_regionkey`, Int64)\n(`n_comment`, String)\n"
        ]
    },
    {
        "sql_id": 484,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(ps_supplycost > 500, 1, 0)) AS REAL) * 100 / COUNT(ps_suppkey) FROM partsupp",
        "target_query": "SELECT SUM(if(`ps_supplycost` > 500, 1, 0)) * 100 / COUNT(`ps_suppkey`) FROM `partsupp`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 46,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 42,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `partsupp`\nColumns:\n(`ps_partkey`, integer, primary key)\n(`ps_suppkey`, integer, primary key)\n(`ps_supplycost`, real)\n(`ps_availqty`, integer)\n(`ps_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `partsupp`\nColumns:\n(`ps_partkey`, Int64, primary key)\n(`ps_suppkey`, Int64, primary key)\n(`ps_supplycost`, Float64)\n(`ps_availqty`, Int64)\n(`ps_comment`, String)\n"
        ]
    },
    {
        "sql_id": 485,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T1.c_mktsegment = 'AUTOMOBILE', 1, 0)) AS REAL) * 100 / COUNT(T1.c_name) FROM customer AS T1 INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE T2.n_name = 'FRANCE'",
        "target_query": "SELECT CAST(SUM(if(T1.`c_mktsegment` = 'AUTOMOBILE', 1, 0)) AS Float64) * 100 / COUNT(T1.`c_name`) FROM `customer` AS T1 INNER JOIN `nation` AS T2 ON T1.`c_nationkey` = T2.`n_nationkey` WHERE T2.`n_name` = 'FRANCE';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 57,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 58,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`c_custkey`, integer, primary key)\n(`c_mktsegment`, text)\n(`c_nationkey`, integer)\n(`c_name`, text)\n(`c_address`, text)\n(`c_phone`, text)\n(`c_acctbal`, real)\n(`c_comment`, text)\n",
            "Table: `nation`\nColumns:\n(`n_nationkey`, integer, primary key)\n(`n_name`, text)\n(`n_regionkey`, integer)\n(`n_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `customer`\nColumns:\n(`c_custkey`, Int64, primary key)\n(`c_mktsegment`, String)\n(`c_nationkey`, Int64)\n(`c_name`, String)\n(`c_address`, String)\n(`c_phone`, String)\n(`c_acctbal`, Float64)\n(`c_comment`, String)\n",
            "Table: `nation`\nColumns:\n(`n_nationkey`, Int64, primary key)\n(`n_name`, String)\n(`n_regionkey`, Int64)\n(`n_comment`, String)\n"
        ]
    },
    {
        "sql_id": 486,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T2.r_name = 'AFRICA', 1, 0)) AS REAL) * 100 / COUNT(T1.n_nationkey) FROM nation AS T1 INNER JOIN region AS T2 ON T1.n_regionkey = T2.r_regionkey INNER JOIN customer AS T3 ON T1.n_nationkey = T3.c_nationkey WHERE T3.c_mktsegment = 'HOUSEHOLD'",
        "target_query": "SELECT CAST(SUM(if(T2.`r_name` = 'AFRICA', 1, 0)) AS Float64) * 100 / COUNT(T1.`n_nationkey`) FROM `nation` AS T1 INNER JOIN `region` AS T2 ON T1.`n_regionkey` = T2.`r_regionkey` INNER JOIN `customer` AS T3 ON T1.`n_nationkey` = T3.`c_nationkey` WHERE T3.`c_mktsegment` = 'HOUSEHOLD';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 47,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 48,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `nation`\nColumns:\n(`n_nationkey`, integer, primary key)\n(`n_name`, text)\n(`n_regionkey`, integer)\n(`n_comment`, text)\n",
            "Table: `region`\nColumns:\n(`r_regionkey`, integer, primary key)\n(`r_name`, text)\n(`r_comment`, text)\n",
            "Table: `customer`\nColumns:\n(`c_custkey`, integer, primary key)\n(`c_mktsegment`, text)\n(`c_nationkey`, integer)\n(`c_name`, text)\n(`c_address`, text)\n(`c_phone`, text)\n(`c_acctbal`, real)\n(`c_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `nation`\nColumns:\n(`n_nationkey`, Int64, primary key)\n(`n_name`, String)\n(`n_regionkey`, Int64)\n(`n_comment`, String)\n",
            "Table: `region`\nColumns:\n(`r_regionkey`, Int64, primary key)\n(`r_name`, String)\n(`r_comment`, String)\n",
            "Table: `customer`\nColumns:\n(`c_custkey`, Int64, primary key)\n(`c_mktsegment`, String)\n(`c_nationkey`, Int64)\n(`c_name`, String)\n(`c_address`, String)\n(`c_phone`, String)\n(`c_acctbal`, Float64)\n(`c_comment`, String)\n"
        ]
    },
    {
        "sql_id": 487,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT (CAST(SUM(IIF(T3.l_shipmode = 'SHIP', T1.p_retailprice, 0)) AS REAL) / SUM(IIF(T3.l_shipmode = 'SHIP', 1, 0))) - (CAST(SUM(IIF(T3.l_shipmode = 'AIR', T1.p_retailprice, 0)) AS REAL) / SUM(IIF(T3.l_shipmode = 'AIR', 1, 0))) FROM part AS T1 INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey INNER JOIN lineitem AS T3 ON T2.ps_suppkey = T3.l_suppkey",
        "target_query": "SELECT (CAST(SUM(if(T3.l_shipmode = 'SHIP', T1.p_retailprice, 0)) AS Float64) / SUM(if(T3.l_shipmode = 'SHIP', 1, 0))) - (CAST(SUM(if(T3.l_shipmode = 'AIR', T1.p_retailprice, 0)) AS Float64) / SUM(if(T3.l_shipmode = 'AIR', 1, 0))) FROM `part` AS T1 INNER JOIN `partsupp` AS T2 ON T1.`p_partkey` = T2.`ps_partkey` INNER JOIN `lineitem` AS T3 ON T2.`ps_suppkey` = T3.`l_suppkey`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 17,
                "end_index": 65,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 82,
                "end_index": 115,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 130,
                "end_index": 177,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 194,
                "end_index": 226,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 17,
                "end_index": 64,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 84,
                "end_index": 116,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 131,
                "end_index": 177,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 197,
                "end_index": 228,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `part`\nColumns:\n(`p_partkey`, integer, primary key)\n(`p_type`, text)\n(`p_size`, integer)\n(`p_brand`, text)\n(`p_name`, text)\n(`p_container`, text)\n(`p_mfgr`, text)\n(`p_retailprice`, real)\n(`p_comment`, text)\n",
            "Table: `partsupp`\nColumns:\n(`ps_partkey`, integer, primary key)\n(`ps_suppkey`, integer, primary key)\n(`ps_supplycost`, real)\n(`ps_availqty`, integer)\n(`ps_comment`, text)\n",
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, date)\n(`l_orderkey`, integer, primary key)\n(`l_discount`, real)\n(`l_extendedprice`, real)\n(`l_suppkey`, integer)\n(`l_quantity`, integer)\n(`l_returnflag`, text)\n(`l_partkey`, integer)\n(`l_linestatus`, text)\n(`l_tax`, real)\n(`l_commitdate`, date)\n(`l_receiptdate`, date)\n(`l_shipmode`, text)\n(`l_linenumber`, integer, primary key)\n(`l_shipinstruct`, text)\n(`l_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `part`\nColumns:\n(`p_partkey`, Int64, primary key)\n(`p_type`, String)\n(`p_size`, Int64)\n(`p_brand`, String)\n(`p_name`, String)\n(`p_container`, String)\n(`p_mfgr`, String)\n(`p_retailprice`, Float64)\n(`p_comment`, String)\n",
            "Table: `partsupp`\nColumns:\n(`ps_partkey`, Int64, primary key)\n(`ps_suppkey`, Int64, primary key)\n(`ps_supplycost`, Float64)\n(`ps_availqty`, Int64)\n(`ps_comment`, String)\n",
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, Date32)\n(`l_orderkey`, Int64, primary key)\n(`l_discount`, Float64)\n(`l_extendedprice`, Float64)\n(`l_suppkey`, Int64)\n(`l_quantity`, Int64)\n(`l_returnflag`, String)\n(`l_partkey`, Int64)\n(`l_linestatus`, String)\n(`l_tax`, Float64)\n(`l_commitdate`, Date32)\n(`l_receiptdate`, Date32)\n(`l_shipmode`, String)\n(`l_linenumber`, Int64, primary key)\n(`l_shipinstruct`, String)\n(`l_comment`, String)\n"
        ]
    },
    {
        "sql_id": 488,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T3.s_acctbal < ( SELECT AVG(supplier.s_acctbal) FROM supplier ), 1, 0)) AS REAL) * 100 / COUNT(T1.n_nationkey) FROM nation AS T1 INNER JOIN region AS T2 ON T1.n_regionkey = T2.r_regionkey INNER JOIN supplier AS T3 ON T1.n_nationkey = T3.s_nationkey WHERE T2.r_name = 'EUROPE'",
        "target_query": "SELECT CAST(SUM(if(T3.`s_acctbal` < ( SELECT AVG(`s_acctbal`) FROM `supplier` ), 1, 0)) AS Float64) * 100 / COUNT(T1.`n_nationkey`) \nFROM `nation` AS T1 \nINNER JOIN `region` AS T2 ON T1.`n_regionkey` = T2.`r_regionkey` \nINNER JOIN `supplier` AS T3 ON T1.`n_nationkey` = T3.`s_nationkey` \nWHERE T2.`r_name` = 'EUROPE';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 67,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 61,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `nation`\nColumns:\n(`n_nationkey`, integer, primary key)\n(`n_name`, text)\n(`n_regionkey`, integer)\n(`n_comment`, text)\n",
            "Table: `region`\nColumns:\n(`r_regionkey`, integer, primary key)\n(`r_name`, text)\n(`r_comment`, text)\n",
            "Table: `supplier`\nColumns:\n(`s_suppkey`, integer, primary key)\n(`s_nationkey`, integer)\n(`s_comment`, text)\n(`s_name`, text)\n(`s_address`, text)\n(`s_phone`, text)\n(`s_acctbal`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `nation`\nColumns:\n(`n_nationkey`, Int64, primary key)\n(`n_name`, String)\n(`n_regionkey`, Int64)\n(`n_comment`, String)\n",
            "Table: `region`\nColumns:\n(`r_regionkey`, Int64, primary key)\n(`r_name`, String)\n(`r_comment`, String)\n",
            "Table: `supplier`\nColumns:\n(`s_suppkey`, Int64, primary key)\n(`s_nationkey`, Int64)\n(`s_comment`, String)\n(`s_name`, String)\n(`s_address`, String)\n(`s_phone`, String)\n(`s_acctbal`, Float64)\n"
        ]
    },
    {
        "sql_id": 490,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T2.n_name = 'IRAN', 1, 0)) AS REAL) * 100 / COUNT(T2.n_name) FROM customer AS T1 INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE T1.c_mktsegment = 'HOUSEHOLD'",
        "target_query": "SELECT toFloat64(SUM(if(T2.`n_name` = 'IRAN', 1, 0))) * 100 / COUNT(T2.`n_name`) FROM `customer` AS T1 INNER JOIN `nation` AS T2 ON T1.`c_nationkey` = T2.`n_nationkey` WHERE T1.`c_mktsegment` = 'HOUSEHOLD';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 45,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 51,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`c_custkey`, integer, primary key)\n(`c_mktsegment`, text)\n(`c_nationkey`, integer)\n(`c_name`, text)\n(`c_address`, text)\n(`c_phone`, text)\n(`c_acctbal`, real)\n(`c_comment`, text)\n",
            "Table: `nation`\nColumns:\n(`n_nationkey`, integer, primary key)\n(`n_name`, text)\n(`n_regionkey`, integer)\n(`n_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `customer`\nColumns:\n(`c_custkey`, Int64, primary key)\n(`c_mktsegment`, String)\n(`c_nationkey`, Int64)\n(`c_name`, String)\n(`c_address`, String)\n(`c_phone`, String)\n(`c_acctbal`, Float64)\n(`c_comment`, String)\n",
            "Table: `nation`\nColumns:\n(`n_nationkey`, Int64, primary key)\n(`n_name`, String)\n(`n_regionkey`, Int64)\n(`n_comment`, String)\n"
        ]
    },
    {
        "sql_id": 492,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(o_orderkey) AS countorders FROM orders WHERE STRFTIME('%Y', o_orderdate) = '1998' AND o_totalprice < 950",
        "target_query": "SELECT COUNT(`o_orderkey`) AS countorders FROM `orders` WHERE formatDateTime(`o_orderdate`, '%Y') = '1998' AND `o_totalprice` < 950;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 58,
                "end_index": 85,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 62,
                "end_index": 97,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `orders`\nColumns:\n(`o_orderdate`, date)\n(`o_orderkey`, integer, primary key)\n(`o_custkey`, integer)\n(`o_orderpriority`, text)\n(`o_shippriority`, integer)\n(`o_clerk`, text)\n(`o_orderstatus`, text)\n(`o_totalprice`, real)\n(`o_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `orders`\nColumns:\n(`o_orderdate`, Date32)\n(`o_orderkey`, Int64, primary key)\n(`o_custkey`, Int64)\n(`o_orderpriority`, String)\n(`o_shippriority`, Int64)\n(`o_clerk`, String)\n(`o_orderstatus`, String)\n(`o_totalprice`, Float64)\n(`o_comment`, String)\n"
        ]
    },
    {
        "sql_id": 493,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(l_returnflag = 'A', 1, 0)) - SUM(IIF(l_returnflag = 'N', 1, 0)) AS diff FROM lineitem WHERE l_extendedprice < 16947.7",
        "target_query": "SELECT SUM(if(`l_returnflag` = 'A', 1, 0)) - SUM(if(`l_returnflag` = 'N', 1, 0)) AS `diff` FROM `lineitem` WHERE `l_extendedprice` < 16947.7;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 40,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 48,
                "end_index": 77,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 41,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 49,
                "end_index": 79,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, date)\n(`l_orderkey`, integer, primary key)\n(`l_discount`, real)\n(`l_extendedprice`, real)\n(`l_suppkey`, integer)\n(`l_quantity`, integer)\n(`l_returnflag`, text)\n(`l_partkey`, integer)\n(`l_linestatus`, text)\n(`l_tax`, real)\n(`l_commitdate`, date)\n(`l_receiptdate`, date)\n(`l_shipmode`, text)\n(`l_linenumber`, integer, primary key)\n(`l_shipinstruct`, text)\n(`l_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, Date32)\n(`l_orderkey`, Int64, primary key)\n(`l_discount`, Float64)\n(`l_extendedprice`, Float64)\n(`l_suppkey`, Int64)\n(`l_quantity`, Int64)\n(`l_returnflag`, String)\n(`l_partkey`, Int64)\n(`l_linestatus`, String)\n(`l_tax`, Float64)\n(`l_commitdate`, Date32)\n(`l_receiptdate`, Date32)\n(`l_shipmode`, String)\n(`l_linenumber`, Int64, primary key)\n(`l_shipinstruct`, String)\n(`l_comment`, String)\n"
        ]
    },
    {
        "sql_id": 494,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT JULIANDAY(T2.l_receiptdate) - JULIANDAY(T2.l_commitdate), T1.o_clerk FROM orders AS T1 INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey WHERE T1.o_orderkey = 6",
        "target_query": "SELECT (toUInt32(toDateTime(T2.`l_receiptdate`)) / 86400 + 2440587.5) - (toUInt32(toDateTime(T2.`l_commitdate`)) / 86400 + 2440587.5) AS date_difference, T1.`o_clerk` FROM `orders` AS T1 INNER JOIN `lineitem` AS T2 ON T1.`o_orderkey` = T2.`l_orderkey` WHERE T1.`o_orderkey` = 6;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 34,
                "dialect_content": "The julianday(time-value, modifier, modifier, ...) function returns the Julian day number - the fractional number of days since noon in Greenwich on November 24, 4714 B.C. (Proleptic Gregorian calendar). It accepts a time-value and zero or more modifiers.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day').\nReturns: A real number representing the Julian day number.",
                "feature": "julianday(time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 37,
                "end_index": 63,
                "dialect_content": "The julianday(time-value, modifier, modifier, ...) function returns the Julian day number - the fractional number of days since noon in Greenwich on November 24, 4714 B.C. (Proleptic Gregorian calendar). It accepts a time-value and zero or more modifiers.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day').\nReturns: A real number representing the Julian day number.",
                "feature": "julianday(time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 8,
                "end_index": 47,
                "dialect_content": "ClickHouse does not have a built-in `julianday()` function like SQLite. However, you can compute the Julian day number using the formula: `toUInt32(toDateTime(time_value)) / 86400 + 2440587.5`. This expression converts a `DateTime` value to Julian day number by converting it to seconds since the Unix epoch (1970-01-01), dividing by the number of seconds in a day, and adjusting by adding the Julian day number of the Unix epoch (2440587.5).",
                "feature": "toUInt32(toDateTime(time_value)) / 86400 + 2440587.5"
            },
            {
                "start_index": 73,
                "end_index": 111,
                "dialect_content": "ClickHouse does not have a built-in `julianday()` function like SQLite. However, you can compute the Julian day number using the formula: `toUInt32(toDateTime(time_value)) / 86400 + 2440587.5`. This expression converts a `DateTime` value to Julian day number by converting it to seconds since the Unix epoch (1970-01-01), dividing by the number of seconds in a day, and adjusting by adding the Julian day number of the Unix epoch (2440587.5).",
                "feature": "toUInt32(toDateTime(time_value)) / 86400 + 2440587.5"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "julianday(time-value, modifier, modifier, ...)",
                "explanation": "The julianday(time-value, modifier, modifier, ...) function returns the Julian day number - the fractional number of days since noon in Greenwich on November 24, 4714 B.C. (Proleptic Gregorian calendar). It accepts a time-value and zero or more modifiers.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day').\nReturns: A real number representing the Julian day number.",
                "examples": [
                    "SELECT julianday(); -- Returns the current Julian day number.",
                    "SELECT julianday('2024-08-21'); -- Returns the Julian day number for August 21, 2024.",
                    "SELECT julianday('now', '+1 day'); -- Returns the Julian day number for one day after the current date."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "toUInt32(toDateTime(time_value)) / 86400 + 2440587.5",
                "explanation": "ClickHouse does not have a built-in `julianday()` function like SQLite. However, you can compute the Julian day number using the formula: `toUInt32(toDateTime(time_value)) / 86400 + 2440587.5`. This expression converts a `DateTime` value to Julian day number by converting it to seconds since the Unix epoch (1970-01-01), dividing by the number of seconds in a day, and adjusting by adding the Julian day number of the Unix epoch (2440587.5).",
                "examples": [
                    "SELECT toUInt32(toDateTime(now())) / 86400 + 2440587.5; -- Returns the current Julian day number.",
                    "SELECT toUInt32(toDateTime('2024-08-21')) / 86400 + 2440587.5; -- Returns the Julian day number for August 21, 2024.",
                    "SELECT toUInt32(toDateTime(now() + INTERVAL 1 DAY)) / 86400 + 2440587.5; -- Returns the Julian day number for one day after the current date."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `orders`\nColumns:\n(`o_orderdate`, date)\n(`o_orderkey`, integer, primary key)\n(`o_custkey`, integer)\n(`o_orderpriority`, text)\n(`o_shippriority`, integer)\n(`o_clerk`, text)\n(`o_orderstatus`, text)\n(`o_totalprice`, real)\n(`o_comment`, text)\n",
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, date)\n(`l_orderkey`, integer, primary key)\n(`l_discount`, real)\n(`l_extendedprice`, real)\n(`l_suppkey`, integer)\n(`l_quantity`, integer)\n(`l_returnflag`, text)\n(`l_partkey`, integer)\n(`l_linestatus`, text)\n(`l_tax`, real)\n(`l_commitdate`, date)\n(`l_receiptdate`, date)\n(`l_shipmode`, text)\n(`l_linenumber`, integer, primary key)\n(`l_shipinstruct`, text)\n(`l_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `orders`\nColumns:\n(`o_orderdate`, Date32)\n(`o_orderkey`, Int64, primary key)\n(`o_custkey`, Int64)\n(`o_orderpriority`, String)\n(`o_shippriority`, Int64)\n(`o_clerk`, String)\n(`o_orderstatus`, String)\n(`o_totalprice`, Float64)\n(`o_comment`, String)\n",
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, Date32)\n(`l_orderkey`, Int64, primary key)\n(`l_discount`, Float64)\n(`l_extendedprice`, Float64)\n(`l_suppkey`, Int64)\n(`l_quantity`, Int64)\n(`l_returnflag`, String)\n(`l_partkey`, Int64)\n(`l_linestatus`, String)\n(`l_tax`, Float64)\n(`l_commitdate`, Date32)\n(`l_receiptdate`, Date32)\n(`l_shipmode`, String)\n(`l_linenumber`, Int64, primary key)\n(`l_shipinstruct`, String)\n(`l_comment`, String)\n"
        ]
    },
    {
        "sql_id": 495,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T1.r_name = 'ASIA', 1, 0)) AS REAL) * 100 / COUNT(T1.r_regionkey) FROM region AS T1 INNER JOIN nation AS T2 ON T1.r_regionkey = T2.n_regionkey INNER JOIN supplier AS T3 ON T2.n_nationkey = T3.s_nationkey",
        "target_query": "SELECT CAST(SUM(if(T1.`r_name` = 'ASIA', 1, 0)) AS Float64) * 100 / COUNT(T1.`r_regionkey`) FROM `region` AS T1 INNER JOIN `nation` AS T2 ON T1.`r_regionkey` = T2.`n_regionkey` INNER JOIN `supplier` AS T3 ON T2.`n_nationkey` = T3.`s_nationkey`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 45,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 46,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `region`\nColumns:\n(`r_regionkey`, integer, primary key)\n(`r_name`, text)\n(`r_comment`, text)\n",
            "Table: `nation`\nColumns:\n(`n_nationkey`, integer, primary key)\n(`n_name`, text)\n(`n_regionkey`, integer)\n(`n_comment`, text)\n",
            "Table: `supplier`\nColumns:\n(`s_suppkey`, integer, primary key)\n(`s_nationkey`, integer)\n(`s_comment`, text)\n(`s_name`, text)\n(`s_address`, text)\n(`s_phone`, text)\n(`s_acctbal`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `region`\nColumns:\n(`r_regionkey`, Int64, primary key)\n(`r_name`, String)\n(`r_comment`, String)\n",
            "Table: `nation`\nColumns:\n(`n_nationkey`, Int64, primary key)\n(`n_name`, String)\n(`n_regionkey`, Int64)\n(`n_comment`, String)\n",
            "Table: `supplier`\nColumns:\n(`s_suppkey`, Int64, primary key)\n(`s_nationkey`, Int64)\n(`s_comment`, String)\n(`s_name`, String)\n(`s_address`, String)\n(`s_phone`, String)\n(`s_acctbal`, Float64)\n"
        ]
    },
    {
        "sql_id": 496,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT l_linenumber FROM lineitem WHERE STRFTIME('%Y', l_shipdate) < 1997 AND l_shipmode = 'truck'",
        "target_query": "SELECT `l_linenumber` FROM `lineitem` WHERE formatDateTime(`l_shipdate`, '%Y') < '1997' AND `l_shipmode` = 'truck';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 40,
                "end_index": 66,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 44,
                "end_index": 78,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, date)\n(`l_orderkey`, integer, primary key)\n(`l_discount`, real)\n(`l_extendedprice`, real)\n(`l_suppkey`, integer)\n(`l_quantity`, integer)\n(`l_returnflag`, text)\n(`l_partkey`, integer)\n(`l_linestatus`, text)\n(`l_tax`, real)\n(`l_commitdate`, date)\n(`l_receiptdate`, date)\n(`l_shipmode`, text)\n(`l_linenumber`, integer, primary key)\n(`l_shipinstruct`, text)\n(`l_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, Date32)\n(`l_orderkey`, Int64, primary key)\n(`l_discount`, Float64)\n(`l_extendedprice`, Float64)\n(`l_suppkey`, Int64)\n(`l_quantity`, Int64)\n(`l_returnflag`, String)\n(`l_partkey`, Int64)\n(`l_linestatus`, String)\n(`l_tax`, Float64)\n(`l_commitdate`, Date32)\n(`l_receiptdate`, Date32)\n(`l_shipmode`, String)\n(`l_linenumber`, Int64, primary key)\n(`l_shipinstruct`, String)\n(`l_comment`, String)\n"
        ]
    },
    {
        "sql_id": 497,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT l_linenumber FROM lineitem WHERE STRFTIME('%Y', l_shipdate) < 1997 AND l_shipmode = 'TRUCK'",
        "target_query": "SELECT `l_linenumber` FROM `lineitem` WHERE formatDateTime(`l_shipdate`, '%Y') < '1997' AND `l_shipmode` = 'TRUCK';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 40,
                "end_index": 66,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 44,
                "end_index": 78,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, date)\n(`l_orderkey`, integer, primary key)\n(`l_discount`, real)\n(`l_extendedprice`, real)\n(`l_suppkey`, integer)\n(`l_quantity`, integer)\n(`l_returnflag`, text)\n(`l_partkey`, integer)\n(`l_linestatus`, text)\n(`l_tax`, real)\n(`l_commitdate`, date)\n(`l_receiptdate`, date)\n(`l_shipmode`, text)\n(`l_linenumber`, integer, primary key)\n(`l_shipinstruct`, text)\n(`l_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, Date32)\n(`l_orderkey`, Int64, primary key)\n(`l_discount`, Float64)\n(`l_extendedprice`, Float64)\n(`l_suppkey`, Int64)\n(`l_quantity`, Int64)\n(`l_returnflag`, String)\n(`l_partkey`, Int64)\n(`l_linestatus`, String)\n(`l_tax`, Float64)\n(`l_commitdate`, Date32)\n(`l_receiptdate`, Date32)\n(`l_shipmode`, String)\n(`l_linenumber`, Int64, primary key)\n(`l_shipinstruct`, String)\n(`l_comment`, String)\n"
        ]
    },
    {
        "sql_id": 499,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T1.r_name = 'America', 1, 0)) AS REAL) * 100 / COUNT(T2.n_name) FROM region AS T1 INNER JOIN nation AS T2 ON T1.r_regionkey = T2.n_regionkey",
        "target_query": "SELECT CAST(SUM(if(T1.`r_name` = 'America', 1, 0)) AS Float64) * 100 / COUNT(T2.`n_name`) FROM `region` AS T1 INNER JOIN `nation` AS T2 ON T1.`r_regionkey` = T2.`n_regionkey`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 48,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 49,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `region`\nColumns:\n(`r_regionkey`, integer, primary key)\n(`r_name`, text)\n(`r_comment`, text)\n",
            "Table: `nation`\nColumns:\n(`n_nationkey`, integer, primary key)\n(`n_name`, text)\n(`n_regionkey`, integer)\n(`n_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `region`\nColumns:\n(`r_regionkey`, Int64, primary key)\n(`r_name`, String)\n(`r_comment`, String)\n",
            "Table: `nation`\nColumns:\n(`n_nationkey`, Int64, primary key)\n(`n_name`, String)\n(`n_regionkey`, Int64)\n(`n_comment`, String)\n"
        ]
    },
    {
        "sql_id": 500,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T1.c_mktsegment = 'HOUSEHOLD', 1, 0)) AS REAL) * 100 / COUNT(T1.c_mktsegment) FROM customer AS T1 INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE T2.n_name = 'INDONESIA'",
        "target_query": "SELECT toFloat64(SUM(if(T1.c_mktsegment = 'HOUSEHOLD', 1, 0))) * 100 / COUNT(T1.c_mktsegment) FROM `customer` AS T1 INNER JOIN `nation` AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE T2.n_name = 'INDONESIA';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 56,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 60,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `customer`\nColumns:\n(`c_custkey`, integer, primary key)\n(`c_mktsegment`, text)\n(`c_nationkey`, integer)\n(`c_name`, text)\n(`c_address`, text)\n(`c_phone`, text)\n(`c_acctbal`, real)\n(`c_comment`, text)\n",
            "Table: `nation`\nColumns:\n(`n_nationkey`, integer, primary key)\n(`n_name`, text)\n(`n_regionkey`, integer)\n(`n_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `customer`\nColumns:\n(`c_custkey`, Int64, primary key)\n(`c_mktsegment`, String)\n(`c_nationkey`, Int64)\n(`c_name`, String)\n(`c_address`, String)\n(`c_phone`, String)\n(`c_acctbal`, Float64)\n(`c_comment`, String)\n",
            "Table: `nation`\nColumns:\n(`n_nationkey`, Int64, primary key)\n(`n_name`, String)\n(`n_regionkey`, Int64)\n(`n_comment`, String)\n"
        ]
    },
    {
        "sql_id": 501,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(l_orderkey) FROM lineitem WHERE STRFTIME('%Y', l_shipdate) = '1997' AND l_shipmode = 'MAIL'",
        "target_query": "SELECT COUNT(`l_orderkey`) FROM `lineitem` WHERE formatDateTime(`l_shipdate`, '%Y') = '1997' AND `l_shipmode` = 'MAIL';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 45,
                "end_index": 71,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 49,
                "end_index": 83,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, date)\n(`l_orderkey`, integer, primary key)\n(`l_discount`, real)\n(`l_extendedprice`, real)\n(`l_suppkey`, integer)\n(`l_quantity`, integer)\n(`l_returnflag`, text)\n(`l_partkey`, integer)\n(`l_linestatus`, text)\n(`l_tax`, real)\n(`l_commitdate`, date)\n(`l_receiptdate`, date)\n(`l_shipmode`, text)\n(`l_linenumber`, integer, primary key)\n(`l_shipinstruct`, text)\n(`l_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, Date32)\n(`l_orderkey`, Int64, primary key)\n(`l_discount`, Float64)\n(`l_extendedprice`, Float64)\n(`l_suppkey`, Int64)\n(`l_quantity`, Int64)\n(`l_returnflag`, String)\n(`l_partkey`, Int64)\n(`l_linestatus`, String)\n(`l_tax`, Float64)\n(`l_commitdate`, Date32)\n(`l_receiptdate`, Date32)\n(`l_shipmode`, String)\n(`l_linenumber`, Int64, primary key)\n(`l_shipinstruct`, String)\n(`l_comment`, String)\n"
        ]
    },
    {
        "sql_id": 502,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(l_orderkey) FROM lineitem WHERE STRFTIME('%Y', l_shipdate) = '1994' AND l_returnflag = 'R' AND l_shipmode = 'TRUCK'",
        "target_query": "SELECT COUNT(`l_orderkey`) FROM `lineitem` WHERE formatDateTime(`l_shipdate`, '%Y') = '1994' AND `l_returnflag` = 'R' AND `l_shipmode` = 'TRUCK';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 45,
                "end_index": 71,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 49,
                "end_index": 83,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, date)\n(`l_orderkey`, integer, primary key)\n(`l_discount`, real)\n(`l_extendedprice`, real)\n(`l_suppkey`, integer)\n(`l_quantity`, integer)\n(`l_returnflag`, text)\n(`l_partkey`, integer)\n(`l_linestatus`, text)\n(`l_tax`, real)\n(`l_commitdate`, date)\n(`l_receiptdate`, date)\n(`l_shipmode`, text)\n(`l_linenumber`, integer, primary key)\n(`l_shipinstruct`, text)\n(`l_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `lineitem`\nColumns:\n(`l_shipdate`, Date32)\n(`l_orderkey`, Int64, primary key)\n(`l_discount`, Float64)\n(`l_extendedprice`, Float64)\n(`l_suppkey`, Int64)\n(`l_quantity`, Int64)\n(`l_returnflag`, String)\n(`l_partkey`, Int64)\n(`l_linestatus`, String)\n(`l_tax`, Float64)\n(`l_commitdate`, Date32)\n(`l_receiptdate`, Date32)\n(`l_shipmode`, String)\n(`l_linenumber`, Int64, primary key)\n(`l_shipinstruct`, String)\n(`l_comment`, String)\n"
        ]
    },
    {
        "sql_id": 503,
        "database_name": "retails",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(o_orderkey) FROM orders WHERE STRFTIME('%Y', o_orderdate) = '1997' AND o_clerk = 'Clerk#000000001' AND o_orderpriority = '1-URGENT'",
        "target_query": "SELECT COUNT(`o_orderkey`) FROM `orders` WHERE formatDateTime(`o_orderdate`, '%Y') = '1997' AND `o_clerk` = 'Clerk#000000001' AND `o_orderpriority` = '1-URGENT';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 43,
                "end_index": 70,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 47,
                "end_index": 82,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `orders`\nColumns:\n(`o_orderdate`, date)\n(`o_orderkey`, integer, primary key)\n(`o_custkey`, integer)\n(`o_orderpriority`, text)\n(`o_shippriority`, integer)\n(`o_clerk`, text)\n(`o_orderstatus`, text)\n(`o_totalprice`, real)\n(`o_comment`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `orders`\nColumns:\n(`o_orderdate`, Date32)\n(`o_orderkey`, Int64, primary key)\n(`o_custkey`, Int64)\n(`o_orderpriority`, String)\n(`o_shippriority`, Int64)\n(`o_clerk`, String)\n(`o_orderstatus`, String)\n(`o_totalprice`, Float64)\n(`o_comment`, String)\n"
        ]
    },
    {
        "sql_id": 19,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T1.sex) FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE strftime('%Y', T2.`Date received`) = '2016' AND T1.sex = 'Male' AND T2.Product = 'Credit card'",
        "target_query": "SELECT COUNT(`T1`.`sex`) FROM `client` AS `T1` INNER JOIN `events` AS `T2` ON `T1`.`client_id` = `T2`.`Client_ID` WHERE formatDateTime(`T2`.`Date_received`, '%Y') = '2016' AND `T1`.`sex` = 'Male' AND `T2`.`Product` = 'Credit card';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 100,
                "end_index": 134,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 120,
                "end_index": 162,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `client`\nColumns:\n(`client_id`, text, primary key)\n(`sex`, text)\n(`day`, integer)\n(`month`, integer)\n(`year`, integer)\n(`age`, integer)\n(`social`, text)\n(`first`, text)\n(`middle`, text)\n(`last`, text)\n(`phone`, text)\n(`email`, text)\n(`address_1`, text)\n(`address_2`, text)\n(`city`, text)\n(`state`, text)\n(`zipcode`, integer)\n(`district_id`, integer)\n",
            "Table: `events`\nColumns:\n(`Date received`, date)\n(`Product`, text)\n(`Sub-product`, text)\n(`Issue`, text)\n(`Sub-issue`, text)\n(`Consumer complaint narrative`, text)\n(`Tags`, text)\n(`Consumer consent provided?`, text)\n(`Submitted via`, text)\n(`Date sent to company`, text)\n(`Company response to consumer`, text)\n(`Timely response?`, text)\n(`Consumer disputed?`, text)\n(`Complaint ID`, text, primary key)\n(`Client_ID`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `client`\nColumns:\n(`client_id`, String, primary key)\n(`sex`, String)\n(`day`, Int64)\n(`month`, Int64)\n(`year`, Int64)\n(`age`, Int64)\n(`social`, String)\n(`first`, String)\n(`middle`, String)\n(`last`, String)\n(`phone`, String)\n(`email`, String)\n(`address_1`, String)\n(`address_2`, String)\n(`city`, String)\n(`state`, String)\n(`zipcode`, Int64)\n(`district_id`, Int64)\n",
            "Table: `events`\nColumns:\n(`Date_received`, Date32)\n(`Product`, String)\n(`Sub_product`, String)\n(`Issue`, String)\n(`Sub_issue`, String)\n(`Consumer_complaint_narrative`, String)\n(`Tags`, String)\n(`Consumer_consent_provided_`, String)\n(`Submitted_via`, String)\n(`Date_sent_to_company`, String)\n(`Company_response_to_consumer`, String)\n(`Timely_response_`, String)\n(`Consumer_disputed_`, String)\n(`Complaint_ID`, String, primary key)\n(`Client_ID`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 20,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(COUNT(T2.`Complaint ID`) AS REAL) / 3 AS average FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE strftime('%Y', T2.`Date received`) BETWEEN '2015' AND '2017' AND T1.city = 'New York City' AND T2.Product = 'Credit card'",
        "target_query": "SELECT COUNT(T2.`Complaint_ID`) / 3 AS average \nFROM `client` AS T1 \nINNER JOIN `events` AS T2 ON T1.`client_id` = T2.`Client_ID` \nWHERE formatDateTime(T2.`Date_received`, '%Y') BETWEEN '2015' AND '2017' \nAND T1.`city` = 'New York City' \nAND T2.`Product` = 'Credit card';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 140,
                "end_index": 174,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 137,
                "end_index": 177,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `client`\nColumns:\n(`client_id`, text, primary key)\n(`sex`, text)\n(`day`, integer)\n(`month`, integer)\n(`year`, integer)\n(`age`, integer)\n(`social`, text)\n(`first`, text)\n(`middle`, text)\n(`last`, text)\n(`phone`, text)\n(`email`, text)\n(`address_1`, text)\n(`address_2`, text)\n(`city`, text)\n(`state`, text)\n(`zipcode`, integer)\n(`district_id`, integer)\n",
            "Table: `events`\nColumns:\n(`Date received`, date)\n(`Product`, text)\n(`Sub-product`, text)\n(`Issue`, text)\n(`Sub-issue`, text)\n(`Consumer complaint narrative`, text)\n(`Tags`, text)\n(`Consumer consent provided?`, text)\n(`Submitted via`, text)\n(`Date sent to company`, text)\n(`Company response to consumer`, text)\n(`Timely response?`, text)\n(`Consumer disputed?`, text)\n(`Complaint ID`, text, primary key)\n(`Client_ID`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `client`\nColumns:\n(`client_id`, String, primary key)\n(`sex`, String)\n(`day`, Int64)\n(`month`, Int64)\n(`year`, Int64)\n(`age`, Int64)\n(`social`, String)\n(`first`, String)\n(`middle`, String)\n(`last`, String)\n(`phone`, String)\n(`email`, String)\n(`address_1`, String)\n(`address_2`, String)\n(`city`, String)\n(`state`, String)\n(`zipcode`, Int64)\n(`district_id`, Int64)\n",
            "Table: `events`\nColumns:\n(`Date_received`, Date32)\n(`Product`, String)\n(`Sub_product`, String)\n(`Issue`, String)\n(`Sub_issue`, String)\n(`Consumer_complaint_narrative`, String)\n(`Tags`, String)\n(`Consumer_consent_provided_`, String)\n(`Submitted_via`, String)\n(`Date_sent_to_company`, String)\n(`Company_response_to_consumer`, String)\n(`Timely_response_`, String)\n(`Consumer_disputed_`, String)\n(`Complaint_ID`, String, primary key)\n(`Client_ID`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 21,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT 100.0 * (SUM(CASE WHEN strftime('%Y', T2.`Date received`) = '2017' THEN 1 ELSE 0 END) - SUM(CASE WHEN strftime('%Y', T2.`Date received`) = '2016' THEN 1 ELSE 0 END)) / SUM(CASE WHEN strftime('%Y', T2.`Date received`) = '2016' THEN 1 ELSE 0 END) FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T1.city = 'New York City'",
        "target_query": "SELECT 100.0 * (SUM(CASE WHEN formatDateTime(T2.`Date_received`, '%Y') = '2017' THEN 1 ELSE 0 END) - SUM(CASE WHEN formatDateTime(T2.`Date_received`, '%Y') = '2016' THEN 1 ELSE 0 END)) / SUM(CASE WHEN formatDateTime(T2.`Date_received`, '%Y') = '2016' THEN 1 ELSE 0 END) FROM `client` AS T1 INNER JOIN `events` AS T2 ON T1.`client_id` = T2.`Client_ID` WHERE T1.`city` = 'New York City';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 30,
                "end_index": 64,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 109,
                "end_index": 143,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 189,
                "end_index": 223,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 30,
                "end_index": 70,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            },
            {
                "start_index": 115,
                "end_index": 155,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            },
            {
                "start_index": 201,
                "end_index": 241,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `client`\nColumns:\n(`client_id`, text, primary key)\n(`sex`, text)\n(`day`, integer)\n(`month`, integer)\n(`year`, integer)\n(`age`, integer)\n(`social`, text)\n(`first`, text)\n(`middle`, text)\n(`last`, text)\n(`phone`, text)\n(`email`, text)\n(`address_1`, text)\n(`address_2`, text)\n(`city`, text)\n(`state`, text)\n(`zipcode`, integer)\n(`district_id`, integer)\n",
            "Table: `events`\nColumns:\n(`Date received`, date)\n(`Product`, text)\n(`Sub-product`, text)\n(`Issue`, text)\n(`Sub-issue`, text)\n(`Consumer complaint narrative`, text)\n(`Tags`, text)\n(`Consumer consent provided?`, text)\n(`Submitted via`, text)\n(`Date sent to company`, text)\n(`Company response to consumer`, text)\n(`Timely response?`, text)\n(`Consumer disputed?`, text)\n(`Complaint ID`, text, primary key)\n(`Client_ID`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `client`\nColumns:\n(`client_id`, String, primary key)\n(`sex`, String)\n(`day`, Int64)\n(`month`, Int64)\n(`year`, Int64)\n(`age`, Int64)\n(`social`, String)\n(`first`, String)\n(`middle`, String)\n(`last`, String)\n(`phone`, String)\n(`email`, String)\n(`address_1`, String)\n(`address_2`, String)\n(`city`, String)\n(`state`, String)\n(`zipcode`, Int64)\n(`district_id`, Int64)\n",
            "Table: `events`\nColumns:\n(`Date_received`, Date32)\n(`Product`, String)\n(`Sub_product`, String)\n(`Issue`, String)\n(`Sub_issue`, String)\n(`Consumer_complaint_narrative`, String)\n(`Tags`, String)\n(`Consumer_consent_provided_`, String)\n(`Submitted_via`, String)\n(`Date_sent_to_company`, String)\n(`Company_response_to_consumer`, String)\n(`Timely_response_`, String)\n(`Consumer_disputed_`, String)\n(`Complaint_ID`, String, primary key)\n(`Client_ID`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 23,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT STRFTIME('%Y', T3.`Date received`) , CAST(SUM(CASE WHEN T3.`Company response to consumer` = 'Closed with explanation' THEN 1 ELSE 0 END) AS REAL) / COUNT(T3.`Complaint ID`) AS average FROM callcenterlogs AS T1 INNER JOIN client AS T2 ON T1.`rand client` = T2.client_id INNER JOIN events AS T3 ON T1.`Complaint ID` = T3.`Complaint ID` WHERE T2.city = 'New Bedford' GROUP BY strftime('%Y', T3.`Date received`)",
        "target_query": "SELECT formatDateTime(T3.`Date_received`, '%Y'), CAST(SUM(CASE WHEN T3.`Company_response_to_consumer` = 'Closed with explanation' THEN 1 ELSE 0 END) AS Float64) / COUNT(T3.`Complaint_ID`) AS average \nFROM `callcenterlogs` AS T1 \nINNER JOIN `client` AS T2 ON T1.`rand_client` = T2.`client_id` \nINNER JOIN `events` AS T3 ON T1.`Complaint_ID` = T3.`Complaint_ID` \nWHERE T2.`city` = 'New Bedford' \nGROUP BY formatDateTime(T3.`Date_received`, '%Y');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 41,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 380,
                "end_index": 414,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 47,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            },
            {
                "start_index": 403,
                "end_index": 443,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `callcenterlogs`\nColumns:\n(`Date received`, date)\n(`Complaint ID`, text, primary key)\n(`rand client`, text)\n(`phonefinal`, text)\n(`vru+line`, text)\n(`call_id`, integer)\n(`priority`, integer)\n(`type`, text)\n(`outcome`, text)\n(`server`, text)\n(`ser_start`, text)\n(`ser_exit`, text)\n(`ser_time`, text)\n",
            "Table: `client`\nColumns:\n(`client_id`, text, primary key)\n(`sex`, text)\n(`day`, integer)\n(`month`, integer)\n(`year`, integer)\n(`age`, integer)\n(`social`, text)\n(`first`, text)\n(`middle`, text)\n(`last`, text)\n(`phone`, text)\n(`email`, text)\n(`address_1`, text)\n(`address_2`, text)\n(`city`, text)\n(`state`, text)\n(`zipcode`, integer)\n(`district_id`, integer)\n",
            "Table: `events`\nColumns:\n(`Date received`, date)\n(`Product`, text)\n(`Sub-product`, text)\n(`Issue`, text)\n(`Sub-issue`, text)\n(`Consumer complaint narrative`, text)\n(`Tags`, text)\n(`Consumer consent provided?`, text)\n(`Submitted via`, text)\n(`Date sent to company`, text)\n(`Company response to consumer`, text)\n(`Timely response?`, text)\n(`Consumer disputed?`, text)\n(`Complaint ID`, text, primary key)\n(`Client_ID`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `callcenterlogs`\nColumns:\n(`Date_received`, Date32)\n(`Complaint_ID`, String, primary key)\n(`rand_client`, String)\n(`phonefinal`, String)\n(`vru_line`, String)\n(`call_id`, Int64)\n(`priority`, Int64)\n(`_type`, String)\n(`outcome`, String)\n(`server`, String)\n(`ser_start`, String)\n(`ser_exit`, String)\n(`ser_time`, String)\n",
            "Table: `client`\nColumns:\n(`client_id`, String, primary key)\n(`sex`, String)\n(`day`, Int64)\n(`month`, Int64)\n(`year`, Int64)\n(`age`, Int64)\n(`social`, String)\n(`first`, String)\n(`middle`, String)\n(`last`, String)\n(`phone`, String)\n(`email`, String)\n(`address_1`, String)\n(`address_2`, String)\n(`city`, String)\n(`state`, String)\n(`zipcode`, Int64)\n(`district_id`, Int64)\n",
            "Table: `events`\nColumns:\n(`Date_received`, Date32)\n(`Product`, String)\n(`Sub_product`, String)\n(`Issue`, String)\n(`Sub_issue`, String)\n(`Consumer_complaint_narrative`, String)\n(`Tags`, String)\n(`Consumer_consent_provided_`, String)\n(`Submitted_via`, String)\n(`Date_sent_to_company`, String)\n(`Company_response_to_consumer`, String)\n(`Timely_response_`, String)\n(`Consumer_disputed_`, String)\n(`Complaint_ID`, String, primary key)\n(`Client_ID`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 29,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT `Complaint ID`, call_id, phonefinal FROM callcenterlogs WHERE strftime('%Y', `Date received`) = '2014' AND server = 'AVIDAN'",
        "target_query": "SELECT `Complaint_ID`, `call_id`, `phonefinal` FROM `callcenterlogs` WHERE formatDateTime(`Date_received`, '%Y') = '2014' AND `server` = 'AVIDAN';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 69,
                "end_index": 100,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 75,
                "end_index": 112,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `callcenterlogs`\nColumns:\n(`Date received`, date)\n(`Complaint ID`, text, primary key)\n(`rand client`, text)\n(`phonefinal`, text)\n(`vru+line`, text)\n(`call_id`, integer)\n(`priority`, integer)\n(`type`, text)\n(`outcome`, text)\n(`server`, text)\n(`ser_start`, text)\n(`ser_exit`, text)\n(`ser_time`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `callcenterlogs`\nColumns:\n(`Date_received`, Date32)\n(`Complaint_ID`, String, primary key)\n(`rand_client`, String)\n(`phonefinal`, String)\n(`vru_line`, String)\n(`call_id`, Int64)\n(`priority`, Int64)\n(`_type`, String)\n(`outcome`, String)\n(`server`, String)\n(`ser_start`, String)\n(`ser_exit`, String)\n(`ser_time`, String)\n"
        ]
    },
    {
        "sql_id": 30,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT AVG(CAST(SUBSTR(ser_time, 4, 2) AS REAL)) FROM callcenterlogs WHERE `Date received` BETWEEN '2017-01-01' AND '2017-04-01'",
        "target_query": "SELECT AVG(CAST(substring(`ser_time`, 4, 2) AS Float64)) FROM `callcenterlogs` WHERE `Date_received` BETWEEN '2017-01-01' AND '2017-04-01';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 38,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 43,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `callcenterlogs`\nColumns:\n(`Date received`, date)\n(`Complaint ID`, text, primary key)\n(`rand client`, text)\n(`phonefinal`, text)\n(`vru+line`, text)\n(`call_id`, integer)\n(`priority`, integer)\n(`type`, text)\n(`outcome`, text)\n(`server`, text)\n(`ser_start`, text)\n(`ser_exit`, text)\n(`ser_time`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `callcenterlogs`\nColumns:\n(`Date_received`, Date32)\n(`Complaint_ID`, String, primary key)\n(`rand_client`, String)\n(`phonefinal`, String)\n(`vru_line`, String)\n(`call_id`, Int64)\n(`priority`, Int64)\n(`_type`, String)\n(`outcome`, String)\n(`server`, String)\n(`ser_start`, String)\n(`ser_exit`, String)\n(`ser_time`, String)\n"
        ]
    },
    {
        "sql_id": 33,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(CASE WHEN T1.priority = 2 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.`Complaint ID`) FROM callcenterlogs AS T1 INNER JOIN events AS T2 ON T1.`Complaint ID` = T2.`Complaint ID` WHERE strftime('%Y', T1.`Date received`) = '2017'",
        "target_query": "SELECT CAST(SUM(CASE WHEN T1.`priority` = 2 THEN 1 ELSE 0 END) AS Float64) * 100 / NULLIF(COUNT(T1.`Complaint_ID`), 0) FROM `callcenterlogs` AS T1 INNER JOIN `events` AS T2 ON T1.`Complaint_ID` = T2.`Complaint_ID` WHERE formatDateTime(T1.`Date_received`, '%Y') = '2017';",
        "semantic_equivalent_type": "Approximate equivalence",
        "source_dialect_locations": [
            {
                "start_index": 200,
                "end_index": 234,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 220,
                "end_index": 260,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `callcenterlogs`\nColumns:\n(`Date received`, date)\n(`Complaint ID`, text, primary key)\n(`rand client`, text)\n(`phonefinal`, text)\n(`vru+line`, text)\n(`call_id`, integer)\n(`priority`, integer)\n(`type`, text)\n(`outcome`, text)\n(`server`, text)\n(`ser_start`, text)\n(`ser_exit`, text)\n(`ser_time`, text)\n",
            "Table: `events`\nColumns:\n(`Date received`, date)\n(`Product`, text)\n(`Sub-product`, text)\n(`Issue`, text)\n(`Sub-issue`, text)\n(`Consumer complaint narrative`, text)\n(`Tags`, text)\n(`Consumer consent provided?`, text)\n(`Submitted via`, text)\n(`Date sent to company`, text)\n(`Company response to consumer`, text)\n(`Timely response?`, text)\n(`Consumer disputed?`, text)\n(`Complaint ID`, text, primary key)\n(`Client_ID`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `callcenterlogs`\nColumns:\n(`Date_received`, Date32)\n(`Complaint_ID`, String, primary key)\n(`rand_client`, String)\n(`phonefinal`, String)\n(`vru_line`, String)\n(`call_id`, Int64)\n(`priority`, Int64)\n(`_type`, String)\n(`outcome`, String)\n(`server`, String)\n(`ser_start`, String)\n(`ser_exit`, String)\n(`ser_time`, String)\n",
            "Table: `events`\nColumns:\n(`Date_received`, Date32)\n(`Product`, String)\n(`Sub_product`, String)\n(`Issue`, String)\n(`Sub_issue`, String)\n(`Consumer_complaint_narrative`, String)\n(`Tags`, String)\n(`Consumer_consent_provided_`, String)\n(`Submitted_via`, String)\n(`Date_sent_to_company`, String)\n(`Company_response_to_consumer`, String)\n(`Timely_response_`, String)\n(`Consumer_disputed_`, String)\n(`Complaint_ID`, String, primary key)\n(`Client_ID`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 34,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T1.city = 'Omaha' AND strftime('%Y', T2.`Date received`) = '2012' AND T2.Product = 'Credit card'",
        "target_query": "SELECT COUNT(`T1`.`client_id`) FROM `client` AS `T1` INNER JOIN `events` AS `T2` ON `T1`.`client_id` = `T2`.`Client_ID` WHERE `T1`.`city` = 'Omaha' AND formatDateTime(`T2`.`Date_received`, '%Y') = '2012' AND `T2`.`Product` = 'Credit card';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 128,
                "end_index": 162,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 152,
                "end_index": 194,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `client`\nColumns:\n(`client_id`, text, primary key)\n(`sex`, text)\n(`day`, integer)\n(`month`, integer)\n(`year`, integer)\n(`age`, integer)\n(`social`, text)\n(`first`, text)\n(`middle`, text)\n(`last`, text)\n(`phone`, text)\n(`email`, text)\n(`address_1`, text)\n(`address_2`, text)\n(`city`, text)\n(`state`, text)\n(`zipcode`, integer)\n(`district_id`, integer)\n",
            "Table: `events`\nColumns:\n(`Date received`, date)\n(`Product`, text)\n(`Sub-product`, text)\n(`Issue`, text)\n(`Sub-issue`, text)\n(`Consumer complaint narrative`, text)\n(`Tags`, text)\n(`Consumer consent provided?`, text)\n(`Submitted via`, text)\n(`Date sent to company`, text)\n(`Company response to consumer`, text)\n(`Timely response?`, text)\n(`Consumer disputed?`, text)\n(`Complaint ID`, text, primary key)\n(`Client_ID`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `client`\nColumns:\n(`client_id`, String, primary key)\n(`sex`, String)\n(`day`, Int64)\n(`month`, Int64)\n(`year`, Int64)\n(`age`, Int64)\n(`social`, String)\n(`first`, String)\n(`middle`, String)\n(`last`, String)\n(`phone`, String)\n(`email`, String)\n(`address_1`, String)\n(`address_2`, String)\n(`city`, String)\n(`state`, String)\n(`zipcode`, Int64)\n(`district_id`, Int64)\n",
            "Table: `events`\nColumns:\n(`Date_received`, Date32)\n(`Product`, String)\n(`Sub_product`, String)\n(`Issue`, String)\n(`Sub_issue`, String)\n(`Consumer_complaint_narrative`, String)\n(`Tags`, String)\n(`Consumer_consent_provided_`, String)\n(`Submitted_via`, String)\n(`Date_sent_to_company`, String)\n(`Company_response_to_consumer`, String)\n(`Timely_response_`, String)\n(`Consumer_disputed_`, String)\n(`Complaint_ID`, String, primary key)\n(`Client_ID`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 35,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE strftime('%Y', T2.`Date received`) BETWEEN '2012' AND '2015' AND T2.`Submitted via` = 'Email' AND T1.sex = 'Male'",
        "target_query": "SELECT COUNT(`T1`.`client_id`) FROM `client` AS `T1` INNER JOIN `events` AS `T2` ON `T1`.`client_id` = `T2`.`Client_ID` WHERE formatDateTime(`T2`.`Date_received`, '%Y') BETWEEN '2012' AND '2015' AND `T2`.`Submitted_via` = 'Email' AND `T1`.`sex` = 'Male';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 106,
                "end_index": 140,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 126,
                "end_index": 168,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `client`\nColumns:\n(`client_id`, text, primary key)\n(`sex`, text)\n(`day`, integer)\n(`month`, integer)\n(`year`, integer)\n(`age`, integer)\n(`social`, text)\n(`first`, text)\n(`middle`, text)\n(`last`, text)\n(`phone`, text)\n(`email`, text)\n(`address_1`, text)\n(`address_2`, text)\n(`city`, text)\n(`state`, text)\n(`zipcode`, integer)\n(`district_id`, integer)\n",
            "Table: `events`\nColumns:\n(`Date received`, date)\n(`Product`, text)\n(`Sub-product`, text)\n(`Issue`, text)\n(`Sub-issue`, text)\n(`Consumer complaint narrative`, text)\n(`Tags`, text)\n(`Consumer consent provided?`, text)\n(`Submitted via`, text)\n(`Date sent to company`, text)\n(`Company response to consumer`, text)\n(`Timely response?`, text)\n(`Consumer disputed?`, text)\n(`Complaint ID`, text, primary key)\n(`Client_ID`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `client`\nColumns:\n(`client_id`, String, primary key)\n(`sex`, String)\n(`day`, Int64)\n(`month`, Int64)\n(`year`, Int64)\n(`age`, Int64)\n(`social`, String)\n(`first`, String)\n(`middle`, String)\n(`last`, String)\n(`phone`, String)\n(`email`, String)\n(`address_1`, String)\n(`address_2`, String)\n(`city`, String)\n(`state`, String)\n(`zipcode`, Int64)\n(`district_id`, Int64)\n",
            "Table: `events`\nColumns:\n(`Date_received`, Date32)\n(`Product`, String)\n(`Sub_product`, String)\n(`Issue`, String)\n(`Sub_issue`, String)\n(`Consumer_complaint_narrative`, String)\n(`Tags`, String)\n(`Consumer_consent_provided_`, String)\n(`Submitted_via`, String)\n(`Date_sent_to_company`, String)\n(`Company_response_to_consumer`, String)\n(`Timely_response_`, String)\n(`Consumer_disputed_`, String)\n(`Complaint_ID`, String, primary key)\n(`Client_ID`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 36,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST((SUM(CASE WHEN strftime('%J', T2.`Date sent to company`) - strftime('%J', T2.`Date received`) > 5 THEN 1 ELSE 0 END)) AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T1.city = 'Houston' AND strftime('%Y', T2.`Date received`) = '2014'",
        "target_query": "SELECT \n    toFloat64(SUM(CASE \n        WHEN (toDate(`Date_sent_to_company`) IS NOT NULL AND toDate(`Date_received`) IS NOT NULL AND (toDate(`Date_sent_to_company`) - toDate(`Date_received`)) > 5) \n        THEN 1 \n        ELSE 0 \n    END) * 100) / \n    NULLIF(COUNTIf(`client_id` IS NOT NULL), 0) \nFROM \n    `client` AS T1 \nINNER JOIN \n    `events` AS T2 \nON \n    T1.`client_id` = T2.`Client_ID` \nWHERE \n    T1.`city` = 'Houston' \n    AND formatDateTime(T2.`Date_received`, '%Y') = '2014';",
        "semantic_equivalent_type": "Approximate equivalence",
        "source_dialect_locations": [
            {
                "start_index": 27,
                "end_index": 68,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 71,
                "end_index": 105,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 270,
                "end_index": 304,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 439,
                "end_index": 479,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `client`\nColumns:\n(`client_id`, text, primary key)\n(`sex`, text)\n(`day`, integer)\n(`month`, integer)\n(`year`, integer)\n(`age`, integer)\n(`social`, text)\n(`first`, text)\n(`middle`, text)\n(`last`, text)\n(`phone`, text)\n(`email`, text)\n(`address_1`, text)\n(`address_2`, text)\n(`city`, text)\n(`state`, text)\n(`zipcode`, integer)\n(`district_id`, integer)\n",
            "Table: `events`\nColumns:\n(`Date received`, date)\n(`Product`, text)\n(`Sub-product`, text)\n(`Issue`, text)\n(`Sub-issue`, text)\n(`Consumer complaint narrative`, text)\n(`Tags`, text)\n(`Consumer consent provided?`, text)\n(`Submitted via`, text)\n(`Date sent to company`, text)\n(`Company response to consumer`, text)\n(`Timely response?`, text)\n(`Consumer disputed?`, text)\n(`Complaint ID`, text, primary key)\n(`Client_ID`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `client`\nColumns:\n(`client_id`, String, primary key)\n(`sex`, String)\n(`day`, Int64)\n(`month`, Int64)\n(`year`, Int64)\n(`age`, Int64)\n(`social`, String)\n(`first`, String)\n(`middle`, String)\n(`last`, String)\n(`phone`, String)\n(`email`, String)\n(`address_1`, String)\n(`address_2`, String)\n(`city`, String)\n(`state`, String)\n(`zipcode`, Int64)\n(`district_id`, Int64)\n",
            "Table: `events`\nColumns:\n(`Date_received`, Date32)\n(`Product`, String)\n(`Sub_product`, String)\n(`Issue`, String)\n(`Sub_issue`, String)\n(`Consumer_complaint_narrative`, String)\n(`Tags`, String)\n(`Consumer_consent_provided_`, String)\n(`Submitted_via`, String)\n(`Date_sent_to_company`, String)\n(`Company_response_to_consumer`, String)\n(`Timely_response_`, String)\n(`Consumer_disputed_`, String)\n(`Complaint_ID`, String, primary key)\n(`Client_ID`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 37,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(`Submitted via`) FROM events WHERE strftime('%Y', `Date received`) = '2012' AND `Submitted via` = 'Email'",
        "target_query": "SELECT COUNT(`Submitted_via`) FROM `events` WHERE formatDateTime(`Date_received`, '%Y') = '2012' AND `Submitted_via` = 'Email';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 48,
                "end_index": 79,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 50,
                "end_index": 87,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `events`\nColumns:\n(`Date received`, date)\n(`Product`, text)\n(`Sub-product`, text)\n(`Issue`, text)\n(`Sub-issue`, text)\n(`Consumer complaint narrative`, text)\n(`Tags`, text)\n(`Consumer consent provided?`, text)\n(`Submitted via`, text)\n(`Date sent to company`, text)\n(`Company response to consumer`, text)\n(`Timely response?`, text)\n(`Consumer disputed?`, text)\n(`Complaint ID`, text, primary key)\n(`Client_ID`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `events`\nColumns:\n(`Date_received`, Date32)\n(`Product`, String)\n(`Sub_product`, String)\n(`Issue`, String)\n(`Sub_issue`, String)\n(`Consumer_complaint_narrative`, String)\n(`Tags`, String)\n(`Consumer_consent_provided_`, String)\n(`Submitted_via`, String)\n(`Date_sent_to_company`, String)\n(`Company_response_to_consumer`, String)\n(`Timely_response_`, String)\n(`Consumer_disputed_`, String)\n(`Complaint_ID`, String, primary key)\n(`Client_ID`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 38,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T1.`Complaint ID`) FROM callcenterlogs AS T1 INNER JOIN events AS T2 ON T1.`Complaint ID` = T2.`Complaint ID` WHERE strftime('%Y', T1.`Date received`) = '2015' AND T2.`Timely response?` = 'Yes' AND T2.`Company response to consumer` = 'Closed with explanation'",
        "target_query": "SELECT COUNT(T1.`Complaint_ID`) \nFROM `callcenterlogs` AS T1 \nINNER JOIN `events` AS T2 ON T1.`Complaint_ID` = T2.`Complaint_ID` \nWHERE formatDateTime(T1.`Date_received`, '%Y') = '2015' \nAND T2.`Timely_response_` = 'Yes' \nAND T2.`Company_response_to_consumer` = 'Closed with explanation';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 129,
                "end_index": 163,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 136,
                "end_index": 176,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `callcenterlogs`\nColumns:\n(`Date received`, date)\n(`Complaint ID`, text, primary key)\n(`rand client`, text)\n(`phonefinal`, text)\n(`vru+line`, text)\n(`call_id`, integer)\n(`priority`, integer)\n(`type`, text)\n(`outcome`, text)\n(`server`, text)\n(`ser_start`, text)\n(`ser_exit`, text)\n(`ser_time`, text)\n",
            "Table: `events`\nColumns:\n(`Date received`, date)\n(`Product`, text)\n(`Sub-product`, text)\n(`Issue`, text)\n(`Sub-issue`, text)\n(`Consumer complaint narrative`, text)\n(`Tags`, text)\n(`Consumer consent provided?`, text)\n(`Submitted via`, text)\n(`Date sent to company`, text)\n(`Company response to consumer`, text)\n(`Timely response?`, text)\n(`Consumer disputed?`, text)\n(`Complaint ID`, text, primary key)\n(`Client_ID`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `callcenterlogs`\nColumns:\n(`Date_received`, Date32)\n(`Complaint_ID`, String, primary key)\n(`rand_client`, String)\n(`phonefinal`, String)\n(`vru_line`, String)\n(`call_id`, Int64)\n(`priority`, Int64)\n(`_type`, String)\n(`outcome`, String)\n(`server`, String)\n(`ser_start`, String)\n(`ser_exit`, String)\n(`ser_time`, String)\n",
            "Table: `events`\nColumns:\n(`Date_received`, Date32)\n(`Product`, String)\n(`Sub_product`, String)\n(`Issue`, String)\n(`Sub_issue`, String)\n(`Consumer_complaint_narrative`, String)\n(`Tags`, String)\n(`Consumer_consent_provided_`, String)\n(`Submitted_via`, String)\n(`Date_sent_to_company`, String)\n(`Company_response_to_consumer`, String)\n(`Timely_response_`, String)\n(`Consumer_disputed_`, String)\n(`Complaint_ID`, String, primary key)\n(`Client_ID`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 39,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T2.`Complaint ID`) FROM callcenterlogs AS T1 INNER JOIN events AS T2 ON T1.`Complaint ID` = T2.`Complaint ID` WHERE T2.`Submitted via` = 'Phone' AND strftime('%Y', T1.`Date received`) = '2014'",
        "target_query": "SELECT COUNT(T2.`Complaint_ID`) FROM `callcenterlogs` AS T1 INNER JOIN `events` AS T2 ON T1.`Complaint_ID` = T2.`Complaint_ID` WHERE T2.`Submitted_via` = 'Phone' AND formatDateTime(T1.`Date_received`, '%Y') = '2014';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 162,
                "end_index": 196,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 166,
                "end_index": 206,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `callcenterlogs`\nColumns:\n(`Date received`, date)\n(`Complaint ID`, text, primary key)\n(`rand client`, text)\n(`phonefinal`, text)\n(`vru+line`, text)\n(`call_id`, integer)\n(`priority`, integer)\n(`type`, text)\n(`outcome`, text)\n(`server`, text)\n(`ser_start`, text)\n(`ser_exit`, text)\n(`ser_time`, text)\n",
            "Table: `events`\nColumns:\n(`Date received`, date)\n(`Product`, text)\n(`Sub-product`, text)\n(`Issue`, text)\n(`Sub-issue`, text)\n(`Consumer complaint narrative`, text)\n(`Tags`, text)\n(`Consumer consent provided?`, text)\n(`Submitted via`, text)\n(`Date sent to company`, text)\n(`Company response to consumer`, text)\n(`Timely response?`, text)\n(`Consumer disputed?`, text)\n(`Complaint ID`, text, primary key)\n(`Client_ID`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `callcenterlogs`\nColumns:\n(`Date_received`, Date32)\n(`Complaint_ID`, String, primary key)\n(`rand_client`, String)\n(`phonefinal`, String)\n(`vru_line`, String)\n(`call_id`, Int64)\n(`priority`, Int64)\n(`_type`, String)\n(`outcome`, String)\n(`server`, String)\n(`ser_start`, String)\n(`ser_exit`, String)\n(`ser_time`, String)\n",
            "Table: `events`\nColumns:\n(`Date_received`, Date32)\n(`Product`, String)\n(`Sub_product`, String)\n(`Issue`, String)\n(`Sub_issue`, String)\n(`Consumer_complaint_narrative`, String)\n(`Tags`, String)\n(`Consumer_consent_provided_`, String)\n(`Submitted_via`, String)\n(`Date_sent_to_company`, String)\n(`Company_response_to_consumer`, String)\n(`Timely_response_`, String)\n(`Consumer_disputed_`, String)\n(`Complaint_ID`, String, primary key)\n(`Client_ID`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 24,
        "database_name": "retail_complains",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT `Complaint ID` FROM events WHERE strftime('%J', `Date sent to company`) - strftime('%J', `Date received`) = ( SELECT MAX(strftime('%J', `Date sent to company`) - strftime('%J', `Date received`)) FROM events WHERE `Date sent to company` = '2014-09-25' ) AND `Date sent to company` = '2014-09-25'",
        "target_query": "SELECT `Complaint_ID` FROM `events` WHERE toDate(`Date_sent_to_company`) - toDate(`Date_received`) = ( SELECT MAX(toDate(`Date_sent_to_company`) - toDate(`Date_received`)) FROM `events` WHERE `Date_sent_to_company` = '2014-09-25' ) AND `Date_sent_to_company` = '2014-09-25';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 40,
                "end_index": 78,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 81,
                "end_index": 112,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 128,
                "end_index": 166,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 169,
                "end_index": 200,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `events`\nColumns:\n(`Date received`, date)\n(`Product`, text)\n(`Sub-product`, text)\n(`Issue`, text)\n(`Sub-issue`, text)\n(`Consumer complaint narrative`, text)\n(`Tags`, text)\n(`Consumer consent provided?`, text)\n(`Submitted via`, text)\n(`Date sent to company`, text)\n(`Company response to consumer`, text)\n(`Timely response?`, text)\n(`Consumer disputed?`, text)\n(`Complaint ID`, text, primary key)\n(`Client_ID`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `events`\nColumns:\n(`Date_received`, Date32)\n(`Product`, String)\n(`Sub_product`, String)\n(`Issue`, String)\n(`Sub_issue`, String)\n(`Consumer_complaint_narrative`, String)\n(`Tags`, String)\n(`Consumer_consent_provided_`, String)\n(`Submitted_via`, String)\n(`Date_sent_to_company`, String)\n(`Company_response_to_consumer`, String)\n(`Timely_response_`, String)\n(`Consumer_disputed_`, String)\n(`Complaint_ID`, String, primary key)\n(`Client_ID`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 453,
        "database_name": "retail_world",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T1.CustomerID) FROM Customers AS T1 INNER JOIN Orders AS T2 ON T1.CustomerID = T2.CustomerID WHERE STRFTIME('%Y', T2.OrderDate) = '1996' AND T1.Country = 'UK'",
        "target_query": "SELECT COUNT(`T1`.`CustomerID`) FROM `Customers` AS `T1` INNER JOIN `Orders` AS `T2` ON `T1`.`CustomerID` = `T2`.`CustomerID` WHERE formatDateTime(`T2`.`OrderDate`, '%Y') = '1996' AND `T1`.`Country` = 'UK';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 112,
                "end_index": 140,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 132,
                "end_index": 170,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Customers`\nColumns:\n(`CustomerID`, integer, primary key)\n(`CustomerName`, text)\n(`ContactName`, text)\n(`Address`, text)\n(`City`, text)\n(`PostalCode`, text)\n(`Country`, text)\n",
            "Table: `Orders`\nColumns:\n(`OrderID`, integer, primary key)\n(`CustomerID`, integer)\n(`EmployeeID`, integer)\n(`OrderDate`, date)\n(`ShipperID`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `Customers`\nColumns:\n(`CustomerID`, Int64, primary key)\n(`CustomerName`, String)\n(`ContactName`, String)\n(`Address`, String)\n(`City`, String)\n(`PostalCode`, String)\n(`Country`, String)\n",
            "Table: `Orders`\nColumns:\n(`OrderID`, Int64, primary key)\n(`CustomerID`, Int64)\n(`EmployeeID`, Int64)\n(`OrderDate`, Date32)\n(`ShipperID`, Int64)\n"
        ]
    },
    {
        "sql_id": 455,
        "database_name": "retail_world",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T2.CustomerID) FROM Customers AS T1 INNER JOIN Orders AS T2 ON T1.CustomerID = T2.CustomerID WHERE STRFTIME('%Y', T2.OrderDate) = '1996' GROUP BY T1.Country",
        "target_query": "SELECT COUNT(`T2`.`CustomerID`) FROM `Customers` AS `T1` INNER JOIN `Orders` AS `T2` ON `T1`.`CustomerID` = `T2`.`CustomerID` WHERE formatDateTime(`T2`.`OrderDate`, '%Y') = '1996' GROUP BY `T1`.`Country`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 112,
                "end_index": 140,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 132,
                "end_index": 170,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Customers`\nColumns:\n(`CustomerID`, integer, primary key)\n(`CustomerName`, text)\n(`ContactName`, text)\n(`Address`, text)\n(`City`, text)\n(`PostalCode`, text)\n(`Country`, text)\n",
            "Table: `Orders`\nColumns:\n(`OrderID`, integer, primary key)\n(`CustomerID`, integer)\n(`EmployeeID`, integer)\n(`OrderDate`, date)\n(`ShipperID`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `Customers`\nColumns:\n(`CustomerID`, Int64, primary key)\n(`CustomerName`, String)\n(`ContactName`, String)\n(`Address`, String)\n(`City`, String)\n(`PostalCode`, String)\n(`Country`, String)\n",
            "Table: `Orders`\nColumns:\n(`OrderID`, Int64, primary key)\n(`CustomerID`, Int64)\n(`EmployeeID`, Int64)\n(`OrderDate`, Date32)\n(`ShipperID`, Int64)\n"
        ]
    },
    {
        "sql_id": 463,
        "database_name": "retail_world",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T4.ProductName FROM Customers AS T1 INNER JOIN Orders AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN `OrderDetails` AS T3 ON T2.OrderID = T3.OrderID INNER JOIN Products AS T4 ON T3.ProductID = T4.ProductID WHERE T1.Country = 'Norway' AND STRFTIME('%Y', T2.OrderDate) = '1996'",
        "target_query": "SELECT T4.`ProductName` FROM `Customers` AS T1 \nINNER JOIN `Orders` AS T2 ON T1.`CustomerID` = T2.`CustomerID` \nINNER JOIN `OrderDetails` AS T3 ON T2.`OrderID` = T3.`OrderID` \nINNER JOIN `Products` AS T4 ON T3.`ProductID` = T4.`ProductID` \nWHERE T1.`Country` = 'Norway' AND formatDateTime(T2.`OrderDate`, '%Y') = '1996';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 248,
                "end_index": 276,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 274,
                "end_index": 310,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Customers`\nColumns:\n(`CustomerID`, integer, primary key)\n(`CustomerName`, text)\n(`ContactName`, text)\n(`Address`, text)\n(`City`, text)\n(`PostalCode`, text)\n(`Country`, text)\n",
            "Table: `Orders`\nColumns:\n(`OrderID`, integer, primary key)\n(`CustomerID`, integer)\n(`EmployeeID`, integer)\n(`OrderDate`, date)\n(`ShipperID`, integer)\n",
            "Table: `OrderDetails`\nColumns:\n(`OrderDetailID`, integer, primary key)\n(`OrderID`, integer)\n(`ProductID`, integer)\n(`Quantity`, integer)\n",
            "Table: `Products`\nColumns:\n(`ProductID`, integer, primary key)\n(`ProductName`, text)\n(`SupplierID`, integer)\n(`CategoryID`, integer)\n(`Unit`, text)\n(`Price`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `Customers`\nColumns:\n(`CustomerID`, Int64, primary key)\n(`CustomerName`, String)\n(`ContactName`, String)\n(`Address`, String)\n(`City`, String)\n(`PostalCode`, String)\n(`Country`, String)\n",
            "Table: `Orders`\nColumns:\n(`OrderID`, Int64, primary key)\n(`CustomerID`, Int64)\n(`EmployeeID`, Int64)\n(`OrderDate`, Date32)\n(`ShipperID`, Int64)\n",
            "Table: `OrderDetails`\nColumns:\n(`OrderDetailID`, Int64, primary key)\n(`OrderID`, Int64)\n(`ProductID`, Int64)\n(`Quantity`, Int64)\n",
            "Table: `Products`\nColumns:\n(`ProductID`, Int64, primary key)\n(`ProductName`, String)\n(`SupplierID`, Int64)\n(`CategoryID`, Int64)\n(`Unit`, String)\n(`Price`, Float64)\n"
        ]
    },
    {
        "sql_id": 363,
        "database_name": "sales",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.SalesID FROM Sales AS T1 INNER JOIN Employees AS T2 ON T1.SalesPersonID = T2.EmployeeID WHERE SUBSTR(T2.FirstName, 1, 1) = 's'",
        "target_query": "SELECT `T1`.`SalesID` FROM `Sales` AS `T1` INNER JOIN `Employees` AS `T2` ON `T1`.`SalesPersonID` = `T2`.`EmployeeID` WHERE substring(`T2`.`FirstName`, 1, 1) = 's';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 104,
                "end_index": 130,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 124,
                "end_index": 157,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales`\nColumns:\n(`SalesID`, integer, primary key)\n(`SalesPersonID`, integer)\n(`CustomerID`, integer)\n(`ProductID`, integer)\n(`Quantity`, integer)\n",
            "Table: `Employees`\nColumns:\n(`EmployeeID`, integer, primary key)\n(`FirstName`, text)\n(`MiddleInitial`, text)\n(`LastName`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Sales`\nColumns:\n(`SalesID`, Int64, primary key)\n(`SalesPersonID`, Int64)\n(`CustomerID`, Int64)\n(`ProductID`, Int64)\n(`Quantity`, Int64)\n",
            "Table: `Employees`\nColumns:\n(`EmployeeID`, Int64, primary key)\n(`FirstName`, String)\n(`MiddleInitial`, String)\n(`LastName`, String)\n"
        ]
    },
    {
        "sql_id": 364,
        "database_name": "sales",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(T2.FirstName = 'Morningstar', 1, 0)) + SUM(IIF(T2.FirstName = 'Heather', 1, 0)) + SUM(IIF(T2.FirstName = 'Dean', 1, 0)) AS num FROM Sales AS T1 INNER JOIN Employees AS T2 ON T1.SalesPersonID = T2.EmployeeID",
        "target_query": "SELECT SUM(if(`T2`.`FirstName` = 'Morningstar', 1, 0)) + SUM(if(`T2`.`FirstName` = 'Heather', 1, 0)) + SUM(if(`T2`.`FirstName` = 'Dean', 1, 0)) AS `num` FROM `Sales` AS `T1` INNER JOIN `Employees` AS `T2` ON `T1`.`SalesPersonID` = `T2`.`EmployeeID`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 50,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 58,
                "end_index": 93,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 101,
                "end_index": 133,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 53,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 61,
                "end_index": 99,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 107,
                "end_index": 142,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales`\nColumns:\n(`SalesID`, integer, primary key)\n(`SalesPersonID`, integer)\n(`CustomerID`, integer)\n(`ProductID`, integer)\n(`Quantity`, integer)\n",
            "Table: `Employees`\nColumns:\n(`EmployeeID`, integer, primary key)\n(`FirstName`, text)\n(`MiddleInitial`, text)\n(`LastName`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Sales`\nColumns:\n(`SalesID`, Int64, primary key)\n(`SalesPersonID`, Int64)\n(`CustomerID`, Int64)\n(`ProductID`, Int64)\n(`Quantity`, Int64)\n",
            "Table: `Employees`\nColumns:\n(`EmployeeID`, Int64, primary key)\n(`FirstName`, String)\n(`MiddleInitial`, String)\n(`LastName`, String)\n"
        ]
    },
    {
        "sql_id": 365,
        "database_name": "sales",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT IIF(T1.ProductID = 498, 'YES', 'NO') FROM Sales AS T1 INNER JOIN Customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.FirstName = 'Alex'",
        "target_query": "SELECT if(`T1`.`ProductID` = 498, 'YES', 'NO') FROM `Sales` AS `T1` INNER JOIN `Customers` AS `T2` ON `T1`.`CustomerID` = `T2`.`CustomerID` WHERE `T2`.`FirstName` = 'Alex';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 43,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 46,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales`\nColumns:\n(`SalesID`, integer, primary key)\n(`SalesPersonID`, integer)\n(`CustomerID`, integer)\n(`ProductID`, integer)\n(`Quantity`, integer)\n",
            "Table: `Customers`\nColumns:\n(`CustomerID`, integer, primary key)\n(`FirstName`, text)\n(`MiddleInitial`, text)\n(`LastName`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Sales`\nColumns:\n(`SalesID`, Int64, primary key)\n(`SalesPersonID`, Int64)\n(`CustomerID`, Int64)\n(`ProductID`, Int64)\n(`Quantity`, Int64)\n",
            "Table: `Customers`\nColumns:\n(`CustomerID`, Int64, primary key)\n(`FirstName`, String)\n(`MiddleInitial`, String)\n(`LastName`, String)\n"
        ]
    },
    {
        "sql_id": 366,
        "database_name": "sales",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(T2.Quantity) FROM Products AS T1 INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID WHERE SUBSTR(T1.Name, 1, 1) = 'C'",
        "target_query": "SELECT SUM(`T2`.`Quantity`) FROM `Products` AS `T1` INNER JOIN `Sales` AS `T2` ON `T1`.`ProductID` = `T2`.`ProductID` WHERE substring(`T1`.`Name`, 1, 1) = 'C';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 104,
                "end_index": 125,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 124,
                "end_index": 152,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Products`\nColumns:\n(`ProductID`, integer, primary key)\n(`Name`, text)\n(`Price`, real)\n",
            "Table: `Sales`\nColumns:\n(`SalesID`, integer, primary key)\n(`SalesPersonID`, integer)\n(`CustomerID`, integer)\n(`ProductID`, integer)\n(`Quantity`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `Products`\nColumns:\n(`ProductID`, Int64, primary key)\n(`Name`, String)\n(`Price`, Float64)\n",
            "Table: `Sales`\nColumns:\n(`SalesID`, Int64, primary key)\n(`SalesPersonID`, Int64)\n(`CustomerID`, Int64)\n(`ProductID`, Int64)\n(`Quantity`, Int64)\n"
        ]
    },
    {
        "sql_id": 367,
        "database_name": "sales",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT IIF(SUM(IIF(T1.Name = 'HL Mountain Frame - Silver, 42', T2.SalesID, 0)) - SUM(IIF(T1.Name = 'HL Mountain Frame - Black, 42', T2.SalesID, 0)) > 0, 'Silver', 'Black') FROM Products AS T1 INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID",
        "target_query": "SELECT if(SUM(if(`T1`.`Name` = 'HL Mountain Frame - Silver, 42', `T2`.`SalesID`, 0)) - SUM(if(`T1`.`Name` = 'HL Mountain Frame - Black, 42', `T2`.`SalesID`, 0)) > 0, 'Silver', 'Black') FROM `Products` AS `T1` INNER JOIN `Sales` AS `T2` ON `T1`.`ProductID` = `T2`.`ProductID`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 77,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 85,
                "end_index": 146,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 83,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 91,
                "end_index": 159,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Products`\nColumns:\n(`ProductID`, integer, primary key)\n(`Name`, text)\n(`Price`, real)\n",
            "Table: `Sales`\nColumns:\n(`SalesID`, integer, primary key)\n(`SalesPersonID`, integer)\n(`CustomerID`, integer)\n(`ProductID`, integer)\n(`Quantity`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `Products`\nColumns:\n(`ProductID`, Int64, primary key)\n(`Name`, String)\n(`Price`, Float64)\n",
            "Table: `Sales`\nColumns:\n(`SalesID`, Int64, primary key)\n(`SalesPersonID`, Int64)\n(`CustomerID`, Int64)\n(`ProductID`, Int64)\n(`Quantity`, Int64)\n"
        ]
    },
    {
        "sql_id": 368,
        "database_name": "sales",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T3.FirstName = 'Albert' AND T3.MiddleInitial = 'I' AND T3.LastName = 'Ringer', 1, 0)) AS REAL) * 100 / COUNT(T2.CustomerID) FROM Products AS T1 INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID INNER JOIN Employees AS T3 ON T2.SalesPersonID = T3.EmployeeID WHERE T1.Name = 'ML Bottom Bracket'",
        "target_query": "SELECT SUM(if(`T3`.`FirstName` = 'Albert' AND `T3`.`MiddleInitial` = 'I' AND `T3`.`LastName` = 'Ringer', 1, 0)) * 100 / COUNT(`T2`.`CustomerID`) FROM `Products` AS `T1` INNER JOIN `Sales` AS `T2` ON `T1`.`ProductID` = `T2`.`ProductID` INNER JOIN `Employees` AS `T3` ON `T2`.`SalesPersonID` = `T3`.`EmployeeID` WHERE `T1`.`Name` = 'ML Bottom Bracket';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 104,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 110,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Products`\nColumns:\n(`ProductID`, integer, primary key)\n(`Name`, text)\n(`Price`, real)\n",
            "Table: `Sales`\nColumns:\n(`SalesID`, integer, primary key)\n(`SalesPersonID`, integer)\n(`CustomerID`, integer)\n(`ProductID`, integer)\n(`Quantity`, integer)\n",
            "Table: `Employees`\nColumns:\n(`EmployeeID`, integer, primary key)\n(`FirstName`, text)\n(`MiddleInitial`, text)\n(`LastName`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Products`\nColumns:\n(`ProductID`, Int64, primary key)\n(`Name`, String)\n(`Price`, Float64)\n",
            "Table: `Sales`\nColumns:\n(`SalesID`, Int64, primary key)\n(`SalesPersonID`, Int64)\n(`CustomerID`, Int64)\n(`ProductID`, Int64)\n(`Quantity`, Int64)\n",
            "Table: `Employees`\nColumns:\n(`EmployeeID`, Int64, primary key)\n(`FirstName`, String)\n(`MiddleInitial`, String)\n(`LastName`, String)\n"
        ]
    },
    {
        "sql_id": 369,
        "database_name": "sales",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T1.Price = 0, T2.Quantity, 0)) AS REAL) * 100 / SUM(T2.Quantity)FROM Products AS T1 INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID",
        "target_query": "SELECT SUM(if(`T1`.`Price` = 0, `T2`.`Quantity`, 0)) * 100 / SUM(`T2`.`Quantity`) FROM `Products` AS `T1` INNER JOIN `Sales` AS `T2` ON `T1`.`ProductID` = `T2`.`ProductID`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 49,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 51,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Products`\nColumns:\n(`ProductID`, integer, primary key)\n(`Name`, text)\n(`Price`, real)\n",
            "Table: `Sales`\nColumns:\n(`SalesID`, integer, primary key)\n(`SalesPersonID`, integer)\n(`CustomerID`, integer)\n(`ProductID`, integer)\n(`Quantity`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `Products`\nColumns:\n(`ProductID`, Int64, primary key)\n(`Name`, String)\n(`Price`, Float64)\n",
            "Table: `Sales`\nColumns:\n(`SalesID`, Int64, primary key)\n(`SalesPersonID`, Int64)\n(`CustomerID`, Int64)\n(`ProductID`, Int64)\n(`Quantity`, Int64)\n"
        ]
    },
    {
        "sql_id": 370,
        "database_name": "sales",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T1.Name = 'Blade', T2.Quantity, 0)) AS REAL) * 100 / SUM(T2.Quantity) FROM Products AS T1 INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID",
        "target_query": "SELECT toFloat64(SUM(if(`T1`.`Name` = 'Blade', `T2`.`Quantity`, 0))) * 100 / SUM(`T2`.`Quantity`) FROM `Products` AS `T1` INNER JOIN `Sales` AS `T2` ON `T1`.`ProductID` = `T2`.`ProductID`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 54,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 66,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Products`\nColumns:\n(`ProductID`, integer, primary key)\n(`Name`, text)\n(`Price`, real)\n",
            "Table: `Sales`\nColumns:\n(`SalesID`, integer, primary key)\n(`SalesPersonID`, integer)\n(`CustomerID`, integer)\n(`ProductID`, integer)\n(`Quantity`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `Products`\nColumns:\n(`ProductID`, Int64, primary key)\n(`Name`, String)\n(`Price`, Float64)\n",
            "Table: `Sales`\nColumns:\n(`SalesID`, Int64, primary key)\n(`SalesPersonID`, Int64)\n(`CustomerID`, Int64)\n(`ProductID`, Int64)\n(`Quantity`, Int64)\n"
        ]
    },
    {
        "sql_id": 371,
        "database_name": "sales",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T2.Price BETWEEN 200 AND 300, 1, 0)) AS REAL) * 100 / COUNT(T2.Price) FROM Sales AS T1 INNER JOIN Products AS T2 ON T1.ProductID = T2.ProductID WHERE T1.SalesID BETWEEN 1 AND 200",
        "target_query": "SELECT SUM(if(T2.`Price` BETWEEN 200 AND 300, 1, 0)) * 100 / COUNT(T2.`Price`) FROM `Sales` AS T1 INNER JOIN `Products` AS T2 ON T1.`ProductID` = T2.`ProductID` WHERE T1.`SalesID` BETWEEN 1 AND 200;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 55,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 51,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Sales`\nColumns:\n(`SalesID`, integer, primary key)\n(`SalesPersonID`, integer)\n(`CustomerID`, integer)\n(`ProductID`, integer)\n(`Quantity`, integer)\n",
            "Table: `Products`\nColumns:\n(`ProductID`, integer, primary key)\n(`Name`, text)\n(`Price`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `Sales`\nColumns:\n(`SalesID`, Int64, primary key)\n(`SalesPersonID`, Int64)\n(`CustomerID`, Int64)\n(`ProductID`, Int64)\n(`Quantity`, Int64)\n",
            "Table: `Products`\nColumns:\n(`ProductID`, Int64, primary key)\n(`Name`, String)\n(`Price`, Float64)\n"
        ]
    },
    {
        "sql_id": 573,
        "database_name": "sales_in_weather",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(DISTINCT `date`) AS days FROM weather WHERE sunrise < time('05:00:00')",
        "target_query": "SELECT COUNT(DISTINCT `date`) AS days FROM `weather` WHERE `sunrise` < toDateTime(concat('1970-01-01 ', '05:00:00'));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 67,
                "end_index": 83,
                "dialect_content": "The time(time-value, modifier, modifier, ...) function returns the time as text formatted as HH:MM:SS or HH:MM:SS.SSS if the subsec modifier is used. It accepts a time-value and zero or more modifiers.\nParameters: time-value (e.g., 'now', '14:16:00'), modifiers (e.g., '+1 hour', 'subsec').\nReturns: A string formatted as HH:MM:SS or HH:MM:SS.SSS.",
                "feature": "time(time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "time(time-value, modifier, modifier, ...)",
                "explanation": "The time(time-value, modifier, modifier, ...) function returns the time as text formatted as HH:MM:SS or HH:MM:SS.SSS if the subsec modifier is used. It accepts a time-value and zero or more modifiers.\nParameters: time-value (e.g., 'now', '14:16:00'), modifiers (e.g., '+1 hour', 'subsec').\nReturns: A string formatted as HH:MM:SS or HH:MM:SS.SSS.",
                "examples": [
                    "SELECT time(); -- Returns the current time.",
                    "SELECT time('now', '+1 hour'); -- Returns the time one hour after the current time.",
                    "SELECT time('14:16:00', 'subsec'); -- Returns '14:16:00.000' with milliseconds."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(datetime_expr, format)",
                "explanation": "ClickHouse does not have a native TIME type (unlike MySQL), so operations involving just hours, minutes, and seconds must be done on full DateTime values. To extract or format time-only values like 'HH:MM:SS' or 'HH:MM:SS.SSSSSS', you must convert a full DateTime using `formatDateTime`. If only a time string like '14:16:00' is provided, you must first concatenate it with a default date (e.g., '1970-01-01') and then convert it to DateTime using `toDateTime`. \nParameters: datetime_expr (e.g., NOW(), toDateTime('1970-01-01 14:16:00')), format (e.g., '%H:%i:%s', '%H:%i:%s.%f').\nReturns: A string formatted as 'HH:MM:SS' or 'HH:MM:SS.SSSSSS'.",
                "examples": [
                    "SELECT formatDateTime(NOW(), '%H:%i:%s'); -- Returns the current time, formatted as 'HH:MM:SS'.",
                    "SELECT formatDateTime(NOW(), '%H:%i:%s'); -- Returns the current time, formatted as 'HH:MM:SS'.",
                    "SELECT formatDateTime(toDateTime(concat('1970-01-01 ', '14:16:00')), '%H:%i:%s.%f'); -- Returns '14:16:00.000000' with fractional seconds."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `weather`\nColumns:\n(`station_nbr`, integer, primary key)\n(`date`, date, primary key)\n(`tmax`, integer)\n(`tmin`, integer)\n(`tavg`, integer)\n(`depart`, integer)\n(`dewpoint`, integer)\n(`wetbulb`, integer)\n(`heat`, integer)\n(`cool`, integer)\n(`sunrise`, text)\n(`sunset`, text)\n(`codesum`, text)\n(`snowfall`, real)\n(`preciptotal`, real)\n(`stnpressure`, real)\n(`sealevel`, real)\n(`resultspeed`, real)\n(`resultdir`, integer)\n(`avgspeed`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `weather`\nColumns:\n(`station_nbr`, Int64, primary key)\n(`date`, Date32, primary key)\n(`tmax`, Int64)\n(`tmin`, Int64)\n(`tavg`, Int64)\n(`depart`, Int64)\n(`dewpoint`, Int64)\n(`wetbulb`, Int64)\n(`heat`, Int64)\n(`cool`, Int64)\n(`sunrise`, String)\n(`sunset`, String)\n(`codesum`, String)\n(`snowfall`, Float64)\n(`preciptotal`, Float64)\n(`stnpressure`, Float64)\n(`sealevel`, Float64)\n(`resultspeed`, Float64)\n(`resultdir`, Int64)\n(`avgspeed`, Float64)\n"
        ]
    },
    {
        "sql_id": 238,
        "database_name": "shakespeare",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(T2.Act = 1, 1, 0)) - SUM(IIF(T2.Act = 5, 1, 0)) AS more FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE T1.Title = 'Twelfth Night'",
        "target_query": "SELECT SUM(if(T2.`Act` = 1, 1, 0)) - SUM(if(T2.`Act` = 5, 1, 0)) AS `more` FROM `works` AS T1 INNER JOIN `chapters` AS T2 ON T1.`id` = T2.`work_id` WHERE T1.`Title` = 'Twelfth Night';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 32,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 40,
                "end_index": 61,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 33,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 41,
                "end_index": 63,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `works`\nColumns:\n(`id`, integer, primary key)\n(`Title`, text)\n(`LongTitle`, text)\n(`Date`, integer)\n(`GenreType`, text)\n",
            "Table: `chapters`\nColumns:\n(`id`, integer, primary key)\n(`Act`, integer)\n(`Scene`, integer)\n(`Description`, text)\n(`work_id`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `works`\nColumns:\n(`id`, Int64, primary key)\n(`Title`, String)\n(`LongTitle`, String)\n(`Date`, Int64)\n(`GenreType`, String)\n",
            "Table: `chapters`\nColumns:\n(`id`, Int64, primary key)\n(`Act`, Int64)\n(`Scene`, Int64)\n(`Description`, String)\n(`work_id`, Int64)\n"
        ]
    },
    {
        "sql_id": 239,
        "database_name": "shakespeare",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T2.GenreType = 'Tragedy', 1, 0)) AS REAL) * 100 / COUNT(T1.Scene) FROM chapters AS T1 INNER JOIN works AS T2 ON T1.work_id = T2.id WHERE T2.Date = '1594'",
        "target_query": "SELECT toFloat64(SUM(if(`T2`.`GenreType` = 'Tragedy', 1, 0))) * 100 / COUNT(`T1`.`Scene`) FROM `chapters` AS `T1` INNER JOIN `works` AS `T2` ON `T1`.`work_id` = `T2`.`id` WHERE `T2`.`Date` = 1594;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 51,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 21,
                "end_index": 59,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `chapters`\nColumns:\n(`id`, integer, primary key)\n(`Act`, integer)\n(`Scene`, integer)\n(`Description`, text)\n(`work_id`, integer)\n",
            "Table: `works`\nColumns:\n(`id`, integer, primary key)\n(`Title`, text)\n(`LongTitle`, text)\n(`Date`, integer)\n(`GenreType`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `chapters`\nColumns:\n(`id`, Int64, primary key)\n(`Act`, Int64)\n(`Scene`, Int64)\n(`Description`, String)\n(`work_id`, Int64)\n",
            "Table: `works`\nColumns:\n(`id`, Int64, primary key)\n(`Title`, String)\n(`LongTitle`, String)\n(`Date`, Int64)\n(`GenreType`, String)\n"
        ]
    },
    {
        "sql_id": 240,
        "database_name": "shakespeare",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(T4.CharName = 'Romeo', 1, 0)), SUM(IIF(T4.CharName = 'Juliet', 1, 0)), CAST(SUM(IIF(T4.CharName = 'Romeo', 1, 0)) + SUM(IIF(T4.CharName = 'Juliet', 1, 0)) AS REAL) * 100 / COUNT(T1.id) FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id INNER JOIN characters AS T4 ON T3.character_id = T4.id",
        "target_query": "SELECT SUM(if(`T4`.`CharName` = 'Romeo', 1, 0)), SUM(if(`T4`.`CharName` = 'Juliet', 1, 0)), CAST(SUM(if(`T4`.`CharName` = 'Romeo', 1, 0)) + SUM(if(`T4`.`CharName` = 'Juliet', 1, 0)) AS Float64) * 100 / COUNT(`T1`.`id`) FROM `works` AS `T1` INNER JOIN `chapters` AS `T2` ON `T1`.`id` = `T2`.`work_id` INNER JOIN `paragraphs` AS `T3` ON `T2`.`id` = `T3`.`chapter_id` INNER JOIN `characters` AS `T4` ON `T3`.`character_id` = `T4`.`id`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 43,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 50,
                "end_index": 83,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 95,
                "end_index": 127,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 135,
                "end_index": 168,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 46,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 53,
                "end_index": 89,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 101,
                "end_index": 136,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 144,
                "end_index": 180,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `works`\nColumns:\n(`id`, integer, primary key)\n(`Title`, text)\n(`LongTitle`, text)\n(`Date`, integer)\n(`GenreType`, text)\n",
            "Table: `chapters`\nColumns:\n(`id`, integer, primary key)\n(`Act`, integer)\n(`Scene`, integer)\n(`Description`, text)\n(`work_id`, integer)\n",
            "Table: `paragraphs`\nColumns:\n(`id`, integer, primary key)\n(`ParagraphNum`, integer)\n(`PlainText`, text)\n(`character_id`, integer)\n(`chapter_id`, integer)\n",
            "Table: `characters`\nColumns:\n(`id`, integer, primary key)\n(`CharName`, text)\n(`Abbrev`, text)\n(`Description`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `works`\nColumns:\n(`id`, Int64, primary key)\n(`Title`, String)\n(`LongTitle`, String)\n(`Date`, Int64)\n(`GenreType`, String)\n",
            "Table: `chapters`\nColumns:\n(`id`, Int64, primary key)\n(`Act`, Int64)\n(`Scene`, Int64)\n(`Description`, String)\n(`work_id`, Int64)\n",
            "Table: `paragraphs`\nColumns:\n(`id`, Int64, primary key)\n(`ParagraphNum`, Int64)\n(`PlainText`, String)\n(`character_id`, Int64)\n(`chapter_id`, Int64)\n",
            "Table: `characters`\nColumns:\n(`id`, Int64, primary key)\n(`CharName`, String)\n(`Abbrev`, String)\n(`Description`, String)\n"
        ]
    },
    {
        "sql_id": 241,
        "database_name": "shakespeare",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T1.Title = 'All''s Well That Ends Well', 1, 0)) AS REAL) * 100 / COUNT(T3.id) FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id",
        "target_query": "SELECT CAST(SUM(if(`T1`.`Title` = 'All''s Well That Ends Well', 1, 0)) AS Float64) * 100 / COUNT(`T3`.`id`) FROM `works` AS `T1` INNER JOIN `chapters` AS `T2` ON `T1`.`id` = `T2`.`work_id` INNER JOIN `paragraphs` AS `T3` ON `T2`.`id` = `T3`.`chapter_id`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 66,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 69,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `works`\nColumns:\n(`id`, integer, primary key)\n(`Title`, text)\n(`LongTitle`, text)\n(`Date`, integer)\n(`GenreType`, text)\n",
            "Table: `chapters`\nColumns:\n(`id`, integer, primary key)\n(`Act`, integer)\n(`Scene`, integer)\n(`Description`, text)\n(`work_id`, integer)\n",
            "Table: `paragraphs`\nColumns:\n(`id`, integer, primary key)\n(`ParagraphNum`, integer)\n(`PlainText`, text)\n(`character_id`, integer)\n(`chapter_id`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `works`\nColumns:\n(`id`, Int64, primary key)\n(`Title`, String)\n(`LongTitle`, String)\n(`Date`, Int64)\n(`GenreType`, String)\n",
            "Table: `chapters`\nColumns:\n(`id`, Int64, primary key)\n(`Act`, Int64)\n(`Scene`, Int64)\n(`Description`, String)\n(`work_id`, Int64)\n",
            "Table: `paragraphs`\nColumns:\n(`id`, Int64, primary key)\n(`ParagraphNum`, Int64)\n(`PlainText`, String)\n(`character_id`, Int64)\n(`chapter_id`, Int64)\n"
        ]
    },
    {
        "sql_id": 242,
        "database_name": "shakespeare",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(GenreType = 'Comedy', 1, 0)) - SUM(IIF(GenreType = 'History', 1, 0)) FROM works WHERE Date > 1593",
        "target_query": "SELECT SUM(if(`GenreType` = 'Comedy', 1, 0)) - SUM(if(`GenreType` = 'History', 1, 0)) FROM `works` WHERE `Date` > 1593;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 42,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 50,
                "end_index": 82,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 43,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 51,
                "end_index": 84,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `works`\nColumns:\n(`id`, integer, primary key)\n(`Title`, text)\n(`LongTitle`, text)\n(`Date`, integer)\n(`GenreType`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `works`\nColumns:\n(`id`, Int64, primary key)\n(`Title`, String)\n(`LongTitle`, String)\n(`Date`, Int64)\n(`GenreType`, String)\n"
        ]
    },
    {
        "sql_id": 243,
        "database_name": "shakespeare",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T2.act = 5, 1, 0)) AS REAL) * 100 / COUNT(T2.act) FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE T1.Title = 'Titus Andronicus'",
        "target_query": "SELECT SUM(if(T2.Act = 5, 1, 0)) * 100 / COUNT(T2.Act) FROM `works` AS T1 INNER JOIN `chapters` AS T2 ON T1.id = T2.work_id WHERE T1.`Title` = 'Titus Andronicus';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 37,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 31,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `works`\nColumns:\n(`id`, integer, primary key)\n(`Title`, text)\n(`LongTitle`, text)\n(`Date`, integer)\n(`GenreType`, text)\n",
            "Table: `chapters`\nColumns:\n(`id`, integer, primary key)\n(`Act`, integer)\n(`Scene`, integer)\n(`Description`, text)\n(`work_id`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `works`\nColumns:\n(`id`, Int64, primary key)\n(`Title`, String)\n(`LongTitle`, String)\n(`Date`, Int64)\n(`GenreType`, String)\n",
            "Table: `chapters`\nColumns:\n(`id`, Int64, primary key)\n(`Act`, Int64)\n(`Scene`, Int64)\n(`Description`, String)\n(`work_id`, Int64)\n"
        ]
    },
    {
        "sql_id": 244,
        "database_name": "shakespeare",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.LongTitle FROM works AS T1 RIGHT JOIN chapters AS T2 ON T1.id = T2.work_id WHERE T2.Description = 'Mytilene. A street before the brothel.'",
        "target_query": "SELECT `T1`.`LongTitle` FROM `works` AS `T1` RIGHT JOIN `chapters` AS `T2` ON `T1`.`id` = `T2`.`work_id` WHERE `T2`.`Description` = 'Mytilene. A street before the brothel.';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [],
        "target_dialect_knowledge": [],
        "source_related_schemas": [
            "Table: `works`\nColumns:\n(`id`, integer, primary key)\n(`Title`, text)\n(`LongTitle`, text)\n(`Date`, integer)\n(`GenreType`, text)\n",
            "Table: `chapters`\nColumns:\n(`id`, integer, primary key)\n(`Act`, integer)\n(`Scene`, integer)\n(`Description`, text)\n(`work_id`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `works`\nColumns:\n(`id`, Int64, primary key)\n(`Title`, String)\n(`LongTitle`, String)\n(`Date`, Int64)\n(`GenreType`, String)\n",
            "Table: `chapters`\nColumns:\n(`id`, Int64, primary key)\n(`Act`, Int64)\n(`Scene`, Int64)\n(`Description`, String)\n(`work_id`, Int64)\n"
        ]
    },
    {
        "sql_id": 245,
        "database_name": "shakespeare",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.Description FROM works AS T1 RIGHT JOIN chapters AS T2 ON T1.id = T2.work_id WHERE T1.Title = 'Venus and Adonis' ORDER BY T2.Scene DESC LIMIT 1",
        "target_query": "SELECT `T2`.`Description` FROM `chapters` AS `T2` LEFT JOIN `works` AS `T1` ON `T1`.`id` = `T2`.`work_id` WHERE `T1`.`Title` = 'Venus and Adonis' ORDER BY `T2`.`Scene` DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [],
        "target_dialect_knowledge": [],
        "source_related_schemas": [
            "Table: `works`\nColumns:\n(`id`, integer, primary key)\n(`Title`, text)\n(`LongTitle`, text)\n(`Date`, integer)\n(`GenreType`, text)\n",
            "Table: `chapters`\nColumns:\n(`id`, integer, primary key)\n(`Act`, integer)\n(`Scene`, integer)\n(`Description`, text)\n(`work_id`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `works`\nColumns:\n(`id`, Int64, primary key)\n(`Title`, String)\n(`LongTitle`, String)\n(`Date`, Int64)\n(`GenreType`, String)\n",
            "Table: `chapters`\nColumns:\n(`id`, Int64, primary key)\n(`Act`, Int64)\n(`Scene`, Int64)\n(`Description`, String)\n(`work_id`, Int64)\n"
        ]
    },
    {
        "sql_id": 246,
        "database_name": "shakespeare",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T4.CharName = 'antonio', 1, 0)) AS REAL) * 100 / COUNT(T1.id) FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id INNER JOIN characters AS T4 ON T3.character_id = T4.id WHERE T1.GenreType = 'Comedy'",
        "target_query": "SELECT CAST(SUM(if(`T4`.`CharName` = 'antonio', 1, 0)) AS Float64) * 100 / COUNT(`T1`.`id`) FROM `works` AS `T1` INNER JOIN `chapters` AS `T2` ON `T1`.`id` = `T2`.`work_id` INNER JOIN `paragraphs` AS `T3` ON `T2`.`id` = `T3`.`chapter_id` INNER JOIN `characters` AS `T4` ON `T3`.`character_id` = `T4`.`id` WHERE `T1`.`GenreType` = 'Comedy';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 50,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 53,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `works`\nColumns:\n(`id`, integer, primary key)\n(`Title`, text)\n(`LongTitle`, text)\n(`Date`, integer)\n(`GenreType`, text)\n",
            "Table: `chapters`\nColumns:\n(`id`, integer, primary key)\n(`Act`, integer)\n(`Scene`, integer)\n(`Description`, text)\n(`work_id`, integer)\n",
            "Table: `paragraphs`\nColumns:\n(`id`, integer, primary key)\n(`ParagraphNum`, integer)\n(`PlainText`, text)\n(`character_id`, integer)\n(`chapter_id`, integer)\n",
            "Table: `characters`\nColumns:\n(`id`, integer, primary key)\n(`CharName`, text)\n(`Abbrev`, text)\n(`Description`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `works`\nColumns:\n(`id`, Int64, primary key)\n(`Title`, String)\n(`LongTitle`, String)\n(`Date`, Int64)\n(`GenreType`, String)\n",
            "Table: `chapters`\nColumns:\n(`id`, Int64, primary key)\n(`Act`, Int64)\n(`Scene`, Int64)\n(`Description`, String)\n(`work_id`, Int64)\n",
            "Table: `paragraphs`\nColumns:\n(`id`, Int64, primary key)\n(`ParagraphNum`, Int64)\n(`PlainText`, String)\n(`character_id`, Int64)\n(`chapter_id`, Int64)\n",
            "Table: `characters`\nColumns:\n(`id`, Int64, primary key)\n(`CharName`, String)\n(`Abbrev`, String)\n(`Description`, String)\n"
        ]
    },
    {
        "sql_id": 207,
        "database_name": "shooting",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(race = 'W', 1, 0)) AS REAL) * 100 / COUNT(case_number) FROM officers WHERE gender = 'M'",
        "target_query": "SELECT CAST(SUM(if(`race` = 'W', 1, 0)) AS Float64) * 100 / COUNT(`case_number`) FROM `officers` WHERE `gender` = 'M';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 37,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 38,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `officers`\nColumns:\n(`case_number`, text)\n(`race`, text)\n(`gender`, text)\n(`last_name`, text)\n(`first_name`, text)\n(`full_name`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `officers`\nColumns:\n(`case_number`, String)\n(`race`, String)\n(`gender`, String)\n(`last_name`, String)\n(`first_name`, String)\n(`full_name`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 210,
        "database_name": "shooting",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(STRFTIME('%Y', date) = '2007', 1, 0)) - SUM(IIF(STRFTIME('%Y', date) = '2008', 1, 0)) FROM incidents WHERE subject_weapon = 'Vehicle'",
        "target_query": "SELECT SUM(if(formatDateTime(`date`, '%Y') = '2007', 1, 0)) - SUM(if(formatDateTime(`date`, '%Y') = '2008', 1, 0)) FROM `incidents` WHERE `subject_weapon` = 'Vehicle';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 35,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 59,
                "end_index": 83,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 42,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 66,
                "end_index": 97,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            },
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            },
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `incidents`\nColumns:\n(`case_number`, text, primary key)\n(`date`, date)\n(`location`, text)\n(`subject_statuses`, text)\n(`subject_weapon`, text)\n(`subjects`, text)\n(`subject_count`, integer)\n(`officers`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `incidents`\nColumns:\n(`case_number`, String, primary key)\n(`date`, Date32)\n(`location`, String)\n(`subject_statuses`, String)\n(`subject_weapon`, String)\n(`subjects`, String)\n(`subject_count`, Int64)\n(`officers`, String)\n"
        ]
    },
    {
        "sql_id": 211,
        "database_name": "shooting",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT case_number FROM incidents WHERE STRFTIME('%Y', date) > '2011' AND subject_statuses = 'Deceased'",
        "target_query": "SELECT `case_number` FROM `incidents` WHERE formatDateTime(`date`, '%Y') > '2011' AND `subject_statuses` = 'Deceased';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 40,
                "end_index": 60,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 44,
                "end_index": 72,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `incidents`\nColumns:\n(`case_number`, text, primary key)\n(`date`, date)\n(`location`, text)\n(`subject_statuses`, text)\n(`subject_weapon`, text)\n(`subjects`, text)\n(`subject_count`, integer)\n(`officers`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `incidents`\nColumns:\n(`case_number`, String, primary key)\n(`date`, Date32)\n(`location`, String)\n(`subject_statuses`, String)\n(`subject_weapon`, String)\n(`subjects`, String)\n(`subject_count`, Int64)\n(`officers`, String)\n"
        ]
    },
    {
        "sql_id": 255,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(name) FROM Person WHERE birth_region = 'New York' AND SUBSTR(birthdate, 1, 4) > '1970';",
        "target_query": "SELECT COUNT(`name`) FROM `Person` WHERE `birth_region` = 'New York' AND substring(`birthdate`, 1, 4) > '1970';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 67,
                "end_index": 90,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 73,
                "end_index": 101,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`name`, text, primary key)\n(`birthdate`, text)\n(`birth_name`, text)\n(`birth_place`, text)\n(`birth_region`, text)\n(`birth_country`, text)\n(`height_meters`, real)\n(`nickname`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Person`\nColumns:\n(`name`, String, primary key)\n(`birthdate`, String)\n(`birth_name`, String)\n(`birth_place`, String)\n(`birth_region`, String)\n(`birth_country`, String)\n(`height_meters`, Float64)\n(`nickname`, String)\n"
        ]
    },
    {
        "sql_id": 256,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.rating FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE T1.award = 'Outstanding Voice-Over Performance' AND SUBSTR(T1.year, 1, 4) = '2009' AND T1.person = 'Dan Castellaneta';",
        "target_query": "SELECT T2.`rating` FROM `Award` AS T1 INNER JOIN `Episode` AS T2 ON T1.`episode_id` = T2.`episode_id` WHERE T1.`award` = 'Outstanding Voice-Over Performance' AND substring(CAST(T1.`year` AS String), 1, 4) = '2009' AND T1.`person` = 'Dan Castellaneta';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 150,
                "end_index": 171,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 162,
                "end_index": 197,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, integer, primary key)\n(`organization`, text)\n(`year`, integer)\n(`award_category`, text)\n(`award`, text)\n(`person`, text)\n(`role`, text)\n(`episode_id`, text)\n(`season`, text)\n(`song`, text)\n(`result`, text)\n",
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, Int64, primary key)\n(`organization`, String)\n(`year`, Int64)\n(`award_category`, String)\n(`award`, String)\n(`person`, String)\n(`_role`, String)\n(`episode_id`, String)\n(`season`, String)\n(`song`, String)\n(`result`, String)\n",
            "Table: `Episode`\nColumns:\n(`episode_id`, String, primary key)\n(`season`, Int64)\n(`episode`, Int64)\n(`number_in_series`, Int64)\n(`title`, String)\n(`summary`, String)\n(`air_date`, String)\n(`episode_image`, String)\n(`rating`, Float64)\n(`votes`, Int64)\n"
        ]
    },
    {
        "sql_id": 257,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(*) FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE SUBSTR(T1.air_date, 1, 4) = '2009' AND T2.stars = 10 AND T2.percent > 15;",
        "target_query": "SELECT COUNT(*) FROM `Episode` AS `T1` INNER JOIN `Vote` AS `T2` ON `T2`.`episode_id` = `T1`.`episode_id` WHERE substring(`T1`.`air_date`, 1, 4) = '2009' AND `T2`.`stars` = 10 AND `T2`.`percent` > 15;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 96,
                "end_index": 121,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 112,
                "end_index": 144,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n",
            "Table: `Vote`\nColumns:\n(`episode_id`, text)\n(`stars`, integer)\n(`votes`, integer)\n(`percent`, real)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, String, primary key)\n(`season`, Int64)\n(`episode`, Int64)\n(`number_in_series`, Int64)\n(`title`, String)\n(`summary`, String)\n(`air_date`, String)\n(`episode_image`, String)\n(`rating`, Float64)\n(`votes`, Int64)\n",
            "Table: `Vote`\nColumns:\n(`episode_id`, String)\n(`stars`, Int64)\n(`votes`, Int64)\n(`percent`, Float64)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 259,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.title FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE SUBSTR(T1.year, 1, 4) = '2017' AND T1.award = 'Best International TV Series' AND T1.result = 'Winner';",
        "target_query": "SELECT T2.`title` FROM `Award` AS T1 INNER JOIN `Episode` AS T2 ON T1.`episode_id` = T2.`episode_id` WHERE substring(toString(T1.`year`), 1, 4) = '2017' AND T1.`award` = 'Best International TV Series' AND T1.`result` = 'Winner';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 97,
                "end_index": 118,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 107,
                "end_index": 136,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, integer, primary key)\n(`organization`, text)\n(`year`, integer)\n(`award_category`, text)\n(`award`, text)\n(`person`, text)\n(`role`, text)\n(`episode_id`, text)\n(`season`, text)\n(`song`, text)\n(`result`, text)\n",
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, Int64, primary key)\n(`organization`, String)\n(`year`, Int64)\n(`award_category`, String)\n(`award`, String)\n(`person`, String)\n(`_role`, String)\n(`episode_id`, String)\n(`season`, String)\n(`song`, String)\n(`result`, String)\n",
            "Table: `Episode`\nColumns:\n(`episode_id`, String, primary key)\n(`season`, Int64)\n(`episode`, Int64)\n(`number_in_series`, Int64)\n(`title`, String)\n(`summary`, String)\n(`air_date`, String)\n(`episode_image`, String)\n(`rating`, Float64)\n(`votes`, Int64)\n"
        ]
    },
    {
        "sql_id": 260,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT T2.person FROM Episode AS T1 INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE SUBSTR(T1.air_date, 6, 2) BETWEEN '10' AND '11';",
        "target_query": "SELECT DISTINCT `T2`.`person` FROM `Episode` AS `T1` INNER JOIN `Credit` AS `T2` ON `T1`.`episode_id` = `T2`.`episode_id` WHERE substring(`T1`.`air_date`, 6, 2) BETWEEN '10' AND '11';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 108,
                "end_index": 133,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 128,
                "end_index": 160,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n",
            "Table: `Credit`\nColumns:\n(`episode_id`, text)\n(`category`, text)\n(`person`, text)\n(`role`, text)\n(`credited`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, String, primary key)\n(`season`, Int64)\n(`episode`, Int64)\n(`number_in_series`, Int64)\n(`title`, String)\n(`summary`, String)\n(`air_date`, String)\n(`episode_image`, String)\n(`rating`, Float64)\n(`votes`, Int64)\n",
            "Table: `Credit`\nColumns:\n(`episode_id`, String)\n(`category`, String)\n(`person`, String)\n(`_role`, String)\n(`credited`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 261,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.year - CAST(SUBSTR(T1.birthdate, 1, 4) AS int) AS age FROM Person AS T1 INNER JOIN Award AS T2 ON T1.name = T2.person WHERE T2.award = 'Outstanding Voice-Over Performance' AND T2.organization = 'Primetime Emmy Awards' AND T2.result = 'Winner';",
        "target_query": "SELECT `T2`.`year` - CAST(substring(`T1`.`birthdate`, 1, 4) AS Int32) AS `age` FROM `Person` AS `T1` INNER JOIN `Award` AS `T2` ON `T1`.`name` = `T2`.`person` WHERE `T2`.`award` = 'Outstanding Voice-Over Performance' AND `T2`.`organization` = 'Primetime Emmy Awards' AND `T2`.`result` = 'Winner';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 22,
                "end_index": 48,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 26,
                "end_index": 59,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`name`, text, primary key)\n(`birthdate`, text)\n(`birth_name`, text)\n(`birth_place`, text)\n(`birth_region`, text)\n(`birth_country`, text)\n(`height_meters`, real)\n(`nickname`, text)\n",
            "Table: `Award`\nColumns:\n(`award_id`, integer, primary key)\n(`organization`, text)\n(`year`, integer)\n(`award_category`, text)\n(`award`, text)\n(`person`, text)\n(`role`, text)\n(`episode_id`, text)\n(`season`, text)\n(`song`, text)\n(`result`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Person`\nColumns:\n(`name`, String, primary key)\n(`birthdate`, String)\n(`birth_name`, String)\n(`birth_place`, String)\n(`birth_region`, String)\n(`birth_country`, String)\n(`height_meters`, Float64)\n(`nickname`, String)\n",
            "Table: `Award`\nColumns:\n(`award_id`, Int64, primary key)\n(`organization`, String)\n(`year`, Int64)\n(`award_category`, String)\n(`award`, String)\n(`person`, String)\n(`_role`, String)\n(`episode_id`, String)\n(`season`, String)\n(`song`, String)\n(`result`, String)\n"
        ]
    },
    {
        "sql_id": 264,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT episode, title, rating FROM Episode WHERE SUBSTR(air_date, 1, 7) LIKE '2008-10%';",
        "target_query": "SELECT `episode`, `title`, `rating` FROM `Episode` WHERE substring(`air_date`, 1, 7) LIKE '2008-10%';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 49,
                "end_index": 71,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 57,
                "end_index": 84,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, String, primary key)\n(`season`, Int64)\n(`episode`, Int64)\n(`number_in_series`, Int64)\n(`title`, String)\n(`summary`, String)\n(`air_date`, String)\n(`episode_image`, String)\n(`rating`, Float64)\n(`votes`, Int64)\n"
        ]
    },
    {
        "sql_id": 265,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.title, T2.episode_image, T1.award, T1.person FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE T2.rating BETWEEN 7 AND 10 AND SUBSTR(T2.air_date, 1, 4) = '2008' AND T1.result = 'Nominee';",
        "target_query": "SELECT `T2`.`title`, `T2`.`episode_image`, `T1`.`award`, `T1`.`person` FROM `Award` AS `T1` INNER JOIN `Episode` AS `T2` ON `T1`.`episode_id` = `T2`.`episode_id` WHERE `T2`.`rating` BETWEEN 7 AND 10 AND substring(`T2`.`air_date`, 1, 4) = '2008' AND `T1`.`result` = 'Nominee';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 167,
                "end_index": 192,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 203,
                "end_index": 235,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, integer, primary key)\n(`organization`, text)\n(`year`, integer)\n(`award_category`, text)\n(`award`, text)\n(`person`, text)\n(`role`, text)\n(`episode_id`, text)\n(`season`, text)\n(`song`, text)\n(`result`, text)\n",
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, Int64, primary key)\n(`organization`, String)\n(`year`, Int64)\n(`award_category`, String)\n(`award`, String)\n(`person`, String)\n(`_role`, String)\n(`episode_id`, String)\n(`season`, String)\n(`song`, String)\n(`result`, String)\n",
            "Table: `Episode`\nColumns:\n(`episode_id`, String, primary key)\n(`season`, Int64)\n(`episode`, Int64)\n(`number_in_series`, Int64)\n(`title`, String)\n(`summary`, String)\n(`air_date`, String)\n(`episode_image`, String)\n(`rating`, Float64)\n(`votes`, Int64)\n"
        ]
    },
    {
        "sql_id": 266,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.name, T1.birth_place, T2.role, 2022 - CAST(SUBSTR(T1.birthdate, 1, 4) AS int) AS age FROM Person AS T1 INNER JOIN Credit AS T2 ON T1.name = T2.person WHERE T1.birthdate IS NOT NULL ORDER BY T1.birthdate LIMIT 1;",
        "target_query": "SELECT `T1`.`name`, `T1`.`birth_place`, `T2`.`_role`, 2022 - CAST(substring(`T1`.`birthdate`, 1, 4) AS Int32) AS `age` FROM `Person` AS `T1` INNER JOIN `Credit` AS `T2` ON `T1`.`name` = `T2`.`person` WHERE `T1`.`birthdate` IS NOT NULL ORDER BY `T1`.`birthdate` LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 53,
                "end_index": 79,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 66,
                "end_index": 99,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`name`, text, primary key)\n(`birthdate`, text)\n(`birth_name`, text)\n(`birth_place`, text)\n(`birth_region`, text)\n(`birth_country`, text)\n(`height_meters`, real)\n(`nickname`, text)\n",
            "Table: `Credit`\nColumns:\n(`episode_id`, text)\n(`category`, text)\n(`person`, text)\n(`role`, text)\n(`credited`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `Person`\nColumns:\n(`name`, String, primary key)\n(`birthdate`, String)\n(`birth_name`, String)\n(`birth_place`, String)\n(`birth_region`, String)\n(`birth_country`, String)\n(`height_meters`, Float64)\n(`nickname`, String)\n",
            "Table: `Credit`\nColumns:\n(`episode_id`, String)\n(`category`, String)\n(`person`, String)\n(`_role`, String)\n(`credited`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 268,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(award_id) FROM Award WHERE person = 'Billy Kimball' AND SUBSTR(year, 1, 4) = '2010' AND result = 'Nominee';",
        "target_query": "SELECT COUNT(`award_id`) FROM `Award` WHERE `person` = 'Billy Kimball' AND substring(toString(`year`), 1, 4) = '2010' AND `result` = 'Nominee';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 69,
                "end_index": 87,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 75,
                "end_index": 101,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, integer, primary key)\n(`organization`, text)\n(`year`, integer)\n(`award_category`, text)\n(`award`, text)\n(`person`, text)\n(`role`, text)\n(`episode_id`, text)\n(`season`, text)\n(`song`, text)\n(`result`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, Int64, primary key)\n(`organization`, String)\n(`year`, Int64)\n(`award_category`, String)\n(`award`, String)\n(`person`, String)\n(`_role`, String)\n(`episode_id`, String)\n(`season`, String)\n(`song`, String)\n(`result`, String)\n"
        ]
    },
    {
        "sql_id": 269,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT name FROM Person WHERE SUBSTR(birthdate, 1, 4) < '1970';",
        "target_query": "SELECT `name` FROM `Person` WHERE substring(`birthdate`, 1, 4) < '1970';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 30,
                "end_index": 53,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 34,
                "end_index": 62,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`name`, text, primary key)\n(`birthdate`, text)\n(`birth_name`, text)\n(`birth_place`, text)\n(`birth_region`, text)\n(`birth_country`, text)\n(`height_meters`, real)\n(`nickname`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Person`\nColumns:\n(`name`, String, primary key)\n(`birthdate`, String)\n(`birth_name`, String)\n(`birth_place`, String)\n(`birth_region`, String)\n(`birth_country`, String)\n(`height_meters`, Float64)\n(`nickname`, String)\n"
        ]
    },
    {
        "sql_id": 270,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT name FROM Person WHERE SUBSTR(birthdate, 1, 4) = '1958' AND birth_place = 'California' AND birth_country = 'USA';",
        "target_query": "SELECT `name` FROM `Person` WHERE substring(`birthdate`, 1, 4) = '1958' AND `birth_place` = 'California' AND `birth_country` = 'USA';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 30,
                "end_index": 53,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 34,
                "end_index": 62,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`name`, text, primary key)\n(`birthdate`, text)\n(`birth_name`, text)\n(`birth_place`, text)\n(`birth_region`, text)\n(`birth_country`, text)\n(`height_meters`, real)\n(`nickname`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Person`\nColumns:\n(`name`, String, primary key)\n(`birthdate`, String)\n(`birth_name`, String)\n(`birth_place`, String)\n(`birth_region`, String)\n(`birth_country`, String)\n(`height_meters`, Float64)\n(`nickname`, String)\n"
        ]
    },
    {
        "sql_id": 271,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.person FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE SUBSTR(T1.year, 1, 4) = '2009' AND T1.role = 'writer' AND T2.votes > 5;",
        "target_query": "SELECT `T1`.`person` FROM `Award` AS `T1` INNER JOIN `Episode` AS `T2` ON `T1`.`episode_id` = `T2`.`episode_id` WHERE substring(toString(`T1`.`year`), 1, 4) = '2009' AND `T1`.`_role` = 'writer' AND `T2`.`votes` > 5;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 98,
                "end_index": 119,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 118,
                "end_index": 149,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, integer, primary key)\n(`organization`, text)\n(`year`, integer)\n(`award_category`, text)\n(`award`, text)\n(`person`, text)\n(`role`, text)\n(`episode_id`, text)\n(`season`, text)\n(`song`, text)\n(`result`, text)\n",
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, Int64, primary key)\n(`organization`, String)\n(`year`, Int64)\n(`award_category`, String)\n(`award`, String)\n(`person`, String)\n(`_role`, String)\n(`episode_id`, String)\n(`season`, String)\n(`song`, String)\n(`result`, String)\n",
            "Table: `Episode`\nColumns:\n(`episode_id`, String, primary key)\n(`season`, Int64)\n(`episode`, Int64)\n(`number_in_series`, Int64)\n(`title`, String)\n(`summary`, String)\n(`air_date`, String)\n(`episode_image`, String)\n(`rating`, Float64)\n(`votes`, Int64)\n"
        ]
    },
    {
        "sql_id": 273,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT name FROM Person WHERE SUBSTR(birthdate, 1, 4) = '1962' AND birth_region = 'California';",
        "target_query": "SELECT `name` FROM `Person` WHERE substring(`birthdate`, 1, 4) = '1962' AND `birth_region` = 'California';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 30,
                "end_index": 53,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 34,
                "end_index": 62,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`name`, text, primary key)\n(`birthdate`, text)\n(`birth_name`, text)\n(`birth_place`, text)\n(`birth_region`, text)\n(`birth_country`, text)\n(`height_meters`, real)\n(`nickname`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Person`\nColumns:\n(`name`, String, primary key)\n(`birthdate`, String)\n(`birth_name`, String)\n(`birth_place`, String)\n(`birth_region`, String)\n(`birth_country`, String)\n(`height_meters`, Float64)\n(`nickname`, String)\n"
        ]
    },
    {
        "sql_id": 274,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.episode_id FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE SUBSTR(T1.air_date, 1, 4) = '2008' ORDER BY T2.votes DESC LIMIT 1;",
        "target_query": "SELECT `T1`.`episode_id` FROM `Episode` AS `T1` INNER JOIN `Vote` AS `T2` ON `T2`.`episode_id` = `T1`.`episode_id` WHERE substring(`T1`.`air_date`, 1, 4) = '2008' ORDER BY `T2`.`votes` DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 101,
                "end_index": 126,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 121,
                "end_index": 153,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n",
            "Table: `Vote`\nColumns:\n(`episode_id`, text)\n(`stars`, integer)\n(`votes`, integer)\n(`percent`, real)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, String, primary key)\n(`season`, Int64)\n(`episode`, Int64)\n(`number_in_series`, Int64)\n(`title`, String)\n(`summary`, String)\n(`air_date`, String)\n(`episode_image`, String)\n(`rating`, Float64)\n(`votes`, Int64)\n",
            "Table: `Vote`\nColumns:\n(`episode_id`, String)\n(`stars`, Int64)\n(`votes`, Int64)\n(`percent`, Float64)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 275,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.title FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE SUBSTR(T1.year, 1, 4) = '2010' AND T1.person = 'Joel H. Cohen';",
        "target_query": "SELECT T2.`title` FROM `Award` AS T1 INNER JOIN `Episode` AS T2 ON T1.`episode_id` = T2.`episode_id` WHERE substring(toString(T1.`year`), 1, 4) = '2010' AND T1.`person` = 'Joel H. Cohen';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 97,
                "end_index": 118,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 107,
                "end_index": 136,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, integer, primary key)\n(`organization`, text)\n(`year`, integer)\n(`award_category`, text)\n(`award`, text)\n(`person`, text)\n(`role`, text)\n(`episode_id`, text)\n(`season`, text)\n(`song`, text)\n(`result`, text)\n",
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, Int64, primary key)\n(`organization`, String)\n(`year`, Int64)\n(`award_category`, String)\n(`award`, String)\n(`person`, String)\n(`_role`, String)\n(`episode_id`, String)\n(`season`, String)\n(`song`, String)\n(`result`, String)\n",
            "Table: `Episode`\nColumns:\n(`episode_id`, String, primary key)\n(`season`, Int64)\n(`episode`, Int64)\n(`number_in_series`, Int64)\n(`title`, String)\n(`summary`, String)\n(`air_date`, String)\n(`episode_image`, String)\n(`rating`, Float64)\n(`votes`, Int64)\n"
        ]
    },
    {
        "sql_id": 276,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(CASE WHEN birth_region = 'California' AND SUBSTR(birthdate, 1, 4) > '1970' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(birthdate) FROM Person;",
        "target_query": "SELECT CAST(SUM(CASE WHEN `birth_region` = 'California' AND substring(`birthdate`, 1, 4) > '1970' THEN 1 ELSE 0 END) AS Float64) * 100 / COUNT(`birthdate`) FROM `Person`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 58,
                "end_index": 81,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 60,
                "end_index": 88,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`name`, text, primary key)\n(`birthdate`, text)\n(`birth_name`, text)\n(`birth_place`, text)\n(`birth_region`, text)\n(`birth_country`, text)\n(`height_meters`, real)\n(`nickname`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Person`\nColumns:\n(`name`, String, primary key)\n(`birthdate`, String)\n(`birth_name`, String)\n(`birth_place`, String)\n(`birth_region`, String)\n(`birth_country`, String)\n(`height_meters`, Float64)\n(`nickname`, String)\n"
        ]
    },
    {
        "sql_id": 278,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.title FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE T1.award = 'Best International TV Series' AND SUBSTR(T1.year, 1, 4) = '2017';",
        "target_query": "SELECT T2.`title` FROM `Award` AS T1 INNER JOIN `Episode` AS T2 ON T1.`episode_id` = T2.`episode_id` WHERE T1.`award` = 'Best International TV Series' AND substring(toString(T1.`year`), 1, 4) = '2017';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 143,
                "end_index": 164,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 155,
                "end_index": 184,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, integer, primary key)\n(`organization`, text)\n(`year`, integer)\n(`award_category`, text)\n(`award`, text)\n(`person`, text)\n(`role`, text)\n(`episode_id`, text)\n(`season`, text)\n(`song`, text)\n(`result`, text)\n",
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, Int64, primary key)\n(`organization`, String)\n(`year`, Int64)\n(`award_category`, String)\n(`award`, String)\n(`person`, String)\n(`_role`, String)\n(`episode_id`, String)\n(`season`, String)\n(`song`, String)\n(`result`, String)\n",
            "Table: `Episode`\nColumns:\n(`episode_id`, String, primary key)\n(`season`, Int64)\n(`episode`, Int64)\n(`number_in_series`, Int64)\n(`title`, String)\n(`summary`, String)\n(`air_date`, String)\n(`episode_image`, String)\n(`rating`, Float64)\n(`votes`, Int64)\n"
        ]
    },
    {
        "sql_id": 279,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(award_id) FROM Award WHERE SUBSTR(year, 1, 4) = '2009';",
        "target_query": "SELECT COUNT(`award_id`) FROM `Award` WHERE substring(toString(`year`), 1, 4) = '2009';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 40,
                "end_index": 58,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 44,
                "end_index": 70,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, integer, primary key)\n(`organization`, text)\n(`year`, integer)\n(`award_category`, text)\n(`award`, text)\n(`person`, text)\n(`role`, text)\n(`episode_id`, text)\n(`season`, text)\n(`song`, text)\n(`result`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, Int64, primary key)\n(`organization`, String)\n(`year`, Int64)\n(`award_category`, String)\n(`award`, String)\n(`person`, String)\n(`_role`, String)\n(`episode_id`, String)\n(`season`, String)\n(`song`, String)\n(`result`, String)\n"
        ]
    },
    {
        "sql_id": 281,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.keyword FROM Episode AS T1 INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE SUBSTR(T1.air_date, 1, 4) = '2008';",
        "target_query": "SELECT T2.`keyword` FROM `Episode` AS T1 INNER JOIN `Keyword` AS T2 ON T1.`episode_id` = T2.`episode_id` WHERE substring(T1.`air_date`, 1, 4) = '2008';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 101,
                "end_index": 126,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 111,
                "end_index": 141,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n",
            "Table: `Keyword`\nColumns:\n(`episode_id`, text, primary key)\n(`keyword`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, String, primary key)\n(`season`, Int64)\n(`episode`, Int64)\n(`number_in_series`, Int64)\n(`title`, String)\n(`summary`, String)\n(`air_date`, String)\n(`episode_image`, String)\n(`rating`, Float64)\n(`votes`, Int64)\n",
            "Table: `Keyword`\nColumns:\n(`episode_id`, String, primary key)\n(`keyword`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 283,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(award_id) FROM Award WHERE SUBSTR(year, 1, 4) = '2009' AND result = 'Winner';",
        "target_query": "SELECT COUNT(`award_id`) FROM `Award` WHERE substring(toString(`year`), 1, 4) = '2009' AND `result` = 'Winner';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 40,
                "end_index": 58,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 44,
                "end_index": 70,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, integer, primary key)\n(`organization`, text)\n(`year`, integer)\n(`award_category`, text)\n(`award`, text)\n(`person`, text)\n(`role`, text)\n(`episode_id`, text)\n(`season`, text)\n(`song`, text)\n(`result`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Award`\nColumns:\n(`award_id`, Int64, primary key)\n(`organization`, String)\n(`year`, Int64)\n(`award_category`, String)\n(`award`, String)\n(`person`, String)\n(`_role`, String)\n(`episode_id`, String)\n(`season`, String)\n(`song`, String)\n(`result`, String)\n"
        ]
    },
    {
        "sql_id": 284,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT T1.episode_id FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE SUBSTR(T1.air_date, 1, 4) = '2008' AND T2.stars < 5;",
        "target_query": "SELECT DISTINCT `T1`.`episode_id` FROM `Episode` AS `T1` INNER JOIN `Vote` AS `T2` ON `T2`.`episode_id` = `T1`.`episode_id` WHERE substring(`T1`.`air_date`, 1, 4) = '2008' AND `T2`.`stars` < 5;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 110,
                "end_index": 135,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 130,
                "end_index": 162,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n",
            "Table: `Vote`\nColumns:\n(`episode_id`, text)\n(`stars`, integer)\n(`votes`, integer)\n(`percent`, real)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, String, primary key)\n(`season`, Int64)\n(`episode`, Int64)\n(`number_in_series`, Int64)\n(`title`, String)\n(`summary`, String)\n(`air_date`, String)\n(`episode_image`, String)\n(`rating`, Float64)\n(`votes`, Int64)\n",
            "Table: `Vote`\nColumns:\n(`episode_id`, String)\n(`stars`, Int64)\n(`votes`, Int64)\n(`percent`, Float64)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 285,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.percent FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE SUBSTR(T1.air_date, 1, 4) = '2008' AND T1.votes BETWEEN 950 AND 960;",
        "target_query": "SELECT `T2`.`percent` FROM `Episode` AS `T1` INNER JOIN `Vote` AS `T2` ON `T2`.`episode_id` = `T1`.`episode_id` WHERE substring(`T1`.`air_date`, 1, 4) = '2008' AND `T1`.`votes` BETWEEN 950 AND 960;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 98,
                "end_index": 123,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 118,
                "end_index": 150,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n",
            "Table: `Vote`\nColumns:\n(`episode_id`, text)\n(`stars`, integer)\n(`votes`, integer)\n(`percent`, real)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, String, primary key)\n(`season`, Int64)\n(`episode`, Int64)\n(`number_in_series`, Int64)\n(`title`, String)\n(`summary`, String)\n(`air_date`, String)\n(`episode_image`, String)\n(`rating`, Float64)\n(`votes`, Int64)\n",
            "Table: `Vote`\nColumns:\n(`episode_id`, String)\n(`stars`, Int64)\n(`votes`, Int64)\n(`percent`, Float64)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 286,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.stars FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE SUBSTR(T1.air_date, 1, 7) = '2008-11';",
        "target_query": "SELECT `T2`.`stars` FROM `Episode` AS `T1` INNER JOIN `Vote` AS `T2` ON `T2`.`episode_id` = `T1`.`episode_id` WHERE substring(`T1`.`air_date`, 1, 7) = '2008-11';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 96,
                "end_index": 121,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 116,
                "end_index": 148,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n",
            "Table: `Vote`\nColumns:\n(`episode_id`, text)\n(`stars`, integer)\n(`votes`, integer)\n(`percent`, real)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, String, primary key)\n(`season`, Int64)\n(`episode`, Int64)\n(`number_in_series`, Int64)\n(`title`, String)\n(`summary`, String)\n(`air_date`, String)\n(`episode_image`, String)\n(`rating`, Float64)\n(`votes`, Int64)\n",
            "Table: `Vote`\nColumns:\n(`episode_id`, String)\n(`stars`, Int64)\n(`votes`, Int64)\n(`percent`, Float64)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 287,
        "database_name": "simpson_episodes",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(*) FROM Episode AS T1 INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE T2.credited = 'true' AND T2.person = 'Sam Im' AND SUBSTR(T1.air_date, 1, 4) = '2009' AND T2.role = 'additional timer';",
        "target_query": "SELECT COUNT(*) FROM `Episode` AS T1 INNER JOIN `Credit` AS T2 ON T1.`episode_id` = T2.`episode_id` WHERE T2.`credited` = 'true' AND T2.`person` = 'Sam Im' AND substring(T1.`air_date`, 1, 4) = '2009' AND T2.`_role` = 'additional timer';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 148,
                "end_index": 173,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 160,
                "end_index": 190,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, text, primary key)\n(`season`, integer)\n(`episode`, integer)\n(`number_in_series`, integer)\n(`title`, text)\n(`summary`, text)\n(`air_date`, text)\n(`episode_image`, text)\n(`rating`, real)\n(`votes`, integer)\n",
            "Table: `Credit`\nColumns:\n(`episode_id`, text)\n(`category`, text)\n(`person`, text)\n(`role`, text)\n(`credited`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `Episode`\nColumns:\n(`episode_id`, String, primary key)\n(`season`, Int64)\n(`episode`, Int64)\n(`number_in_series`, Int64)\n(`title`, String)\n(`summary`, String)\n(`air_date`, String)\n(`episode_image`, String)\n(`rating`, Float64)\n(`votes`, Int64)\n",
            "Table: `Credit`\nColumns:\n(`episode_id`, String)\n(`category`, String)\n(`person`, String)\n(`_role`, String)\n(`credited`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 168,
        "database_name": "soccer_2016",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(CASE WHEN Team_1 = 10 OR Team_2 = 10 THEN 1 ELSE 0 END) FROM `Match` WHERE SUBSTR(Match_Date, 1, 4) = '2012'",
        "target_query": "SELECT SUM(CASE WHEN `Team_1` = 10 OR `Team_2` = 10 THEN 1 ELSE 0 END) FROM `Match` WHERE substring(toString(`Match_Date`), 1, 4) = '2012';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 86,
                "end_index": 110,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 90,
                "end_index": 122,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Match`\nColumns:\n(`Match_Id`, integer, primary key)\n(`Team_1`, integer)\n(`Team_2`, integer)\n(`Match_Date`, date)\n(`Season_Id`, integer)\n(`Venue_Id`, integer)\n(`Toss_Winner`, integer)\n(`Toss_Decide`, integer)\n(`Win_Type`, integer)\n(`Win_Margin`, integer)\n(`Outcome_type`, integer)\n(`Match_Winner`, integer)\n(`Man_of_the_Match`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `Match`\nColumns:\n(`Match_Id`, Int64, primary key)\n(`Team_1`, Int64)\n(`Team_2`, Int64)\n(`Match_Date`, Date32)\n(`Season_Id`, Int64)\n(`Venue_Id`, Int64)\n(`Toss_Winner`, Int64)\n(`Toss_Decide`, Int64)\n(`Win_Type`, Int64)\n(`Win_Margin`, Int64)\n(`Outcome_type`, Int64)\n(`Match_Winner`, Int64)\n(`Man_of_the_Match`, Int64)\n"
        ]
    },
    {
        "sql_id": 169,
        "database_name": "soccer_2016",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(COUNT(CASE WHEN Win_Margin > 100 THEN 1 ELSE 0 END) AS REAL) * 100 / TOTAL(Match_Id) FROM `Match`",
        "target_query": "SELECT COUNT(CASE WHEN `Win_Margin` > 100 THEN 1 ELSE 0 END) * 100 / sum(`Match_Id`) FROM `Match`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 81,
                "end_index": 96,
                "dialect_content": "The `TOTAL` function in SQLite is an aggregate function that returns the sum of all non-null values in a group. Unlike `SUM`, it always returns a floating-point value (REAL) even if all inputs are integers. If no non-null values exist, it returns 0.0 instead of NULL.",
                "feature": "TOTAL(expression)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 69,
                "end_index": 84,
                "dialect_content": "ClickHouse does not have a `TOTAL()` function, but the `sum()` function serves a similar purpose. It returns the sum of all non-null values in a group, and always returns a numeric value, similar to SQLite's `TOTAL`. If there are no non-null values, the result is 0.",
                "feature": "sum(expression)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "TOTAL(expression)",
                "explanation": "The `TOTAL` function in SQLite is an aggregate function that returns the sum of all non-null values in a group. Unlike `SUM`, it always returns a floating-point value (REAL) even if all inputs are integers. If no non-null values exist, it returns 0.0 instead of NULL.",
                "examples": [
                    "SELECT TOTAL(salary) FROM employees;",
                    "SELECT department, TOTAL(bonus) FROM employees GROUP BY department;",
                    "SELECT TOTAL(price * quantity) AS total_revenue FROM sales;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sum(expression)",
                "explanation": "ClickHouse does not have a `TOTAL()` function, but the `sum()` function serves a similar purpose. It returns the sum of all non-null values in a group, and always returns a numeric value, similar to SQLite's `TOTAL`. If there are no non-null values, the result is 0.",
                "examples": [
                    "SELECT sum(salary) FROM employees;",
                    "SELECT department, sum(bonus) FROM employees GROUP BY department;",
                    "SELECT sum(price * quantity) AS total_revenue FROM sales;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Match`\nColumns:\n(`Match_Id`, integer, primary key)\n(`Team_1`, integer)\n(`Team_2`, integer)\n(`Match_Date`, date)\n(`Season_Id`, integer)\n(`Venue_Id`, integer)\n(`Toss_Winner`, integer)\n(`Toss_Decide`, integer)\n(`Win_Type`, integer)\n(`Win_Margin`, integer)\n(`Outcome_type`, integer)\n(`Match_Winner`, integer)\n(`Man_of_the_Match`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `Match`\nColumns:\n(`Match_Id`, Int64, primary key)\n(`Team_1`, Int64)\n(`Team_2`, Int64)\n(`Match_Date`, Date32)\n(`Season_Id`, Int64)\n(`Venue_Id`, Int64)\n(`Toss_Winner`, Int64)\n(`Toss_Decide`, Int64)\n(`Win_Type`, Int64)\n(`Win_Margin`, Int64)\n(`Outcome_type`, Int64)\n(`Match_Winner`, Int64)\n(`Man_of_the_Match`, Int64)\n"
        ]
    },
    {
        "sql_id": 170,
        "database_name": "soccer_2016",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(CASE WHEN T2.Role_Desc = 'CaptainKeeper' THEN 1 ELSE 0 END) AS REAL) * 100 / TOTAL(T1.Player_Id) FROM Player_Match AS T1 INNER JOIN Rolee AS T2 ON T1.Role_Id = T2.Role_Id",
        "target_query": "SELECT sum(CASE WHEN `T2`.`Role_Desc` = 'CaptainKeeper' THEN 1 ELSE 0 END) * 100 / sum(`T1`.`Player_Id`) FROM `Player_Match` AS `T1` INNER JOIN `Rolee` AS `T2` ON `T1`.`Role_Id` = `T2`.`Role_Id`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 93,
                "end_index": 112,
                "dialect_content": "The `TOTAL` function in SQLite is an aggregate function that returns the sum of all non-null values in a group. Unlike `SUM`, it always returns a floating-point value (REAL) even if all inputs are integers. If no non-null values exist, it returns 0.0 instead of NULL.",
                "feature": "TOTAL(expression)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 74,
                "dialect_content": "ClickHouse does not have a `TOTAL()` function, but the `sum()` function serves a similar purpose. It returns the sum of all non-null values in a group, and always returns a numeric value, similar to SQLite's `TOTAL`. If there are no non-null values, the result is 0.",
                "feature": "sum(expression)"
            },
            {
                "start_index": 83,
                "end_index": 104,
                "dialect_content": "ClickHouse does not have a `TOTAL()` function, but the `sum()` function serves a similar purpose. It returns the sum of all non-null values in a group, and always returns a numeric value, similar to SQLite's `TOTAL`. If there are no non-null values, the result is 0.",
                "feature": "sum(expression)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "TOTAL(expression)",
                "explanation": "The `TOTAL` function in SQLite is an aggregate function that returns the sum of all non-null values in a group. Unlike `SUM`, it always returns a floating-point value (REAL) even if all inputs are integers. If no non-null values exist, it returns 0.0 instead of NULL.",
                "examples": [
                    "SELECT TOTAL(salary) FROM employees;",
                    "SELECT department, TOTAL(bonus) FROM employees GROUP BY department;",
                    "SELECT TOTAL(price * quantity) AS total_revenue FROM sales;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sum(expression)",
                "explanation": "ClickHouse does not have a `TOTAL()` function, but the `sum()` function serves a similar purpose. It returns the sum of all non-null values in a group, and always returns a numeric value, similar to SQLite's `TOTAL`. If there are no non-null values, the result is 0.",
                "examples": [
                    "SELECT sum(salary) FROM employees;",
                    "SELECT department, sum(bonus) FROM employees GROUP BY department;",
                    "SELECT sum(price * quantity) AS total_revenue FROM sales;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Player_Match`\nColumns:\n(`Match_Id`, integer, primary key)\n(`Player_Id`, integer, primary key)\n(`Role_Id`, integer, primary key)\n(`Team_Id`, integer)\n",
            "Table: `Rolee`\nColumns:\n(`Role_Id`, integer, primary key)\n(`Role_Desc`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Player_Match`\nColumns:\n(`Match_Id`, Int64, primary key)\n(`Player_Id`, Int64, primary key)\n(`Role_Id`, Int64, primary key)\n(`Team_Id`, Int64)\n",
            "Table: `Rolee`\nColumns:\n(`Role_Id`, Int64, primary key)\n(`Role_Desc`, String)\n"
        ]
    },
    {
        "sql_id": 171,
        "database_name": "soccer_2016",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(CASE WHEN T2.Bowling_skill = ' Legbreak' THEN 1 ELSE 0 END) AS REAL) * 100 / TOTAL(T1.Player_Id) FROM Player AS T1 INNER JOIN Bowling_Style AS T2 ON T1.Bowling_skill = T2.Bowling_Id",
        "target_query": "SELECT sum(CASE WHEN T2.`Bowling_skill` = ' Legbreak' THEN 1 ELSE 0 END) * 100 / sum(T1.`Player_Id`) FROM `Player` AS T1 INNER JOIN `Bowling_Style` AS T2 ON T1.`Bowling_skill` = T2.`Bowling_Id`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 93,
                "end_index": 112,
                "dialect_content": "The `TOTAL` function in SQLite is an aggregate function that returns the sum of all non-null values in a group. Unlike `SUM`, it always returns a floating-point value (REAL) even if all inputs are integers. If no non-null values exist, it returns 0.0 instead of NULL.",
                "feature": "TOTAL(expression)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 72,
                "dialect_content": "ClickHouse does not have a `TOTAL()` function, but the `sum()` function serves a similar purpose. It returns the sum of all non-null values in a group, and always returns a numeric value, similar to SQLite's `TOTAL`. If there are no non-null values, the result is 0.",
                "feature": "sum(expression)"
            },
            {
                "start_index": 81,
                "end_index": 100,
                "dialect_content": "ClickHouse does not have a `TOTAL()` function, but the `sum()` function serves a similar purpose. It returns the sum of all non-null values in a group, and always returns a numeric value, similar to SQLite's `TOTAL`. If there are no non-null values, the result is 0.",
                "feature": "sum(expression)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "TOTAL(expression)",
                "explanation": "The `TOTAL` function in SQLite is an aggregate function that returns the sum of all non-null values in a group. Unlike `SUM`, it always returns a floating-point value (REAL) even if all inputs are integers. If no non-null values exist, it returns 0.0 instead of NULL.",
                "examples": [
                    "SELECT TOTAL(salary) FROM employees;",
                    "SELECT department, TOTAL(bonus) FROM employees GROUP BY department;",
                    "SELECT TOTAL(price * quantity) AS total_revenue FROM sales;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sum(expression)",
                "explanation": "ClickHouse does not have a `TOTAL()` function, but the `sum()` function serves a similar purpose. It returns the sum of all non-null values in a group, and always returns a numeric value, similar to SQLite's `TOTAL`. If there are no non-null values, the result is 0.",
                "examples": [
                    "SELECT sum(salary) FROM employees;",
                    "SELECT department, sum(bonus) FROM employees GROUP BY department;",
                    "SELECT sum(price * quantity) AS total_revenue FROM sales;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Player`\nColumns:\n(`Player_Id`, integer, primary key)\n(`Player_Name`, text)\n(`DOB`, date)\n(`Batting_hand`, integer)\n(`Bowling_skill`, integer)\n(`Country_Name`, integer)\n",
            "Table: `Bowling_Style`\nColumns:\n(`Bowling_Id`, integer, primary key)\n(`Bowling_skill`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Player`\nColumns:\n(`Player_Id`, Int64, primary key)\n(`Player_Name`, String)\n(`DOB`, Date32)\n(`Batting_hand`, Int64)\n(`Bowling_skill`, Int64)\n(`Country_Name`, Int64)\n",
            "Table: `Bowling_Style`\nColumns:\n(`Bowling_Id`, Int64, primary key)\n(`Bowling_skill`, String)\n"
        ]
    },
    {
        "sql_id": 172,
        "database_name": "soccer_2016",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(COUNT(CASE WHEN T1.Team_1 = T1.Match_Winner = T1.Toss_Winner THEN 1 ELSE 0 END) AS REAL) * 100 / TOTAL(T1.Team_1) FROM `Match` AS T1 INNER JOIN Win_By AS T2 ON T1.Win_Type = T2.Win_Id INNER JOIN Toss_Decision AS T3 ON T1.Toss_Decide = T3.Toss_Id WHERE T3.Toss_Name = 'field' AND T2.Win_Type = 'runs'",
        "target_query": "SELECT CAST(COUNT(CASE WHEN `T1`.`Team_1` = `T1`.`Match_Winner` AND `T1`.`Match_Winner` = `T1`.`Toss_Winner` THEN 1 ELSE 0 END) AS Float64) * 100 / sum(`T1`.`Team_1`) FROM `Match` AS `T1` INNER JOIN `Win_By` AS `T2` ON `T1`.`Win_Type` = `T2`.`Win_Id` INNER JOIN `Toss_Decision` AS `T3` ON `T1`.`Toss_Decide` = `T3`.`Toss_Id` WHERE `T3`.`Toss_Name` = 'field' AND `T2`.`Win_Type` = 'runs';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 109,
                "end_index": 125,
                "dialect_content": "The `TOTAL` function in SQLite is an aggregate function that returns the sum of all non-null values in a group. Unlike `SUM`, it always returns a floating-point value (REAL) even if all inputs are integers. If no non-null values exist, it returns 0.0 instead of NULL.",
                "feature": "TOTAL(expression)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 148,
                "end_index": 166,
                "dialect_content": "ClickHouse does not have a `TOTAL()` function, but the `sum()` function serves a similar purpose. It returns the sum of all non-null values in a group, and always returns a numeric value, similar to SQLite's `TOTAL`. If there are no non-null values, the result is 0.",
                "feature": "sum(expression)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "TOTAL(expression)",
                "explanation": "The `TOTAL` function in SQLite is an aggregate function that returns the sum of all non-null values in a group. Unlike `SUM`, it always returns a floating-point value (REAL) even if all inputs are integers. If no non-null values exist, it returns 0.0 instead of NULL.",
                "examples": [
                    "SELECT TOTAL(salary) FROM employees;",
                    "SELECT department, TOTAL(bonus) FROM employees GROUP BY department;",
                    "SELECT TOTAL(price * quantity) AS total_revenue FROM sales;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sum(expression)",
                "explanation": "ClickHouse does not have a `TOTAL()` function, but the `sum()` function serves a similar purpose. It returns the sum of all non-null values in a group, and always returns a numeric value, similar to SQLite's `TOTAL`. If there are no non-null values, the result is 0.",
                "examples": [
                    "SELECT sum(salary) FROM employees;",
                    "SELECT department, sum(bonus) FROM employees GROUP BY department;",
                    "SELECT sum(price * quantity) AS total_revenue FROM sales;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Match`\nColumns:\n(`Match_Id`, integer, primary key)\n(`Team_1`, integer)\n(`Team_2`, integer)\n(`Match_Date`, date)\n(`Season_Id`, integer)\n(`Venue_Id`, integer)\n(`Toss_Winner`, integer)\n(`Toss_Decide`, integer)\n(`Win_Type`, integer)\n(`Win_Margin`, integer)\n(`Outcome_type`, integer)\n(`Match_Winner`, integer)\n(`Man_of_the_Match`, integer)\n",
            "Table: `Win_By`\nColumns:\n(`Win_Id`, integer, primary key)\n(`Win_Type`, text)\n",
            "Table: `Toss_Decision`\nColumns:\n(`Toss_Id`, integer, primary key)\n(`Toss_Name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Match`\nColumns:\n(`Match_Id`, Int64, primary key)\n(`Team_1`, Int64)\n(`Team_2`, Int64)\n(`Match_Date`, Date32)\n(`Season_Id`, Int64)\n(`Venue_Id`, Int64)\n(`Toss_Winner`, Int64)\n(`Toss_Decide`, Int64)\n(`Win_Type`, Int64)\n(`Win_Margin`, Int64)\n(`Outcome_type`, Int64)\n(`Match_Winner`, Int64)\n(`Man_of_the_Match`, Int64)\n",
            "Table: `Win_By`\nColumns:\n(`Win_Id`, Int64, primary key)\n(`Win_Type`, String)\n",
            "Table: `Toss_Decision`\nColumns:\n(`Toss_Id`, Int64, primary key)\n(`Toss_Name`, String)\n"
        ]
    },
    {
        "sql_id": 173,
        "database_name": "soccer_2016",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(COUNT(CASE WHEN T2.Win_Margin < 10 THEN 1 ELSE 0 END) AS REAL) * 100 / TOTAL(T1.Venue_Id) FROM Venue AS T1 INNER JOIN Match AS T2 ON T1.Venue_Id = T2.Venue_Id WHERE T1.Venue_Name = 'Dr DY Patil Sports Academy'",
        "target_query": "SELECT COUNT(CASE WHEN `T2`.`Win_Margin` < 10 THEN 1 ELSE 0 END) * 100 / sum(`T1`.`Venue_Id`) FROM `Venue` AS `T1` INNER JOIN `Match` AS `T2` ON `T1`.`Venue_Id` = `T2`.`Venue_Id` WHERE `T1`.`Venue_Name` = 'Dr DY Patil Sports Academy';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 83,
                "end_index": 101,
                "dialect_content": "The `TOTAL` function in SQLite is an aggregate function that returns the sum of all non-null values in a group. Unlike `SUM`, it always returns a floating-point value (REAL) even if all inputs are integers. If no non-null values exist, it returns 0.0 instead of NULL.",
                "feature": "TOTAL(expression)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 73,
                "end_index": 93,
                "dialect_content": "ClickHouse does not have a `TOTAL()` function, but the `sum()` function serves a similar purpose. It returns the sum of all non-null values in a group, and always returns a numeric value, similar to SQLite's `TOTAL`. If there are no non-null values, the result is 0.",
                "feature": "sum(expression)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "TOTAL(expression)",
                "explanation": "The `TOTAL` function in SQLite is an aggregate function that returns the sum of all non-null values in a group. Unlike `SUM`, it always returns a floating-point value (REAL) even if all inputs are integers. If no non-null values exist, it returns 0.0 instead of NULL.",
                "examples": [
                    "SELECT TOTAL(salary) FROM employees;",
                    "SELECT department, TOTAL(bonus) FROM employees GROUP BY department;",
                    "SELECT TOTAL(price * quantity) AS total_revenue FROM sales;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "sum(expression)",
                "explanation": "ClickHouse does not have a `TOTAL()` function, but the `sum()` function serves a similar purpose. It returns the sum of all non-null values in a group, and always returns a numeric value, similar to SQLite's `TOTAL`. If there are no non-null values, the result is 0.",
                "examples": [
                    "SELECT sum(salary) FROM employees;",
                    "SELECT department, sum(bonus) FROM employees GROUP BY department;",
                    "SELECT sum(price * quantity) AS total_revenue FROM sales;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Venue`\nColumns:\n(`Venue_Id`, integer, primary key)\n(`Venue_Name`, text)\n(`City_Id`, integer)\n",
            "Table: `Match`\nColumns:\n(`Match_Id`, integer, primary key)\n(`Team_1`, integer)\n(`Team_2`, integer)\n(`Match_Date`, date)\n(`Season_Id`, integer)\n(`Venue_Id`, integer)\n(`Toss_Winner`, integer)\n(`Toss_Decide`, integer)\n(`Win_Type`, integer)\n(`Win_Margin`, integer)\n(`Outcome_type`, integer)\n(`Match_Winner`, integer)\n(`Man_of_the_Match`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `Venue`\nColumns:\n(`Venue_Id`, Int64, primary key)\n(`Venue_Name`, String)\n(`City_Id`, Int64)\n",
            "Table: `Match`\nColumns:\n(`Match_Id`, Int64, primary key)\n(`Team_1`, Int64)\n(`Team_2`, Int64)\n(`Match_Date`, Date32)\n(`Season_Id`, Int64)\n(`Venue_Id`, Int64)\n(`Toss_Winner`, Int64)\n(`Toss_Decide`, Int64)\n(`Win_Type`, Int64)\n(`Win_Margin`, Int64)\n(`Outcome_type`, Int64)\n(`Match_Winner`, Int64)\n(`Man_of_the_Match`, Int64)\n"
        ]
    },
    {
        "sql_id": 175,
        "database_name": "soccer_2016",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT 2022 - SUBSTR(DOB, 1, 4) FROM Player WHERE Player_Name = 'Ishan Kishan'",
        "target_query": "SELECT 2022 - toInt32(substring(toString(`DOB`), 1, 4)) FROM `Player` WHERE `Player_Name` = 'Ishan Kishan';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 14,
                "end_index": 31,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 22,
                "end_index": 47,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Player`\nColumns:\n(`Player_Id`, integer, primary key)\n(`Player_Name`, text)\n(`DOB`, date)\n(`Batting_hand`, integer)\n(`Bowling_skill`, integer)\n(`Country_Name`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `Player`\nColumns:\n(`Player_Id`, Int64, primary key)\n(`Player_Name`, String)\n(`DOB`, Date32)\n(`Batting_hand`, Int64)\n(`Bowling_skill`, Int64)\n(`Country_Name`, Int64)\n"
        ]
    },
    {
        "sql_id": 179,
        "database_name": "soccer_2016",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(CASE WHEN T2.Country_Name = 'India' THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.Player_Id) FROM Player AS T1 INNER JOIN Country AS T2 ON T1.Country_Name = T2.Country_ID WHERE strftime('%Y', T1.DOB) BETWEEN '1975' AND '1985'",
        "target_query": "SELECT toFloat64(SUM(CASE WHEN T2.`Country_Name` = 'India' THEN 1 ELSE 0 END)) / COUNT(T1.`Player_Id`) FROM `Player` AS T1 INNER JOIN `Country` AS T2 ON T1.`Country_Name` = T2.`Country_Id` WHERE formatDateTime(T1.`DOB`, '%Y') BETWEEN '1975' AND '1985';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 186,
                "end_index": 208,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 195,
                "end_index": 225,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Player`\nColumns:\n(`Player_Id`, integer, primary key)\n(`Player_Name`, text)\n(`DOB`, date)\n(`Batting_hand`, integer)\n(`Bowling_skill`, integer)\n(`Country_Name`, integer)\n",
            "Table: `Country`\nColumns:\n(`Country_Id`, integer, primary key)\n(`Country_Name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `Player`\nColumns:\n(`Player_Id`, Int64, primary key)\n(`Player_Name`, String)\n(`DOB`, Date32)\n(`Batting_hand`, Int64)\n(`Bowling_skill`, Int64)\n(`Country_Name`, Int64)\n",
            "Table: `Country`\nColumns:\n(`Country_Id`, Int64, primary key)\n(`Country_Name`, String)\n"
        ]
    },
    {
        "sql_id": 180,
        "database_name": "soccer_2016",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(Player_Id) FROM Player WHERE strftime('%Y', DOB) BETWEEN '1970' AND '1975'",
        "target_query": "SELECT COUNT(`Player_Id`) FROM `Player` WHERE formatDateTime(`DOB`, '%Y') BETWEEN '1970' AND '1975';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 42,
                "end_index": 61,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 46,
                "end_index": 73,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Player`\nColumns:\n(`Player_Id`, integer, primary key)\n(`Player_Name`, text)\n(`DOB`, date)\n(`Batting_hand`, integer)\n(`Bowling_skill`, integer)\n(`Country_Name`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `Player`\nColumns:\n(`Player_Id`, Int64, primary key)\n(`Player_Name`, String)\n(`DOB`, Date32)\n(`Batting_hand`, Int64)\n(`Bowling_skill`, Int64)\n(`Country_Name`, Int64)\n"
        ]
    },
    {
        "sql_id": 288,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T1.bool = 'pos', 1, 0)) AS REAL) * 100 / SUM(IIF(T1.bool = 'neg', 1, 0)) FROM no_payment_due AS T1 INNER JOIN enlist AS T2 ON T1.`name` = T2.`name` WHERE T2.organ = 'foreign_legion'",
        "target_query": "SELECT CAST(SUM(if(T1.`bool` = 'pos', 1, 0)) AS Float64) * 100 / SUM(if(T1.`bool` = 'neg', 1, 0)) FROM `no_payment_due` AS T1 INNER JOIN `enlist` AS T2 ON T1.`name` = T2.`name` WHERE T2.`organ` = 'foreign_legion';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 42,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 65,
                "end_index": 91,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 43,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 69,
                "end_index": 96,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `no_payment_due`\nColumns:\n(`name`, text, primary key)\n(`bool`, text)\n",
            "Table: `enlist`\nColumns:\n(`name`, text)\n(`organ`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `no_payment_due`\nColumns:\n(`name`, String, primary key)\n(`bool`, String)\n",
            "Table: `enlist`\nColumns:\n(`name`, String)\n(`organ`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 289,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T1.school = 'occ', 1.0, 0)) AS REAL) * 100 / COUNT(T1.name) FROM enrolled AS T1 INNER JOIN enlist AS T2 ON T1.`name` = T2.`name` WHERE T2.organ = 'navy'",
        "target_query": "SELECT SUM(if(T1.`school` = 'occ', 1.0, 0)) * 100 / COUNT(T1.`name`) FROM `enrolled` AS T1 INNER JOIN `enlist` AS T2 ON T1.`name` = T2.`name` WHERE T2.`organ` = 'navy';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 46,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 42,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `enrolled`\nColumns:\n(`name`, text, primary key)\n(`school`, text, primary key)\n(`month`, integer)\n",
            "Table: `enlist`\nColumns:\n(`name`, text)\n(`organ`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `enrolled`\nColumns:\n(`name`, String, primary key)\n(`school`, String, primary key)\n(`month`, Int64)\n",
            "Table: `enlist`\nColumns:\n(`name`, String)\n(`organ`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 292,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T1.month > 5, 1, 0)) AS REAL) * 100 / COUNT(T1.month) FROM longest_absense_from_school AS T1 INNER JOIN unemployed AS T2 ON T1.name = T2.name",
        "target_query": "SELECT CAST(SUM(if(`T1`.`month` > 5, 1, 0)) AS Float64) * 100 / COUNT(`T1`.`month`) FROM `longest_absense_from_school` AS `T1` INNER JOIN `unemployed` AS `T2` ON `T1`.`name` = `T2`.`name`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 39,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 42,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `longest_absense_from_school`\nColumns:\n(`name`, text, primary key)\n(`month`, integer)\n",
            "Table: `unemployed`\nColumns:\n(`name`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `longest_absense_from_school`\nColumns:\n(`name`, String, primary key)\n(`month`, Int64)\n",
            "Table: `unemployed`\nColumns:\n(`name`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 293,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT IIF(T.result = 0, 'female', 'male') AS re FROM ( SELECT COUNT(name) AS result FROM male WHERE name = 'studenT1000' ) T",
        "target_query": "SELECT if(T.result = 0, 'female', 'male') AS re FROM ( SELECT COUNT(`name`) AS result FROM `male` WHERE `name` = 'studenT1000' ) T;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 42,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 41,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `male`\nColumns:\n(`name`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `male`\nColumns:\n(`name`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 294,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T3.name IS NULL, 1, 0)) AS REAL) / COUNT(T1.name) FROM disabled AS T1 INNER JOIN enlist AS T2 ON T1.name = T2.name LEFT JOIN male AS T3 ON T2.name = T3.name WHERE T2.organ = 'foreign_legion'",
        "target_query": "SELECT SUM(if(T3.name IS NULL, 1, 0)) / COUNT(T1.name) FROM `disabled` AS T1 INNER JOIN `enlist` AS T2 ON T1.name = T2.name LEFT JOIN `male` AS T3 ON T2.name = T3.name WHERE T2.organ = 'foreign_legion';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 42,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 36,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `disabled`\nColumns:\n(`name`, text, primary key)\n",
            "Table: `enlist`\nColumns:\n(`name`, text)\n(`organ`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `male`\nColumns:\n(`name`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `disabled`\nColumns:\n(`name`, String, primary key)\n",
            "Table: `enlist`\nColumns:\n(`name`, String)\n(`organ`, String)\n(`rowid`, Int64, primary key)\n",
            "Table: `male`\nColumns:\n(`name`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 296,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(month = 0, 1, 0)) AS REAL) * 100 / COUNT(name) FROM longest_absense_from_school",
        "target_query": "SELECT SUM(if(`month` = 0, 1, 0)) * 100 / COUNT(`name`) FROM `longest_absense_from_school`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 36,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 32,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `longest_absense_from_school`\nColumns:\n(`name`, text, primary key)\n(`month`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `longest_absense_from_school`\nColumns:\n(`name`, String, primary key)\n(`month`, Int64)\n"
        ]
    },
    {
        "sql_id": 297,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(`bool` = 'pos', 1, 0)) AS REAL) / SUM(IIF(`bool` = 'neg', 1, 0)) FROM no_payment_due",
        "target_query": "SELECT CAST(SUM(if(`bool` = 'pos', 1, 0)) AS Float64) / SUM(if(`bool` = 'neg', 1, 0)) FROM `no_payment_due`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 41,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 58,
                "end_index": 83,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 40,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 60,
                "end_index": 84,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `no_payment_due`\nColumns:\n(`name`, text, primary key)\n(`bool`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `no_payment_due`\nColumns:\n(`name`, String, primary key)\n(`bool`, String)\n"
        ]
    },
    {
        "sql_id": 301,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(((SUM(IIF(month = 0, 1, 0)) - SUM(IIF(month = 9, 1, 0)))) AS REAL) * 100 / SUM(IIF(month = 0, 1, 0)) FROM longest_absense_from_school",
        "target_query": "SELECT toFloat64((SUM(if(`month` = 0, 1, 0)) - SUM(if(`month` = 9, 1, 0)))) * 100 / SUM(if(`month` = 0, 1, 0)) FROM `longest_absense_from_school`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 18,
                "end_index": 38,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 46,
                "end_index": 66,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 91,
                "end_index": 111,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 22,
                "end_index": 43,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 51,
                "end_index": 72,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 88,
                "end_index": 109,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `longest_absense_from_school`\nColumns:\n(`name`, text, primary key)\n(`month`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `longest_absense_from_school`\nColumns:\n(`name`, String, primary key)\n(`month`, Int64)\n"
        ]
    },
    {
        "sql_id": 304,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T2.month = 0, 1, 0)) AS REAL) * 100 / COUNT(T1.name) FROM unemployed AS T1 INNER JOIN longest_absense_from_school AS T2 ON T2.name = T1.name",
        "target_query": "SELECT SUM(if(`T2`.`month` = 0, 1, 0)) * 100 / COUNT(`T1`.`name`) FROM `unemployed` AS `T1` INNER JOIN `longest_absense_from_school` AS `T2` ON `T2`.`name` = `T1`.`name`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 39,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 37,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `unemployed`\nColumns:\n(`name`, text, primary key)\n",
            "Table: `longest_absense_from_school`\nColumns:\n(`name`, text, primary key)\n(`month`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `unemployed`\nColumns:\n(`name`, String, primary key)\n",
            "Table: `longest_absense_from_school`\nColumns:\n(`name`, String, primary key)\n(`month`, Int64)\n"
        ]
    },
    {
        "sql_id": 305,
        "database_name": "student_loan",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT 100 * SUM(IIF(T2.month = 0, 1, 0)) AS num FROM disabled AS T1 INNER JOIN longest_absense_from_school AS T2 ON T1.name = T2.name",
        "target_query": "SELECT 100 * SUM(if(`T2`.`month` = 0, 1, 0)) AS `num` FROM `disabled` AS `T1` INNER JOIN `longest_absense_from_school` AS `T2` ON `T1`.`name` = `T2`.`name`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 17,
                "end_index": 40,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 17,
                "end_index": 43,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `disabled`\nColumns:\n(`name`, text, primary key)\n",
            "Table: `longest_absense_from_school`\nColumns:\n(`name`, text, primary key)\n(`month`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `disabled`\nColumns:\n(`name`, String, primary key)\n",
            "Table: `longest_absense_from_school`\nColumns:\n(`name`, String, primary key)\n(`month`, Int64)\n"
        ]
    },
    {
        "sql_id": 192,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT MAX(strftime('%J', `Ship Date`) - strftime('%J', `Order Date`)) AS longestTimeDays FROM people AS T1 INNER JOIN central_superstore AS T2 ON T1.`Customer ID` = T2.`Customer ID` WHERE T1.`Customer Name` = 'Aimee Bixby'",
        "target_query": "SELECT MAX(toUnixTimestamp(`Ship_Date`) / 86400 - toUnixTimestamp(`Order_Date`) / 86400) AS longestTimeDays \nFROM `people` AS T1 \nINNER JOIN `central_superstore` AS T2 ON T1.`Customer_ID` = T2.`Customer_ID` \nWHERE T1.`Customer_Name` = 'Aimee Bixby';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 38,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 41,
                "end_index": 69,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `people`\nColumns:\n(`Customer ID`, text, primary key)\n(`Customer Name`, text)\n(`Segment`, text)\n(`Country`, text)\n(`City`, text)\n(`State`, text)\n(`Postal Code`, integer)\n(`Region`, text, primary key)\n",
            "Table: `central_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `people`\nColumns:\n(`Customer_ID`, String, primary key)\n(`Customer_Name`, String)\n(`Segment`, String)\n(`Country`, String)\n(`City`, String)\n(`State`, String)\n(`Postal_Code`, Int64)\n(`Region`, String, primary key)\n",
            "Table: `central_superstore`\nColumns:\n(`Row_ID`, Int64, primary key)\n(`Order_ID`, String)\n(`Order_Date`, Date32)\n(`Ship_Date`, Date32)\n(`Ship_Mode`, String)\n(`Customer_ID`, String)\n(`Region`, String)\n(`Product_ID`, String)\n(`Sales`, Float64)\n(`Quantity`, Int64)\n(`Discount`, Float64)\n(`Profit`, Float64)\n"
        ]
    },
    {
        "sql_id": 193,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT T3.`Product Name` FROM people AS T1 INNER JOIN central_superstore AS T2 ON T1.`Customer ID` = T2.`Customer ID` INNER JOIN product AS T3 ON T3.`Product ID` = T2.`Product ID` WHERE T1.`Customer Name` = 'Aimee Bixby' AND STRFTIME('%Y', T2.`Ship Date`) = '2016'",
        "target_query": "SELECT DISTINCT T3.`Product_Name` \nFROM `people` AS T1 \nINNER JOIN `central_superstore` AS T2 ON T1.`Customer_ID` = T2.`Customer_ID` \nINNER JOIN `product` AS T3 ON T3.`Product_ID` = T2.`Product_ID` \nWHERE T1.`Customer_Name` = 'Aimee Bixby' \nAND formatDateTime(T2.`Ship_Date`, '%Y') = '2016';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 234,
                "end_index": 264,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 245,
                "end_index": 281,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `people`\nColumns:\n(`Customer ID`, text, primary key)\n(`Customer Name`, text)\n(`Segment`, text)\n(`Country`, text)\n(`City`, text)\n(`State`, text)\n(`Postal Code`, integer)\n(`Region`, text, primary key)\n",
            "Table: `central_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n",
            "Table: `product`\nColumns:\n(`Product ID`, text, primary key)\n(`Product Name`, text)\n(`Category`, text)\n(`Sub-Category`, text)\n(`Region`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `people`\nColumns:\n(`Customer_ID`, String, primary key)\n(`Customer_Name`, String)\n(`Segment`, String)\n(`Country`, String)\n(`City`, String)\n(`State`, String)\n(`Postal_Code`, Int64)\n(`Region`, String, primary key)\n",
            "Table: `central_superstore`\nColumns:\n(`Row_ID`, Int64, primary key)\n(`Order_ID`, String)\n(`Order_Date`, Date32)\n(`Ship_Date`, Date32)\n(`Ship_Mode`, String)\n(`Customer_ID`, String)\n(`Region`, String)\n(`Product_ID`, String)\n(`Sales`, Float64)\n(`Quantity`, Int64)\n(`Discount`, Float64)\n(`Profit`, Float64)\n",
            "Table: `product`\nColumns:\n(`Product_ID`, String, primary key)\n(`Product_Name`, String)\n(`Category`, String)\n(`Sub_Category`, String)\n(`Region`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 194,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(DISTINCT T1.`Product ID`) FROM east_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` WHERE T2.`Sub-Category` = 'Art' AND T1.Region = 'East' AND STRFTIME('%Y', T1.`Order Date`) = '2013'",
        "target_query": "SELECT COUNT(DISTINCT T1.`Product_ID`) FROM `east_superstore` AS T1 INNER JOIN `product` AS T2 ON T1.`Product_ID` = T2.`Product_ID` WHERE T2.`Sub_Category` = 'Art' AND T1.`Region` = 'East' AND formatDateTime(T1.`Order_Date`, '%Y') = '2013';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 187,
                "end_index": 218,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 193,
                "end_index": 230,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `east_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n",
            "Table: `product`\nColumns:\n(`Product ID`, text, primary key)\n(`Product Name`, text)\n(`Category`, text)\n(`Sub-Category`, text)\n(`Region`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `east_superstore`\nColumns:\n(`Row_ID`, Int64, primary key)\n(`Order_ID`, String)\n(`Order_Date`, Date32)\n(`Ship_Date`, Date32)\n(`Ship_Mode`, String)\n(`Customer_ID`, String)\n(`Region`, String)\n(`Product_ID`, String)\n(`Sales`, Float64)\n(`Quantity`, Int64)\n(`Discount`, Float64)\n(`Profit`, Float64)\n",
            "Table: `product`\nColumns:\n(`Product_ID`, String, primary key)\n(`Product_Name`, String)\n(`Category`, String)\n(`Sub_Category`, String)\n(`Region`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 195,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(DISTINCT T1.`Order ID`) FROM east_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` WHERE T2.`Customer Name` = 'Maxwell Schwartz' AND STRFTIME('%Y', T1.`Order Date`) = '2015'",
        "target_query": "SELECT COUNT(DISTINCT T1.`Order_ID`) FROM `east_superstore` AS T1 INNER JOIN `people` AS T2 ON T1.`Customer_ID` = T2.`Customer_ID` WHERE T2.`Customer_Name` = 'Maxwell Schwartz' AND formatDateTime(T1.`Order_Date`, '%Y') = '2015';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 177,
                "end_index": 208,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 181,
                "end_index": 218,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `east_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n",
            "Table: `people`\nColumns:\n(`Customer ID`, text, primary key)\n(`Customer Name`, text)\n(`Segment`, text)\n(`Country`, text)\n(`City`, text)\n(`State`, text)\n(`Postal Code`, integer)\n(`Region`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `east_superstore`\nColumns:\n(`Row_ID`, Int64, primary key)\n(`Order_ID`, String)\n(`Order_Date`, Date32)\n(`Ship_Date`, Date32)\n(`Ship_Mode`, String)\n(`Customer_ID`, String)\n(`Region`, String)\n(`Product_ID`, String)\n(`Sales`, Float64)\n(`Quantity`, Int64)\n(`Discount`, Float64)\n(`Profit`, Float64)\n",
            "Table: `people`\nColumns:\n(`Customer_ID`, String, primary key)\n(`Customer_Name`, String)\n(`Segment`, String)\n(`Country`, String)\n(`City`, String)\n(`State`, String)\n(`Postal_Code`, Int64)\n(`Region`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 196,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT T3.`Product Name` FROM west_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` INNER JOIN product AS T3 ON T3.`Product ID` = T1.`Product ID` WHERE T2.`Customer Name` = 'Matt Abelman' AND STRFTIME('%Y', T1.`Order Date`) = '2013'",
        "target_query": "SELECT DISTINCT T3.`Product_Name` \nFROM `west_superstore` AS T1 \nINNER JOIN `people` AS T2 ON T1.`Customer_ID` = T2.`Customer_ID` \nINNER JOIN `product` AS T3 ON T3.`Product_ID` = T1.`Product_ID` \nWHERE T2.`Customer_Name` = 'Matt Abelman' \nAND formatDateTime(T1.`Order_Date`, '%Y') = '2013';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 232,
                "end_index": 263,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 243,
                "end_index": 280,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `west_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n",
            "Table: `people`\nColumns:\n(`Customer ID`, text, primary key)\n(`Customer Name`, text)\n(`Segment`, text)\n(`Country`, text)\n(`City`, text)\n(`State`, text)\n(`Postal Code`, integer)\n(`Region`, text, primary key)\n",
            "Table: `product`\nColumns:\n(`Product ID`, text, primary key)\n(`Product Name`, text)\n(`Category`, text)\n(`Sub-Category`, text)\n(`Region`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `west_superstore`\nColumns:\n(`Row_ID`, Int64, primary key)\n(`Order_ID`, String)\n(`Order_Date`, Date32)\n(`Ship_Date`, Date32)\n(`Ship_Mode`, String)\n(`Customer_ID`, String)\n(`Region`, String)\n(`Product_ID`, String)\n(`Sales`, Float64)\n(`Quantity`, Int64)\n(`Discount`, Float64)\n(`Profit`, Float64)\n",
            "Table: `people`\nColumns:\n(`Customer_ID`, String, primary key)\n(`Customer_Name`, String)\n(`Segment`, String)\n(`Country`, String)\n(`City`, String)\n(`State`, String)\n(`Postal_Code`, Int64)\n(`Region`, String, primary key)\n",
            "Table: `product`\nColumns:\n(`Product_ID`, String, primary key)\n(`Product_Name`, String)\n(`Category`, String)\n(`Sub_Category`, String)\n(`Region`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 197,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM((T1.Sales / (1 - T1.Discount)) * T1.Quantity - T1.Profit) AS cost FROM east_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` INNER JOIN product AS T3 ON T1.`Product ID` = T3.`Product ID` AND T1.Region = T3.Region WHERE T1.Region = 'East' AND T2.`Customer Name` = 'Brad Thomas' AND strftime('%Y', T1.`Order Date`) = '2016'",
        "target_query": "SELECT SUM((T1.`Sales` / (1 - T1.`Discount`)) * T1.`Quantity` - T1.`Profit`) AS `cost` \nFROM `east_superstore` AS T1 \nINNER JOIN `people` AS T2 ON T1.`Customer_ID` = T2.`Customer_ID` \nINNER JOIN `product` AS T3 ON T1.`Product_ID` = T3.`Product_ID` AND T1.`Region` = T3.`Region` \nWHERE T1.`Region` = 'East' AND T2.`Customer_Name` = 'Brad Thomas' AND formatDateTime(T1.`Order_Date`, '%Y') = '2016';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 323,
                "end_index": 354,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 349,
                "end_index": 386,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `east_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n",
            "Table: `people`\nColumns:\n(`Customer ID`, text, primary key)\n(`Customer Name`, text)\n(`Segment`, text)\n(`Country`, text)\n(`City`, text)\n(`State`, text)\n(`Postal Code`, integer)\n(`Region`, text, primary key)\n",
            "Table: `product`\nColumns:\n(`Product ID`, text, primary key)\n(`Product Name`, text)\n(`Category`, text)\n(`Sub-Category`, text)\n(`Region`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `east_superstore`\nColumns:\n(`Row_ID`, Int64, primary key)\n(`Order_ID`, String)\n(`Order_Date`, Date32)\n(`Ship_Date`, Date32)\n(`Ship_Mode`, String)\n(`Customer_ID`, String)\n(`Region`, String)\n(`Product_ID`, String)\n(`Sales`, Float64)\n(`Quantity`, Int64)\n(`Discount`, Float64)\n(`Profit`, Float64)\n",
            "Table: `people`\nColumns:\n(`Customer_ID`, String, primary key)\n(`Customer_Name`, String)\n(`Segment`, String)\n(`Country`, String)\n(`City`, String)\n(`State`, String)\n(`Postal_Code`, Int64)\n(`Region`, String, primary key)\n",
            "Table: `product`\nColumns:\n(`Product_ID`, String, primary key)\n(`Product_Name`, String)\n(`Category`, String)\n(`Sub_Category`, String)\n(`Region`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 198,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(T1.Sales) FROM east_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` WHERE STRFTIME('%Y', T1.`Order Date`) = '2016' AND T2.Category = 'Furniture'",
        "target_query": "SELECT SUM(T1.`Sales`) FROM `east_superstore` AS T1 INNER JOIN `product` AS T2 ON T1.`Product_ID` = T2.`Product_ID` WHERE formatDateTime(T1.`Order_Date`, '%Y') = '2016' AND T2.`Category` = 'Furniture';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 116,
                "end_index": 147,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 122,
                "end_index": 159,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `east_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n",
            "Table: `product`\nColumns:\n(`Product ID`, text, primary key)\n(`Product Name`, text)\n(`Category`, text)\n(`Sub-Category`, text)\n(`Region`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `east_superstore`\nColumns:\n(`Row_ID`, Int64, primary key)\n(`Order_ID`, String)\n(`Order_Date`, Date32)\n(`Ship_Date`, Date32)\n(`Ship_Mode`, String)\n(`Customer_ID`, String)\n(`Region`, String)\n(`Product_ID`, String)\n(`Sales`, Float64)\n(`Quantity`, Int64)\n(`Discount`, Float64)\n(`Profit`, Float64)\n",
            "Table: `product`\nColumns:\n(`Product_ID`, String, primary key)\n(`Product_Name`, String)\n(`Category`, String)\n(`Sub_Category`, String)\n(`Region`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 199,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT T2.`Customer Name` FROM south_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` WHERE STRFTIME('%Y', T1.`Order Date`) = '2015' GROUP BY T2.`Customer Name` HAVING COUNT(T2.`Customer Name`) > 3",
        "target_query": "SELECT DISTINCT T2.`Customer_Name` FROM `south_superstore` AS T1 INNER JOIN `people` AS T2 ON T1.`Customer_ID` = T2.`Customer_ID` WHERE formatDateTime(T1.`Order_Date`, '%Y') = '2015' GROUP BY T2.`Customer_Name` HAVING COUNT(T2.`Customer_Name`) > 3;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 132,
                "end_index": 163,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 136,
                "end_index": 173,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `south_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n",
            "Table: `people`\nColumns:\n(`Customer ID`, text, primary key)\n(`Customer Name`, text)\n(`Segment`, text)\n(`Country`, text)\n(`City`, text)\n(`State`, text)\n(`Postal Code`, integer)\n(`Region`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `south_superstore`\nColumns:\n(`Row_ID`, Int64, primary key)\n(`Order_ID`, String)\n(`Order_Date`, Date32)\n(`Ship_Date`, Date32)\n(`Ship_Mode`, String)\n(`Customer_ID`, String)\n(`Region`, String)\n(`Product_ID`, String)\n(`Sales`, Float64)\n(`Quantity`, Int64)\n(`Discount`, Float64)\n(`Profit`, Float64)\n",
            "Table: `people`\nColumns:\n(`Customer_ID`, String, primary key)\n(`Customer_Name`, String)\n(`Segment`, String)\n(`Country`, String)\n(`City`, String)\n(`State`, String)\n(`Postal_Code`, Int64)\n(`Region`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 200,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T2.`Customer ID`) FROM people AS T1 INNER JOIN central_superstore AS T2 ON T1.`Customer ID` = T2.`Customer ID` WHERE T1.`Customer Name` = 'Corey Roper' AND STRFTIME('%Y', T2.`Ship Date`) = '2015'",
        "target_query": "SELECT COUNT(T2.`Customer_ID`) FROM `people` AS T1 INNER JOIN `central_superstore` AS T2 ON T1.`Customer_ID` = T2.`Customer_ID` WHERE T1.`Customer_Name` = 'Corey Roper' AND formatDateTime(T2.`Ship_Date`, '%Y') = '2015';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 169,
                "end_index": 199,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 173,
                "end_index": 209,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `people`\nColumns:\n(`Customer ID`, text, primary key)\n(`Customer Name`, text)\n(`Segment`, text)\n(`Country`, text)\n(`City`, text)\n(`State`, text)\n(`Postal Code`, integer)\n(`Region`, text, primary key)\n",
            "Table: `central_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `people`\nColumns:\n(`Customer_ID`, String, primary key)\n(`Customer_Name`, String)\n(`Segment`, String)\n(`Country`, String)\n(`City`, String)\n(`State`, String)\n(`Postal_Code`, Int64)\n(`Region`, String, primary key)\n",
            "Table: `central_superstore`\nColumns:\n(`Row_ID`, Int64, primary key)\n(`Order_ID`, String)\n(`Order_Date`, Date32)\n(`Ship_Date`, Date32)\n(`Ship_Mode`, String)\n(`Customer_ID`, String)\n(`Region`, String)\n(`Product_ID`, String)\n(`Sales`, Float64)\n(`Quantity`, Int64)\n(`Discount`, Float64)\n(`Profit`, Float64)\n"
        ]
    },
    {
        "sql_id": 201,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.`Customer Name` FROM east_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` WHERE T2.Segment = 'Corporate' AND T2.State = 'Rhode Island' AND T2.Region = 'East' AND STRFTIME('%Y', T1.`Order Date`) = '2016' GROUP BY T2.`Customer Name` ORDER BY COUNT(T2.`Customer Name`) DESC LIMIT 1",
        "target_query": "SELECT T2.`Customer_Name` FROM `east_superstore` AS T1 INNER JOIN `people` AS T2 ON T1.`Customer_ID` = T2.`Customer_ID` WHERE T2.`Segment` = 'Corporate' AND T2.`State` = 'Rhode Island' AND T2.`Region` = 'East' AND formatDateTime(T1.`Order_Date`, '%Y') = '2016' GROUP BY T2.`Customer_Name` ORDER BY COUNT(T2.`Customer_Name`) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 204,
                "end_index": 235,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 214,
                "end_index": 251,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `east_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n",
            "Table: `people`\nColumns:\n(`Customer ID`, text, primary key)\n(`Customer Name`, text)\n(`Segment`, text)\n(`Country`, text)\n(`City`, text)\n(`State`, text)\n(`Postal Code`, integer)\n(`Region`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `east_superstore`\nColumns:\n(`Row_ID`, Int64, primary key)\n(`Order_ID`, String)\n(`Order_Date`, Date32)\n(`Ship_Date`, Date32)\n(`Ship_Mode`, String)\n(`Customer_ID`, String)\n(`Region`, String)\n(`Product_ID`, String)\n(`Sales`, Float64)\n(`Quantity`, Int64)\n(`Discount`, Float64)\n(`Profit`, Float64)\n",
            "Table: `people`\nColumns:\n(`Customer_ID`, String, primary key)\n(`Customer_Name`, String)\n(`Segment`, String)\n(`Country`, String)\n(`City`, String)\n(`State`, String)\n(`Postal_Code`, Int64)\n(`Region`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 202,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT strftime('%J', `Ship Date`) - strftime('%J', `Order Date`) AS duration FROM central_superstore WHERE `Order ID` = 'CA-2011-134103'",
        "target_query": "SELECT DISTINCT CAST(dateDiff('day', `Order_Date`, `Ship_Date`) AS Float64) AS duration FROM `central_superstore` WHERE `Order_ID` = 'CA-2011-134103';",
        "semantic_equivalent_type": "Approximate equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 43,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 46,
                "end_index": 74,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `central_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `central_superstore`\nColumns:\n(`Row_ID`, Int64, primary key)\n(`Order_ID`, String)\n(`Order_Date`, Date32)\n(`Ship_Date`, Date32)\n(`Ship_Mode`, String)\n(`Customer_ID`, String)\n(`Region`, String)\n(`Product_ID`, String)\n(`Sales`, Float64)\n(`Quantity`, Int64)\n(`Discount`, Float64)\n(`Profit`, Float64)\n"
        ]
    },
    {
        "sql_id": 203,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT T2.`Product Name` FROM central_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` WHERE strftime('%Y-%m', T1.`Ship Date`) = '2013-03'",
        "target_query": "SELECT DISTINCT T2.`Product_Name` FROM `central_superstore` AS T1 INNER JOIN `product` AS T2 ON T1.`Product_ID` = T2.`Product_ID` WHERE formatDateTime(T1.`Ship_Date`, '%Y-%m') = '2013-03';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 132,
                "end_index": 165,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 136,
                "end_index": 175,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `central_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n",
            "Table: `product`\nColumns:\n(`Product ID`, text, primary key)\n(`Product Name`, text)\n(`Category`, text)\n(`Sub-Category`, text)\n(`Region`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `central_superstore`\nColumns:\n(`Row_ID`, Int64, primary key)\n(`Order_ID`, String)\n(`Order_Date`, Date32)\n(`Ship_Date`, Date32)\n(`Ship_Mode`, String)\n(`Customer_ID`, String)\n(`Region`, String)\n(`Product_ID`, String)\n(`Sales`, Float64)\n(`Quantity`, Int64)\n(`Discount`, Float64)\n(`Profit`, Float64)\n",
            "Table: `product`\nColumns:\n(`Product_ID`, String, primary key)\n(`Product_Name`, String)\n(`Category`, String)\n(`Sub_Category`, String)\n(`Region`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 204,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(DISTINCT T2.`Order ID`) FROM people AS T1 INNER JOIN central_superstore AS T2 ON T1.`Customer ID` = T2.`Customer ID` WHERE T1.`Customer Name` = 'Alan Barnes' AND STRFTIME('%Y', T2.`Order Date`) = '2015'",
        "target_query": "SELECT COUNT(DISTINCT T2.`Order_ID`) FROM `people` AS T1 INNER JOIN `central_superstore` AS T2 ON T1.`Customer_ID` = T2.`Customer_ID` WHERE T1.`Customer_Name` = 'Alan Barnes' AND formatDateTime(T2.`Order_Date`, '%Y') = '2015';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 175,
                "end_index": 206,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 179,
                "end_index": 216,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `people`\nColumns:\n(`Customer ID`, text, primary key)\n(`Customer Name`, text)\n(`Segment`, text)\n(`Country`, text)\n(`City`, text)\n(`State`, text)\n(`Postal Code`, integer)\n(`Region`, text, primary key)\n",
            "Table: `central_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `people`\nColumns:\n(`Customer_ID`, String, primary key)\n(`Customer_Name`, String)\n(`Segment`, String)\n(`Country`, String)\n(`City`, String)\n(`State`, String)\n(`Postal_Code`, Int64)\n(`Region`, String, primary key)\n",
            "Table: `central_superstore`\nColumns:\n(`Row_ID`, Int64, primary key)\n(`Order_ID`, String)\n(`Order_Date`, Date32)\n(`Ship_Date`, Date32)\n(`Ship_Mode`, String)\n(`Customer_ID`, String)\n(`Region`, String)\n(`Product_ID`, String)\n(`Sales`, Float64)\n(`Quantity`, Int64)\n(`Discount`, Float64)\n(`Profit`, Float64)\n"
        ]
    },
    {
        "sql_id": 205,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(CASE  WHEN T1.`Ship Mode` = 'First Class' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM central_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` WHERE T2.Category = 'Furniture' AND STRFTIME('%Y', T1.`Ship Date`) = '2013'",
        "target_query": "SELECT SUM(CASE WHEN T1.`Ship_Mode` = 'First Class' THEN 1 ELSE 0 END) * 100 / COUNT(*) FROM `central_superstore` AS T1 INNER JOIN `product` AS T2 ON T1.`Product_ID` = T2.`Product_ID` WHERE T2.`Category` = 'Furniture' AND formatDateTime(T1.`Ship_Date`, '%Y') = '2013';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 231,
                "end_index": 261,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 222,
                "end_index": 258,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `central_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n",
            "Table: `product`\nColumns:\n(`Product ID`, text, primary key)\n(`Product Name`, text)\n(`Category`, text)\n(`Sub-Category`, text)\n(`Region`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `central_superstore`\nColumns:\n(`Row_ID`, Int64, primary key)\n(`Order_ID`, String)\n(`Order_Date`, Date32)\n(`Ship_Date`, Date32)\n(`Ship_Mode`, String)\n(`Customer_ID`, String)\n(`Region`, String)\n(`Product_ID`, String)\n(`Sales`, Float64)\n(`Quantity`, Int64)\n(`Discount`, Float64)\n(`Profit`, Float64)\n",
            "Table: `product`\nColumns:\n(`Product_ID`, String, primary key)\n(`Product_Name`, String)\n(`Category`, String)\n(`Sub_Category`, String)\n(`Region`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 206,
        "database_name": "superstore",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.`Product Name` FROM central_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` WHERE T2.Region = 'Central' AND STRFTIME('%Y', T1.`Order Date`) = '2016' ORDER BY T1.Profit ASC LIMIT 1",
        "target_query": "SELECT T2.`Product_Name` FROM `central_superstore` AS T1 INNER JOIN `product` AS T2 ON T1.`Product_ID` = T2.`Product_ID` WHERE T2.`Region` = 'Central' AND formatDateTime(T1.`Order_Date`, '%Y') = '2016' ORDER BY T1.`Profit` ASC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 149,
                "end_index": 180,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 155,
                "end_index": 192,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `central_superstore`\nColumns:\n(`Row ID`, integer, primary key)\n(`Order ID`, text)\n(`Order Date`, date)\n(`Ship Date`, date)\n(`Ship Mode`, text)\n(`Customer ID`, text)\n(`Region`, text)\n(`Product ID`, text)\n(`Sales`, real)\n(`Quantity`, integer)\n(`Discount`, real)\n(`Profit`, real)\n",
            "Table: `product`\nColumns:\n(`Product ID`, text, primary key)\n(`Product Name`, text)\n(`Category`, text)\n(`Sub-Category`, text)\n(`Region`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `central_superstore`\nColumns:\n(`Row_ID`, Int64, primary key)\n(`Order_ID`, String)\n(`Order_Date`, Date32)\n(`Ship_Date`, Date32)\n(`Ship_Mode`, String)\n(`Customer_ID`, String)\n(`Region`, String)\n(`Product_ID`, String)\n(`Sales`, Float64)\n(`Quantity`, Int64)\n(`Discount`, Float64)\n(`Profit`, Float64)\n",
            "Table: `product`\nColumns:\n(`Product_ID`, String, primary key)\n(`Product_Name`, String)\n(`Category`, String)\n(`Sub_Category`, String)\n(`Region`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 100,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT strftime('%J', T2.STOP) - strftime('%J', T2.START) AS days FROM patients AS T1 INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Elly' AND T1.last = 'Koss' AND T2.description LIKE 'Acetaminophen%'",
        "target_query": "SELECT toFloat64(dateDiff('day', `T2`.`START`, `T2`.`STOP`)) AS `days` FROM `patients` AS `T1` INNER JOIN `medications` AS `T2` ON `T1`.`patient` = `T2`.`PATIENT` WHERE `T1`.`first` = 'Elly' AND `T1`.`last` = 'Koss' AND `T2`.`DESCRIPTION` LIKE 'Acetaminophen%';",
        "semantic_equivalent_type": "Approximate equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 30,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 33,
                "end_index": 57,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `medications`\nColumns:\n(`START`, date, primary key)\n(`STOP`, date)\n(`PATIENT`, text, primary key)\n(`ENCOUNTER`, text, primary key)\n(`CODE`, integer, primary key)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, String, primary key)\n(`birthdate`, Date32)\n(`deathdate`, Date32)\n(`ssn`, String)\n(`drivers`, String)\n(`passport`, String)\n(`prefix`, String)\n(`first`, String)\n(`last`, String)\n(`suffix`, String)\n(`maiden`, String)\n(`marital`, String)\n(`race`, String)\n(`ethnicity`, String)\n(`gender`, String)\n(`birthplace`, String)\n(`address`, String)\n",
            "Table: `medications`\nColumns:\n(`START`, Date32, primary key)\n(`STOP`, Date32)\n(`PATIENT`, String, primary key)\n(`ENCOUNTER`, String, primary key)\n(`CODE`, Int64, primary key)\n(`DESCRIPTION`, String)\n(`REASONCODE`, Int64)\n(`REASONDESCRIPTION`, String)\n"
        ]
    },
    {
        "sql_id": 102,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(strftime('%J', T2.STOP) - strftime('%J', T2.START)) AS REAL) / COUNT(T1.patient) FROM patients AS T1 INNER JOIN careplans AS T2 ON T1.patient = T2.PATIENT WHERE T1.prefix = 'Mr.' AND T1.first = 'Wesley' AND T1.last = 'Lemke'",
        "target_query": "SELECT CAST(SUM(dateDiff('day', `T2`.`START`, `T2`.`STOP`)) AS Float64) / COUNT(`T1`.`patient`) \nFROM `patients` AS `T1` \nINNER JOIN `careplans` AS `T2` ON `T1`.`patient` = `T2`.`PATIENT` \nWHERE `T1`.`prefix` = 'Mr.' AND `T1`.`first` = 'Wesley' AND `T1`.`last` = 'Lemke';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 39,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 42,
                "end_index": 66,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `careplans`\nColumns:\n(`ID`, text)\n(`START`, date)\n(`STOP`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, real)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, String, primary key)\n(`birthdate`, Date32)\n(`deathdate`, Date32)\n(`ssn`, String)\n(`drivers`, String)\n(`passport`, String)\n(`prefix`, String)\n(`first`, String)\n(`last`, String)\n(`suffix`, String)\n(`maiden`, String)\n(`marital`, String)\n(`race`, String)\n(`ethnicity`, String)\n(`gender`, String)\n(`birthplace`, String)\n(`address`, String)\n",
            "Table: `careplans`\nColumns:\n(`ID`, String)\n(`START`, Date32)\n(`STOP`, Date32)\n(`PATIENT`, String)\n(`ENCOUNTER`, String)\n(`CODE`, Float64)\n(`DESCRIPTION`, String)\n(`REASONCODE`, Int64)\n(`REASONDESCRIPTION`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 105,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(PATIENT) FROM conditions WHERE DESCRIPTION = 'Diabetes' AND strftime('%Y', START) = '1988'",
        "target_query": "SELECT COUNT(`PATIENT`) FROM `conditions` WHERE `DESCRIPTION` = 'Diabetes' AND formatDateTime(`START`, '%Y') = '1988';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 73,
                "end_index": 94,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 79,
                "end_index": 108,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `conditions`\nColumns:\n(`START`, date)\n(`STOP`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, integer)\n(`DESCRIPTION`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `conditions`\nColumns:\n(`START`, Date32)\n(`STOP`, Date32)\n(`PATIENT`, String)\n(`ENCOUNTER`, String)\n(`CODE`, Int64)\n(`DESCRIPTION`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 106,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(DISTINCT T1.patient) FROM patients AS T1 INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Ibuprofen 200 MG Oral Tablet' AND T1.ethnicity = 'dominican' AND strftime('%Y', T2.START) = '2016' AND strftime('%m', T2.STOP) - strftime('%m', T2.START) = 1",
        "target_query": "SELECT COUNT(DISTINCT `T1`.`patient`) FROM `patients` AS `T1` INNER JOIN `medications` AS `T2` ON `T1`.`patient` = `T2`.`PATIENT` WHERE `T2`.`DESCRIPTION` = 'Ibuprofen 200 MG Oral Tablet' AND `T1`.`ethnicity` = 'dominican' AND formatDateTime(`T2`.`START`, '%Y') = '2016' AND toInt32(formatDateTime(`T2`.`STOP`, '%m')) - toInt32(formatDateTime(`T2`.`START`, '%m')) = 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 199,
                "end_index": 223,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 237,
                "end_index": 260,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 263,
                "end_index": 287,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 227,
                "end_index": 261,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            },
            {
                "start_index": 283,
                "end_index": 316,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            },
            {
                "start_index": 328,
                "end_index": 362,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `medications`\nColumns:\n(`START`, date, primary key)\n(`STOP`, date)\n(`PATIENT`, text, primary key)\n(`ENCOUNTER`, text, primary key)\n(`CODE`, integer, primary key)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, String, primary key)\n(`birthdate`, Date32)\n(`deathdate`, Date32)\n(`ssn`, String)\n(`drivers`, String)\n(`passport`, String)\n(`prefix`, String)\n(`first`, String)\n(`last`, String)\n(`suffix`, String)\n(`maiden`, String)\n(`marital`, String)\n(`race`, String)\n(`ethnicity`, String)\n(`gender`, String)\n(`birthplace`, String)\n(`address`, String)\n",
            "Table: `medications`\nColumns:\n(`START`, Date32, primary key)\n(`STOP`, Date32)\n(`PATIENT`, String, primary key)\n(`ENCOUNTER`, String, primary key)\n(`CODE`, Int64, primary key)\n(`DESCRIPTION`, String)\n(`REASONCODE`, Int64)\n(`REASONDESCRIPTION`, String)\n"
        ]
    },
    {
        "sql_id": 107,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(DISTINCT T1.patient) FROM patients AS T1 INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT WHERE DESCRIPTION = 'Pneumonia' AND strftime('%Y', T1.birthdate) LIKE '192%'",
        "target_query": "SELECT COUNT(DISTINCT `T1`.`patient`) FROM `patients` AS `T1` INNER JOIN `conditions` AS `T2` ON `T1`.`patient` = `T2`.`PATIENT` WHERE `T2`.`DESCRIPTION` = 'Pneumonia' AND formatDateTime(`T1`.`birthdate`, '%Y') LIKE '192%';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 145,
                "end_index": 173,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 172,
                "end_index": 210,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `conditions`\nColumns:\n(`START`, date)\n(`STOP`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, integer)\n(`DESCRIPTION`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, String, primary key)\n(`birthdate`, Date32)\n(`deathdate`, Date32)\n(`ssn`, String)\n(`drivers`, String)\n(`passport`, String)\n(`prefix`, String)\n(`first`, String)\n(`last`, String)\n(`suffix`, String)\n(`maiden`, String)\n(`marital`, String)\n(`race`, String)\n(`ethnicity`, String)\n(`gender`, String)\n(`birthplace`, String)\n(`address`, String)\n",
            "Table: `conditions`\nColumns:\n(`START`, Date32)\n(`STOP`, Date32)\n(`PATIENT`, String)\n(`ENCOUNTER`, String)\n(`CODE`, Int64)\n(`DESCRIPTION`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 108,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT T1.first, T1.last, T1.suffix FROM patients AS T1 INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Yaz 28 Day Pack' AND strftime('%Y', T2.START) = '2011'",
        "target_query": "SELECT DISTINCT `T1`.`first`, `T1`.`last`, `T1`.`suffix` FROM `patients` AS `T1` INNER JOIN `medications` AS `T2` ON `T1`.`patient` = `T2`.`PATIENT` WHERE `T2`.`DESCRIPTION` = 'Yaz 28 Day Pack' AND formatDateTime(`T2`.`START`, '%Y') = '2011';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 166,
                "end_index": 190,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 198,
                "end_index": 232,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `medications`\nColumns:\n(`START`, date, primary key)\n(`STOP`, date)\n(`PATIENT`, text, primary key)\n(`ENCOUNTER`, text, primary key)\n(`CODE`, integer, primary key)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, String, primary key)\n(`birthdate`, Date32)\n(`deathdate`, Date32)\n(`ssn`, String)\n(`drivers`, String)\n(`passport`, String)\n(`prefix`, String)\n(`first`, String)\n(`last`, String)\n(`suffix`, String)\n(`maiden`, String)\n(`marital`, String)\n(`race`, String)\n(`ethnicity`, String)\n(`gender`, String)\n(`birthplace`, String)\n(`address`, String)\n",
            "Table: `medications`\nColumns:\n(`START`, Date32, primary key)\n(`STOP`, Date32)\n(`PATIENT`, String, primary key)\n(`ENCOUNTER`, String, primary key)\n(`CODE`, Int64, primary key)\n(`DESCRIPTION`, String)\n(`REASONCODE`, Int64)\n(`REASONDESCRIPTION`, String)\n"
        ]
    },
    {
        "sql_id": 109,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(DISTINCT T1.patient) FROM patients AS T1 INNER JOIN immunizations AS T2 ON T1.patient = T2.PATIENT WHERE T1.race = 'black' AND T2.DESCRIPTION = 'DTaP' AND strftime('%Y', T2.DATE) = '2013'",
        "target_query": "SELECT COUNT(DISTINCT T1.`patient`) FROM `patients` AS T1 INNER JOIN `immunizations` AS T2 ON T1.`patient` = T2.`PATIENT` WHERE T1.`race` = 'black' AND T2.`DESCRIPTION` = 'DTaP' AND formatDateTime(T2.`DATE`, '%Y') = '2013';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 168,
                "end_index": 191,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 182,
                "end_index": 213,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `immunizations`\nColumns:\n(`DATE`, date, primary key)\n(`PATIENT`, text, primary key)\n(`ENCOUNTER`, text, primary key)\n(`CODE`, integer, primary key)\n(`DESCRIPTION`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, String, primary key)\n(`birthdate`, Date32)\n(`deathdate`, Date32)\n(`ssn`, String)\n(`drivers`, String)\n(`passport`, String)\n(`prefix`, String)\n(`first`, String)\n(`last`, String)\n(`suffix`, String)\n(`maiden`, String)\n(`marital`, String)\n(`race`, String)\n(`ethnicity`, String)\n(`gender`, String)\n(`birthplace`, String)\n(`address`, String)\n",
            "Table: `immunizations`\nColumns:\n(`DATE`, Date32, primary key)\n(`PATIENT`, String, primary key)\n(`ENCOUNTER`, String, primary key)\n(`CODE`, Int64, primary key)\n(`DESCRIPTION`, String)\n"
        ]
    },
    {
        "sql_id": 111,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.DESCRIPTION FROM conditions AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE T2.deathdate IS NOT NULL ORDER BY strftime('%Y', T2.deathdate) - strftime('%Y', T2.birthdate) DESC LIMIT 1",
        "target_query": "SELECT `T1`.`DESCRIPTION` FROM `conditions` AS `T1` INNER JOIN `patients` AS `T2` ON `T1`.`PATIENT` = `T2`.`patient` WHERE `T2`.`deathdate` IS NOT NULL ORDER BY (toYear(`T2`.`deathdate`) - toYear(`T2`.`birthdate`)) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 137,
                "end_index": 165,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 168,
                "end_index": 196,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `conditions`\nColumns:\n(`START`, date)\n(`STOP`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, integer)\n(`DESCRIPTION`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `conditions`\nColumns:\n(`START`, Date32)\n(`STOP`, Date32)\n(`PATIENT`, String)\n(`ENCOUNTER`, String)\n(`CODE`, Int64)\n(`DESCRIPTION`, String)\n(`rowid`, Int64, primary key)\n",
            "Table: `patients`\nColumns:\n(`patient`, String, primary key)\n(`birthdate`, Date32)\n(`deathdate`, Date32)\n(`ssn`, String)\n(`drivers`, String)\n(`passport`, String)\n(`prefix`, String)\n(`first`, String)\n(`last`, String)\n(`suffix`, String)\n(`maiden`, String)\n(`marital`, String)\n(`race`, String)\n(`ethnicity`, String)\n(`gender`, String)\n(`birthplace`, String)\n(`address`, String)\n"
        ]
    },
    {
        "sql_id": 112,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.first, T1.last FROM patients AS T1 INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Clopidogrel 75 MG Oral Tablet' AND strftime('%Y', T2.STOP) - strftime('%Y', T2.START) > 10",
        "target_query": "SELECT T1.`first`, T1.`last` FROM `patients` AS T1 INNER JOIN `medications` AS T2 ON T1.`patient` = T2.`PATIENT` WHERE T2.`DESCRIPTION` = 'Clopidogrel 75 MG Oral Tablet' AND dateDiff('year', T2.`START`, T2.`STOP`) > 10;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 160,
                "end_index": 183,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 186,
                "end_index": 210,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `medications`\nColumns:\n(`START`, date, primary key)\n(`STOP`, date)\n(`PATIENT`, text, primary key)\n(`ENCOUNTER`, text, primary key)\n(`CODE`, integer, primary key)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, String, primary key)\n(`birthdate`, Date32)\n(`deathdate`, Date32)\n(`ssn`, String)\n(`drivers`, String)\n(`passport`, String)\n(`prefix`, String)\n(`first`, String)\n(`last`, String)\n(`suffix`, String)\n(`maiden`, String)\n(`marital`, String)\n(`race`, String)\n(`ethnicity`, String)\n(`gender`, String)\n(`birthplace`, String)\n(`address`, String)\n",
            "Table: `medications`\nColumns:\n(`START`, Date32, primary key)\n(`STOP`, Date32)\n(`PATIENT`, String, primary key)\n(`ENCOUNTER`, String, primary key)\n(`CODE`, Int64, primary key)\n(`DESCRIPTION`, String)\n(`REASONCODE`, Int64)\n(`REASONDESCRIPTION`, String)\n"
        ]
    },
    {
        "sql_id": 114,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(CASE WHEN T2.DESCRIPTION = 'Influenza seasonal injectable preservative free' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.patient), SUM(CASE WHEN T1.ethnicity = 'english' THEN 1 ELSE 0 END) FROM patients AS T1 INNER JOIN immunizations AS T2 ON T1.patient = T2.PATIENT WHERE strftime('%Y', T2.DATE) = '2017'",
        "target_query": "SELECT CAST(SUM(CASE WHEN `T2`.`DESCRIPTION` = 'Influenza seasonal injectable preservative free' THEN 1 ELSE 0 END) AS Float64) * 100 / COUNT(`T1`.`patient`), SUM(CASE WHEN `T1`.`ethnicity` = 'english' THEN 1 ELSE 0 END) FROM `patients` AS `T1` INNER JOIN `immunizations` AS `T2` ON `T1`.`patient` = `T2`.`PATIENT` WHERE formatDateTime(`T2`.`DATE`, '%Y') = '2017';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 290,
                "end_index": 313,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 321,
                "end_index": 354,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `immunizations`\nColumns:\n(`DATE`, date, primary key)\n(`PATIENT`, text, primary key)\n(`ENCOUNTER`, text, primary key)\n(`CODE`, integer, primary key)\n(`DESCRIPTION`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, String, primary key)\n(`birthdate`, Date32)\n(`deathdate`, Date32)\n(`ssn`, String)\n(`drivers`, String)\n(`passport`, String)\n(`prefix`, String)\n(`first`, String)\n(`last`, String)\n(`suffix`, String)\n(`maiden`, String)\n(`marital`, String)\n(`race`, String)\n(`ethnicity`, String)\n(`gender`, String)\n(`birthplace`, String)\n(`address`, String)\n",
            "Table: `immunizations`\nColumns:\n(`DATE`, Date32, primary key)\n(`PATIENT`, String, primary key)\n(`ENCOUNTER`, String, primary key)\n(`CODE`, Int64, primary key)\n(`DESCRIPTION`, String)\n"
        ]
    },
    {
        "sql_id": 118,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT strftime('%J', T2.STOP) - strftime('%J', T2.START) AS takenDays FROM patients AS T1 INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Berry' AND T1.last = 'Keebler' AND T2.REASONDESCRIPTION = 'Acute bronchitis (disorder)' AND T2.DESCRIPTION = 'Acetaminophen 160 MG'",
        "target_query": "SELECT (toUnixTimestamp(`T2`.`STOP`) - toUnixTimestamp(`T2`.`START`)) / 86400 AS takenDays FROM `patients` AS `T1` INNER JOIN `medications` AS `T2` ON `T1`.`patient` = `T2`.`PATIENT` WHERE `T1`.`first` = 'Berry' AND `T1`.`last` = 'Keebler' AND `T2`.`REASONDESCRIPTION` = 'Acute bronchitis (disorder)' AND `T2`.`DESCRIPTION` = 'Acetaminophen 160 MG';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 30,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 33,
                "end_index": 57,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `medications`\nColumns:\n(`START`, date, primary key)\n(`STOP`, date)\n(`PATIENT`, text, primary key)\n(`ENCOUNTER`, text, primary key)\n(`CODE`, integer, primary key)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, String, primary key)\n(`birthdate`, Date32)\n(`deathdate`, Date32)\n(`ssn`, String)\n(`drivers`, String)\n(`passport`, String)\n(`prefix`, String)\n(`first`, String)\n(`last`, String)\n(`suffix`, String)\n(`maiden`, String)\n(`marital`, String)\n(`race`, String)\n(`ethnicity`, String)\n(`gender`, String)\n(`birthplace`, String)\n(`address`, String)\n",
            "Table: `medications`\nColumns:\n(`START`, Date32, primary key)\n(`STOP`, Date32)\n(`PATIENT`, String, primary key)\n(`ENCOUNTER`, String, primary key)\n(`CODE`, Int64, primary key)\n(`DESCRIPTION`, String)\n(`REASONCODE`, Int64)\n(`REASONDESCRIPTION`, String)\n"
        ]
    },
    {
        "sql_id": 119,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(DISTINCT T1.patient) FROM patients AS T1 INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE T1.marital = 'S' AND T2.REASONDESCRIPTION = 'Cystitis' AND T2.DESCRIPTION = 'Nitrofurantoin 5 MG/ML [Furadantin]' AND strftime('%Y', T2.START) = '2010'",
        "target_query": "SELECT COUNT(DISTINCT `T1`.`patient`) FROM `patients` AS `T1` INNER JOIN `medications` AS `T2` ON `T1`.`patient` = `T2`.`PATIENT` WHERE `T1`.`marital` = 'S' AND `T2`.`REASONDESCRIPTION` = 'Cystitis' AND `T2`.`DESCRIPTION` = 'Nitrofurantoin 5 MG/ML [Furadantin]' AND formatDateTime(`T2`.`START`, '%Y') = '2010';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 234,
                "end_index": 258,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 266,
                "end_index": 300,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `medications`\nColumns:\n(`START`, date, primary key)\n(`STOP`, date)\n(`PATIENT`, text, primary key)\n(`ENCOUNTER`, text, primary key)\n(`CODE`, integer, primary key)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, String, primary key)\n(`birthdate`, Date32)\n(`deathdate`, Date32)\n(`ssn`, String)\n(`drivers`, String)\n(`passport`, String)\n(`prefix`, String)\n(`first`, String)\n(`last`, String)\n(`suffix`, String)\n(`maiden`, String)\n(`marital`, String)\n(`race`, String)\n(`ethnicity`, String)\n(`gender`, String)\n(`birthplace`, String)\n(`address`, String)\n",
            "Table: `medications`\nColumns:\n(`START`, Date32, primary key)\n(`STOP`, Date32)\n(`PATIENT`, String, primary key)\n(`ENCOUNTER`, String, primary key)\n(`CODE`, Int64, primary key)\n(`DESCRIPTION`, String)\n(`REASONCODE`, Int64)\n(`REASONDESCRIPTION`, String)\n"
        ]
    },
    {
        "sql_id": 123,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.DESCRIPTION FROM patients AS T1 INNER JOIN careplans AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Elly' AND T1.last = 'Koss' AND strftime('%Y', T2.START) = '2013'",
        "target_query": "SELECT T2.`DESCRIPTION` FROM `patients` AS T1 INNER JOIN `careplans` AS T2 ON T1.`patient` = T2.`PATIENT` WHERE T1.`first` = 'Elly' AND T1.`last` = 'Koss' AND formatDateTime(T2.`START`, '%Y') = '2013';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 145,
                "end_index": 169,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 159,
                "end_index": 191,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `careplans`\nColumns:\n(`ID`, text)\n(`START`, date)\n(`STOP`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, real)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, String, primary key)\n(`birthdate`, Date32)\n(`deathdate`, Date32)\n(`ssn`, String)\n(`drivers`, String)\n(`passport`, String)\n(`prefix`, String)\n(`first`, String)\n(`last`, String)\n(`suffix`, String)\n(`maiden`, String)\n(`marital`, String)\n(`race`, String)\n(`ethnicity`, String)\n(`gender`, String)\n(`birthplace`, String)\n(`address`, String)\n",
            "Table: `careplans`\nColumns:\n(`ID`, String)\n(`START`, Date32)\n(`STOP`, Date32)\n(`PATIENT`, String)\n(`ENCOUNTER`, String)\n(`CODE`, Float64)\n(`DESCRIPTION`, String)\n(`REASONCODE`, Int64)\n(`REASONDESCRIPTION`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 126,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(COUNT(PATIENT) AS REAL) / COUNT(DISTINCT strftime('%Y', DATE)) FROM procedures WHERE DESCRIPTION = 'Combined chemotherapy and radiation therapy (procedure)'",
        "target_query": "SELECT COUNT(`PATIENT`) / COUNT(DISTINCT formatDateTime(`DATE`, '%Y')) FROM `procedures` WHERE `DESCRIPTION` = 'Combined chemotherapy and radiation therapy (procedure)';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 53,
                "end_index": 73,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 41,
                "end_index": 69,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `procedures`\nColumns:\n(`DATE`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, integer)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `procedures`\nColumns:\n(`DATE`, Date32)\n(`PATIENT`, String)\n(`ENCOUNTER`, String)\n(`CODE`, Int64)\n(`DESCRIPTION`, String)\n(`REASONCODE`, Int64)\n(`REASONDESCRIPTION`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 127,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT strftime('%J', T2.STOP) - strftime('%J', T2.START) AS timeFrame , T2.DESCRIPTION FROM patients AS T1 INNER JOIN careplans AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Jacquelyn' AND T1.last = 'Shanahan' ORDER BY T2.START DESC LIMIT 1",
        "target_query": "SELECT dateDiff('day', `T2`.`STOP`, `T2`.`START`) AS `timeFrame`, `T2`.`DESCRIPTION` FROM `patients` AS `T1` INNER JOIN `careplans` AS `T2` ON `T1`.`patient` = `T2`.`PATIENT` WHERE `T1`.`first` = 'Jacquelyn' AND `T1`.`last` = 'Shanahan' ORDER BY `T2`.`START` DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 30,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 33,
                "end_index": 57,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `careplans`\nColumns:\n(`ID`, text)\n(`START`, date)\n(`STOP`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, real)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, String, primary key)\n(`birthdate`, Date32)\n(`deathdate`, Date32)\n(`ssn`, String)\n(`drivers`, String)\n(`passport`, String)\n(`prefix`, String)\n(`first`, String)\n(`last`, String)\n(`suffix`, String)\n(`maiden`, String)\n(`marital`, String)\n(`race`, String)\n(`ethnicity`, String)\n(`gender`, String)\n(`birthplace`, String)\n(`address`, String)\n",
            "Table: `careplans`\nColumns:\n(`ID`, String)\n(`START`, Date32)\n(`STOP`, Date32)\n(`PATIENT`, String)\n(`ENCOUNTER`, String)\n(`CODE`, Float64)\n(`DESCRIPTION`, String)\n(`REASONCODE`, Int64)\n(`REASONDESCRIPTION`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 128,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.DESCRIPTION FROM patients AS T1 INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Joye' AND T1.last = 'Homenick' AND strftime('%Y', T2.START) = '2017'",
        "target_query": "SELECT T2.`DESCRIPTION` FROM `patients` AS T1 INNER JOIN `conditions` AS T2 ON T1.`patient` = T2.`PATIENT` WHERE T1.`first` = 'Joye' AND T1.`last` = 'Homenick' AND formatDateTime(T2.`START`, '%Y') = '2017';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 150,
                "end_index": 174,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 164,
                "end_index": 196,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `conditions`\nColumns:\n(`START`, date)\n(`STOP`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, integer)\n(`DESCRIPTION`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, String, primary key)\n(`birthdate`, Date32)\n(`deathdate`, Date32)\n(`ssn`, String)\n(`drivers`, String)\n(`passport`, String)\n(`prefix`, String)\n(`first`, String)\n(`last`, String)\n(`suffix`, String)\n(`maiden`, String)\n(`marital`, String)\n(`race`, String)\n(`ethnicity`, String)\n(`gender`, String)\n(`birthplace`, String)\n(`address`, String)\n",
            "Table: `conditions`\nColumns:\n(`START`, Date32)\n(`STOP`, Date32)\n(`PATIENT`, String)\n(`ENCOUNTER`, String)\n(`CODE`, Int64)\n(`DESCRIPTION`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 129,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT strftime('%J', T2.STOP) - strftime('%J', T2.START) AS days FROM patients AS T1 INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Elly' AND last = 'Koss' AND T2.DESCRIPTION = 'Acetaminophen 160 MG'",
        "target_query": "SELECT CAST(dateDiff('day', `T2`.`START`, `T2`.`STOP`) AS Float64) AS `days` FROM `patients` AS `T1` INNER JOIN `medications` AS `T2` ON `T1`.`patient` = `T2`.`PATIENT` WHERE `T1`.`first` = 'Elly' AND `T1`.`last` = 'Koss' AND `T2`.`DESCRIPTION` = 'Acetaminophen 160 MG';",
        "semantic_equivalent_type": "Approximate equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 30,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 33,
                "end_index": 57,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `medications`\nColumns:\n(`START`, date, primary key)\n(`STOP`, date)\n(`PATIENT`, text, primary key)\n(`ENCOUNTER`, text, primary key)\n(`CODE`, integer, primary key)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, String, primary key)\n(`birthdate`, Date32)\n(`deathdate`, Date32)\n(`ssn`, String)\n(`drivers`, String)\n(`passport`, String)\n(`prefix`, String)\n(`first`, String)\n(`last`, String)\n(`suffix`, String)\n(`maiden`, String)\n(`marital`, String)\n(`race`, String)\n(`ethnicity`, String)\n(`gender`, String)\n(`birthplace`, String)\n(`address`, String)\n",
            "Table: `medications`\nColumns:\n(`START`, Date32, primary key)\n(`STOP`, Date32)\n(`PATIENT`, String, primary key)\n(`ENCOUNTER`, String, primary key)\n(`CODE`, Int64, primary key)\n(`DESCRIPTION`, String)\n(`REASONCODE`, Int64)\n(`REASONDESCRIPTION`, String)\n"
        ]
    },
    {
        "sql_id": 130,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(CASE WHEN T2.gender = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.PATIENT) FROM encounters AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE strftime('%Y', T1.DATE) = '2010' AND T1.REASONDESCRIPTION = 'Contact dermatitis'",
        "target_query": "SELECT CAST(SUM(CASE WHEN `T2`.`gender` = 'F' THEN 1 ELSE 0 END) AS Float64) * 100 / COUNT(`T1`.`PATIENT`) FROM `encounters` AS `T1` INNER JOIN `patients` AS `T2` ON `T1`.`PATIENT` = `T2`.`patient` WHERE formatDateTime(`T1`.`DATE`, '%Y') = '2010' AND `T1`.`REASONDESCRIPTION` = 'Contact dermatitis';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 177,
                "end_index": 200,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 204,
                "end_index": 237,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `encounters`\nColumns:\n(`ID`, text, primary key)\n(`DATE`, date)\n(`PATIENT`, text)\n(`CODE`, integer)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n",
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `encounters`\nColumns:\n(`ID`, String, primary key)\n(`DATE`, Date32)\n(`PATIENT`, String)\n(`CODE`, Int64)\n(`DESCRIPTION`, String)\n(`REASONCODE`, Int64)\n(`REASONDESCRIPTION`, String)\n",
            "Table: `patients`\nColumns:\n(`patient`, String, primary key)\n(`birthdate`, Date32)\n(`deathdate`, Date32)\n(`ssn`, String)\n(`drivers`, String)\n(`passport`, String)\n(`prefix`, String)\n(`first`, String)\n(`last`, String)\n(`suffix`, String)\n(`maiden`, String)\n(`marital`, String)\n(`race`, String)\n(`ethnicity`, String)\n(`gender`, String)\n(`birthplace`, String)\n(`address`, String)\n"
        ]
    },
    {
        "sql_id": 131,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T1.patient) , CAST(SUM(CASE WHEN T2.DESCRIPTION = 'Prenatal visit' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.patient) FROM patients AS T1 INNER JOIN encounters AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Lorri' AND T1.last = 'Simonis' AND strftime('%Y', T2.DATE) BETWEEN '2010' AND '2017'",
        "target_query": "SELECT COUNT(`T1`.`patient`), SUM(CASE WHEN `T2`.`DESCRIPTION` = 'Prenatal visit' THEN 1 ELSE 0 END) * 100 / COUNT(`T1`.`patient`) \nFROM `patients` AS `T1` \nINNER JOIN `encounters` AS `T2` ON `T1`.`patient` = `T2`.`PATIENT` \nWHERE `T1`.`first` = 'Lorri' AND `T1`.`last` = 'Simonis' AND formatDateTime(`T2`.`DATE`, '%Y') BETWEEN '2010' AND '2017';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 262,
                "end_index": 285,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 286,
                "end_index": 319,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `encounters`\nColumns:\n(`ID`, text, primary key)\n(`DATE`, date)\n(`PATIENT`, text)\n(`CODE`, integer)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, String, primary key)\n(`birthdate`, Date32)\n(`deathdate`, Date32)\n(`ssn`, String)\n(`drivers`, String)\n(`passport`, String)\n(`prefix`, String)\n(`first`, String)\n(`last`, String)\n(`suffix`, String)\n(`maiden`, String)\n(`marital`, String)\n(`race`, String)\n(`ethnicity`, String)\n(`gender`, String)\n(`birthplace`, String)\n(`address`, String)\n",
            "Table: `encounters`\nColumns:\n(`ID`, String, primary key)\n(`DATE`, Date32)\n(`PATIENT`, String)\n(`CODE`, Int64)\n(`DESCRIPTION`, String)\n(`REASONCODE`, Int64)\n(`REASONDESCRIPTION`, String)\n"
        ]
    },
    {
        "sql_id": 132,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(CASE WHEN T2.race = 'hispanic' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.PATIENT) FROM careplans AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE strftime('%Y', T1.stop) = '2011'",
        "target_query": "SELECT CASE WHEN COUNT(`T1`.`PATIENT`) = 0 THEN NULL ELSE SUM(CASE WHEN `T2`.`race` = 'hispanic' THEN 1 ELSE 0 END) * 100 / COUNT(`T1`.`PATIENT`) END FROM `careplans` AS `T1` INNER JOIN `patients` AS `T2` ON `T1`.`PATIENT` = `T2`.`patient` WHERE formatDateTime(`T1`.`STOP`, '%Y') = '2011';",
        "semantic_equivalent_type": "Approximate equivalence",
        "source_dialect_locations": [
            {
                "start_index": 181,
                "end_index": 204,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 246,
                "end_index": 279,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `careplans`\nColumns:\n(`ID`, text)\n(`START`, date)\n(`STOP`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, real)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `careplans`\nColumns:\n(`ID`, String)\n(`START`, Date32)\n(`STOP`, Date32)\n(`PATIENT`, String)\n(`ENCOUNTER`, String)\n(`CODE`, Float64)\n(`DESCRIPTION`, String)\n(`REASONCODE`, Int64)\n(`REASONDESCRIPTION`, String)\n(`rowid`, Int64, primary key)\n",
            "Table: `patients`\nColumns:\n(`patient`, String, primary key)\n(`birthdate`, Date32)\n(`deathdate`, Date32)\n(`ssn`, String)\n(`drivers`, String)\n(`passport`, String)\n(`prefix`, String)\n(`first`, String)\n(`last`, String)\n(`suffix`, String)\n(`maiden`, String)\n(`marital`, String)\n(`race`, String)\n(`ethnicity`, String)\n(`gender`, String)\n(`birthplace`, String)\n(`address`, String)\n"
        ]
    },
    {
        "sql_id": 133,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(CASE WHEN T2.gender = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.PATIENT) AS percentage FROM careplans AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE strftime('%Y', T1.START) = '2010'",
        "target_query": "SELECT CAST(SUM(CASE WHEN `T2`.`gender` = 'F' THEN 1 ELSE 0 END) AS Float64) * 100 / COUNT(`T1`.`PATIENT`) AS percentage FROM `careplans` AS `T1` INNER JOIN `patients` AS `T2` ON `T1`.`PATIENT` = `T2`.`patient` WHERE formatDateTime(`T1`.`START`, '%Y') = '2010';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 190,
                "end_index": 214,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 217,
                "end_index": 251,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `careplans`\nColumns:\n(`ID`, text)\n(`START`, date)\n(`STOP`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, real)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `careplans`\nColumns:\n(`ID`, String)\n(`START`, Date32)\n(`STOP`, Date32)\n(`PATIENT`, String)\n(`ENCOUNTER`, String)\n(`CODE`, Float64)\n(`DESCRIPTION`, String)\n(`REASONCODE`, Int64)\n(`REASONDESCRIPTION`, String)\n(`rowid`, Int64, primary key)\n",
            "Table: `patients`\nColumns:\n(`patient`, String, primary key)\n(`birthdate`, Date32)\n(`deathdate`, Date32)\n(`ssn`, String)\n(`drivers`, String)\n(`passport`, String)\n(`prefix`, String)\n(`first`, String)\n(`last`, String)\n(`suffix`, String)\n(`maiden`, String)\n(`marital`, String)\n(`race`, String)\n(`ethnicity`, String)\n(`gender`, String)\n(`birthplace`, String)\n(`address`, String)\n"
        ]
    },
    {
        "sql_id": 134,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(DISTINCT T2.patient) FROM careplans AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE T2.race = 'black' AND strftime('%Y', T1.STOP) = '2017'",
        "target_query": "SELECT COUNT(DISTINCT `T2`.`patient`) FROM `careplans` AS `T1` INNER JOIN `patients` AS `T2` ON `T1`.`PATIENT` = `T2`.`patient` WHERE `T2`.`race` = 'black' AND formatDateTime(`T1`.`STOP`, '%Y') = '2017';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 136,
                "end_index": 159,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 160,
                "end_index": 193,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `careplans`\nColumns:\n(`ID`, text)\n(`START`, date)\n(`STOP`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, real)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `careplans`\nColumns:\n(`ID`, String)\n(`START`, Date32)\n(`STOP`, Date32)\n(`PATIENT`, String)\n(`ENCOUNTER`, String)\n(`CODE`, Float64)\n(`DESCRIPTION`, String)\n(`REASONCODE`, Int64)\n(`REASONDESCRIPTION`, String)\n(`rowid`, Int64, primary key)\n",
            "Table: `patients`\nColumns:\n(`patient`, String, primary key)\n(`birthdate`, Date32)\n(`deathdate`, Date32)\n(`ssn`, String)\n(`drivers`, String)\n(`passport`, String)\n(`prefix`, String)\n(`first`, String)\n(`last`, String)\n(`suffix`, String)\n(`maiden`, String)\n(`marital`, String)\n(`race`, String)\n(`ethnicity`, String)\n(`gender`, String)\n(`birthplace`, String)\n(`address`, String)\n"
        ]
    },
    {
        "sql_id": 135,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT T1.first, T1.last FROM patients AS T1 INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Penicillin V Potassium 250 MG' AND strftime('%Y', T2.START) >= '1948'",
        "target_query": "SELECT DISTINCT `T1`.`first`, `T1`.`last` \nFROM `patients` AS `T1` \nINNER JOIN `medications` AS `T2` \nON `T1`.`patient` = `T2`.`PATIENT` \nWHERE `T2`.`DESCRIPTION` = 'Penicillin V Potassium 250 MG' \nAND formatDateTime(`T2`.`START`, '%Y') >= '1948';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 169,
                "end_index": 193,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 202,
                "end_index": 236,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `medications`\nColumns:\n(`START`, date, primary key)\n(`STOP`, date)\n(`PATIENT`, text, primary key)\n(`ENCOUNTER`, text, primary key)\n(`CODE`, integer, primary key)\n(`DESCRIPTION`, text)\n(`REASONCODE`, integer)\n(`REASONDESCRIPTION`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, String, primary key)\n(`birthdate`, Date32)\n(`deathdate`, Date32)\n(`ssn`, String)\n(`drivers`, String)\n(`passport`, String)\n(`prefix`, String)\n(`first`, String)\n(`last`, String)\n(`suffix`, String)\n(`maiden`, String)\n(`marital`, String)\n(`race`, String)\n(`ethnicity`, String)\n(`gender`, String)\n(`birthplace`, String)\n(`address`, String)\n",
            "Table: `medications`\nColumns:\n(`START`, Date32, primary key)\n(`STOP`, Date32)\n(`PATIENT`, String, primary key)\n(`ENCOUNTER`, String, primary key)\n(`CODE`, Int64, primary key)\n(`DESCRIPTION`, String)\n(`REASONCODE`, Int64)\n(`REASONDESCRIPTION`, String)\n"
        ]
    },
    {
        "sql_id": 136,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(DISTINCT T1.patient) FROM patients AS T1 INNER JOIN conditions AS T2 ON T1.patient = T2.patient WHERE strftime('%Y', T1.birthdate) = '1935' AND T1.race = 'white' AND T2.DESCRIPTION = 'Stroke'",
        "target_query": "SELECT COUNT(DISTINCT `T1`.`patient`) FROM `patients` AS `T1` INNER JOIN `conditions` AS `T2` ON `T1`.`patient` = `T2`.`PATIENT` WHERE formatDateTime(`T1`.`birthdate`, '%Y') = '1935' AND `T1`.`race` = 'white' AND `T2`.`DESCRIPTION` = 'Stroke';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 115,
                "end_index": 143,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 135,
                "end_index": 173,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n",
            "Table: `conditions`\nColumns:\n(`START`, date)\n(`STOP`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, integer)\n(`DESCRIPTION`, text)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `patients`\nColumns:\n(`patient`, String, primary key)\n(`birthdate`, Date32)\n(`deathdate`, Date32)\n(`ssn`, String)\n(`drivers`, String)\n(`passport`, String)\n(`prefix`, String)\n(`first`, String)\n(`last`, String)\n(`suffix`, String)\n(`maiden`, String)\n(`marital`, String)\n(`race`, String)\n(`ethnicity`, String)\n(`gender`, String)\n(`birthplace`, String)\n(`address`, String)\n",
            "Table: `conditions`\nColumns:\n(`START`, Date32)\n(`STOP`, Date32)\n(`PATIENT`, String)\n(`ENCOUNTER`, String)\n(`CODE`, Int64)\n(`DESCRIPTION`, String)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 137,
        "database_name": "synthea",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.first, T2.last FROM conditions AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE T1.DESCRIPTION = 'Drug overdose' AND ROUND((strftime('%J', T2.deathdate) - strftime('%J', T2.birthdate)) / 365) = 44",
        "target_query": "SELECT T2.`first`, T2.`last` FROM `conditions` AS T1 INNER JOIN `patients` AS T2 ON T1.`PATIENT` = T2.`patient` WHERE T1.`DESCRIPTION` = 'Drug overdose' AND ROUND((dateDiff('day', T2.`birthdate`, T2.`deathdate`)) / 365) = 44;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 150,
                "end_index": 178,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 181,
                "end_index": 209,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `conditions`\nColumns:\n(`START`, date)\n(`STOP`, date)\n(`PATIENT`, text)\n(`ENCOUNTER`, text)\n(`CODE`, integer)\n(`DESCRIPTION`, text)\n(`rowid`, integer, primary key)\n",
            "Table: `patients`\nColumns:\n(`patient`, text, primary key)\n(`birthdate`, date)\n(`deathdate`, date)\n(`ssn`, text)\n(`drivers`, text)\n(`passport`, text)\n(`prefix`, text)\n(`first`, text)\n(`last`, text)\n(`suffix`, text)\n(`maiden`, text)\n(`marital`, text)\n(`race`, text)\n(`ethnicity`, text)\n(`gender`, text)\n(`birthplace`, text)\n(`address`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `conditions`\nColumns:\n(`START`, Date32)\n(`STOP`, Date32)\n(`PATIENT`, String)\n(`ENCOUNTER`, String)\n(`CODE`, Int64)\n(`DESCRIPTION`, String)\n(`rowid`, Int64, primary key)\n",
            "Table: `patients`\nColumns:\n(`patient`, String, primary key)\n(`birthdate`, Date32)\n(`deathdate`, Date32)\n(`ssn`, String)\n(`drivers`, String)\n(`passport`, String)\n(`prefix`, String)\n(`first`, String)\n(`last`, String)\n(`suffix`, String)\n(`maiden`, String)\n(`marital`, String)\n(`race`, String)\n(`ethnicity`, String)\n(`gender`, String)\n(`birthplace`, String)\n(`address`, String)\n"
        ]
    },
    {
        "sql_id": 57,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT app_id , IIF(is_installed = 1, 'YES', 'NO') AS status FROM app_events WHERE event_id = 844",
        "target_query": "SELECT `app_id`, if(`is_installed` = 1, 'YES', 'NO') AS `status` FROM `app_events` WHERE `event_id` = 844;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 50,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 17,
                "end_index": 52,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `app_events`\nColumns:\n(`event_id`, integer, primary key)\n(`app_id`, integer, primary key)\n(`is_installed`, integer)\n(`is_active`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `app_events`\nColumns:\n(`event_id`, Int64, primary key)\n(`app_id`, Int64, primary key)\n(`is_installed`, Int64)\n(`is_active`, Int64)\n"
        ]
    },
    {
        "sql_id": 62,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(T1.device_model = 'Nexus 5', 1, 0)) * 100 / COUNT(T1.device_id) AS per , SUM(IIF(T1.device_model = 'Nexus 5' AND T2.gender = 'M', 1, 0)) / SUM(IIF(T1.device_model = 'Nexus 5' AND T2.gender = 'F', 1, 0)) AS r FROM phone_brand_device_model2 AS T1 INNER JOIN gender_age AS T2 ON T2.device_id = T1.device_id WHERE T1.phone_brand = 'LG'",
        "target_query": "SELECT SUM(if(`T1`.`device_model` = 'Nexus 5', 1, 0)) * 100 / NULLIF(COUNT(`T1`.`device_id`), 0) AS `per`, \n       SUM(if(`T1`.`device_model` = 'Nexus 5' AND `T2`.`gender` = 'M', 1, 0)) / \n       NULLIF(SUM(if(`T1`.`device_model` = 'Nexus 5' AND `T2`.`gender` = 'F', 1, 0)), 0) AS `r` \nFROM `phone_brand_device_model2` AS `T1` \nINNER JOIN `gender_age` AS `T2` ON `T2`.`device_id` = `T1`.`device_id` \nWHERE `T1`.`phone_brand` = 'LG';",
        "semantic_equivalent_type": "Approximate equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 49,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 92,
                "end_index": 150,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 158,
                "end_index": 216,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 52,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 66,
                "end_index": 92,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 119,
                "end_index": 184,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 200,
                "end_index": 272,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, integer, primary key)\n(`phone_brand`, text, primary key)\n(`device_model`, text, primary key)\n",
            "Table: `gender_age`\nColumns:\n(`device_id`, integer, primary key)\n(`gender`, text)\n(`age`, integer)\n(`group`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, Int64, primary key)\n(`phone_brand`, String, primary key)\n(`device_model`, String, primary key)\n",
            "Table: `gender_age`\nColumns:\n(`device_id`, Int64, primary key)\n(`gender`, String)\n(`age`, Int64)\n(`_group`, String)\n"
        ]
    },
    {
        "sql_id": 63,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(event_id) FROM `events` WHERE SUBSTR(`timestamp`, 1, 4) = '2016'",
        "target_query": "SELECT COUNT(`event_id`) FROM `events` WHERE toYear(`timestamp`) = 2016;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 43,
                "end_index": 68,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `events`\nColumns:\n(`event_id`, integer, primary key)\n(`device_id`, integer)\n(`timestamp`, datetime)\n(`longitude`, real)\n(`latitude`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `events`\nColumns:\n(`event_id`, Int64, primary key)\n(`device_id`, Int64)\n(`timestamp`, DateTime)\n(`longitude`, Float64)\n(`latitude`, Float64)\n"
        ]
    },
    {
        "sql_id": 65,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T1.event_id) FROM events AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.event_id = T2.device_id WHERE STRFTIME('%Y', T1.timestamp) = '2016' AND T2.phone_brand = 'vivo'",
        "target_query": "SELECT COUNT(`T1`.`event_id`) FROM `events` AS `T1` INNER JOIN `phone_brand_device_model2` AS `T2` ON `T1`.`event_id` = `T2`.`device_id` WHERE formatDateTime(`T1`.`timestamp`, '%Y') = '2016' AND `T2`.`phone_brand` = 'vivo';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 123,
                "end_index": 151,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 143,
                "end_index": 181,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `events`\nColumns:\n(`event_id`, integer, primary key)\n(`device_id`, integer)\n(`timestamp`, datetime)\n(`longitude`, real)\n(`latitude`, real)\n",
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, integer, primary key)\n(`phone_brand`, text, primary key)\n(`device_model`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `events`\nColumns:\n(`event_id`, Int64, primary key)\n(`device_id`, Int64)\n(`timestamp`, DateTime)\n(`longitude`, Float64)\n(`latitude`, Float64)\n",
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, Int64, primary key)\n(`phone_brand`, String, primary key)\n(`device_model`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 67,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(T2.phone_brand = 'vivo', 1, 0)) / COUNT(T1.device_id) AS per FROM events AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.event_id = T2.device_id WHERE T1.event_id = '2'",
        "target_query": "SELECT SUM(if(`T2`.`phone_brand` = 'vivo', 1, 0)) / NULLIF(COUNT(`T1`.`device_id`), 0) AS `per` FROM `events` AS `T1` INNER JOIN `phone_brand_device_model2` AS `T2` ON `T1`.`event_id` = `T2`.`device_id` WHERE `T1`.`event_id` = '2';",
        "semantic_equivalent_type": "Approximate equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 45,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 48,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 56,
                "end_index": 82,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `events`\nColumns:\n(`event_id`, integer, primary key)\n(`device_id`, integer)\n(`timestamp`, datetime)\n(`longitude`, real)\n(`latitude`, real)\n",
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, integer, primary key)\n(`phone_brand`, text, primary key)\n(`device_model`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `events`\nColumns:\n(`event_id`, Int64, primary key)\n(`device_id`, Int64)\n(`timestamp`, DateTime)\n(`longitude`, Float64)\n(`latitude`, Float64)\n",
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, Int64, primary key)\n(`phone_brand`, String, primary key)\n(`device_model`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 70,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(event_id) FROM events WHERE SUBSTR(`timestamp`, 1, 10) = '2016-05-06'",
        "target_query": "SELECT COUNT(`event_id`) FROM `events` WHERE formatDateTime(`timestamp`, '%Y-%m-%d') = '2016-05-06';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 41,
                "end_index": 67,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `events`\nColumns:\n(`event_id`, integer, primary key)\n(`device_id`, integer)\n(`timestamp`, datetime)\n(`longitude`, real)\n(`latitude`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `events`\nColumns:\n(`event_id`, Int64, primary key)\n(`device_id`, Int64)\n(`timestamp`, DateTime)\n(`longitude`, Float64)\n(`latitude`, Float64)\n"
        ]
    },
    {
        "sql_id": 75,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(phone_brand = 'vivo', 1, 0)) - SUM(IIF(phone_brand = 'LG', 1, 0)) AS num FROM phone_brand_device_model2",
        "target_query": "SELECT SUM(if(`phone_brand` = 'vivo', 1, 0)) - SUM(if(`phone_brand` = 'LG', 1, 0)) AS `num` FROM `phone_brand_device_model2`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 42,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 50,
                "end_index": 79,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 43,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 51,
                "end_index": 81,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, integer, primary key)\n(`phone_brand`, text, primary key)\n(`device_model`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, Int64, primary key)\n(`phone_brand`, String, primary key)\n(`device_model`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 76,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T1.device_id) FROM gender_age AS T1 INNER JOIN events AS T2 ON T1.device_id = T2.device_id WHERE STRFTIME('%Y', T2.timestamp) = '2016' AND T1.`group` = 'M23-26'",
        "target_query": "SELECT COUNT(`T1`.`device_id`) FROM `gender_age` AS `T1` INNER JOIN `events` AS `T2` ON `T1`.`device_id` = `T2`.`device_id` WHERE formatDateTime(`T2`.`timestamp`, '%Y') = '2016' AND `T1`.`_group` = 'M23-26';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 110,
                "end_index": 138,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 130,
                "end_index": 168,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `gender_age`\nColumns:\n(`device_id`, integer, primary key)\n(`gender`, text)\n(`age`, integer)\n(`group`, text)\n",
            "Table: `events`\nColumns:\n(`event_id`, integer, primary key)\n(`device_id`, integer)\n(`timestamp`, datetime)\n(`longitude`, real)\n(`latitude`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `gender_age`\nColumns:\n(`device_id`, Int64, primary key)\n(`gender`, String)\n(`age`, Int64)\n(`_group`, String)\n",
            "Table: `events`\nColumns:\n(`event_id`, Int64, primary key)\n(`device_id`, Int64)\n(`timestamp`, DateTime)\n(`longitude`, Float64)\n(`latitude`, Float64)\n"
        ]
    },
    {
        "sql_id": 77,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT IIF(SUM(IIF(T2.category = 'Securities', 1, 0)) - SUM(IIF(T2.category = 'Finance', 1, 0)) > 0, 'Securities', 'Finance') AS diff FROM app_labels AS T1 INNER JOIN label_categories AS T2 ON T1.label_id = T2.label_id",
        "target_query": "SELECT if(SUM(if(`T2`.`category` = 'Securities', 1, 0)) - SUM(if(`T2`.`category` = 'Finance', 1, 0)) > 0, 'Securities', 'Finance') AS `diff` \nFROM `app_labels` AS `T1` \nINNER JOIN `label_categories` AS `T2` ON `T1`.`label_id` = `T2`.`label_id`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 52,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 60,
                "end_index": 94,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 54,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 62,
                "end_index": 99,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `app_labels`\nColumns:\n(`app_id`, integer)\n(`label_id`, integer)\n(`rowid`, integer, primary key)\n",
            "Table: `label_categories`\nColumns:\n(`label_id`, integer, primary key)\n(`category`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `app_labels`\nColumns:\n(`app_id`, Int64)\n(`label_id`, Int64)\n(`rowid`, Int64, primary key)\n",
            "Table: `label_categories`\nColumns:\n(`label_id`, Int64, primary key)\n(`category`, String)\n"
        ]
    },
    {
        "sql_id": 78,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(T1.gender = 'M', 1, 0)) / SUM(IIF(T1.gender = 'F', 1, 0)) AS per FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'vivo'",
        "target_query": "SELECT \n    CASE \n        WHEN SUM(if(`T1`.`gender` = 'F', 1, 0)) = 0 THEN NULL \n        ELSE SUM(if(`T1`.`gender` = 'M', 1, 0)) / SUM(if(`T1`.`gender` = 'F', 1, 0)) \n    END AS `per` \nFROM `gender_age` AS `T1` \nINNER JOIN `phone_brand_device_model2` AS `T2` ON `T1`.`device_id` = `T2`.`device_id` \nWHERE `T2`.`phone_brand` = 'vivo';",
        "semantic_equivalent_type": "Approximate equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 37,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 45,
                "end_index": 71,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 35,
                "end_index": 64,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 98,
                "end_index": 127,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 135,
                "end_index": 164,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `gender_age`\nColumns:\n(`device_id`, integer, primary key)\n(`gender`, text)\n(`age`, integer)\n(`group`, text)\n",
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, integer, primary key)\n(`phone_brand`, text, primary key)\n(`device_model`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `gender_age`\nColumns:\n(`device_id`, Int64, primary key)\n(`gender`, String)\n(`age`, Int64)\n(`_group`, String)\n",
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, Int64, primary key)\n(`phone_brand`, String, primary key)\n(`device_model`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 80,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(is_active = 1, 1, 0)) / SUM(IIF(is_active = 0, 1, 0)) AS per FROM app_events WHERE event_id = 58",
        "target_query": "SELECT \n    if(SUM(if(`is_active` = 0, 1, 0)) = 0, NULL, SUM(if(`is_active` = 1, 1, 0)) / SUM(if(`is_active` = 0, 1, 0))) AS `per` \nFROM \n    `app_events` \nWHERE \n    `event_id` = 58;",
        "semantic_equivalent_type": "Approximate equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 35,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 43,
                "end_index": 67,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 12,
                "end_index": 44,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 61,
                "end_index": 86,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 94,
                "end_index": 119,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `app_events`\nColumns:\n(`event_id`, integer, primary key)\n(`app_id`, integer, primary key)\n(`is_installed`, integer)\n(`is_active`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `app_events`\nColumns:\n(`event_id`, Int64, primary key)\n(`app_id`, Int64, primary key)\n(`is_installed`, Int64)\n(`is_active`, Int64)\n"
        ]
    },
    {
        "sql_id": 82,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T1.device_id) FROM events AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'OPPO' AND STRFTIME('%Y-%m-%d', T1.`timestamp`) = '2016-05-01'",
        "target_query": "SELECT COUNT(`T1`.`device_id`) FROM `events` AS `T1` INNER JOIN `phone_brand_device_model2` AS `T2` ON `T1`.`device_id` = `T2`.`device_id` WHERE `T2`.`phone_brand` = 'OPPO' AND formatDateTime(`T1`.`timestamp`, '%Y-%m-%d') = '2016-05-01';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 153,
                "end_index": 189,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 177,
                "end_index": 221,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `events`\nColumns:\n(`event_id`, integer, primary key)\n(`device_id`, integer)\n(`timestamp`, datetime)\n(`longitude`, real)\n(`latitude`, real)\n",
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, integer, primary key)\n(`phone_brand`, text, primary key)\n(`device_model`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `events`\nColumns:\n(`event_id`, Int64, primary key)\n(`device_id`, Int64)\n(`timestamp`, DateTime)\n(`longitude`, Float64)\n(`latitude`, Float64)\n",
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, Int64, primary key)\n(`phone_brand`, String, primary key)\n(`device_model`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 83,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(T1.gender = 'M', 1, 0)) / SUM(IIF(T1.gender = 'F', 1, 0)) AS per FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'vivo' AND T2.device_model = 'X5Pro'",
        "target_query": "SELECT \n    CASE \n        WHEN SUM(if(`T1`.`gender` = 'F', 1, 0)) = 0 THEN NULL \n        ELSE SUM(if(`T1`.`gender` = 'M', 1, 0)) / SUM(if(`T1`.`gender` = 'F', 1, 0)) \n    END AS `per` \nFROM `gender_age` AS `T1` \nINNER JOIN `phone_brand_device_model2` AS `T2` ON `T1`.`device_id` = `T2`.`device_id` \nWHERE `T2`.`phone_brand` = 'vivo' AND `T2`.`device_model` = 'X5Pro';",
        "semantic_equivalent_type": "Approximate equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 37,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 45,
                "end_index": 71,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 35,
                "end_index": 64,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 98,
                "end_index": 127,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 135,
                "end_index": 164,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `gender_age`\nColumns:\n(`device_id`, integer, primary key)\n(`gender`, text)\n(`age`, integer)\n(`group`, text)\n",
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, integer, primary key)\n(`phone_brand`, text, primary key)\n(`device_model`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `gender_age`\nColumns:\n(`device_id`, Int64, primary key)\n(`gender`, String)\n(`age`, Int64)\n(`_group`, String)\n",
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, Int64, primary key)\n(`phone_brand`, String, primary key)\n(`device_model`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 66,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(T1.`group` = 'M23-26', 1.0, 0)) / COUNT(T1.device_id) AS per FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'vivo'",
        "target_query": "SELECT if(COUNT(T1.device_id) = 0, NULL, SUM(if(T1.`_group` = 'M23-26', 1.0, 0)) / COUNT(T1.device_id)) AS per FROM `gender_age` AS T1 INNER JOIN `phone_brand_device_model2` AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'vivo';",
        "semantic_equivalent_type": "Approximate equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 45,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 29,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 45,
                "end_index": 79,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `gender_age`\nColumns:\n(`device_id`, integer, primary key)\n(`gender`, text)\n(`age`, integer)\n(`group`, text)\n",
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, integer, primary key)\n(`phone_brand`, text, primary key)\n(`device_model`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `gender_age`\nColumns:\n(`device_id`, Int64, primary key)\n(`gender`, String)\n(`age`, Int64)\n(`_group`, String)\n",
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, Int64, primary key)\n(`phone_brand`, String, primary key)\n(`device_model`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 74,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(timestamp = '2016-05-02 7:50:28', 1, 0)) / SUM(IIF(timestamp = '2016-05-02 7:41:03', 1, 0)) AS num FROM events AS T1 INNER JOIN app_events AS T2 ON T1.event_id = T2.event_id WHERE T2.is_active = '1'",
        "target_query": "SELECT SUM(if(`timestamp` = '2016-05-02 7:50:28', 1, 0)) / if(SUM(if(`timestamp` = '2016-05-02 7:41:03', 1, 0)) = 0, NULL, SUM(if(`timestamp` = '2016-05-02 7:41:03', 1, 0))) AS `num` FROM `events` AS `T1` INNER JOIN `app_events` AS `T2` ON `T1`.`event_id` = `T2`.`event_id` WHERE `T2`.`is_active` = '1';",
        "semantic_equivalent_type": "Approximate equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 54,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 62,
                "end_index": 105,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 55,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 59,
                "end_index": 110,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 127,
                "end_index": 171,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `events`\nColumns:\n(`event_id`, integer, primary key)\n(`device_id`, integer)\n(`timestamp`, datetime)\n(`longitude`, real)\n(`latitude`, real)\n",
            "Table: `app_events`\nColumns:\n(`event_id`, integer, primary key)\n(`app_id`, integer, primary key)\n(`is_installed`, integer)\n(`is_active`, integer)\n"
        ],
        "target_related_schemas": [
            "Table: `events`\nColumns:\n(`event_id`, Int64, primary key)\n(`device_id`, Int64)\n(`timestamp`, DateTime)\n(`longitude`, Float64)\n(`latitude`, Float64)\n",
            "Table: `app_events`\nColumns:\n(`event_id`, Int64, primary key)\n(`app_id`, Int64, primary key)\n(`is_installed`, Int64)\n(`is_active`, Int64)\n"
        ]
    },
    {
        "sql_id": 84,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(T1.gender = 'F' AND T1.age > 80, 1, 0)) / COUNT(T1.device_id) AS per FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'HTC'",
        "target_query": "SELECT SUM(if(`T1`.`gender` = 'F' AND `T1`.`age` > 80, 1, 0)) / NULLIF(COUNT(`T1`.`device_id`), 0) AS `per` FROM `gender_age` AS `T1` INNER JOIN `phone_brand_device_model2` AS `T2` ON `T1`.`device_id` = `T2`.`device_id` WHERE `T2`.`phone_brand` = 'HTC';",
        "semantic_equivalent_type": "Approximate equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 53,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 60,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 68,
                "end_index": 94,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `gender_age`\nColumns:\n(`device_id`, integer, primary key)\n(`gender`, text)\n(`age`, integer)\n(`group`, text)\n",
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, integer, primary key)\n(`phone_brand`, text, primary key)\n(`device_model`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `gender_age`\nColumns:\n(`device_id`, Int64, primary key)\n(`gender`, String)\n(`age`, Int64)\n(`_group`, String)\n",
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, Int64, primary key)\n(`phone_brand`, String, primary key)\n(`device_model`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 87,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT longitude, latitude FROM events WHERE date(timestamp) = '2016-04-30'",
        "target_query": "SELECT `longitude`, `latitude` FROM `events` WHERE toDate(`timestamp`) = '2016-04-30';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 45,
                "end_index": 60,
                "dialect_content": "The date(time-value, modifier, modifier, ...) function returns the date as text in the format: YYYY-MM-DD. The function accepts a time-value and zero or more modifiers to alter the date.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day', 'start of month').\nReturns: A string in the format YYYY-MM-DD.",
                "feature": "date(time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 51,
                "end_index": 70,
                "dialect_content": "The `toDate` function in ClickHouse converts a given time value into a date in the 'YYYY-MM-DD' format. It accepts a time value (e.g., 'now', '2024-08-21') and can handle various time-value expressions. Modifiers such as '+1 day' can be applied to modify the date before conversion.",
                "feature": "toDate(time_value)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "date(time-value, modifier, modifier, ...)",
                "explanation": "The date(time-value, modifier, modifier, ...) function returns the date as text in the format: YYYY-MM-DD. The function accepts a time-value and zero or more modifiers to alter the date.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day', 'start of month').\nReturns: A string in the format YYYY-MM-DD.",
                "examples": [
                    "SELECT date(); -- Returns the current date.",
                    "SELECT date('now', '+1 day'); -- Returns the date one day after the current date.",
                    "SELECT date('2024-08-21'); -- Returns '2024-08-21'."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "toDate(time_value)",
                "explanation": "The `toDate` function in ClickHouse converts a given time value into a date in the 'YYYY-MM-DD' format. It accepts a time value (e.g., 'now', '2024-08-21') and can handle various time-value expressions. Modifiers such as '+1 day' can be applied to modify the date before conversion.",
                "examples": [
                    "SELECT toDate(now()); -- Returns the current date in 'YYYY-MM-DD' format.",
                    "SELECT toDate(now() + INTERVAL 1 DAY); -- Returns the date one day after the current date.",
                    "SELECT toDate('2024-08-21'); -- Returns '2024-08-21'."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `events`\nColumns:\n(`event_id`, integer, primary key)\n(`device_id`, integer)\n(`timestamp`, datetime)\n(`longitude`, real)\n(`latitude`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `events`\nColumns:\n(`event_id`, Int64, primary key)\n(`device_id`, Int64)\n(`timestamp`, DateTime)\n(`longitude`, Float64)\n(`latitude`, Float64)\n"
        ]
    },
    {
        "sql_id": 88,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T.gender FROM ( SELECT T1.gender, COUNT(T1.device_id) AS num FROM gender_age AS T1 INNER JOIN events_relevant AS T2 ON T1.device_id = T2.device_id WHERE date(T2.timestamp) BETWEEN '2016-05-01' AND '2016-05-10' GROUP BY T1.gender ) AS T ORDER BY T.num DESC LIMIT 1",
        "target_query": "SELECT T.`gender` FROM ( SELECT T1.`gender`, COUNT(T1.`device_id`) AS `num` FROM `gender_age` AS T1 INNER JOIN `events_relevant` AS T2 ON T1.`device_id` = T2.`device_id` WHERE toDate(T2.`timestamp`) BETWEEN '2016-05-01' AND '2016-05-10' GROUP BY T1.`gender` ) AS T ORDER BY T.`num` DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 160,
                "end_index": 178,
                "dialect_content": "The date(time-value, modifier, modifier, ...) function returns the date as text in the format: YYYY-MM-DD. The function accepts a time-value and zero or more modifiers to alter the date.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day', 'start of month').\nReturns: A string in the format YYYY-MM-DD.",
                "feature": "date(time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 176,
                "end_index": 198,
                "dialect_content": "The `toDate` function in ClickHouse converts a given time value into a date in the 'YYYY-MM-DD' format. It accepts a time value (e.g., 'now', '2024-08-21') and can handle various time-value expressions. Modifiers such as '+1 day' can be applied to modify the date before conversion.",
                "feature": "toDate(time_value)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "date(time-value, modifier, modifier, ...)",
                "explanation": "The date(time-value, modifier, modifier, ...) function returns the date as text in the format: YYYY-MM-DD. The function accepts a time-value and zero or more modifiers to alter the date.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day', 'start of month').\nReturns: A string in the format YYYY-MM-DD.",
                "examples": [
                    "SELECT date(); -- Returns the current date.",
                    "SELECT date('now', '+1 day'); -- Returns the date one day after the current date.",
                    "SELECT date('2024-08-21'); -- Returns '2024-08-21'."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "toDate(time_value)",
                "explanation": "The `toDate` function in ClickHouse converts a given time value into a date in the 'YYYY-MM-DD' format. It accepts a time value (e.g., 'now', '2024-08-21') and can handle various time-value expressions. Modifiers such as '+1 day' can be applied to modify the date before conversion.",
                "examples": [
                    "SELECT toDate(now()); -- Returns the current date in 'YYYY-MM-DD' format.",
                    "SELECT toDate(now() + INTERVAL 1 DAY); -- Returns the date one day after the current date.",
                    "SELECT toDate('2024-08-21'); -- Returns '2024-08-21'."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `gender_age`\nColumns:\n(`device_id`, integer, primary key)\n(`gender`, text)\n(`age`, integer)\n(`group`, text)\n",
            "Table: `events_relevant`\nColumns:\n(`event_id`, integer, primary key)\n(`device_id`, integer)\n(`timestamp`, datetime)\n(`longitude`, real)\n(`latitude`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `gender_age`\nColumns:\n(`device_id`, Int64, primary key)\n(`gender`, String)\n(`age`, Int64)\n(`_group`, String)\n",
            "Table: `events_relevant`\nColumns:\n(`event_id`, Int64, primary key)\n(`device_id`, Int64)\n(`timestamp`, DateTime)\n(`longitude`, Float64)\n(`latitude`, Float64)\n"
        ]
    },
    {
        "sql_id": 92,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT IIF(SUM(IIF(T1.gender = 'M', 1, 0)) - SUM(IIF(T1.gender = 'F', 1, 0)) > 0, 'M', 'F') AS gender FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.device_model = 'Galaxy Note 2'",
        "target_query": "SELECT if(SUM(if(`T1`.`gender` = 'M', 1, 0)) - SUM(if(`T1`.`gender` = 'F', 1, 0)) > 0, 'M', 'F') AS `gender` FROM `gender_age` AS `T1` INNER JOIN `phone_brand_device_model2` AS `T2` ON `T1`.`device_id` = `T2`.`device_id` WHERE `T2`.`device_model` = 'Galaxy Note 2';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 41,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 49,
                "end_index": 75,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 43,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 51,
                "end_index": 80,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `gender_age`\nColumns:\n(`device_id`, integer, primary key)\n(`gender`, text)\n(`age`, integer)\n(`group`, text)\n",
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, integer, primary key)\n(`phone_brand`, text, primary key)\n(`device_model`, text, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `gender_age`\nColumns:\n(`device_id`, Int64, primary key)\n(`gender`, String)\n(`age`, Int64)\n(`_group`, String)\n",
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, Int64, primary key)\n(`phone_brand`, String, primary key)\n(`device_model`, String, primary key)\n"
        ]
    },
    {
        "sql_id": 55,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(T2.gender = 'F', 1, 0)) * 100 / COUNT(T2.device_id) AS perFemale , SUM(IIF(T2.gender = 'M', 1, 0)) * 100 / COUNT(T2.device_id) AS perMale FROM phone_brand_device_model2 AS T1 INNER JOIN gender_age AS T2 ON T2.device_id = T1.device_id WHERE T1.phone_brand = 'OPPO'",
        "target_query": "SELECT SUM(if(T2.gender = 'F', 1, 0)) * 100 / COUNT(*) AS perFemale, SUM(if(T2.gender = 'M', 1, 0)) * 100 / COUNT(*) AS perMale FROM (SELECT T1.device_id FROM `phone_brand_device_model2` AS T1 WHERE T1.phone_brand = 'OPPO') AS filtered_devices INNER JOIN `gender_age` AS T2 ON T2.device_id = filtered_devices.device_id;",
        "semantic_equivalent_type": "Approximate equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 37,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 86,
                "end_index": 112,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 36,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 73,
                "end_index": 98,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, integer, primary key)\n(`phone_brand`, text, primary key)\n(`device_model`, text, primary key)\n",
            "Table: `gender_age`\nColumns:\n(`device_id`, integer, primary key)\n(`gender`, text)\n(`age`, integer)\n(`group`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `phone_brand_device_model2`\nColumns:\n(`device_id`, Int64, primary key)\n(`phone_brand`, String, primary key)\n(`device_model`, String, primary key)\n",
            "Table: `gender_age`\nColumns:\n(`device_id`, Int64, primary key)\n(`gender`, String)\n(`age`, Int64)\n(`_group`, String)\n"
        ]
    },
    {
        "sql_id": 68,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(T1.category = '80s Japanese comic', 1, 0)) / COUNT(T1.label_id) AS J8 , SUM(IIF(T1.category = '90s Japanese comic', 1, 0)) / COUNT(T1.label_id) AS J9 FROM label_categories AS T1 INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id",
        "target_query": "SELECT SUM(if(`T1`.`category` = '80s Japanese comic', 1, 0)) / COUNT(`T1`.`label_id`) AS `J8`, SUM(if(`T1`.`category` = '90s Japanese comic', 1, 0)) / COUNT(`T1`.`label_id`) AS `J9` FROM `label_categories` AS `T1` INNER JOIN `app_labels` AS `T2` ON `T1`.`label_id` = `T2`.`label_id`;",
        "semantic_equivalent_type": "Approximate equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 56,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 91,
                "end_index": 136,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 59,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 99,
                "end_index": 147,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `label_categories`\nColumns:\n(`label_id`, integer, primary key)\n(`category`, text)\n",
            "Table: `app_labels`\nColumns:\n(`app_id`, integer)\n(`label_id`, integer)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `label_categories`\nColumns:\n(`label_id`, Int64, primary key)\n(`category`, String)\n",
            "Table: `app_labels`\nColumns:\n(`app_id`, Int64)\n(`label_id`, Int64)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 93,
        "database_name": "talkingdata",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(T1.category = 'Academic Information', 1.0, 0)) / COUNT(T2.app_id) AS per FROM label_categories AS T1 INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id",
        "target_query": "SELECT SUM(if(`T1`.`category` = 'Academic Information', 1.0, 0)) / COUNT(`T2`.`app_id`) AS `per` FROM `label_categories` AS `T1` INNER JOIN `app_labels` AS `T2` ON `T1`.`label_id` = `T2`.`label_id`;",
        "semantic_equivalent_type": "Approximate equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 60,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 63,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `label_categories`\nColumns:\n(`label_id`, integer, primary key)\n(`category`, text)\n",
            "Table: `app_labels`\nColumns:\n(`app_id`, integer)\n(`label_id`, integer)\n(`rowid`, integer, primary key)\n"
        ],
        "target_related_schemas": [
            "Table: `label_categories`\nColumns:\n(`label_id`, Int64, primary key)\n(`category`, String)\n",
            "Table: `app_labels`\nColumns:\n(`app_id`, Int64)\n(`label_id`, Int64)\n(`rowid`, Int64, primary key)\n"
        ]
    },
    {
        "sql_id": 248,
        "database_name": "video_games",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T.game_name FROM game AS T ORDER BY LENGTH(T.game_name) DESC LIMIT 1",
        "target_query": "SELECT `T`.`game_name` FROM `game` AS `T` ORDER BY length(`T`.`game_name`) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 43,
                "end_index": 62,
                "dialect_content": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "feature": "length(X)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 51,
                "end_index": 74,
                "dialect_content": "The length(str) function returns the number of bytes in the given string str. Unlike SQLite, which counts Unicode code points for strings, ClickHouse measures the length in bytes. For multibyte characters (UTF-8 encoded), the byte count may be larger than the character count. If str is NULL, the function returns NULL.",
                "feature": "length(str)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "length(str)",
                "explanation": "The length(str) function returns the number of bytes in the given string str. Unlike SQLite, which counts Unicode code points for strings, ClickHouse measures the length in bytes. For multibyte characters (UTF-8 encoded), the byte count may be larger than the character count. If str is NULL, the function returns NULL.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(unhex('68656C6C6F')); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `game`\nColumns:\n(`id`, integer, primary key)\n(`genre_id`, integer)\n(`game_name`, text)\n"
        ],
        "target_related_schemas": [
            "Table: `game`\nColumns:\n(`id`, Int64, primary key)\n(`genre_id`, Int64)\n(`game_name`, String)\n"
        ]
    },
    {
        "sql_id": 508,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT JULIANDAY(EndDate) - JULIANDAY(StartDate) FROM BillOfMaterials ORDER BY JULIANDAY(EndDate) - JULIANDAY(StartDate) DESC LIMIT 1",
        "target_query": "SELECT (toUInt32(toDateTime(`EndDate`)) / 86400 + 2440587.5) - (toUInt32(toDateTime(`StartDate`)) / 86400 + 2440587.5) FROM `BillOfMaterials` ORDER BY (toUInt32(toDateTime(`EndDate`)) / 86400 + 2440587.5) - (toUInt32(toDateTime(`StartDate`)) / 86400 + 2440587.5) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 25,
                "dialect_content": "The julianday(time-value, modifier, modifier, ...) function returns the Julian day number - the fractional number of days since noon in Greenwich on November 24, 4714 B.C. (Proleptic Gregorian calendar). It accepts a time-value and zero or more modifiers.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day').\nReturns: A real number representing the Julian day number.",
                "feature": "julianday(time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 28,
                "end_index": 48,
                "dialect_content": "The julianday(time-value, modifier, modifier, ...) function returns the Julian day number - the fractional number of days since noon in Greenwich on November 24, 4714 B.C. (Proleptic Gregorian calendar). It accepts a time-value and zero or more modifiers.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day').\nReturns: A real number representing the Julian day number.",
                "feature": "julianday(time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 79,
                "end_index": 97,
                "dialect_content": "The julianday(time-value, modifier, modifier, ...) function returns the Julian day number - the fractional number of days since noon in Greenwich on November 24, 4714 B.C. (Proleptic Gregorian calendar). It accepts a time-value and zero or more modifiers.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day').\nReturns: A real number representing the Julian day number.",
                "feature": "julianday(time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 100,
                "end_index": 120,
                "dialect_content": "The julianday(time-value, modifier, modifier, ...) function returns the Julian day number - the fractional number of days since noon in Greenwich on November 24, 4714 B.C. (Proleptic Gregorian calendar). It accepts a time-value and zero or more modifiers.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day').\nReturns: A real number representing the Julian day number.",
                "feature": "julianday(time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 8,
                "end_index": 38,
                "dialect_content": "ClickHouse does not have a built-in `julianday()` function like SQLite. However, you can compute the Julian day number using the formula: `toUInt32(toDateTime(time_value)) / 86400 + 2440587.5`. This expression converts a `DateTime` value to Julian day number by converting it to seconds since the Unix epoch (1970-01-01), dividing by the number of seconds in a day, and adjusting by adding the Julian day number of the Unix epoch (2440587.5).",
                "feature": "toUInt32(toDateTime(time_value)) / 86400 + 2440587.5"
            },
            {
                "start_index": 64,
                "end_index": 96,
                "dialect_content": "ClickHouse does not have a built-in `julianday()` function like SQLite. However, you can compute the Julian day number using the formula: `toUInt32(toDateTime(time_value)) / 86400 + 2440587.5`. This expression converts a `DateTime` value to Julian day number by converting it to seconds since the Unix epoch (1970-01-01), dividing by the number of seconds in a day, and adjusting by adding the Julian day number of the Unix epoch (2440587.5).",
                "feature": "toUInt32(toDateTime(time_value)) / 86400 + 2440587.5"
            },
            {
                "start_index": 152,
                "end_index": 182,
                "dialect_content": "ClickHouse does not have a built-in `julianday()` function like SQLite. However, you can compute the Julian day number using the formula: `toUInt32(toDateTime(time_value)) / 86400 + 2440587.5`. This expression converts a `DateTime` value to Julian day number by converting it to seconds since the Unix epoch (1970-01-01), dividing by the number of seconds in a day, and adjusting by adding the Julian day number of the Unix epoch (2440587.5).",
                "feature": "toUInt32(toDateTime(time_value)) / 86400 + 2440587.5"
            },
            {
                "start_index": 208,
                "end_index": 240,
                "dialect_content": "ClickHouse does not have a built-in `julianday()` function like SQLite. However, you can compute the Julian day number using the formula: `toUInt32(toDateTime(time_value)) / 86400 + 2440587.5`. This expression converts a `DateTime` value to Julian day number by converting it to seconds since the Unix epoch (1970-01-01), dividing by the number of seconds in a day, and adjusting by adding the Julian day number of the Unix epoch (2440587.5).",
                "feature": "toUInt32(toDateTime(time_value)) / 86400 + 2440587.5"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "julianday(time-value, modifier, modifier, ...)",
                "explanation": "The julianday(time-value, modifier, modifier, ...) function returns the Julian day number - the fractional number of days since noon in Greenwich on November 24, 4714 B.C. (Proleptic Gregorian calendar). It accepts a time-value and zero or more modifiers.\nParameters: time-value (e.g., 'now', '2024-08-21'), modifiers (e.g., '+1 day').\nReturns: A real number representing the Julian day number.",
                "examples": [
                    "SELECT julianday(); -- Returns the current Julian day number.",
                    "SELECT julianday('2024-08-21'); -- Returns the Julian day number for August 21, 2024.",
                    "SELECT julianday('now', '+1 day'); -- Returns the Julian day number for one day after the current date."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "toUInt32(toDateTime(time_value)) / 86400 + 2440587.5",
                "explanation": "ClickHouse does not have a built-in `julianday()` function like SQLite. However, you can compute the Julian day number using the formula: `toUInt32(toDateTime(time_value)) / 86400 + 2440587.5`. This expression converts a `DateTime` value to Julian day number by converting it to seconds since the Unix epoch (1970-01-01), dividing by the number of seconds in a day, and adjusting by adding the Julian day number of the Unix epoch (2440587.5).",
                "examples": [
                    "SELECT toUInt32(toDateTime(now())) / 86400 + 2440587.5; -- Returns the current Julian day number.",
                    "SELECT toUInt32(toDateTime('2024-08-21')) / 86400 + 2440587.5; -- Returns the Julian day number for August 21, 2024.",
                    "SELECT toUInt32(toDateTime(now() + INTERVAL 1 DAY)) / 86400 + 2440587.5; -- Returns the Julian day number for one day after the current date."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `BillOfMaterials`\nColumns:\n(`BillOfMaterialsID`, integer, primary key)\n(`ProductAssemblyID`, integer)\n(`ComponentID`, integer)\n(`StartDate`, datetime)\n(`EndDate`, datetime)\n(`UnitMeasureCode`, text)\n(`BOMLevel`, integer)\n(`PerAssemblyQty`, real)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `BillOfMaterials`\nColumns:\n(`BillOfMaterialsID`, Int64, primary key)\n(`ProductAssemblyID`, Int64)\n(`ComponentID`, Int64)\n(`StartDate`, DateTime)\n(`EndDate`, DateTime)\n(`UnitMeasureCode`, String)\n(`BOMLevel`, Int64)\n(`PerAssemblyQty`, Float64)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 511,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.CreditRating FROM ProductVendor AS T1 INNER JOIN Vendor AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.StandardPrice = 18.9900 AND T1.AverageLeadTime = 16 AND STRFTIME('%Y-%m-%d', T1.LastReceiptDate) = '2011-08-27'",
        "target_query": "SELECT `T2`.`CreditRating` FROM `ProductVendor` AS `T1` INNER JOIN `Vendor` AS `T2` ON `T1`.`BusinessEntityID` = `T2`.`BusinessEntityID` WHERE `T1`.`StandardPrice` = 18.9900 AND `T1`.`AverageLeadTime` = 16 AND formatDateTime(`T1`.`LastReceiptDate`, '%Y-%m-%d') = '2011-08-27';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 182,
                "end_index": 222,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 210,
                "end_index": 260,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `ProductVendor`\nColumns:\n(`ProductID`, integer, primary key)\n(`BusinessEntityID`, integer, primary key)\n(`AverageLeadTime`, integer)\n(`StandardPrice`, real)\n(`LastReceiptCost`, real)\n(`LastReceiptDate`, datetime)\n(`MinOrderQty`, integer)\n(`MaxOrderQty`, integer)\n(`OnOrderQty`, integer)\n(`UnitMeasureCode`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `Vendor`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`AccountNumber`, text)\n(`Name`, text)\n(`CreditRating`, integer)\n(`PreferredVendorStatus`, integer)\n(`ActiveFlag`, integer)\n(`PurchasingWebServiceURL`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `ProductVendor`\nColumns:\n(`ProductID`, Int64, primary key)\n(`BusinessEntityID`, Int64, primary key)\n(`AverageLeadTime`, Int64)\n(`StandardPrice`, Float64)\n(`LastReceiptCost`, Float64)\n(`LastReceiptDate`, DateTime)\n(`MinOrderQty`, Int64)\n(`MaxOrderQty`, Int64)\n(`OnOrderQty`, Int64)\n(`UnitMeasureCode`, String)\n(`ModifiedDate`, DateTime)\n",
            "Table: `Vendor`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`AccountNumber`, String)\n(`Name`, String)\n(`CreditRating`, Int64)\n(`PreferredVendorStatus`, Int64)\n(`ActiveFlag`, Int64)\n(`PurchasingWebServiceURL`, String)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 512,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T1.ShipMethodID = 5, T3.OrderQty, 0)) AS REAL) / COUNT(T3.ProductID) FROM ShipMethod AS T1 INNER JOIN PurchaseOrderHeader AS T2 ON T1.ShipMethodID = T2.ShipMethodID INNER JOIN PurchaseOrderDetail AS T3 ON T2.PurchaseOrderID = T3.PurchaseOrderID",
        "target_query": "SELECT SUM(if(`T1`.`ShipMethodID` = 5, `T3`.`OrderQty`, 0)) / COUNT(`T3`.`ProductID`) FROM `ShipMethod` AS `T1` INNER JOIN `PurchaseOrderHeader` AS `T2` ON `T1`.`ShipMethodID` = `T2`.`ShipMethodID` INNER JOIN `PurchaseOrderDetail` AS `T3` ON `T2`.`PurchaseOrderID` = `T3`.`PurchaseOrderID`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 56,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 58,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `ShipMethod`\nColumns:\n(`ShipMethodID`, integer, primary key)\n(`Name`, text)\n(`ShipBase`, real)\n(`ShipRate`, real)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `PurchaseOrderHeader`\nColumns:\n(`PurchaseOrderID`, integer, primary key)\n(`RevisionNumber`, integer)\n(`Status`, integer)\n(`EmployeeID`, integer)\n(`VendorID`, integer)\n(`ShipMethodID`, integer)\n(`OrderDate`, datetime)\n(`ShipDate`, datetime)\n(`SubTotal`, real)\n(`TaxAmt`, real)\n(`Freight`, real)\n(`TotalDue`, real)\n(`ModifiedDate`, datetime)\n",
            "Table: `PurchaseOrderDetail`\nColumns:\n(`PurchaseOrderID`, integer)\n(`PurchaseOrderDetailID`, integer, primary key)\n(`DueDate`, datetime)\n(`OrderQty`, integer)\n(`ProductID`, integer)\n(`UnitPrice`, real)\n(`LineTotal`, real)\n(`ReceivedQty`, real)\n(`RejectedQty`, real)\n(`StockedQty`, real)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `ShipMethod`\nColumns:\n(`ShipMethodID`, Int64, primary key)\n(`Name`, String)\n(`ShipBase`, Float64)\n(`ShipRate`, Float64)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n",
            "Table: `PurchaseOrderHeader`\nColumns:\n(`PurchaseOrderID`, Int64, primary key)\n(`RevisionNumber`, Int64)\n(`Status`, Int64)\n(`EmployeeID`, Int64)\n(`VendorID`, Int64)\n(`ShipMethodID`, Int64)\n(`OrderDate`, DateTime)\n(`ShipDate`, DateTime)\n(`SubTotal`, Float64)\n(`TaxAmt`, Float64)\n(`Freight`, Float64)\n(`TotalDue`, Float64)\n(`ModifiedDate`, DateTime)\n",
            "Table: `PurchaseOrderDetail`\nColumns:\n(`PurchaseOrderID`, Int64)\n(`PurchaseOrderDetailID`, Int64, primary key)\n(`DueDate`, DateTime)\n(`OrderQty`, Int64)\n(`ProductID`, Int64)\n(`UnitPrice`, Float64)\n(`LineTotal`, Float64)\n(`ReceivedQty`, Float64)\n(`RejectedQty`, Float64)\n(`StockedQty`, Float64)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 513,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(IIF(T1.city = 'Bothell', 1, 0)) - SUM(IIF(T1.city = 'Kenmore', 1, 0)) , stateprovincecode FROM Address AS T1 INNER JOIN StateProvince AS T2 ON T1.stateprovinceid = T2.stateprovinceid GROUP BY stateprovincecode",
        "target_query": "SELECT SUM(if(`City` = 'Bothell', 1, 0)) - SUM(if(`City` = 'Kenmore', 1, 0)), `StateProvinceCode` FROM `Address` AS T1 INNER JOIN `StateProvince` AS T2 ON T1.`StateProvinceID` = T2.`StateProvinceID` GROUP BY `StateProvinceCode`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 41,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            },
            {
                "start_index": 49,
                "end_index": 79,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 39,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            },
            {
                "start_index": 47,
                "end_index": 75,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Address`\nColumns:\n(`AddressID`, integer, primary key)\n(`AddressLine1`, text)\n(`AddressLine2`, text)\n(`City`, text)\n(`StateProvinceID`, integer)\n(`PostalCode`, text)\n(`SpatialLocation`, text)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `StateProvince`\nColumns:\n(`StateProvinceID`, integer, primary key)\n(`StateProvinceCode`, text)\n(`CountryRegionCode`, text)\n(`IsOnlyStateProvinceFlag`, integer)\n(`Name`, text)\n(`TerritoryID`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `Address`\nColumns:\n(`AddressID`, Int64, primary key)\n(`AddressLine1`, String)\n(`AddressLine2`, String)\n(`City`, String)\n(`StateProvinceID`, Int64)\n(`PostalCode`, String)\n(`SpatialLocation`, String)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n",
            "Table: `StateProvince`\nColumns:\n(`StateProvinceID`, Int64, primary key)\n(`StateProvinceCode`, String)\n(`CountryRegionCode`, String)\n(`IsOnlyStateProvinceFlag`, Int64)\n(`Name`, String)\n(`TerritoryID`, Int64)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 514,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.ListPrice FROM Product AS T1 INNER JOIN ProductListPriceHistory AS T2 ON T1.ProductID = T2.ProductID WHERE T1.ListPrice - T1.StandardCost > 21.9037 AND STRFTIME('%Y-%m-%d', T2.StartDate) >= '2012-10-01'",
        "target_query": "SELECT `T1`.`ListPrice` FROM `Product` AS `T1` INNER JOIN `ProductListPriceHistory` AS `T2` ON `T1`.`ProductID` = `T2`.`ProductID` WHERE `T1`.`ListPrice` - `T1`.`StandardCost` > 21.9037 AND formatDateTime(`T2`.`StartDate`, '%Y-%m-%d') >= '2012-10-01';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 162,
                "end_index": 196,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 190,
                "end_index": 234,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Product`\nColumns:\n(`ProductID`, integer, primary key)\n(`Name`, text)\n(`ProductNumber`, text)\n(`MakeFlag`, integer)\n(`FinishedGoodsFlag`, integer)\n(`Color`, text)\n(`SafetyStockLevel`, integer)\n(`ReorderPoint`, integer)\n(`StandardCost`, real)\n(`ListPrice`, real)\n(`Size`, text)\n(`SizeUnitMeasureCode`, text)\n(`WeightUnitMeasureCode`, text)\n(`Weight`, real)\n(`DaysToManufacture`, integer)\n(`ProductLine`, text)\n(`Class`, text)\n(`Style`, text)\n(`ProductSubcategoryID`, integer)\n(`ProductModelID`, integer)\n(`SellStartDate`, datetime)\n(`SellEndDate`, datetime)\n(`DiscontinuedDate`, datetime)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `ProductListPriceHistory`\nColumns:\n(`ProductID`, integer, primary key)\n(`StartDate`, datetime, primary key)\n(`EndDate`, datetime)\n(`ListPrice`, real)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `Product`\nColumns:\n(`ProductID`, Int64, primary key)\n(`Name`, String)\n(`ProductNumber`, String)\n(`MakeFlag`, Int64)\n(`FinishedGoodsFlag`, Int64)\n(`Color`, String)\n(`SafetyStockLevel`, Int64)\n(`ReorderPoint`, Int64)\n(`StandardCost`, Float64)\n(`ListPrice`, Float64)\n(`Size`, String)\n(`SizeUnitMeasureCode`, String)\n(`WeightUnitMeasureCode`, String)\n(`Weight`, Float64)\n(`DaysToManufacture`, Int64)\n(`ProductLine`, String)\n(`Class`, String)\n(`Style`, String)\n(`ProductSubcategoryID`, Int64)\n(`ProductModelID`, Int64)\n(`SellStartDate`, DateTime)\n(`SellEndDate`, DateTime)\n(`DiscontinuedDate`, DateTime)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n",
            "Table: `ProductListPriceHistory`\nColumns:\n(`ProductID`, Int64, primary key)\n(`StartDate`, DateTime, primary key)\n(`EndDate`, DateTime)\n(`ListPrice`, Float64)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 515,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT LENGTH(T2.PasswordHash) FROM Person AS T1 INNER JOIN Password AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.FirstName = 'Catherine' AND T1.LastName = 'Ward'",
        "target_query": "SELECT length(`T2`.`PasswordHash`) FROM `Person` AS `T1` INNER JOIN `Password` AS `T2` ON `T1`.`BusinessEntityID` = `T2`.`BusinessEntityID` WHERE `T1`.`FirstName` = 'Catherine' AND `T1`.`LastName` = 'Ward';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 30,
                "dialect_content": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "feature": "length(X)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 7,
                "end_index": 34,
                "dialect_content": "The length(str) function returns the number of bytes in the given string str. Unlike SQLite, which counts Unicode code points for strings, ClickHouse measures the length in bytes. For multibyte characters (UTF-8 encoded), the byte count may be larger than the character count. If str is NULL, the function returns NULL.",
                "feature": "length(str)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "length(X)",
                "explanation": "For a string value X, the length(X) function returns the number of \n  Unicode code points (not bytes) in input string X prior to the first U+0000\n  character.\n  Since SQLite strings do not normally contain NUL characters, the length(X)\n  function will usually return the total number of characters in the string X.\n  For a blob value X, length(X) returns the number of bytes in the blob.\n  If X is NULL then length(X) is NULL.\n  If X is numeric then length(X) returns the length of a string\n  representation of X.\n  \n  Note that for strings, the length(X) function returns the character\n  or code-point\n  length of the string, not the byte length.  The character length is the number\n  of characters in the string.  The character length is always different from\n  the byte length for UTF-16 strings, and can be different from the byte length\n  for UTF-8 strings if the string contains multi-byte characters.  Use the\n  octet_length() function to find the byte length of a string.\n  \n  For BLOB values, length(X) always returns the byte-length of the BLOB.\n  \n  For string values, length(X) must read the entire string into memory in order\n  to compute the character length.  But for BLOB values, reading the whole string\n  into memory is not necessary as SQLite already\n  knows how many bytes are in the BLOB.  Hence, for multi-megabyte values,\n  the length(X) function is usually much faster for BLOBs than for strings, since\n  it does not need to load the value into memory.\n",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(X'68656C6C6F'); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "length(str)",
                "explanation": "The length(str) function returns the number of bytes in the given string str. Unlike SQLite, which counts Unicode code points for strings, ClickHouse measures the length in bytes. For multibyte characters (UTF-8 encoded), the byte count may be larger than the character count. If str is NULL, the function returns NULL.",
                "examples": [
                    "SELECT length('Hello'); -- Returns 5",
                    "SELECT length(unhex('68656C6C6F')); -- Returns 5 (Hexadecimal BLOB)"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`PersonType`, text)\n(`NameStyle`, integer)\n(`Title`, text)\n(`FirstName`, text)\n(`MiddleName`, text)\n(`LastName`, text)\n(`Suffix`, text)\n(`EmailPromotion`, integer)\n(`AdditionalContactInfo`, text)\n(`Demographics`, text)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `Password`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`PasswordHash`, text)\n(`PasswordSalt`, text)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`PersonType`, String)\n(`NameStyle`, Int64)\n(`Title`, String)\n(`FirstName`, String)\n(`MiddleName`, String)\n(`LastName`, String)\n(`Suffix`, String)\n(`EmailPromotion`, Int64)\n(`AdditionalContactInfo`, String)\n(`Demographics`, String)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n",
            "Table: `Password`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`PasswordHash`, String)\n(`PasswordSalt`, String)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 516,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.TransactionType FROM TransactionHistory AS T1 INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE T2.Name = 'HL Road Frame - Black, 48' AND STRFTIME('%Y-%m-%d',T1.TransactionDate) = '2013-07-31'",
        "target_query": "SELECT T1.`TransactionType` FROM `TransactionHistory` AS T1 INNER JOIN `Product` AS T2 ON T1.`ProductID` = T2.`ProductID` WHERE T2.`Name` = 'HL Road Frame - Black, 48' AND formatDateTime(T1.`TransactionDate`, '%Y-%m-%d') = '2013-07-31';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 160,
                "end_index": 199,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 172,
                "end_index": 220,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `TransactionHistory`\nColumns:\n(`TransactionID`, integer, primary key)\n(`ProductID`, integer)\n(`ReferenceOrderID`, integer)\n(`ReferenceOrderLineID`, integer)\n(`TransactionDate`, datetime)\n(`TransactionType`, text)\n(`Quantity`, integer)\n(`ActualCost`, real)\n(`ModifiedDate`, datetime)\n",
            "Table: `Product`\nColumns:\n(`ProductID`, integer, primary key)\n(`Name`, text)\n(`ProductNumber`, text)\n(`MakeFlag`, integer)\n(`FinishedGoodsFlag`, integer)\n(`Color`, text)\n(`SafetyStockLevel`, integer)\n(`ReorderPoint`, integer)\n(`StandardCost`, real)\n(`ListPrice`, real)\n(`Size`, text)\n(`SizeUnitMeasureCode`, text)\n(`WeightUnitMeasureCode`, text)\n(`Weight`, real)\n(`DaysToManufacture`, integer)\n(`ProductLine`, text)\n(`Class`, text)\n(`Style`, text)\n(`ProductSubcategoryID`, integer)\n(`ProductModelID`, integer)\n(`SellStartDate`, datetime)\n(`SellEndDate`, datetime)\n(`DiscontinuedDate`, datetime)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `TransactionHistory`\nColumns:\n(`TransactionID`, Int64, primary key)\n(`ProductID`, Int64)\n(`ReferenceOrderID`, Int64)\n(`ReferenceOrderLineID`, Int64)\n(`TransactionDate`, DateTime)\n(`TransactionType`, String)\n(`Quantity`, Int64)\n(`ActualCost`, Float64)\n(`ModifiedDate`, DateTime)\n",
            "Table: `Product`\nColumns:\n(`ProductID`, Int64, primary key)\n(`Name`, String)\n(`ProductNumber`, String)\n(`MakeFlag`, Int64)\n(`FinishedGoodsFlag`, Int64)\n(`Color`, String)\n(`SafetyStockLevel`, Int64)\n(`ReorderPoint`, Int64)\n(`StandardCost`, Float64)\n(`ListPrice`, Float64)\n(`Size`, String)\n(`SizeUnitMeasureCode`, String)\n(`WeightUnitMeasureCode`, String)\n(`Weight`, Float64)\n(`DaysToManufacture`, Int64)\n(`ProductLine`, String)\n(`Class`, String)\n(`Style`, String)\n(`ProductSubcategoryID`, Int64)\n(`ProductModelID`, Int64)\n(`SellStartDate`, DateTime)\n(`SellEndDate`, DateTime)\n(`DiscontinuedDate`, DateTime)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 517,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.TransactionType FROM TransactionHistoryArchive AS T1 INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE T2.Name = 'LL Road Handlebars' AND STRFTIME('%Y-%m-%d',T1.TransactionDate) = '2012-11-03'",
        "target_query": "SELECT `T1`.`TransactionType` FROM `TransactionHistoryArchive` AS `T1` INNER JOIN `Product` AS `T2` ON `T1`.`ProductID` = `T2`.`ProductID` WHERE `T2`.`Name` = 'LL Road Handlebars' AND formatDateTime(`T1`.`TransactionDate`, '%Y-%m-%d') = '2012-11-03';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 160,
                "end_index": 199,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 184,
                "end_index": 234,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `TransactionHistoryArchive`\nColumns:\n(`TransactionID`, integer, primary key)\n(`ProductID`, integer)\n(`ReferenceOrderID`, integer)\n(`ReferenceOrderLineID`, integer)\n(`TransactionDate`, datetime)\n(`TransactionType`, text)\n(`Quantity`, integer)\n(`ActualCost`, real)\n(`ModifiedDate`, datetime)\n",
            "Table: `Product`\nColumns:\n(`ProductID`, integer, primary key)\n(`Name`, text)\n(`ProductNumber`, text)\n(`MakeFlag`, integer)\n(`FinishedGoodsFlag`, integer)\n(`Color`, text)\n(`SafetyStockLevel`, integer)\n(`ReorderPoint`, integer)\n(`StandardCost`, real)\n(`ListPrice`, real)\n(`Size`, text)\n(`SizeUnitMeasureCode`, text)\n(`WeightUnitMeasureCode`, text)\n(`Weight`, real)\n(`DaysToManufacture`, integer)\n(`ProductLine`, text)\n(`Class`, text)\n(`Style`, text)\n(`ProductSubcategoryID`, integer)\n(`ProductModelID`, integer)\n(`SellStartDate`, datetime)\n(`SellEndDate`, datetime)\n(`DiscontinuedDate`, datetime)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `TransactionHistoryArchive`\nColumns:\n(`TransactionID`, Int64, primary key)\n(`ProductID`, Int64)\n(`ReferenceOrderID`, Int64)\n(`ReferenceOrderLineID`, Int64)\n(`TransactionDate`, DateTime)\n(`TransactionType`, String)\n(`Quantity`, Int64)\n(`ActualCost`, Float64)\n(`ModifiedDate`, DateTime)\n",
            "Table: `Product`\nColumns:\n(`ProductID`, Int64, primary key)\n(`Name`, String)\n(`ProductNumber`, String)\n(`MakeFlag`, Int64)\n(`FinishedGoodsFlag`, Int64)\n(`Color`, String)\n(`SafetyStockLevel`, Int64)\n(`ReorderPoint`, Int64)\n(`StandardCost`, Float64)\n(`ListPrice`, Float64)\n(`Size`, String)\n(`SizeUnitMeasureCode`, String)\n(`WeightUnitMeasureCode`, String)\n(`Weight`, Float64)\n(`DaysToManufacture`, Int64)\n(`ProductLine`, String)\n(`Class`, String)\n(`Style`, String)\n(`ProductSubcategoryID`, Int64)\n(`ProductModelID`, Int64)\n(`SellStartDate`, DateTime)\n(`SellEndDate`, DateTime)\n(`DiscontinuedDate`, DateTime)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 518,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT BusinessEntityID FROM SalesPerson WHERE BusinessEntityID IN ( SELECT BusinessEntityID FROM SalesPersonQuotaHistory WHERE STRFTIME('%Y', QuotaDate) = '2013' ) ORDER BY CAST(SalesLastYear AS REAL) / SalesQuota DESC LIMIT 1",
        "target_query": "SELECT `BusinessEntityID` FROM `SalesPerson` WHERE `BusinessEntityID` IN ( SELECT `BusinessEntityID` FROM `SalesPersonQuotaHistory` WHERE formatDateTime(`QuotaDate`, '%Y') = '2013' ) ORDER BY `SalesLastYear` / `SalesQuota` DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 128,
                "end_index": 153,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 138,
                "end_index": 171,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `SalesPerson`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`TerritoryID`, integer)\n(`SalesQuota`, real)\n(`Bonus`, real)\n(`CommissionPct`, real)\n(`SalesYTD`, real)\n(`SalesLastYear`, real)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `SalesPersonQuotaHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`QuotaDate`, datetime, primary key)\n(`SalesQuota`, real)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `SalesPerson`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`TerritoryID`, Int64)\n(`SalesQuota`, Float64)\n(`Bonus`, Float64)\n(`CommissionPct`, Float64)\n(`SalesYTD`, Float64)\n(`SalesLastYear`, Float64)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n",
            "Table: `SalesPersonQuotaHistory`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`QuotaDate`, DateTime, primary key)\n(`SalesQuota`, Float64)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 519,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T1.BusinessEntityID) FROM Employee AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T2.PersonType = 'SP' AND SUBSTR(T1.HireDate, 0, 4) < 2010",
        "target_query": "SELECT COUNT(`T1`.`BusinessEntityID`) FROM `Employee` AS `T1` INNER JOIN `Person` AS `T2` ON `T1`.`BusinessEntityID` = `T2`.`BusinessEntityID` WHERE `T2`.`PersonType` = 'SP' AND toInt32(substring(toString(`T1`.`HireDate`), 1, 4)) < 2010;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 154,
                "end_index": 179,
                "dialect_content": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 186,
                "end_index": 221,
                "dialect_content": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "feature": "substring(str, start, length) | substring(str, start)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "explanation": "The substr(X,Y,Z) function returns a substring of input string X that begins\n  with the Y-th character and which is Z characters long.\n  If Z is omitted then substr(X,Y) returns all characters through the end\n  of the string X beginning with the Y-th.\n  The left-most character of X is number 1.  If Y is negative\n  then the first character of the substring is found by counting from the\n  right rather than the left.  If Z is negative then\n  the abs(Z) characters preceding the Y-th character are returned.\n  If X is a string then characters indices refer to actual UTF-8 \n  characters.  If X is a BLOB then the indices refer to bytes.\n  \n  \"substring()\" is an alias for \"substr()\" beginning with SQLite version 3.34.\n",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "substring(str, start, length) | substring(str, start)",
                "explanation": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
                "examples": [
                    "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`PersonType`, text)\n(`NameStyle`, integer)\n(`Title`, text)\n(`FirstName`, text)\n(`MiddleName`, text)\n(`LastName`, text)\n(`Suffix`, text)\n(`EmailPromotion`, integer)\n(`AdditionalContactInfo`, text)\n(`Demographics`, text)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`NationalIDNumber`, String)\n(`LoginID`, String)\n(`OrganizationNode`, String)\n(`OrganizationLevel`, Int64)\n(`JobTitle`, String)\n(`BirthDate`, Date32)\n(`MaritalStatus`, String)\n(`Gender`, String)\n(`HireDate`, Date32)\n(`SalariedFlag`, Int64)\n(`VacationHours`, Int64)\n(`SickLeaveHours`, Int64)\n(`CurrentFlag`, Int64)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n",
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`PersonType`, String)\n(`NameStyle`, Int64)\n(`Title`, String)\n(`FirstName`, String)\n(`MiddleName`, String)\n(`LastName`, String)\n(`Suffix`, String)\n(`EmailPromotion`, Int64)\n(`AdditionalContactInfo`, String)\n(`Demographics`, String)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 520,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.BusinessEntityID, SUM(T1.SalesQuota) FROM SalesPerson AS T1 INNER JOIN SalesPersonQuotaHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE STRFTIME('%Y', T2.QuotaDate) = '2011' GROUP BY T1.BusinessEntityID ORDER BY SUM(T1.SalesYTD) DESC LIMIT 1",
        "target_query": "SELECT `T1`.`BusinessEntityID`, SUM(`T1`.`SalesQuota`) FROM `SalesPerson` AS `T1` INNER JOIN `SalesPersonQuotaHistory` AS `T2` ON `T1`.`BusinessEntityID` = `T2`.`BusinessEntityID` WHERE formatDateTime(`T2`.`QuotaDate`, '%Y') = '2011' GROUP BY `T1`.`BusinessEntityID` ORDER BY SUM(`T1`.`SalesYTD`) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 162,
                "end_index": 190,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 186,
                "end_index": 224,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `SalesPerson`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`TerritoryID`, integer)\n(`SalesQuota`, real)\n(`Bonus`, real)\n(`CommissionPct`, real)\n(`SalesYTD`, real)\n(`SalesLastYear`, real)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `SalesPersonQuotaHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`QuotaDate`, datetime, primary key)\n(`SalesQuota`, real)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `SalesPerson`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`TerritoryID`, Int64)\n(`SalesQuota`, Float64)\n(`Bonus`, Float64)\n(`CommissionPct`, Float64)\n(`SalesYTD`, Float64)\n(`SalesLastYear`, Float64)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n",
            "Table: `SalesPersonQuotaHistory`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`QuotaDate`, DateTime, primary key)\n(`SalesQuota`, Float64)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 521,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT T1.BusinessEntityID FROM SalesPerson AS T1 INNER JOIN SalesPersonQuotaHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.TerritoryID = 1 AND STRFTIME('%Y', QuotaDate) = '2013'",
        "target_query": "SELECT DISTINCT `T1`.`BusinessEntityID` FROM `SalesPerson` AS `T1` INNER JOIN `SalesPersonQuotaHistory` AS `T2` ON `T1`.`BusinessEntityID` = `T2`.`BusinessEntityID` WHERE `T1`.`TerritoryID` = 1 AND formatDateTime(`T2`.`QuotaDate`, '%Y') = '2013';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 174,
                "end_index": 199,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 198,
                "end_index": 236,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `SalesPerson`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`TerritoryID`, integer)\n(`SalesQuota`, real)\n(`Bonus`, real)\n(`CommissionPct`, real)\n(`SalesYTD`, real)\n(`SalesLastYear`, real)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `SalesPersonQuotaHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`QuotaDate`, datetime, primary key)\n(`SalesQuota`, real)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `SalesPerson`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`TerritoryID`, Int64)\n(`SalesQuota`, Float64)\n(`Bonus`, Float64)\n(`CommissionPct`, Float64)\n(`SalesYTD`, Float64)\n(`SalesLastYear`, Float64)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n",
            "Table: `SalesPersonQuotaHistory`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`QuotaDate`, DateTime, primary key)\n(`SalesQuota`, Float64)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 522,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(T1.SalesQuota) FROM SalesPerson AS T1 INNER JOIN SalesPersonQuotaHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.BusinessEntityID = 275 AND STRFTIME('%Y', QuotaDate) = '2013'",
        "target_query": "SELECT SUM(`T1`.`SalesQuota`) FROM `SalesPerson` AS `T1` INNER JOIN `SalesPersonQuotaHistory` AS `T2` ON `T1`.`BusinessEntityID` = `T2`.`BusinessEntityID` WHERE `T1`.`BusinessEntityID` = 275 AND formatDateTime(`T2`.`QuotaDate`, '%Y') = '2013';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 171,
                "end_index": 196,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 195,
                "end_index": 233,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `SalesPerson`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`TerritoryID`, integer)\n(`SalesQuota`, real)\n(`Bonus`, real)\n(`CommissionPct`, real)\n(`SalesYTD`, real)\n(`SalesLastYear`, real)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `SalesPersonQuotaHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`QuotaDate`, datetime, primary key)\n(`SalesQuota`, real)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `SalesPerson`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`TerritoryID`, Int64)\n(`SalesQuota`, Float64)\n(`Bonus`, Float64)\n(`CommissionPct`, Float64)\n(`SalesYTD`, Float64)\n(`SalesLastYear`, Float64)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n",
            "Table: `SalesPersonQuotaHistory`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`QuotaDate`, DateTime, primary key)\n(`SalesQuota`, Float64)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 523,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT DISTINCT T1.BusinessEntityID FROM SalesPerson AS T1 INNER JOIN SalesPersonQuotaHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE STRFTIME('%Y', T2.QuotaDate) = '2013' AND T1.SalesQuota < T1.SalesLastYear",
        "target_query": "SELECT DISTINCT `T1`.`BusinessEntityID` FROM `SalesPerson` AS `T1` INNER JOIN `SalesPersonQuotaHistory` AS `T2` ON `T1`.`BusinessEntityID` = `T2`.`BusinessEntityID` WHERE formatDateTime(`T2`.`QuotaDate`, '%Y') = '2013' AND `T1`.`SalesQuota` < `T1`.`SalesLastYear`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 151,
                "end_index": 179,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 171,
                "end_index": 209,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `SalesPerson`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`TerritoryID`, integer)\n(`SalesQuota`, real)\n(`Bonus`, real)\n(`CommissionPct`, real)\n(`SalesYTD`, real)\n(`SalesLastYear`, real)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `SalesPersonQuotaHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`QuotaDate`, datetime, primary key)\n(`SalesQuota`, real)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `SalesPerson`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`TerritoryID`, Int64)\n(`SalesQuota`, Float64)\n(`Bonus`, Float64)\n(`CommissionPct`, Float64)\n(`SalesYTD`, Float64)\n(`SalesLastYear`, Float64)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n",
            "Table: `SalesPersonQuotaHistory`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`QuotaDate`, DateTime, primary key)\n(`SalesQuota`, Float64)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 524,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT SUM(T1.Bonus) , CAST(SUM(T1.Bonus) AS REAL) * 100 / SUM(T1.SalesQuota) FROM SalesPerson AS T1 INNER JOIN SalesPersonQuotaHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE STRFTIME('%Y', T2.QuotaDate) = '2013'",
        "target_query": "SELECT SUM(`T1`.`Bonus`), CAST(SUM(`T1`.`Bonus`) AS Float64) * 100 / SUM(`T1`.`SalesQuota`) FROM `SalesPerson` AS `T1` INNER JOIN `SalesPersonQuotaHistory` AS `T2` ON `T1`.`BusinessEntityID` = `T2`.`BusinessEntityID` WHERE formatDateTime(`T2`.`QuotaDate`, '%Y') = '2013';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 193,
                "end_index": 221,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 223,
                "end_index": 261,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `SalesPerson`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`TerritoryID`, integer)\n(`SalesQuota`, real)\n(`Bonus`, real)\n(`CommissionPct`, real)\n(`SalesYTD`, real)\n(`SalesLastYear`, real)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `SalesPersonQuotaHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`QuotaDate`, datetime, primary key)\n(`SalesQuota`, real)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `SalesPerson`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`TerritoryID`, Int64)\n(`SalesQuota`, Float64)\n(`Bonus`, Float64)\n(`CommissionPct`, Float64)\n(`SalesYTD`, Float64)\n(`SalesLastYear`, Float64)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n",
            "Table: `SalesPersonQuotaHistory`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`QuotaDate`, DateTime, primary key)\n(`SalesQuota`, Float64)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 526,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(BusinessEntityID) FROM Employee WHERE MaritalStatus = 'M' AND STRFTIME('%Y', BirthDate) < '1960' AND Gender = 'M'",
        "target_query": "SELECT COUNT(`BusinessEntityID`) FROM `Employee` WHERE `MaritalStatus` = 'M' AND formatDateTime(`BirthDate`, '%Y') < '1960' AND `Gender` = 'M';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 75,
                "end_index": 100,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 81,
                "end_index": 114,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`NationalIDNumber`, String)\n(`LoginID`, String)\n(`OrganizationNode`, String)\n(`OrganizationLevel`, Int64)\n(`JobTitle`, String)\n(`BirthDate`, Date32)\n(`MaritalStatus`, String)\n(`Gender`, String)\n(`HireDate`, Date32)\n(`SalariedFlag`, Int64)\n(`VacationHours`, Int64)\n(`SickLeaveHours`, Int64)\n(`CurrentFlag`, Int64)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 528,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T3.Name) FROM Person AS T1 INNER JOIN EmployeeDepartmentHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Department AS T3 ON T2.DepartmentID = T3.DepartmentID WHERE T1.FirstName = 'Sheela' AND T1.LastName = 'Word' AND STRFTIME('%Y', T3.ModifiedDate) BETWEEN '2011' AND '2012'",
        "target_query": "SELECT COUNT(`T3`.`Name`) FROM `Person` AS `T1` INNER JOIN `EmployeeDepartmentHistory` AS `T2` ON `T1`.`BusinessEntityID` = `T2`.`BusinessEntityID` INNER JOIN `Department` AS `T3` ON `T2`.`DepartmentID` = `T3`.`DepartmentID` WHERE `T1`.`FirstName` = 'Sheela' AND `T1`.`LastName` = 'Word' AND formatDateTime(`T3`.`ModifiedDate`, '%Y') BETWEEN '2011' AND '2012';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 252,
                "end_index": 283,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 292,
                "end_index": 333,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`PersonType`, text)\n(`NameStyle`, integer)\n(`Title`, text)\n(`FirstName`, text)\n(`MiddleName`, text)\n(`LastName`, text)\n(`Suffix`, text)\n(`EmailPromotion`, integer)\n(`AdditionalContactInfo`, text)\n(`Demographics`, text)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `EmployeeDepartmentHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`DepartmentID`, integer, primary key)\n(`ShiftID`, integer, primary key)\n(`StartDate`, date, primary key)\n(`EndDate`, date)\n(`ModifiedDate`, datetime)\n",
            "Table: `Department`\nColumns:\n(`DepartmentID`, integer, primary key)\n(`Name`, text)\n(`GroupName`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`PersonType`, String)\n(`NameStyle`, Int64)\n(`Title`, String)\n(`FirstName`, String)\n(`MiddleName`, String)\n(`LastName`, String)\n(`Suffix`, String)\n(`EmailPromotion`, Int64)\n(`AdditionalContactInfo`, String)\n(`Demographics`, String)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n",
            "Table: `EmployeeDepartmentHistory`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`DepartmentID`, Int64, primary key)\n(`ShiftID`, Int64, primary key)\n(`StartDate`, Date32, primary key)\n(`EndDate`, Date32)\n(`ModifiedDate`, DateTime)\n",
            "Table: `Department`\nColumns:\n(`DepartmentID`, Int64, primary key)\n(`Name`, String)\n(`GroupName`, String)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 529,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT AVG(2009 - STRFTIME('%Y', T2.BirthDate)) FROM Person AS T1 INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.PersonType = 'SP'",
        "target_query": "SELECT AVG(2009 - toYear(`T2`.`BirthDate`)) FROM `Person` AS `T1` INNER JOIN `Employee` AS `T2` ON `T1`.`BusinessEntityID` = `T2`.`BusinessEntityID` WHERE `T1`.`PersonType` = 'SP';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 18,
                "end_index": 46,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`PersonType`, text)\n(`NameStyle`, integer)\n(`Title`, text)\n(`FirstName`, text)\n(`MiddleName`, text)\n(`LastName`, text)\n(`Suffix`, text)\n(`EmailPromotion`, integer)\n(`AdditionalContactInfo`, text)\n(`Demographics`, text)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`PersonType`, String)\n(`NameStyle`, Int64)\n(`Title`, String)\n(`FirstName`, String)\n(`MiddleName`, String)\n(`LastName`, String)\n(`Suffix`, String)\n(`EmailPromotion`, Int64)\n(`AdditionalContactInfo`, String)\n(`Demographics`, String)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n",
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`NationalIDNumber`, String)\n(`LoginID`, String)\n(`OrganizationNode`, String)\n(`OrganizationLevel`, Int64)\n(`JobTitle`, String)\n(`BirthDate`, Date32)\n(`MaritalStatus`, String)\n(`Gender`, String)\n(`HireDate`, Date32)\n(`SalariedFlag`, Int64)\n(`VacationHours`, Int64)\n(`SickLeaveHours`, Int64)\n(`CurrentFlag`, Int64)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 530,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT 2015 - STRFTIME('%Y', T1.BirthDate), T2.Rate FROM Employee AS T1 INNER JOIN EmployeePayHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.JobTitle = 'Marketing Specialist' ORDER BY 2015 - STRFTIME('%Y', T1.BirthDate) DESC LIMIT 1",
        "target_query": "SELECT 2015 - toYear(`T1`.`BirthDate`), `T2`.`Rate` FROM `Employee` AS `T1` INNER JOIN `EmployeePayHistory` AS `T2` ON `T1`.`BusinessEntityID` = `T2`.`BusinessEntityID` WHERE `T1`.`JobTitle` = 'Marketing Specialist' ORDER BY 2015 - toYear(`T1`.`BirthDate`) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 14,
                "end_index": 42,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 212,
                "end_index": 240,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `EmployeePayHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`RateChangeDate`, datetime, primary key)\n(`Rate`, real)\n(`PayFrequency`, integer)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`NationalIDNumber`, String)\n(`LoginID`, String)\n(`OrganizationNode`, String)\n(`OrganizationLevel`, Int64)\n(`JobTitle`, String)\n(`BirthDate`, Date32)\n(`MaritalStatus`, String)\n(`Gender`, String)\n(`HireDate`, Date32)\n(`SalariedFlag`, Int64)\n(`VacationHours`, Int64)\n(`SickLeaveHours`, Int64)\n(`CurrentFlag`, Int64)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n",
            "Table: `EmployeePayHistory`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`RateChangeDate`, DateTime, primary key)\n(`Rate`, Float64)\n(`PayFrequency`, Int64)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 533,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.FirstName, T2.MiddleName, T2.LastName FROM Employee AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID ORDER BY STRFTIME('%Y', T1.HireDate) - STRFTIME('%Y', T1.BirthDate) DESC LIMIT 1, 1",
        "target_query": "SELECT `T2`.`FirstName`, `T2`.`MiddleName`, `T2`.`LastName` FROM `Employee` AS `T1` INNER JOIN `Person` AS `T2` ON `T1`.`BusinessEntityID` = `T2`.`BusinessEntityID` ORDER BY (toYear(`T1`.`HireDate`) - toYear(`T1`.`BirthDate`)) DESC LIMIT 1 OFFSET 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 146,
                "end_index": 173,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 176,
                "end_index": 204,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`PersonType`, text)\n(`NameStyle`, integer)\n(`Title`, text)\n(`FirstName`, text)\n(`MiddleName`, text)\n(`LastName`, text)\n(`Suffix`, text)\n(`EmailPromotion`, integer)\n(`AdditionalContactInfo`, text)\n(`Demographics`, text)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`NationalIDNumber`, String)\n(`LoginID`, String)\n(`OrganizationNode`, String)\n(`OrganizationLevel`, Int64)\n(`JobTitle`, String)\n(`BirthDate`, Date32)\n(`MaritalStatus`, String)\n(`Gender`, String)\n(`HireDate`, Date32)\n(`SalariedFlag`, Int64)\n(`VacationHours`, Int64)\n(`SickLeaveHours`, Int64)\n(`CurrentFlag`, Int64)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n",
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`PersonType`, String)\n(`NameStyle`, Int64)\n(`Title`, String)\n(`FirstName`, String)\n(`MiddleName`, String)\n(`LastName`, String)\n(`Suffix`, String)\n(`EmailPromotion`, Int64)\n(`AdditionalContactInfo`, String)\n(`Demographics`, String)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 534,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.FirstName, T1.LastName FROM Person AS T1 INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE STRFTIME('%Y', T2.HireDate) >= '2007' AND T2.SalariedFlag = 1",
        "target_query": "SELECT `T1`.`FirstName`, `T1`.`LastName` FROM `Person` AS `T1` INNER JOIN `Employee` AS `T2` ON `T1`.`BusinessEntityID` = `T2`.`BusinessEntityID` WHERE formatDateTime(`T2`.`HireDate`, '%Y') >= '2007' AND `T2`.`SalariedFlag` = 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 128,
                "end_index": 155,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 152,
                "end_index": 189,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`PersonType`, text)\n(`NameStyle`, integer)\n(`Title`, text)\n(`FirstName`, text)\n(`MiddleName`, text)\n(`LastName`, text)\n(`Suffix`, text)\n(`EmailPromotion`, integer)\n(`AdditionalContactInfo`, text)\n(`Demographics`, text)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`PersonType`, String)\n(`NameStyle`, Int64)\n(`Title`, String)\n(`FirstName`, String)\n(`MiddleName`, String)\n(`LastName`, String)\n(`Suffix`, String)\n(`EmailPromotion`, Int64)\n(`AdditionalContactInfo`, String)\n(`Demographics`, String)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n",
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`NationalIDNumber`, String)\n(`LoginID`, String)\n(`OrganizationNode`, String)\n(`OrganizationLevel`, Int64)\n(`JobTitle`, String)\n(`BirthDate`, Date32)\n(`MaritalStatus`, String)\n(`Gender`, String)\n(`HireDate`, Date32)\n(`SalariedFlag`, Int64)\n(`VacationHours`, Int64)\n(`SickLeaveHours`, Int64)\n(`CurrentFlag`, Int64)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 536,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.FirstName, T1.LastName FROM Person AS T1 INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN EmployeeDepartmentHistory AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID INNER JOIN Department AS T4 ON T3.DepartmentID = T4.DepartmentID WHERE STRFTIME('%Y', T2.HireDate) = '2009' AND T4.Name = 'Shipping and Receiving'",
        "target_query": "SELECT `T1`.`FirstName`, `T1`.`LastName` \nFROM `Person` AS `T1` \nINNER JOIN `Employee` AS `T2` ON `T1`.`BusinessEntityID` = `T2`.`BusinessEntityID` \nINNER JOIN `EmployeeDepartmentHistory` AS `T3` ON `T2`.`BusinessEntityID` = `T3`.`BusinessEntityID` \nINNER JOIN `Department` AS `T4` ON `T3`.`DepartmentID` = `T4`.`DepartmentID` \nWHERE formatDateTime(`T2`.`HireDate`, '%Y') = '2009' \nAND `T4`.`Name` = 'Shipping and Receiving';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 281,
                "end_index": 308,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 334,
                "end_index": 371,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`PersonType`, text)\n(`NameStyle`, integer)\n(`Title`, text)\n(`FirstName`, text)\n(`MiddleName`, text)\n(`LastName`, text)\n(`Suffix`, text)\n(`EmailPromotion`, integer)\n(`AdditionalContactInfo`, text)\n(`Demographics`, text)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `EmployeeDepartmentHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`DepartmentID`, integer, primary key)\n(`ShiftID`, integer, primary key)\n(`StartDate`, date, primary key)\n(`EndDate`, date)\n(`ModifiedDate`, datetime)\n",
            "Table: `Department`\nColumns:\n(`DepartmentID`, integer, primary key)\n(`Name`, text)\n(`GroupName`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`PersonType`, String)\n(`NameStyle`, Int64)\n(`Title`, String)\n(`FirstName`, String)\n(`MiddleName`, String)\n(`LastName`, String)\n(`Suffix`, String)\n(`EmailPromotion`, Int64)\n(`AdditionalContactInfo`, String)\n(`Demographics`, String)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n",
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`NationalIDNumber`, String)\n(`LoginID`, String)\n(`OrganizationNode`, String)\n(`OrganizationLevel`, Int64)\n(`JobTitle`, String)\n(`BirthDate`, Date32)\n(`MaritalStatus`, String)\n(`Gender`, String)\n(`HireDate`, Date32)\n(`SalariedFlag`, Int64)\n(`VacationHours`, Int64)\n(`SickLeaveHours`, Int64)\n(`CurrentFlag`, Int64)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n",
            "Table: `EmployeeDepartmentHistory`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`DepartmentID`, Int64, primary key)\n(`ShiftID`, Int64, primary key)\n(`StartDate`, Date32, primary key)\n(`EndDate`, Date32)\n(`ModifiedDate`, DateTime)\n",
            "Table: `Department`\nColumns:\n(`DepartmentID`, Int64, primary key)\n(`Name`, String)\n(`GroupName`, String)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 539,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T1.Name, T3.Name FROM Product AS T1 INNER JOIN ProductVendor AS T2 ON T1.ProductID = T2.ProductID INNER JOIN Vendor AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID WHERE STRFTIME('%Y', T1.SellStartDate) = '2013'",
        "target_query": "SELECT `T1`.`Name`, `T3`.`Name` FROM `Product` AS `T1` INNER JOIN `ProductVendor` AS `T2` ON `T1`.`ProductID` = `T2`.`ProductID` INNER JOIN `Vendor` AS `T3` ON `T2`.`BusinessEntityID` = `T3`.`BusinessEntityID` WHERE formatDateTime(`T1`.`SellStartDate`, '%Y') = '2013';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 180,
                "end_index": 212,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 216,
                "end_index": 258,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Product`\nColumns:\n(`ProductID`, integer, primary key)\n(`Name`, text)\n(`ProductNumber`, text)\n(`MakeFlag`, integer)\n(`FinishedGoodsFlag`, integer)\n(`Color`, text)\n(`SafetyStockLevel`, integer)\n(`ReorderPoint`, integer)\n(`StandardCost`, real)\n(`ListPrice`, real)\n(`Size`, text)\n(`SizeUnitMeasureCode`, text)\n(`WeightUnitMeasureCode`, text)\n(`Weight`, real)\n(`DaysToManufacture`, integer)\n(`ProductLine`, text)\n(`Class`, text)\n(`Style`, text)\n(`ProductSubcategoryID`, integer)\n(`ProductModelID`, integer)\n(`SellStartDate`, datetime)\n(`SellEndDate`, datetime)\n(`DiscontinuedDate`, datetime)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `ProductVendor`\nColumns:\n(`ProductID`, integer, primary key)\n(`BusinessEntityID`, integer, primary key)\n(`AverageLeadTime`, integer)\n(`StandardPrice`, real)\n(`LastReceiptCost`, real)\n(`LastReceiptDate`, datetime)\n(`MinOrderQty`, integer)\n(`MaxOrderQty`, integer)\n(`OnOrderQty`, integer)\n(`UnitMeasureCode`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `Vendor`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`AccountNumber`, text)\n(`Name`, text)\n(`CreditRating`, integer)\n(`PreferredVendorStatus`, integer)\n(`ActiveFlag`, integer)\n(`PurchasingWebServiceURL`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `Product`\nColumns:\n(`ProductID`, Int64, primary key)\n(`Name`, String)\n(`ProductNumber`, String)\n(`MakeFlag`, Int64)\n(`FinishedGoodsFlag`, Int64)\n(`Color`, String)\n(`SafetyStockLevel`, Int64)\n(`ReorderPoint`, Int64)\n(`StandardCost`, Float64)\n(`ListPrice`, Float64)\n(`Size`, String)\n(`SizeUnitMeasureCode`, String)\n(`WeightUnitMeasureCode`, String)\n(`Weight`, Float64)\n(`DaysToManufacture`, Int64)\n(`ProductLine`, String)\n(`Class`, String)\n(`Style`, String)\n(`ProductSubcategoryID`, Int64)\n(`ProductModelID`, Int64)\n(`SellStartDate`, DateTime)\n(`SellEndDate`, DateTime)\n(`DiscontinuedDate`, DateTime)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n",
            "Table: `ProductVendor`\nColumns:\n(`ProductID`, Int64, primary key)\n(`BusinessEntityID`, Int64, primary key)\n(`AverageLeadTime`, Int64)\n(`StandardPrice`, Float64)\n(`LastReceiptCost`, Float64)\n(`LastReceiptDate`, DateTime)\n(`MinOrderQty`, Int64)\n(`MaxOrderQty`, Int64)\n(`OnOrderQty`, Int64)\n(`UnitMeasureCode`, String)\n(`ModifiedDate`, DateTime)\n",
            "Table: `Vendor`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`AccountNumber`, String)\n(`Name`, String)\n(`CreditRating`, Int64)\n(`PreferredVendorStatus`, Int64)\n(`ActiveFlag`, Int64)\n(`PurchasingWebServiceURL`, String)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 540,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.FirstName, T2.LastName FROM Employee AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE STRFTIME('%Y', T1.BirthDate) > '1970' ORDER BY T1.SickLeaveHours LIMIT 1",
        "target_query": "SELECT T2.`FirstName`, T2.`LastName` FROM `Employee` AS T1 INNER JOIN `Person` AS T2 ON T1.`BusinessEntityID` = T2.`BusinessEntityID` WHERE formatDateTime(T1.`BirthDate`, '%Y') > '1970' ORDER BY T1.`SickLeaveHours` LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 128,
                "end_index": 156,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 140,
                "end_index": 176,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`PersonType`, text)\n(`NameStyle`, integer)\n(`Title`, text)\n(`FirstName`, text)\n(`MiddleName`, text)\n(`LastName`, text)\n(`Suffix`, text)\n(`EmailPromotion`, integer)\n(`AdditionalContactInfo`, text)\n(`Demographics`, text)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`NationalIDNumber`, String)\n(`LoginID`, String)\n(`OrganizationNode`, String)\n(`OrganizationLevel`, Int64)\n(`JobTitle`, String)\n(`BirthDate`, Date32)\n(`MaritalStatus`, String)\n(`Gender`, String)\n(`HireDate`, Date32)\n(`SalariedFlag`, Int64)\n(`VacationHours`, Int64)\n(`SickLeaveHours`, Int64)\n(`CurrentFlag`, Int64)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n",
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`PersonType`, String)\n(`NameStyle`, Int64)\n(`Title`, String)\n(`FirstName`, String)\n(`MiddleName`, String)\n(`LastName`, String)\n(`Suffix`, String)\n(`EmailPromotion`, Int64)\n(`AdditionalContactInfo`, String)\n(`Demographics`, String)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 543,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T3.StartTime, T3.EndTime FROM Employee AS T1 INNER JOIN EmployeeDepartmentHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Shift AS T3 ON T2.ShiftId = T3.ShiftId WHERE STRFTIME('%Y', T1.BirthDate) < '1969' ORDER BY T1.BirthDate LIMIT 5, 1",
        "target_query": "SELECT `T3`.`StartTime`, `T3`.`EndTime` \nFROM `Employee` AS `T1` \nINNER JOIN `EmployeeDepartmentHistory` AS `T2` ON `T1`.`BusinessEntityID` = `T2`.`BusinessEntityID` \nINNER JOIN `Shift` AS `T3` ON `T2`.`ShiftID` = `T3`.`ShiftID` \nWHERE formatDateTime(`T1`.`BirthDate`, '%Y') < '1969' \nORDER BY `T1`.`BirthDate` \nLIMIT 1 OFFSET 5;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 196,
                "end_index": 224,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 236,
                "end_index": 274,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `EmployeeDepartmentHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`DepartmentID`, integer, primary key)\n(`ShiftID`, integer, primary key)\n(`StartDate`, date, primary key)\n(`EndDate`, date)\n(`ModifiedDate`, datetime)\n",
            "Table: `Shift`\nColumns:\n(`ShiftID`, integer, primary key)\n(`Name`, text)\n(`StartTime`, text)\n(`EndTime`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`NationalIDNumber`, String)\n(`LoginID`, String)\n(`OrganizationNode`, String)\n(`OrganizationLevel`, Int64)\n(`JobTitle`, String)\n(`BirthDate`, Date32)\n(`MaritalStatus`, String)\n(`Gender`, String)\n(`HireDate`, Date32)\n(`SalariedFlag`, Int64)\n(`VacationHours`, Int64)\n(`SickLeaveHours`, Int64)\n(`CurrentFlag`, Int64)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n",
            "Table: `EmployeeDepartmentHistory`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`DepartmentID`, Int64, primary key)\n(`ShiftID`, Int64, primary key)\n(`StartDate`, Date32, primary key)\n(`EndDate`, Date32)\n(`ModifiedDate`, DateTime)\n",
            "Table: `Shift`\nColumns:\n(`ShiftID`, Int64, primary key)\n(`Name`, String)\n(`StartTime`, String)\n(`EndTime`, String)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 544,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.EndDate FROM Employee AS T1 INNER JOIN EmployeeDepartmentHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Department AS T3 ON T2.DepartmentID = T3.DepartmentID WHERE T1.JobTitle = 'Senior Tool Designer' AND STRFTIME('%Y', T1.HireDate) - STRFTIME('%Y', T1.BirthDate) = 33 AND T2.EndDate IS NOT NULL",
        "target_query": "SELECT `T2`.`EndDate` FROM `Employee` AS `T1` INNER JOIN `EmployeeDepartmentHistory` AS `T2` ON `T1`.`BusinessEntityID` = `T2`.`BusinessEntityID` INNER JOIN `Department` AS `T3` ON `T2`.`DepartmentID` = `T3`.`DepartmentID` WHERE `T1`.`JobTitle` = 'Senior Tool Designer' AND toYear(`T1`.`HireDate`) - toYear(`T1`.`BirthDate`) = 33 AND `T2`.`EndDate` IS NOT NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 238,
                "end_index": 265,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 268,
                "end_index": 296,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `EmployeeDepartmentHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`DepartmentID`, integer, primary key)\n(`ShiftID`, integer, primary key)\n(`StartDate`, date, primary key)\n(`EndDate`, date)\n(`ModifiedDate`, datetime)\n",
            "Table: `Department`\nColumns:\n(`DepartmentID`, integer, primary key)\n(`Name`, text)\n(`GroupName`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`NationalIDNumber`, String)\n(`LoginID`, String)\n(`OrganizationNode`, String)\n(`OrganizationLevel`, Int64)\n(`JobTitle`, String)\n(`BirthDate`, Date32)\n(`MaritalStatus`, String)\n(`Gender`, String)\n(`HireDate`, Date32)\n(`SalariedFlag`, Int64)\n(`VacationHours`, Int64)\n(`SickLeaveHours`, Int64)\n(`CurrentFlag`, Int64)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n",
            "Table: `EmployeeDepartmentHistory`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`DepartmentID`, Int64, primary key)\n(`ShiftID`, Int64, primary key)\n(`StartDate`, Date32, primary key)\n(`EndDate`, Date32)\n(`ModifiedDate`, DateTime)\n",
            "Table: `Department`\nColumns:\n(`DepartmentID`, Int64, primary key)\n(`Name`, String)\n(`GroupName`, String)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 546,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT T2.PersonType FROM Employee AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.Gender = 'F' AND T1.MaritalStatus = 'S' AND STRFTIME('%Y-%m-%d', T1.HireDate) BETWEEN '2008-1-1' AND '2008-12-31' GROUP BY T2.PersonType ORDER BY COUNT(T2.PersonType) DESC LIMIT 1",
        "target_query": "SELECT T2.`PersonType` FROM `Employee` AS T1 INNER JOIN `Person` AS T2 ON T1.`BusinessEntityID` = T2.`BusinessEntityID` WHERE T1.`Gender` = 'F' AND T1.`MaritalStatus` = 'S' AND formatDateTime(T1.`HireDate`, '%Y-%m-%d') BETWEEN '2008-01-01' AND '2008-12-31' GROUP BY T2.`PersonType` ORDER BY COUNT(T2.`PersonType`) DESC LIMIT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 163,
                "end_index": 196,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 177,
                "end_index": 218,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`NationalIDNumber`, text)\n(`LoginID`, text)\n(`OrganizationNode`, text)\n(`OrganizationLevel`, integer)\n(`JobTitle`, text)\n(`BirthDate`, date)\n(`MaritalStatus`, text)\n(`Gender`, text)\n(`HireDate`, date)\n(`SalariedFlag`, integer)\n(`VacationHours`, integer)\n(`SickLeaveHours`, integer)\n(`CurrentFlag`, integer)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`PersonType`, text)\n(`NameStyle`, integer)\n(`Title`, text)\n(`FirstName`, text)\n(`MiddleName`, text)\n(`LastName`, text)\n(`Suffix`, text)\n(`EmailPromotion`, integer)\n(`AdditionalContactInfo`, text)\n(`Demographics`, text)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `Employee`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`NationalIDNumber`, String)\n(`LoginID`, String)\n(`OrganizationNode`, String)\n(`OrganizationLevel`, Int64)\n(`JobTitle`, String)\n(`BirthDate`, Date32)\n(`MaritalStatus`, String)\n(`Gender`, String)\n(`HireDate`, Date32)\n(`SalariedFlag`, Int64)\n(`VacationHours`, Int64)\n(`SickLeaveHours`, Int64)\n(`CurrentFlag`, Int64)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n",
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`PersonType`, String)\n(`NameStyle`, Int64)\n(`Title`, String)\n(`FirstName`, String)\n(`MiddleName`, String)\n(`LastName`, String)\n(`Suffix`, String)\n(`EmailPromotion`, Int64)\n(`AdditionalContactInfo`, String)\n(`Demographics`, String)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 547,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T1.BusinessEntityID) FROM Person AS T1 INNER JOIN EmployeeDepartmentHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Department AS T3 ON T2.DepartmentID = T3.DepartmentID WHERE T3.Name = 'Engineering' AND STRFTIME('%Y', T2.EndDate) > '2009' AND STRFTIME('%Y', T2.StartDate) < '2009'",
        "target_query": "SELECT COUNT(`T1`.`BusinessEntityID`) FROM `Person` AS `T1` INNER JOIN `EmployeeDepartmentHistory` AS `T2` ON `T1`.`BusinessEntityID` = `T2`.`BusinessEntityID` INNER JOIN `Department` AS `T3` ON `T2`.`DepartmentID` = `T3`.`DepartmentID` WHERE `T3`.`Name` = 'Engineering' AND formatDateTime(`T2`.`EndDate`, '%Y') > '2009' AND formatDateTime(`T2`.`StartDate`, '%Y') < '2009';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 239,
                "end_index": 265,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 279,
                "end_index": 307,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 275,
                "end_index": 311,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            },
            {
                "start_index": 325,
                "end_index": 363,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`PersonType`, text)\n(`NameStyle`, integer)\n(`Title`, text)\n(`FirstName`, text)\n(`MiddleName`, text)\n(`LastName`, text)\n(`Suffix`, text)\n(`EmailPromotion`, integer)\n(`AdditionalContactInfo`, text)\n(`Demographics`, text)\n(`rowguid`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `EmployeeDepartmentHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`DepartmentID`, integer, primary key)\n(`ShiftID`, integer, primary key)\n(`StartDate`, date, primary key)\n(`EndDate`, date)\n(`ModifiedDate`, datetime)\n",
            "Table: `Department`\nColumns:\n(`DepartmentID`, integer, primary key)\n(`Name`, text)\n(`GroupName`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `Person`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`PersonType`, String)\n(`NameStyle`, Int64)\n(`Title`, String)\n(`FirstName`, String)\n(`MiddleName`, String)\n(`LastName`, String)\n(`Suffix`, String)\n(`EmailPromotion`, Int64)\n(`AdditionalContactInfo`, String)\n(`Demographics`, String)\n(`rowguid`, String)\n(`ModifiedDate`, DateTime)\n",
            "Table: `EmployeeDepartmentHistory`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`DepartmentID`, Int64, primary key)\n(`ShiftID`, Int64, primary key)\n(`StartDate`, Date32, primary key)\n(`EndDate`, Date32)\n(`ModifiedDate`, DateTime)\n",
            "Table: `Department`\nColumns:\n(`DepartmentID`, Int64, primary key)\n(`Name`, String)\n(`GroupName`, String)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 549,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT COUNT(T1.BusinessEntityID) FROM EmployeeDepartmentHistory AS T1 INNER JOIN Department AS T2 ON T1.DepartmentID = T2.DepartmentID WHERE T2.GroupName = 'Quality Assurance' AND STRFTIME('%Y', T1.StartDate) = '2007'",
        "target_query": "SELECT COUNT(`T1`.`BusinessEntityID`) FROM `EmployeeDepartmentHistory` AS `T1` INNER JOIN `Department` AS `T2` ON `T1`.`DepartmentID` = `T2`.`DepartmentID` WHERE `T2`.`GroupName` = 'Quality Assurance' AND formatDateTime(`T1`.`StartDate`, '%Y') = '2007';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 181,
                "end_index": 209,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 205,
                "end_index": 243,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `EmployeeDepartmentHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`DepartmentID`, integer, primary key)\n(`ShiftID`, integer, primary key)\n(`StartDate`, date, primary key)\n(`EndDate`, date)\n(`ModifiedDate`, datetime)\n",
            "Table: `Department`\nColumns:\n(`DepartmentID`, integer, primary key)\n(`Name`, text)\n(`GroupName`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `EmployeeDepartmentHistory`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`DepartmentID`, Int64, primary key)\n(`ShiftID`, Int64, primary key)\n(`StartDate`, Date32, primary key)\n(`EndDate`, Date32)\n(`ModifiedDate`, DateTime)\n",
            "Table: `Department`\nColumns:\n(`DepartmentID`, Int64, primary key)\n(`Name`, String)\n(`GroupName`, String)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 550,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(365 * (STRFTIME('%Y', T1.EndDate) - STRFTIME('%Y', T1.StartDate)) + 30 * (STRFTIME('%m', T1.EndDate) - STRFTIME('%m', T1.StartDate)) + STRFTIME('%d', T1.EndDate) - STRFTIME('%d', T1.StartDate)) AS REAL) / COUNT(T1.BusinessEntityID) FROM EmployeeDepartmentHistory AS T1 INNER JOIN Department AS T2 ON T1.DepartmentID = T2.DepartmentID WHERE T2.Name = 'Engineering' AND T1.EndDate IS NOT NULL",
        "target_query": "SELECT SUM(365 * (toYear(`T1`.`EndDate`) - toYear(`T1`.`StartDate`)) + 30 * (toMonth(`T1`.`EndDate`) - toMonth(`T1`.`StartDate`)) + (toDayOfMonth(`T1`.`EndDate`) - toDayOfMonth(`T1`.`StartDate`))) / COUNT(`T1`.`BusinessEntityID`) FROM `EmployeeDepartmentHistory` AS `T1` INNER JOIN `Department` AS `T2` ON `T1`.`DepartmentID` = `T2`.`DepartmentID` WHERE `T2`.`Name` = 'Engineering' AND `T1`.`EndDate` IS NOT NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 23,
                "end_index": 49,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 52,
                "end_index": 80,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 90,
                "end_index": 116,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 119,
                "end_index": 147,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 151,
                "end_index": 177,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 180,
                "end_index": 208,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `EmployeeDepartmentHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`DepartmentID`, integer, primary key)\n(`ShiftID`, integer, primary key)\n(`StartDate`, date, primary key)\n(`EndDate`, date)\n(`ModifiedDate`, datetime)\n",
            "Table: `Department`\nColumns:\n(`DepartmentID`, integer, primary key)\n(`Name`, text)\n(`GroupName`, text)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `EmployeeDepartmentHistory`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`DepartmentID`, Int64, primary key)\n(`ShiftID`, Int64, primary key)\n(`StartDate`, Date32, primary key)\n(`EndDate`, Date32)\n(`ModifiedDate`, DateTime)\n",
            "Table: `Department`\nColumns:\n(`DepartmentID`, Int64, primary key)\n(`Name`, String)\n(`GroupName`, String)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 551,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT AVG(T3.Rate) FROM EmployeeDepartmentHistory AS T1 INNER JOIN Department AS T2 ON T1.DepartmentID = T2.DepartmentID INNER JOIN EmployeePayHistory AS T3 ON T1.BusinessEntityID = T3.BusinessEntityID WHERE T2.Name = 'Engineering' AND STRFTIME('%Y', EndDate) > '2007' AND STRFTIME('%Y', T1.StartDate) < '2007'",
        "target_query": "SELECT AVG(`T3`.`Rate`) FROM `EmployeeDepartmentHistory` AS `T1` INNER JOIN `Department` AS `T2` ON `T1`.`DepartmentID` = `T2`.`DepartmentID` INNER JOIN `EmployeePayHistory` AS `T3` ON `T1`.`BusinessEntityID` = `T3`.`BusinessEntityID` WHERE `T2`.`Name` = 'Engineering' AND formatDateTime(`T1`.`EndDate`, '%Y') > '2007' AND formatDateTime(`T1`.`StartDate`, '%Y') < '2007';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 237,
                "end_index": 260,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 274,
                "end_index": 302,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 273,
                "end_index": 309,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            },
            {
                "start_index": 323,
                "end_index": 361,
                "dialect_content": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "feature": "formatDateTime(time_value, format)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `EmployeeDepartmentHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`DepartmentID`, integer, primary key)\n(`ShiftID`, integer, primary key)\n(`StartDate`, date, primary key)\n(`EndDate`, date)\n(`ModifiedDate`, datetime)\n",
            "Table: `Department`\nColumns:\n(`DepartmentID`, integer, primary key)\n(`Name`, text)\n(`GroupName`, text)\n(`ModifiedDate`, datetime)\n",
            "Table: `EmployeePayHistory`\nColumns:\n(`BusinessEntityID`, integer, primary key)\n(`RateChangeDate`, datetime, primary key)\n(`Rate`, real)\n(`PayFrequency`, integer)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `EmployeeDepartmentHistory`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`DepartmentID`, Int64, primary key)\n(`ShiftID`, Int64, primary key)\n(`StartDate`, Date32, primary key)\n(`EndDate`, Date32)\n(`ModifiedDate`, DateTime)\n",
            "Table: `Department`\nColumns:\n(`DepartmentID`, Int64, primary key)\n(`Name`, String)\n(`GroupName`, String)\n(`ModifiedDate`, DateTime)\n",
            "Table: `EmployeePayHistory`\nColumns:\n(`BusinessEntityID`, Int64, primary key)\n(`RateChangeDate`, DateTime, primary key)\n(`Rate`, Float64)\n(`PayFrequency`, Int64)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 552,
        "database_name": "works_cycles",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT 365 * (STRFTIME('%Y', ActualEndDate) - STRFTIME('%Y', ActualStartDate)) + 30 * (STRFTIME('%m', ActualEndDate) - STRFTIME('%m', ActualStartDate)) + STRFTIME('%d', ActualEndDate) - STRFTIME('%d', ActualStartDate) FROM WorkOrderRouting WHERE WorkOrderID = 425",
        "target_query": "SELECT 365 * (toYear(`ActualEndDate`) - toYear(`ActualStartDate`)) + 30 * (toMonth(`ActualEndDate`) - toMonth(`ActualStartDate`)) + toDayOfMonth(`ActualEndDate`) - toDayOfMonth(`ActualStartDate`) FROM `WorkOrderRouting` WHERE `WorkOrderID` = 425;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 14,
                "end_index": 43,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 46,
                "end_index": 77,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 87,
                "end_index": 116,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 119,
                "end_index": 150,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 154,
                "end_index": 183,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            },
            {
                "start_index": 186,
                "end_index": 217,
                "dialect_content": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "feature": "strftime(format, time-value, modifier, modifier, ...)"
            }
        ],
        "target_dialect_locations": [],
        "source_dialect_knowledge": [
            {
                "feature": "strftime(format, time-value, modifier, modifier, ...)",
                "explanation": "The strftime(format, time-value, modifier, modifier, ...) function returns the date and time formatted according to the format string specified as the first argument. The function supports various format substitutions and accepts a time-value and zero or more modifiers.\nParameters: format string (e.g., '%F %T'), time-value (e.g., 'now'), modifiers (e.g., '+1 hour').\nReturns: A string formatted according to the specified format string.",
                "examples": [
                    "SELECT strftime('%F'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT strftime('%T'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT strftime('%F %T', 'now', '+1 hour'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "formatDateTime(time_value, format)",
                "explanation": "The `formatDateTime` function in ClickHouse formats the given date or time value according to the specified format string. It works similarly to SQLite's `STRFTIME`, supporting various format substitutions and allowing the use of time-value expressions along with optional modifiers.",
                "examples": [
                    "SELECT formatDateTime(now(), '%Y-%m-%d'); -- Returns the current date formatted as YYYY-MM-DD.",
                    "SELECT formatDateTime(now(), '%H:%i:%s'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT formatDateTime(now() + INTERVAL 1 HOUR, '%Y-%m-%d %H:%i:%s'); -- Returns the date and time one hour after the current time, formatted as YYYY-MM-DD HH:MM:SS."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `WorkOrderRouting`\nColumns:\n(`WorkOrderID`, integer, primary key)\n(`ProductID`, integer, primary key)\n(`OperationSequence`, integer, primary key)\n(`LocationID`, integer)\n(`ScheduledStartDate`, datetime)\n(`ScheduledEndDate`, datetime)\n(`ActualStartDate`, datetime)\n(`ActualEndDate`, datetime)\n(`ActualResourceHrs`, real)\n(`PlannedCost`, real)\n(`ActualCost`, real)\n(`ModifiedDate`, datetime)\n"
        ],
        "target_related_schemas": [
            "Table: `WorkOrderRouting`\nColumns:\n(`WorkOrderID`, Int64, primary key)\n(`ProductID`, Int64, primary key)\n(`OperationSequence`, Int64, primary key)\n(`LocationID`, Int64)\n(`ScheduledStartDate`, DateTime)\n(`ScheduledEndDate`, DateTime)\n(`ActualStartDate`, DateTime)\n(`ActualEndDate`, DateTime)\n(`ActualResourceHrs`, Float64)\n(`PlannedCost`, Float64)\n(`ActualCost`, Float64)\n(`ModifiedDate`, DateTime)\n"
        ]
    },
    {
        "sql_id": 559,
        "database_name": "world",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T2.Language = 'English', 1, 0)) AS REAL) * 100 / COUNT(T1.Code) FROM Country AS T1 INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode",
        "target_query": "SELECT SUM(if(T2.`Language` = 'English', 1, 0)) * 100 / COUNT(T1.`Code`) FROM `Country` AS T1 INNER JOIN `CountryLanguage` AS T2 ON T1.`Code` = T2.`CountryCode`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 50,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 46,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Country`\nColumns:\n(`Code`, text, primary key)\n(`Name`, text)\n(`Continent`, text)\n(`Region`, text)\n(`SurfaceArea`, real)\n(`IndepYear`, integer)\n(`Population`, integer)\n(`LifeExpectancy`, real)\n(`GNP`, real)\n(`GNPOld`, real)\n(`LocalName`, text)\n(`GovernmentForm`, text)\n(`HeadOfState`, text)\n(`Capital`, integer)\n(`Code2`, text)\n",
            "Table: `CountryLanguage`\nColumns:\n(`CountryCode`, text, primary key)\n(`Language`, text, primary key)\n(`IsOfficial`, text)\n(`Percentage`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `Country`\nColumns:\n(`Code`, String, primary key)\n(`Name`, String)\n(`Continent`, String)\n(`Region`, String)\n(`SurfaceArea`, Float64)\n(`IndepYear`, Int64)\n(`Population`, Int64)\n(`LifeExpectancy`, Float64)\n(`GNP`, Float64)\n(`GNPOld`, Float64)\n(`LocalName`, String)\n(`GovernmentForm`, String)\n(`HeadOfState`, String)\n(`Capital`, Int64)\n(`Code2`, String)\n",
            "Table: `CountryLanguage`\nColumns:\n(`CountryCode`, String, primary key)\n(`Language`, String, primary key)\n(`IsOfficial`, String)\n(`Percentage`, Float64)\n"
        ]
    },
    {
        "sql_id": 560,
        "database_name": "world",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T2.Language = 'English', 1, 0)) AS REAL) * 100 / COUNT(T1.Code) FROM Country AS T1 INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE T1.GNP > 1500",
        "target_query": "SELECT SUM(if(T2.Language = 'English', 1, 0)) * 100 / COUNT(T1.`Code`) FROM `Country` AS T1 INNER JOIN `CountryLanguage` AS T2 ON T1.`Code` = T2.`CountryCode` WHERE T1.`GNP` > 1500;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 50,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 44,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Country`\nColumns:\n(`Code`, text, primary key)\n(`Name`, text)\n(`Continent`, text)\n(`Region`, text)\n(`SurfaceArea`, real)\n(`IndepYear`, integer)\n(`Population`, integer)\n(`LifeExpectancy`, real)\n(`GNP`, real)\n(`GNPOld`, real)\n(`LocalName`, text)\n(`GovernmentForm`, text)\n(`HeadOfState`, text)\n(`Capital`, integer)\n(`Code2`, text)\n",
            "Table: `CountryLanguage`\nColumns:\n(`CountryCode`, text, primary key)\n(`Language`, text, primary key)\n(`IsOfficial`, text)\n(`Percentage`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `Country`\nColumns:\n(`Code`, String, primary key)\n(`Name`, String)\n(`Continent`, String)\n(`Region`, String)\n(`SurfaceArea`, Float64)\n(`IndepYear`, Int64)\n(`Population`, Int64)\n(`LifeExpectancy`, Float64)\n(`GNP`, Float64)\n(`GNPOld`, Float64)\n(`LocalName`, String)\n(`GovernmentForm`, String)\n(`HeadOfState`, String)\n(`Capital`, Int64)\n(`Code2`, String)\n",
            "Table: `CountryLanguage`\nColumns:\n(`CountryCode`, String, primary key)\n(`Language`, String, primary key)\n(`IsOfficial`, String)\n(`Percentage`, Float64)\n"
        ]
    },
    {
        "sql_id": 561,
        "database_name": "world",
        "source_dialect": "sqlite",
        "target_dialect": "clickhouse",
        "source_query": "SELECT CAST(SUM(IIF(T2.Language = 'Chinese', T1.SurfaceArea, 0)) AS REAL) * 100 / SUM(T1.SurfaceArea) FROM Country AS T1 INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode",
        "target_query": "SELECT SUM(if(`T2`.`Language` = 'Chinese', `T1`.`SurfaceArea`, 0)) * 100 / SUM(`T1`.`SurfaceArea`) FROM `Country` AS `T1` INNER JOIN `CountryLanguage` AS `T2` ON `T1`.`Code` = `T2`.`CountryCode`;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_dialect_locations": [
            {
                "start_index": 16,
                "end_index": 63,
                "dialect_content": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "feature": "iif(X,Y,Z)"
            }
        ],
        "target_dialect_locations": [
            {
                "start_index": 11,
                "end_index": 65,
                "dialect_content": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "feature": "if(cond, then, else)"
            }
        ],
        "source_dialect_knowledge": [
            {
                "feature": "iif(X,Y,Z)",
                "explanation": "The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise.\n  The iif(X,Y,Z) function is logically equivalent to and generates the same\n  bytecode as the CASE expression \"CASE WHEN X THEN Y ELSE Z END\".\n",
                "examples": [
                    "SELECT iif(10 > 5, 'Yes', 'No'); -- Returns 'Yes'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "feature": "if(cond, then, else)",
                "explanation": "if\nPerforms conditional branching.\nIf the condition cond evaluates to a non-zero value, the function returns the result of the expression then. If cond evaluates to zero or NULL, then the result of the else expression is returned.\nSetting short_circuit_function_evaluation controls whether short-circuit evaluation is used. If enabled, the then expression is evaluated only on rows where cond is true and the else expression where cond is false. For example, with short-circuit evaluation, no division-by-zero exception is thrown when executing the query SELECT if(number = 0, 0, intDiv(42, number)) FROM numbers(10).\nthen and else must be of a similar type.\nSyntax\nif(cond, then, else)\nAlias: cond ? then : else (ternary operator)\nArguments\ncond – The evaluated condition. UInt8, Nullable(UInt8) or NULL.then – The expression returned if condition is true.else – The expression returned if condition is false or NULL.\nReturned values\nThe result of either the then and else expressions, depending on condition cond.",
                "examples": [
                    "SELECT if(1, plus(2, 2), plus(2, 6));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `Country`\nColumns:\n(`Code`, text, primary key)\n(`Name`, text)\n(`Continent`, text)\n(`Region`, text)\n(`SurfaceArea`, real)\n(`IndepYear`, integer)\n(`Population`, integer)\n(`LifeExpectancy`, real)\n(`GNP`, real)\n(`GNPOld`, real)\n(`LocalName`, text)\n(`GovernmentForm`, text)\n(`HeadOfState`, text)\n(`Capital`, integer)\n(`Code2`, text)\n",
            "Table: `CountryLanguage`\nColumns:\n(`CountryCode`, text, primary key)\n(`Language`, text, primary key)\n(`IsOfficial`, text)\n(`Percentage`, real)\n"
        ],
        "target_related_schemas": [
            "Table: `Country`\nColumns:\n(`Code`, String, primary key)\n(`Name`, String)\n(`Continent`, String)\n(`Region`, String)\n(`SurfaceArea`, Float64)\n(`IndepYear`, Int64)\n(`Population`, Int64)\n(`LifeExpectancy`, Float64)\n(`GNP`, Float64)\n(`GNPOld`, Float64)\n(`LocalName`, String)\n(`GovernmentForm`, String)\n(`HeadOfState`, String)\n(`Capital`, Int64)\n(`Code2`, String)\n",
            "Table: `CountryLanguage`\nColumns:\n(`CountryCode`, String, primary key)\n(`Language`, String, primary key)\n(`IsOfficial`, String)\n(`Percentage`, Float64)\n"
        ]
    }
]