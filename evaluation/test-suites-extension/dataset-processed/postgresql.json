[
    {
        "sql_id": "postgresql_1_6",
        "database_name": "postgresql_1_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT * FROM t0 WHERE (a, b) IN (ROW(1, 10)); -- ROW",
        "target_query": "SELECT * FROM t0 WHERE (a, b) IN (ROW(1, 10));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t0`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t0`\nColumns:\n(a, integer, )\n(b, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_1_7",
        "database_name": "postgresql_1_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT * FROM t0 WHERE (a, b) IN (VALUES ROW(1, 10), ROW(2, 20)); -- ROW",
        "target_query": "SELECT * FROM t0 WHERE (a, b) IN (ROW(1, 10), ROW(2, 20));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t0`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t0`\nColumns:\n(a, integer, )\n(b, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_1_8",
        "database_name": "postgresql_1_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT * FROM t0 WHERE (a, b) NOT IN (VALUES ROW(1, 10)); -- ROW",
        "target_query": "SELECT * FROM t0 WHERE (a, b) NOT IN (ROW(1, 10));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t0`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t0`\nColumns:\n(a, integer, )\n(b, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_1_9",
        "database_name": "postgresql_1_9",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT * FROM t0 WHERE (a, b) NOT IN (VALUES ROW(1, 10), ROW(2, 20)); -- ROW",
        "target_query": "SELECT * FROM t0 WHERE (a, b) NOT IN (ROW(1, 10), ROW(2, 20));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t0`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t0`\nColumns:\n(a, integer, )\n(b, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_100_2",
        "database_name": "postgresql_100_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 (ts) VALUES (Unix_timestamp('2002-10-27 01:00')); -- UNIX_TIMESTAMP",
        "target_query": "INSERT INTO t1 (ts) VALUES (EXTRACT(EPOCH FROM TIMESTAMP '2002-10-27 01:00:00'));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Extracts the number of seconds since the Unix epoch from a timestamp using the EPOCH keyword.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(ts, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(ts, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_100_3",
        "database_name": "postgresql_100_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 (ts) VALUES (Unix_timestamp('2002-10-27 02:00')); -- UNIX_TIMESTAMP",
        "target_query": "INSERT INTO t1 (ts) VALUES (EXTRACT(EPOCH FROM TIMESTAMP '2002-10-27 02:00:00'));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Extracts the number of seconds since the Unix epoch from a timestamp using the EPOCH keyword.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(ts, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(ts, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_100_4",
        "database_name": "postgresql_100_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 (ts) VALUES (Unix_timestamp('2002-10-27 03:00')); -- UNIX_TIMESTAMP",
        "target_query": "INSERT INTO t1 (ts) VALUES (EXTRACT(EPOCH FROM TIMESTAMP '2002-10-27 03:00:00'));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Extracts the number of seconds since the Unix epoch from a timestamp using the EPOCH keyword.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(ts, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(ts, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_100_5",
        "database_name": "postgresql_100_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT ts,from_unixtime(ts) FROM t1; -- FROM_UNIXTIME",
        "target_query": "SELECT ts, TO_TIMESTAMP(ts) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "FROM_UNIXTIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
                "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
                "examples": [
                    "SELECT FROM_UNIXTIME(1672531200);",
                    "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
                    "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP(unix_timestamp)",
                "description": "Converts a Unix timestamp (number of seconds since 1970-01-01 UTC) to a timestamp with time zone.",
                "examples": [
                    "SELECT TO_TIMESTAMP(1672531200);",
                    "SELECT TO_TIMESTAMP(1672531200.456);",
                    "SELECT id, TO_CHAR(TO_TIMESTAMP(created_at), 'YYYY-MM-DD') AS created_date FROM events;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(ts, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(ts, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_100_7",
        "database_name": "postgresql_100_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT TIMESTAMP( '2001-01-01 00:00:00' ); -- TIMESTAMP",
        "target_query": "SELECT TO_TIMESTAMP('2001-01-01 00:00:00', 'YYYY-MM-DD HH24:MI:SSOF');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
                "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
                "examples": [
                    "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP('2023-06-15 10:30:45', 'YYYY-MM-DD HH24:MI:SS')",
                "description": "In PostgreSQL, TO_TIMESTAMP is used to convert a date-time string to a TIMESTAMP value, supporting both with and without timezone.",
                "examples": [
                    "SELECT TO_TIMESTAMP('2023-06-15 10:30:45', 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT TO_TIMESTAMP('2023-06-15 10:30:45+02:00', 'YYYY-MM-DD HH24:MI:SSOF');",
                    "SELECT TO_TIMESTAMP('2023-06-15 10:30:45', 'YYYY-MM-DD HH24:MI:SS') > TO_TIMESTAMP('2023-06-14 10:30:45', 'YYYY-MM-DD HH24:MI:SS');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_100_8",
        "database_name": "postgresql_100_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT TO_DAYS( '2001-01-01 00:00:00' ); -- TO_DAYS",
        "target_query": "SELECT (DATE '2001-01-01' - DATE '1970-01-01')::int + 719528;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TO_DAYS"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TO_DAYS(date)",
                "description": "Returns the number of days since 0000-01-01 for a given date.",
                "examples": [
                    "SELECT TO_DAYS('2024-05-07');",
                    "SELECT TO_DAYS(CURDATE());",
                    "SELECT TO_DAYS('1999-12-31 23:59:59');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "(date - DATE '1970-01-01')::int + 719528",
                "description": "Computes the number of days since 0000-01-01 by offsetting from 1970-01-01.",
                "examples": [
                    "SELECT (DATE '2024-05-07' - DATE '1970-01-01')::int + 719528;",
                    "SELECT (CURRENT_DATE - DATE '1970-01-01')::int + 719528;",
                    "SELECT (DATE '1999-12-31' - DATE '1970-01-01')::int + 719528;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_100_9",
        "database_name": "postgresql_100_9",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT TO_DAYS( '2001-01-01 00:00:00' ); -- TO_DAYS",
        "target_query": "SELECT (DATE '2001-01-01' - DATE '1970-01-01')::int + 719528;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TO_DAYS"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TO_DAYS(date)",
                "description": "Returns the number of days since 0000-01-01 for a given date.",
                "examples": [
                    "SELECT TO_DAYS('2024-05-07');",
                    "SELECT TO_DAYS(CURDATE());",
                    "SELECT TO_DAYS('1999-12-31 23:59:59');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "(date - DATE '1970-01-01')::int + 719528",
                "description": "Computes the number of days since 0000-01-01 by offsetting from 1970-01-01.",
                "examples": [
                    "SELECT (DATE '2024-05-07' - DATE '1970-01-01')::int + 719528;",
                    "SELECT (CURRENT_DATE - DATE '1970-01-01')::int + 719528;",
                    "SELECT (DATE '1999-12-31' - DATE '1970-01-01')::int + 719528;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_100_10",
        "database_name": "postgresql_100_10",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT DATEDIFF( '2007-12-31 23:59:59', '2007-12-30  00:00:00' ); -- DATEDIFF",
        "target_query": "SELECT EXTRACT(DAY FROM AGE('2007-12-31 23:59:59', '2007-12-30 00:00:00'));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATEDIFF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATEDIFF(date1, date2)",
                "description": "Returns the number of days between two date or datetime expressions (date1 - date2), ignoring time part.",
                "examples": [
                    "SELECT DATEDIFF('2025-12-31', '2025-12-01');",
                    "SELECT DATEDIFF('2025-01-01', '2024-12-31');",
                    "SELECT DATEDIFF(NULL, '2025-01-01');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(DAY FROM DATE date1) - EXTRACT(DAY FROM DATE date2)",
                "description": "Calculates the number of days between two date. This is achieved by extracting the day component from the dates and subtracting the results.",
                "examples": [
                    "SELECT EXTRACT(DAY FROM DATE '2025-12-31') - EXTRACT(DAY FROM DATE '2025-12-01');",
                    "SELECT EXTRACT(DAY FROM DATE '2025-01-01') - EXTRACT(DAY FROM DATE '2024-12-31');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_100_11",
        "database_name": "postgresql_100_11",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT TIMEDIFF( '2000:01:01 00:00:00','2000:01:01 00:00:00' ); -- TIMEDIFF",
        "target_query": "SELECT (TIMESTAMP '2000-01-01 00:00:00' - TIMESTAMP '2000-01-01 00:00:00')::TIME;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIMEDIFF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMEDIFF('12:00:00', '10:00:00')",
                "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
                "examples": [
                    "SELECT TIMEDIFF('12:00:00', '10:00:00');",
                    "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
                    "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "(timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::TIME",
                "description": "PostgreSQL does not have a direct TIMEDIFF function, but time differences can be calculated by subtracting one timestamp from another and casting the result to a TIME.",
                "examples": [
                    "SELECT (timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::TIME;",
                    "SELECT (NOW() - timestamp '2023-06-15 10:00:00')::INTERVAL;",
                    "SELECT (timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::INTERVAL;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_100_12",
        "database_name": "postgresql_100_12",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT DATE_FORMAT( '2009-10-10 23:59:59', '%W %M %Y' ); -- DATE_FORMAT",
        "target_query": "SELECT TO_CHAR(TIMESTAMP '2009-10-10 23:59:59', 'FMDay FMMonth YYYY');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE_FORMAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(date_expr, format_str)",
                "description": "Formats a date/time value according to a format string using PostgreSQL-style specifiers.",
                "examples": [
                    "SELECT TO_CHAR(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT TO_CHAR(DATE '2023-01-15', 'DD-MM-YYYY');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_100_13",
        "database_name": "postgresql_100_13",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT TIME( '2003-12-31 23:59:59' ); -- TIME",
        "target_query": "SELECT TO_CHAR(TIMESTAMP '2003-12-31 23:59:59', 'HH24:MI:SS');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
                "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
                "examples": [
                    "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
                    "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
                    "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(time_expr, 'HH24:MI:SS')",
                "description": "In PostgreSQL, the time() function does not support SQLite-style modifiers directly within a function call. To modify time values, PostgreSQL uses the INTERVAL type for time adjustments, and the TO_CHAR function for formatting. The time expression returns the time formatted as 'HH:MI:SS'. Milliseconds can be included using 'SS.US' in the format string.",
                "examples": [
                    "SELECT TO_CHAR(NOW()::time, 'HH24:MI:SS'); -- Returns the current time formatted as 'HH:MM:SS'.",
                    "SELECT TO_CHAR(NOW()::time + INTERVAL '1 hour', 'HH24:MI:SS'); -- Returns the time one hour after the current time.",
                    "SELECT TO_CHAR('14:16:00'::time + INTERVAL '0.123 second', 'HH24:MI:SS.US'); -- Returns '14:16:00.123' with milliseconds."
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_100_14",
        "database_name": "postgresql_100_14",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT TIMESTAMP( '2003-12-31 23:59:59', '12:00:00' ); -- TIMESTAMP",
        "target_query": "SELECT TO_TIMESTAMP('2003-12-31 23:59:59', 'YYYY-MM-DD HH24:MI:SS') + INTERVAL '12 hours';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
                "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
                "examples": [
                    "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP('2023-06-15 10:30:45', 'YYYY-MM-DD HH24:MI:SS')",
                "description": "In PostgreSQL, TO_TIMESTAMP is used to convert a date-time string to a TIMESTAMP value, supporting both with and without timezone.",
                "examples": [
                    "SELECT TO_TIMESTAMP('2023-06-15 10:30:45', 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT TO_TIMESTAMP('2023-06-15 10:30:45+02:00', 'YYYY-MM-DD HH24:MI:SSOF');",
                    "SELECT TO_TIMESTAMP('2023-06-15 10:30:45', 'YYYY-MM-DD HH24:MI:SS') > TO_TIMESTAMP('2023-06-14 10:30:45', 'YYYY-MM-DD HH24:MI:SS');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_100_15",
        "database_name": "postgresql_100_15",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT TIMESTAMPADD(MINUTE, 1, '2003-01-02 23:59:59' ); -- TIMESTAMPADD",
        "target_query": "SELECT TIMESTAMP '2003-01-02 23:59:59' + INTERVAL '1 minute';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIMESTAMPADD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMESTAMPADD(unit, interval, datetime_expr)",
                "description": "Adds a time interval to a date or timestamp expression using the specified unit.",
                "examples": [
                    "SELECT TIMESTAMPADD(DAY, 2, '2023-01-01');",
                    "SELECT TIMESTAMPADD(MINUTE, -5, '2023-05-10 12:00:00');",
                    "SELECT TIMESTAMPADD(YEAR, 1, '2020-06-15');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "datetime_expr + INTERVAL 'n unit'",
                "description": "Adds a time interval to a timestamp or date using SQL standard INTERVAL syntax.",
                "examples": [
                    "SELECT DATE '2023-01-01' + INTERVAL '2 day';",
                    "SELECT TIMESTAMP '2023-05-10 12:00:00' + INTERVAL '-5 minute';",
                    "SELECT DATE '2020-06-15' + INTERVAL '1 year';"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_100_16",
        "database_name": "postgresql_100_16",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT TIMESTAMPDIFF(MONTH, '2003-02-01 23:59:59', '2003-05-01' ); -- TIMESTAMPDIFF",
        "target_query": "SELECT EXTRACT(MONTH FROM AGE('2003-05-01', '2003-02-01 23:59:59'));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIMESTAMPDIFF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMESTAMPDIFF(unit, datetime1, datetime2)",
                "description": "Returns the difference between two datetime values in the specified unit.",
                "examples": [
                    "SELECT TIMESTAMPDIFF(YEAR, '2001-01-01', '2005-01-01');  -- 4",
                    "SELECT TIMESTAMPDIFF(MONTH, '2020-01-01', '2020-03-01');  -- 2",
                    "SELECT TIMESTAMPDIFF(DAY, '2020-01-01', '2020-01-31');    -- 30"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(unit FROM AGE(datetime2, datetime1))",
                "description": "The AGE function in PostgreSQL returns the interval between two dates or timestamps. The order of arguments is reversed compared to other DBMSs, meaning the earlier date comes second in the AGE function. You can extract the difference in years, months, days, etc. from the interval.",
                "examples": [
                    "SELECT EXTRACT(YEAR FROM AGE('2005-01-01', '2001-01-01'));  -- 4",
                    "SELECT EXTRACT(MONTH FROM AGE('2020-03-01', '2020-01-01'));  -- 2",
                    "SELECT EXTRACT(DAY FROM AGE('2020-01-31', '2020-01-01'));    -- 30"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_100_17",
        "database_name": "postgresql_100_17",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT TO_SECONDS( '2009-11-29 23:59:59' ); -- TO_SECONDS",
        "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2009-11-29 23:59:59') + 62167219200;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TO_SECONDS"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TO_SECONDS(datetime_expr)",
                "description": "Returns the number of seconds since year 0 to the given datetime.",
                "examples": [
                    "SELECT TO_SECONDS('2000-01-01 00:00:00');",
                    "SELECT TO_SECONDS(NOW());",
                    "SELECT TO_SECONDS(NULL);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM ts) + 62167219200",
                "description": "Adds the number of seconds since year 1970 to the seconds between year 0 and 1970 to simulate TO_SECONDS.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2020-12-31 12:00:00') + 62167219200;",
                    "SELECT EXTRACT(EPOCH FROM NOW()) + 62167219200;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_100_18",
        "database_name": "postgresql_100_18",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT UNIX_TIMESTAMP( '2015-11-13 23:59:59' ); -- UNIX_TIMESTAMP",
        "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Extracts the number of seconds since the Unix epoch from a timestamp using the EPOCH keyword.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_101_3",
        "database_name": "postgresql_101_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select hex(s1) from t1; -- HEX",
        "target_query": "select encode(s1, 'hex') from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(s1, blob, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(s1, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_101_7",
        "database_name": "postgresql_101_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select length(concat('*',s1,'*',s2,'*')) from t1; -- LENGTH, CONCAT",
        "target_query": "select octet_length('*' || s1 || '*' || s2 || '*') from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH",
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            },
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            },
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(s1, blob, )\n(s2, blob, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(s1, bytea, )\n(s2, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_101_11",
        "database_name": "postgresql_101_11",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select hex(s1),s2 from t1 order by s1,s2; -- HEX",
        "target_query": "select encode(s1, 'hex'), s2 from t1 order by s1, s2;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(s1, blob, )\n(s2, varchar(1), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(s1, bytea, )\n(s2, character varying(1), )\n"
        ]
    },
    {
        "sql_id": "postgresql_101_12",
        "database_name": "postgresql_101_12",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select convert(123456789,unsigned); -- CONVERT",
        "target_query": "select CAST(123456789 AS bigint);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONVERT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONVERT(expression USING charset)",
                "description": "Converts data types or changes the character set.",
                "examples": [
                    "SELECT CONVERT('Hello World' USING utf8);",
                    "SELECT CONVERT(1234, CHAR);",
                    "SELECT CONVERT(column_name USING latin1) FROM my_table;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CAST(expression AS target_type)",
                "description": "PostgreSQL uses CAST for type conversion. No direct equivalent for CONVERT TO CHARACTER SET.",
                "examples": [
                    "SELECT CAST('Hello World' AS TEXT);",
                    "SELECT CAST(1234 AS TEXT);",
                    "SELECT column_name::TEXT FROM my_table;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(s1, blob, )\n(s2, varchar(1), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(s1, bytea, )\n(s2, character varying(1), )\n"
        ]
    },
    {
        "sql_id": "postgresql_102_2",
        "database_name": "postgresql_102_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 VALUES (DATE(NOW()), 1); -- DATE, NOW",
        "target_query": "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP::DATE, 1);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE",
            "NOW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE()",
                "description": "In MySQL, the DATE function extracts the date part from a DATETIME or TIMESTAMP value.",
                "examples": [
                    "SELECT DATE('2023-05-01 12:34:56') AS result;",
                    "SELECT DATE(NOW()) AS current_date_result;",
                    "SELECT DATE(CAST('2023-05-01' AS DATETIME)) AS date_from_datetime;"
                ]
            },
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CAST()",
                "description": "In PostgreSQL, the DATE type can be cast directly from a DATETIME or TIMESTAMP using CAST.",
                "examples": [
                    "SELECT '2023-05-01 12:34:56'::DATE AS result;",
                    "SELECT CURRENT_DATE AS current_date_result;",
                    "SELECT CAST('2023-05-01' AS DATE) AS date_from_datetime;"
                ]
            },
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "In PostgreSQL, CURRENT_TIMESTAMP is used to retrieve the current date and time, equivalent to NOW() in MySQL and MariaDB.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, date, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, date, )\n(b, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_102_3",
        "database_name": "postgresql_102_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT COUNT(*) FROM t1 WHERE a = NOW(); -- COUNT, NOW",
        "target_query": "SELECT COUNT(*) FROM t1 WHERE a = CURRENT_TIMESTAMP;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "COUNT",
            "NOW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COUNT()",
                "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
                "examples": [
                    "EXPLAIN FORMAT=TREE SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
                    "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
                    "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
                ]
            },
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COUNT()",
                "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
                "examples": [
                    "EXPLAIN SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
                    "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
                    "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
                ]
            },
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "In PostgreSQL, CURRENT_TIMESTAMP is used to retrieve the current date and time, equivalent to NOW() in MySQL and MariaDB.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, date, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, date, )\n(b, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_102_4",
        "database_name": "postgresql_102_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 VALUES (DATE(NOW()), 2); -- DATE, NOW",
        "target_query": "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP::DATE, 2);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE",
            "NOW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE()",
                "description": "In MySQL, the DATE function extracts the date part from a DATETIME or TIMESTAMP value.",
                "examples": [
                    "SELECT DATE('2023-05-01 12:34:56') AS result;",
                    "SELECT DATE(NOW()) AS current_date_result;",
                    "SELECT DATE(CAST('2023-05-01' AS DATETIME)) AS date_from_datetime;"
                ]
            },
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CAST()",
                "description": "In PostgreSQL, the DATE type can be cast directly from a DATETIME or TIMESTAMP using CAST.",
                "examples": [
                    "SELECT '2023-05-01 12:34:56'::DATE AS result;",
                    "SELECT CURRENT_DATE AS current_date_result;",
                    "SELECT CAST('2023-05-01' AS DATE) AS date_from_datetime;"
                ]
            },
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "In PostgreSQL, CURRENT_TIMESTAMP is used to retrieve the current date and time, equivalent to NOW() in MySQL and MariaDB.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, date, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, date, )\n(b, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_102_5",
        "database_name": "postgresql_102_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT COUNT(*) FROM t1 WHERE a = NOW(); -- COUNT, NOW",
        "target_query": "SELECT COUNT(*) FROM t1 WHERE a = CURRENT_TIMESTAMP;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "COUNT",
            "NOW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COUNT()",
                "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
                "examples": [
                    "EXPLAIN FORMAT=TREE SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
                    "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
                    "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
                ]
            },
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COUNT()",
                "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
                "examples": [
                    "EXPLAIN SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
                    "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
                    "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
                ]
            },
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "In PostgreSQL, CURRENT_TIMESTAMP is used to retrieve the current date and time, equivalent to NOW() in MySQL and MariaDB.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, date, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, date, )\n(b, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_102_6",
        "database_name": "postgresql_102_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT COUNT(*) FROM t1 WHERE a = NOW() AND b = 1; -- COUNT, NOW",
        "target_query": "SELECT COUNT(*) FROM t1 WHERE a = CURRENT_TIMESTAMP AND b = 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "COUNT",
            "NOW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COUNT()",
                "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
                "examples": [
                    "EXPLAIN FORMAT=TREE SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
                    "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
                    "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
                ]
            },
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COUNT()",
                "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
                "examples": [
                    "EXPLAIN SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
                    "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
                    "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
                ]
            },
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "In PostgreSQL, CURRENT_TIMESTAMP is used to retrieve the current date and time, equivalent to NOW() in MySQL and MariaDB.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, date, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, date, )\n(b, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_102_8",
        "database_name": "postgresql_102_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "CREATE TABLE t1 SELECT curdate() AS f1; -- CURDATE",
        "target_query": "CREATE TABLE t1 AS SELECT CURRENT_DATE AS f1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CURDATE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CURDATE()",
                "description": "Returns the current date without the time component.",
                "examples": [
                    "SELECT CURDATE();",
                    "SELECT CONCAT('Today\\'s date is: ', CURDATE());",
                    "SELECT 1 WHERE CURDATE() = CURDATE();"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CURRENT_DATE",
                "description": "Returns the current date without the time component, equivalent to MySQL's CURDATE().",
                "examples": [
                    "SELECT CURRENT_DATE;",
                    "SELECT CONCAT('Today''s date is: ', CURRENT_DATE);",
                    "SELECT 1 WHERE CURRENT_DATE = CURRENT_DATE;"
                ]
            }
        ],
        "source_related_schemas": [
            "CREATE TABLE t1 SELECT curdate() AS f1; -- CURDATE"
        ],
        "target_related_schemas": [
            "CREATE TABLE t1 AS SELECT CURRENT_DATE AS f1;"
        ]
    },
    {
        "sql_id": "postgresql_102_18",
        "database_name": "postgresql_102_18",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT 1 FROM (SELECT MAKEDATE(2011,0)) a; -- MAKEDATE",
        "target_query": "SELECT 1 FROM (SELECT make_date(2011, 1, 1) + (0 - 1) * INTERVAL '1 day') a;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MAKEDATE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MAKEDATE(year, day_of_year)",
                "description": "Returns a date from the given year and day of the year.",
                "examples": [
                    "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
                    "SELECT MAKEDATE(2025, 100) AS specific_date;",
                    "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "make_date(year, 1, 1) + (day_of_year - 1) * INTERVAL '1 day'",
                "description": "Returns a date from the given year and day of the year, created by adding intervals.",
                "examples": [
                    "SELECT make_date(2009, 1, 1) + (1 - 1) * INTERVAL '1 day' AS first_day_of_year;",
                    "SELECT make_date(2025, 1, 1) + (100 - 1) * INTERVAL '1 day' AS specific_date;",
                    "SELECT make_date(2020, 1, 1) + (366 - 1) * INTERVAL '1 day' AS last_day_of_year;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_2_2",
        "database_name": "postgresql_2_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "WITH recursive qn as (select 1 as n, cast('x' as char(100)) as un union all select 1+n, concat(un,'x') from qn where n<10) select * from qn; -- CONCAT",
        "target_query": "WITH RECURSIVE qn AS (SELECT 1 AS n, CAST('x' AS varchar(100)) AS un UNION ALL SELECT 1 + n, (un || 'x')::varchar(100) FROM qn WHERE n < 10) SELECT * FROM qn;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t`\nColumns:\n(c, char(3), )\n(vc, varchar(3), )\n(b, binary(3), )\n(vb, varbinary(3), )\n"
        ],
        "target_related_schemas": [
            "Table: `t`\nColumns:\n(c, character(3), )\n(vc, character varying(3), )\n(b, bytea, )\n(vb, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_3_2",
        "database_name": "postgresql_3_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT IF (COUNT(*) > 0, \"YES\", \"NO\") AS \"IMPLICIT COMMIT\" FROM trans; -- IF",
        "target_query": "SELECT CASE WHEN COUNT(*) > 0 THEN 'YES' ELSE 'NO' END AS \"IMPLICIT COMMIT\" FROM trans;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "In PostgreSQL, `IF` is not directly supported. Instead, the `CASE WHEN` expression is used to evaluate a condition and return different values based on whether the condition is true or false.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `trans`\nColumns:\n(a, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `trans`\nColumns:\n(a, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_39_3",
        "database_name": "postgresql_39_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT IF( a = 1, a, a ) AS b FROM t1 ORDER BY field( b + 1, 1 ); -- IF, FIELD",
        "target_query": "SELECT * FROM (SELECT CASE WHEN a = 1 THEN a ELSE a END AS b FROM t1) AS sub ORDER BY COALESCE(array_position(ARRAY[1], b + 1), 0);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF",
            "FIELD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            },
            {
                "expression": "FIELD(val, val1, val2, ..., valN)",
                "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
                "examples": [
                    "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
                    "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
                    "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "In PostgreSQL, `IF` is not directly supported. Instead, the `CASE WHEN` expression is used to evaluate a condition and return different values based on whether the condition is true or false.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            },
            {
                "expression": "COALESCE(array_position(ARRAY[val1, val2, ..., valN], val), 0)",
                "description": "Returns the index (1-based) of 'val' in the array. Returns 0 if not found, to match MySQL FIELD() behavior.",
                "examples": [
                    "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'c'), 0) AS result;",
                    "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'x'), 0) AS result;",
                    "SELECT COALESCE(array_position(ARRAY['b', 'b', 'b'], 'b'), 0) AS result;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_39_4",
        "database_name": "postgresql_39_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT IF( a = 1, a, a ) AS b FROM t1 ORDER BY field( b, 1 ); -- IF, FIELD",
        "target_query": "SELECT * FROM (SELECT CASE WHEN a = 1 THEN a ELSE a END AS b FROM t1) AS sub ORDER BY COALESCE(array_position(ARRAY[1], b), 0);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF",
            "FIELD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            },
            {
                "expression": "FIELD(val, val1, val2, ..., valN)",
                "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
                "examples": [
                    "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
                    "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
                    "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "In PostgreSQL, `IF` is not directly supported. Instead, the `CASE WHEN` expression is used to evaluate a condition and return different values based on whether the condition is true or false.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            },
            {
                "expression": "COALESCE(array_position(ARRAY[val1, val2, ..., valN], val), 0)",
                "description": "Returns the index (1-based) of 'val' in the array. Returns 0 if not found, to match MySQL FIELD() behavior.",
                "examples": [
                    "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'c'), 0) AS result;",
                    "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'x'), 0) AS result;",
                    "SELECT COALESCE(array_position(ARRAY['b', 'b', 'b'], 'b'), 0) AS result;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_4_4",
        "database_name": "postgresql_4_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775807 AND TRIM(a) = b; -- TRIM",
        "target_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775807 AND TRIM(a::TEXT) = b;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TRIM"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "The TRIM function works in the same way as MySQL, removing unwanted characters from the string. If no character is specified, spaces are removed by default.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(id, int, PRI)\n(a, bigint unsigned, )\n(b, varchar(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(id, integer, PRI)\n(a, numeric(20,0), )\n(b, character varying(20), )\n"
        ]
    },
    {
        "sql_id": "postgresql_4_5",
        "database_name": "postgresql_4_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775806 AND TRIM(a) = b; -- TRIM",
        "target_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775806 AND TRIM(a::TEXT) = b;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TRIM"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "The TRIM function works in the same way as MySQL, removing unwanted characters from the string. If no character is specified, spaces are removed by default.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(id, int, PRI)\n(a, bigint unsigned, )\n(b, varchar(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(id, integer, PRI)\n(a, numeric(20,0), )\n(b, character varying(20), )\n"
        ]
    },
    {
        "sql_id": "postgresql_4_6",
        "database_name": "postgresql_4_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775805 AND TRIM(a) = b; -- TRIM",
        "target_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775805 AND TRIM(a::TEXT) = b;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TRIM"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "The TRIM function works in the same way as MySQL, removing unwanted characters from the string. If no character is specified, spaces are removed by default.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(id, int, PRI)\n(a, bigint unsigned, )\n(b, varchar(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(id, integer, PRI)\n(a, numeric(20,0), )\n(b, character varying(20), )\n"
        ]
    },
    {
        "sql_id": "postgresql_4_7",
        "database_name": "postgresql_4_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 0 AND TRIM(a) = b; -- TRIM",
        "target_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 0 AND TRIM(a::TEXT) = b;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TRIM"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "The TRIM function works in the same way as MySQL, removing unwanted characters from the string. If no character is specified, spaces are removed by default.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(id, int, PRI)\n(a, bigint unsigned, )\n(b, varchar(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(id, integer, PRI)\n(a, numeric(20,0), )\n(b, character varying(20), )\n"
        ]
    },
    {
        "sql_id": "postgresql_4_11",
        "database_name": "postgresql_4_11",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT * FROM t1 WHERE coalesce(a) BETWEEN 0 and 0.9; -- COALESCE",
        "target_query": "SELECT * FROM t1 WHERE COALESCE(a) BETWEEN 0 AND 0.9;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "COALESCE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
                "description": "Returns the first non-NULL value, or merges table partitions.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
                    "ALTER TABLE t1 COALESCE PARTITION 2;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...)",
                "description": "Standard SQL COALESCE function for NULL-handling.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bigint, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bigint, )\n"
        ]
    },
    {
        "sql_id": "postgresql_4_12",
        "database_name": "postgresql_4_12",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT * FROM t1 WHERE coalesce(a)=0.9; -- COALESCE",
        "target_query": "SELECT * FROM t1 WHERE COALESCE(a) = 0.9;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "COALESCE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
                "description": "Returns the first non-NULL value, or merges table partitions.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
                    "ALTER TABLE t1 COALESCE PARTITION 2;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...)",
                "description": "Standard SQL COALESCE function for NULL-handling.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bigint, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bigint, )\n"
        ]
    },
    {
        "sql_id": "postgresql_4_13",
        "database_name": "postgresql_4_13",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT * FROM t1 WHERE coalesce(a) in (0.8,0.9); -- COALESCE",
        "target_query": "SELECT * FROM t1 WHERE COALESCE(a) IN (0.8, 0.9);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "COALESCE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
                "description": "Returns the first non-NULL value, or merges table partitions.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
                    "ALTER TABLE t1 COALESCE PARTITION 2;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...)",
                "description": "Standard SQL COALESCE function for NULL-handling.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bigint, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bigint, )\n"
        ]
    },
    {
        "sql_id": "postgresql_5_6",
        "database_name": "postgresql_5_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT USER(); -- USER",
        "target_query": "SELECT CURRENT_USER; -- USER",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "USER"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "USER()",
                "description": "Returns the current MySQL user and host in the format 'username@hostname'.",
                "examples": [
                    "SELECT USER();"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CURRENT_USER",
                "description": "Returns the current user executing the query. Similar to MySQL's USER().",
                "examples": [
                    "SELECT CURRENT_USER;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_6_3",
        "database_name": "postgresql_6_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT HEX(c1) FROM t1; -- HEX",
        "target_query": "SELECT encode(c1::bytea, 'hex') FROM t1; -- HEX",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, char(4), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_6_5",
        "database_name": "postgresql_6_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "CREATE TABLE t1 SELECT repeat('a',4000) a; -- REPEAT",
        "target_query": "CREATE TABLE t1 AS SELECT repeat('a', 4000) a; -- REPEAT",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "CREATE TABLE t1 SELECT repeat('a',4000) a; -- REPEAT"
        ],
        "target_related_schemas": [
            "CREATE TABLE t1 AS SELECT repeat('a', 4000) a; -- REPEAT"
        ]
    },
    {
        "sql_id": "postgresql_6_12",
        "database_name": "postgresql_6_12",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT",
        "target_query": "CREATE TABLE head AS SELECT b1.b || b2.b AS head FROM t1 b1, t1 b2; -- CONCAT",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(b, varchar(2), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(b, character varying(2), )\n"
        ]
    },
    {
        "sql_id": "postgresql_6_13",
        "database_name": "postgresql_6_13",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "CREATE TABLE tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2; -- CONCAT",
        "target_query": "CREATE TABLE tail AS SELECT b1.b || b2.b AS tail FROM t1 b1, t1 b2; -- CONCAT",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `head`\nColumns:\n(head, varchar(4), )\n",
            "Table: `t1`\nColumns:\n(b, varchar(2), )\n"
        ],
        "target_related_schemas": [
            "Table: `head`\nColumns:\n(head, text, )\n",
            "Table: `t1`\nColumns:\n(b, character varying(2), )\n"
        ]
    },
    {
        "sql_id": "postgresql_6_18",
        "database_name": "postgresql_6_18",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "UPDATE IGNORE t1 SET a=unhex(code); -- UNHEX",
        "target_query": "UPDATE t1 SET a = decode(code, 'hex') WHERE a <> ''; -- UNHEX",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNHEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNHEX(str)",
                "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
                "examples": [
                    "SELECT HEX(UNHEX('4D7953514C'));",
                    "SELECT UNHEX('48656C6C6F');",
                    "SELECT UNHEX(NULL);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "decode(str, 'hex')",
                "description": "Decodes a hexadecimal string into binary (bytea) using the decode function.",
                "examples": [
                    "SELECT encode(decode('4D7953514C', 'hex'), 'hex');",
                    "SELECT decode('48656C6C6F', 'hex');",
                    "SELECT decode(NULL, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(code, varchar(6), )\n(a, varchar(1), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(code, text, )\n(a, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_6_19",
        "database_name": "postgresql_6_19",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT COUNT(*) FROM t1 WHERE a<>'' AND OCTET_LENGTH(a)=2; -- OCTET_LENGTH",
        "target_query": "SELECT COUNT(*) FROM t1 WHERE a <> '' AND OCTET_LENGTH(a) = 2; -- OCTET_LENGTH",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "OCTET_LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "OCTET_LENGTH()",
                "description": "Returns the number of bytes in a string.",
                "examples": [
                    "SELECT OCTET_LENGTH('Hello World');",
                    "SELECT OCTET_LENGTH('Test String') = 11;",
                    "SELECT CASE WHEN OCTET_LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "OCTET_LENGTH()",
                "description": "Returns the number of bytes in a string.",
                "examples": [
                    "SELECT OCTET_LENGTH('Hello World');",
                    "SELECT OCTET_LENGTH('Test String') = 11;",
                    "SELECT CASE WHEN OCTET_LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(code, varchar(6), )\n(a, varchar(1), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(code, text, )\n(a, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_6_20",
        "database_name": "postgresql_6_20",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT * FROM t1 WHERE CHAR_LENGTH(a)=2; -- CHAR_LENGTH",
        "target_query": "SELECT * FROM t1 WHERE CHAR_LENGTH(a) = 2; -- CHAR_LENGTH",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CHAR_LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CHAR_LENGTH(expr)",
                "description": "Returns the number of characters in the string, not bytes.",
                "examples": [
                    "SELECT CHAR_LENGTH('abc');",
                    "SELECT CHAR_LENGTH('\u4f60\u597d');",
                    "SELECT CHAR_LENGTH('a\u4f60b\u597dc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CHAR_LENGTH(expr)",
                "description": "Returns the number of characters in a string.",
                "examples": [
                    "SELECT CHAR_LENGTH('abc');",
                    "SELECT CHAR_LENGTH('\u4f60\u597d');",
                    "SELECT CHAR_LENGTH('a\u4f60b\u597dc');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(code, varchar(6), )\n(a, varchar(1), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(code, text, )\n(a, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_6_21",
        "database_name": "postgresql_6_21",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT COUNT(*) FROM t1 WHERE a<>'' AND OCTET_LENGTH(a)=3; -- OCTET_LENGTH",
        "target_query": "SELECT COUNT(*) FROM t1 WHERE a <> '' AND OCTET_LENGTH(a) = 3; -- OCTET_LENGTH",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "OCTET_LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "OCTET_LENGTH()",
                "description": "Returns the number of bytes in a string.",
                "examples": [
                    "SELECT OCTET_LENGTH('Hello World');",
                    "SELECT OCTET_LENGTH('Test String') = 11;",
                    "SELECT CASE WHEN OCTET_LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "OCTET_LENGTH()",
                "description": "Returns the number of bytes in a string.",
                "examples": [
                    "SELECT OCTET_LENGTH('Hello World');",
                    "SELECT OCTET_LENGTH('Test String') = 11;",
                    "SELECT CASE WHEN OCTET_LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(code, varchar(6), )\n(a, varchar(1), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(code, text, )\n(a, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_7_4",
        "database_name": "postgresql_7_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT c1, LENGTH(c1) FROM h; -- LENGTH",
        "target_query": "SELECT c1, octet_length(c1) FROM h; -- LENGTH",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `h`\nColumns:\n(c1, char(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `h`\nColumns:\n(c1, character(20), )\n"
        ]
    },
    {
        "sql_id": "postgresql_7_5",
        "database_name": "postgresql_7_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT c1, LPAD(c1, 20, ' ') FROM h; -- LPAD",
        "target_query": "SELECT c1, LPAD(c1, 20, ' ') FROM h; -- LPAD",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached, just like in MySQL.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `h`\nColumns:\n(c1, char(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `h`\nColumns:\n(c1, character(20), )\n"
        ]
    },
    {
        "sql_id": "postgresql_7_6",
        "database_name": "postgresql_7_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT c1, RPAD(c1, 20, '52') FROM h; -- RPAD",
        "target_query": "SELECT c1, RPAD(c1, 20, '52') FROM h; -- RPAD",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "PostgreSQL doesn't have a native RPAD, but can simulate it.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::text, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `h`\nColumns:\n(c1, char(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `h`\nColumns:\n(c1, character(20), )\n"
        ]
    },
    {
        "sql_id": "postgresql_7_9",
        "database_name": "postgresql_7_9",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT INSTR(c1, 'h') FROM h; -- INSTR",
        "target_query": "SELECT POSITION('h' in c1) FROM h; -- INSTR",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "INSTR(str, substr)",
                "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
                "examples": [
                    "SELECT INSTR('foobar', 'bar');  -- Returns 4",
                    "SELECT INSTR('foobar', 'baz');  -- Returns 0",
                    "SELECT INSTR('foobar', '');     -- Returns 1",
                    "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION(substr IN str)",
                "description": "Returns the 1-based index of substr in str. Returns 0 if not found. NULL if either argument is NULL.",
                "examples": [
                    "SELECT POSITION('bar' IN 'foobar');   -- Returns 4",
                    "SELECT POSITION('x' IN 'abc');        -- Returns 0"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `h`\nColumns:\n(c1, char(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `h`\nColumns:\n(c1, character(20), )\n"
        ]
    },
    {
        "sql_id": "postgresql_7_10",
        "database_name": "postgresql_7_10",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT INSTR(c1, '') FROM h; -- INSTR",
        "target_query": "SELECT POSITION('' in c1) FROM h; -- INSTR",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "INSTR(str, substr)",
                "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
                "examples": [
                    "SELECT INSTR('foobar', 'bar');  -- Returns 4",
                    "SELECT INSTR('foobar', 'baz');  -- Returns 0",
                    "SELECT INSTR('foobar', '');     -- Returns 1",
                    "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION(substr IN str)",
                "description": "Returns the 1-based index of substr in str. Returns 0 if not found. NULL if either argument is NULL.",
                "examples": [
                    "SELECT POSITION('bar' IN 'foobar');   -- Returns 4",
                    "SELECT POSITION('x' IN 'abc');        -- Returns 0"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `h`\nColumns:\n(c1, char(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `h`\nColumns:\n(c1, character(20), )\n"
        ]
    },
    {
        "sql_id": "postgresql_7_11",
        "database_name": "postgresql_7_11",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT INSTR(c1, '52') FROM h; -- INSTR",
        "target_query": "SELECT POSITION('52' in c1) FROM h; -- INSTR",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "INSTR(str, substr)",
                "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
                "examples": [
                    "SELECT INSTR('foobar', 'bar');  -- Returns 4",
                    "SELECT INSTR('foobar', 'baz');  -- Returns 0",
                    "SELECT INSTR('foobar', '');     -- Returns 1",
                    "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION(substr IN str)",
                "description": "Returns the 1-based index of substr in str. Returns 0 if not found. NULL if either argument is NULL.",
                "examples": [
                    "SELECT POSITION('bar' IN 'foobar');   -- Returns 4",
                    "SELECT POSITION('x' IN 'abc');        -- Returns 0"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `h`\nColumns:\n(c1, char(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `h`\nColumns:\n(c1, character(20), )\n"
        ]
    },
    {
        "sql_id": "postgresql_7_12",
        "database_name": "postgresql_7_12",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT INSTR(c1, '54') FROM h; -- INSTR",
        "target_query": "SELECT POSITION('54' in c1) FROM h; -- INSTR",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "INSTR(str, substr)",
                "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
                "examples": [
                    "SELECT INSTR('foobar', 'bar');  -- Returns 4",
                    "SELECT INSTR('foobar', 'baz');  -- Returns 0",
                    "SELECT INSTR('foobar', '');     -- Returns 1",
                    "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION(substr IN str)",
                "description": "Returns the 1-based index of substr in str. Returns 0 if not found. NULL if either argument is NULL.",
                "examples": [
                    "SELECT POSITION('bar' IN 'foobar');   -- Returns 4",
                    "SELECT POSITION('x' IN 'abc');        -- Returns 0"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `h`\nColumns:\n(c1, char(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `h`\nColumns:\n(c1, character(20), )\n"
        ]
    },
    {
        "sql_id": "postgresql_7_13",
        "database_name": "postgresql_7_13",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT INSTR(c1, '31') FROM h; -- INSTR",
        "target_query": "SELECT POSITION('31' in c1) FROM h; -- INSTR",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "INSTR(str, substr)",
                "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
                "examples": [
                    "SELECT INSTR('foobar', 'bar');  -- Returns 4",
                    "SELECT INSTR('foobar', 'baz');  -- Returns 0",
                    "SELECT INSTR('foobar', '');     -- Returns 1",
                    "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION(substr IN str)",
                "description": "Returns the 1-based index of substr in str. Returns 0 if not found. NULL if either argument is NULL.",
                "examples": [
                    "SELECT POSITION('bar' IN 'foobar');   -- Returns 4",
                    "SELECT POSITION('x' IN 'abc');        -- Returns 0"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `h`\nColumns:\n(c1, char(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `h`\nColumns:\n(c1, character(20), )\n"
        ]
    },
    {
        "sql_id": "postgresql_7_23",
        "database_name": "postgresql_7_23",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT c1, TRIM(c1) FROM h; -- TRIM",
        "target_query": "SELECT c1, TRIM(c1) FROM h; -- TRIM",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TRIM"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "The TRIM function works in the same way as MySQL, removing unwanted characters from the string. If no character is specified, spaces are removed by default.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `h`\nColumns:\n(c1, char(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `h`\nColumns:\n(c1, character(20), )\n"
        ]
    },
    {
        "sql_id": "postgresql_71_0",
        "database_name": "postgresql_71_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select from_unixtime(123456789); -- FROM_UNIXTIME",
        "target_query": "SELECT TO_TIMESTAMP(123456789);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "FROM_UNIXTIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
                "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
                "examples": [
                    "SELECT FROM_UNIXTIME(1672531200);",
                    "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
                    "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP(unix_timestamp)",
                "description": "Converts a Unix timestamp (number of seconds since 1970-01-01 UTC) to a timestamp with time zone.",
                "examples": [
                    "SELECT TO_TIMESTAMP(1672531200);",
                    "SELECT TO_TIMESTAMP(1672531200.456);",
                    "SELECT id, TO_CHAR(TO_TIMESTAMP(created_at), 'YYYY-MM-DD') AS created_date FROM events;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_71_1",
        "database_name": "postgresql_71_1",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select from_unixtime(234567890); -- FROM_UNIXTIME",
        "target_query": "SELECT TO_TIMESTAMP(234567890);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "FROM_UNIXTIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
                "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
                "examples": [
                    "SELECT FROM_UNIXTIME(1672531200);",
                    "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
                    "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP(unix_timestamp)",
                "description": "Converts a Unix timestamp (number of seconds since 1970-01-01 UTC) to a timestamp with time zone.",
                "examples": [
                    "SELECT TO_TIMESTAMP(1672531200);",
                    "SELECT TO_TIMESTAMP(1672531200.456);",
                    "SELECT id, TO_CHAR(TO_TIMESTAMP(created_at), 'YYYY-MM-DD') AS created_date FROM events;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_71_2",
        "database_name": "postgresql_71_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select from_unixtime(1); -- FROM_UNIXTIME",
        "target_query": "SELECT TO_TIMESTAMP(1);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "FROM_UNIXTIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
                "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
                "examples": [
                    "SELECT FROM_UNIXTIME(1672531200);",
                    "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
                    "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP(unix_timestamp)",
                "description": "Converts a Unix timestamp (number of seconds since 1970-01-01 UTC) to a timestamp with time zone.",
                "examples": [
                    "SELECT TO_TIMESTAMP(1672531200);",
                    "SELECT TO_TIMESTAMP(1672531200.456);",
                    "SELECT id, TO_CHAR(TO_TIMESTAMP(created_at), 'YYYY-MM-DD') AS created_date FROM events;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_71_3",
        "database_name": "postgresql_71_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select unix_timestamp(from_unixtime(123456789)); -- UNIX_TIMESTAMP, FROM_UNIXTIME",
        "target_query": "SELECT EXTRACT(EPOCH FROM TO_TIMESTAMP(123456789));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP",
            "FROM_UNIXTIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            },
            {
                "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
                "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
                "examples": [
                    "SELECT FROM_UNIXTIME(1672531200);",
                    "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
                    "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Extracts the number of seconds since the Unix epoch from a timestamp using the EPOCH keyword.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            },
            {
                "expression": "TO_TIMESTAMP(unix_timestamp)",
                "description": "Converts a Unix timestamp (number of seconds since 1970-01-01 UTC) to a timestamp with time zone.",
                "examples": [
                    "SELECT TO_TIMESTAMP(1672531200);",
                    "SELECT TO_TIMESTAMP(1672531200.456);",
                    "SELECT id, TO_CHAR(TO_TIMESTAMP(created_at), 'YYYY-MM-DD') AS created_date FROM events;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_71_4",
        "database_name": "postgresql_71_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select unix_timestamp(from_unixtime(234567890)); -- UNIX_TIMESTAMP, FROM_UNIXTIME",
        "target_query": "SELECT EXTRACT(EPOCH FROM TO_TIMESTAMP(234567890));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP",
            "FROM_UNIXTIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            },
            {
                "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
                "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
                "examples": [
                    "SELECT FROM_UNIXTIME(1672531200);",
                    "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
                    "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Extracts the number of seconds since the Unix epoch from a timestamp using the EPOCH keyword.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            },
            {
                "expression": "TO_TIMESTAMP(unix_timestamp)",
                "description": "Converts a Unix timestamp (number of seconds since 1970-01-01 UTC) to a timestamp with time zone.",
                "examples": [
                    "SELECT TO_TIMESTAMP(1672531200);",
                    "SELECT TO_TIMESTAMP(1672531200.456);",
                    "SELECT id, TO_CHAR(TO_TIMESTAMP(created_at), 'YYYY-MM-DD') AS created_date FROM events;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_71_5",
        "database_name": "postgresql_71_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select unix_timestamp('2039-01-20 01:00:00'); -- UNIX_TIMESTAMP",
        "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2039-01-20 01:00:00');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Extracts the number of seconds since the Unix epoch from a timestamp using the EPOCH keyword.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_71_6",
        "database_name": "postgresql_71_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select unix_timestamp('2038-02-10 01:00:00'); -- UNIX_TIMESTAMP",
        "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-02-10 01:00:00');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Extracts the number of seconds since the Unix epoch from a timestamp using the EPOCH keyword.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_71_7",
        "database_name": "postgresql_71_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select unix_timestamp('1970-01-01 01:00:00'),unix_timestamp('1970-01-01 01:00:01'),unix_timestamp('2038-01-19 04:14:07'),unix_timestamp('2038-01-19 04:14:08'); -- UNIX_TIMESTAMP",
        "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1970-01-01 01:00:00'), EXTRACT(EPOCH FROM TIMESTAMP '1970-01-01 01:00:01'), EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07'), EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:08');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Extracts the number of seconds since the Unix epoch from a timestamp using the EPOCH keyword.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_71_11",
        "database_name": "postgresql_71_11",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT a, FROM_UNIXTIME(a) FROM t1; -- FROM_UNIXTIME",
        "target_query": "SELECT a, TO_TIMESTAMP(a) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "FROM_UNIXTIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
                "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
                "examples": [
                    "SELECT FROM_UNIXTIME(1672531200);",
                    "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
                    "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP(unix_timestamp)",
                "description": "Converts a Unix timestamp (number of seconds since 1970-01-01 UTC) to a timestamp with time zone.",
                "examples": [
                    "SELECT TO_TIMESTAMP(1672531200);",
                    "SELECT TO_TIMESTAMP(1672531200.456);",
                    "SELECT id, TO_CHAR(TO_TIMESTAMP(created_at), 'YYYY-MM-DD') AS created_date FROM events;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bigint, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bigint, )\n"
        ]
    },
    {
        "sql_id": "postgresql_71_13",
        "database_name": "postgresql_71_13",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT UNIX_TIMESTAMP(\"3001-01-19 08:59:59\"); -- UNIX_TIMESTAMP",
        "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '3001-01-19 08:59:59');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Extracts the number of seconds since the Unix epoch from a timestamp using the EPOCH keyword.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_72_4",
        "database_name": "postgresql_72_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "EXPLAIN SELECT * FROM t WHERE CONCAT(x,x) = 'XX'; -- CONCAT",
        "target_query": "EXPLAIN SELECT * FROM t WHERE x || x = 'XX';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t`\nColumns:\n(x, varchar(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t`\nColumns:\n(x, character varying(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_74_2",
        "database_name": "postgresql_74_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "insert into t1(f1) select if(max(f1) is null, '2000',max(f1)) from t1; -- IF, MAX",
        "target_query": "INSERT INTO t1(f1) SELECT CASE WHEN MAX(f1) IS NULL THEN '2000' ELSE MAX(f1) END FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF",
            "MAX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            },
            {
                "expression": "MAX(expr)",
                "description": "Returns the maximum value of the expression in an aggregation context.",
                "examples": [
                    "SELECT MAX(10), MAX(5), MAX(20);",
                    "SELECT MAX('apple'), MAX('banana'), MAX('pear');",
                    "SELECT MAX(ABS(-5)), MAX(ABS(3));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "In PostgreSQL, `IF` is not directly supported. Instead, the `CASE WHEN` expression is used to evaluate a condition and return different values based on whether the condition is true or false.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            },
            {
                "expression": "MAX(expr)",
                "description": "Returns the largest value of the expression across input rows.",
                "examples": [
                    "SELECT MAX(100), MAX(50), MAX(75);",
                    "SELECT MAX('mango'), MAX('kiwi'), MAX('grape');",
                    "SELECT MAX(CEIL(1.2)), MAX(CEIL(2.8));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, varchar(5), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, character varying(5), )\n"
        ]
    },
    {
        "sql_id": "postgresql_74_6",
        "database_name": "postgresql_74_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT (SELECT SUM(LENGTH(c)) FROM t1 WHERE c='13_characters') FROM t1; -- LENGTH",
        "target_query": "SELECT (SELECT SUM(octet_length(c)) FROM t1 WHERE c='13_characters') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c, varchar(30), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c, character varying(30), )\n"
        ]
    },
    {
        "sql_id": "postgresql_74_9",
        "database_name": "postgresql_74_9",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t2 (d)SELECT (SELECT SUM(LENGTH(c)) FROM t1 WHERE c='13_characters') FROM t1; -- LENGTH",
        "target_query": "INSERT INTO t2 (d)SELECT (SELECT SUM(octet_length(c)) FROM t1 WHERE c='13_characters') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c, varchar(30), )\n",
            "Table: `t2`\nColumns:\n(d, varchar(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c, character varying(30), )\n",
            "Table: `t2`\nColumns:\n(d, character varying(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_74_10",
        "database_name": "postgresql_74_10",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t2 (d)SELECT (SELECT SUM(LENGTH(c)) FROM t1 WHERE c='7_chars') FROM t1; -- LENGTH",
        "target_query": "INSERT INTO t2 (d)SELECT (SELECT SUM(octet_length(c)) FROM t1 WHERE c='7_chars') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c, varchar(30), )\n",
            "Table: `t2`\nColumns:\n(d, varchar(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c, character varying(30), )\n",
            "Table: `t2`\nColumns:\n(d, character varying(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_74_16",
        "database_name": "postgresql_74_16",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT *, HEX(a) FROM t1; -- HEX",
        "target_query": "SELECT *, encode(a::bytea, 'hex') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(id, int, PRI)\n(a, varchar(100), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(id, integer, PRI)\n(a, character varying(100), )\n"
        ]
    },
    {
        "sql_id": "postgresql_74_17",
        "database_name": "postgresql_74_17",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT *, HEX(a) FROM t1 WHERE a = 'abc-def'; -- HEX",
        "target_query": "SELECT *, encode(a::bytea, 'hex') FROM t1 WHERE a = 'abc-def';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(id, int, PRI)\n(a, varchar(100), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(id, integer, PRI)\n(a, character varying(100), )\n"
        ]
    },
    {
        "sql_id": "postgresql_75_2",
        "database_name": "postgresql_75_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 VALUES('valid-string',1),(UNHEX('11'),2); -- UNHEX",
        "target_query": "INSERT INTO t1 VALUES('valid-string', 1), (decode('11', 'hex'), 2);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNHEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNHEX(str)",
                "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
                "examples": [
                    "SELECT HEX(UNHEX('4D7953514C'));",
                    "SELECT UNHEX('48656C6C6F');",
                    "SELECT UNHEX(NULL);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "decode(str, 'hex')",
                "description": "Decodes a hexadecimal string into binary (bytea) using the decode function.",
                "examples": [
                    "SELECT encode(decode('4D7953514C', 'hex'), 'hex');",
                    "SELECT decode('48656C6C6F', 'hex');",
                    "SELECT decode(NULL, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(tx, text, )\n(pk, int, PRI)\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(tx, text, )\n(pk, integer, PRI)\n"
        ]
    },
    {
        "sql_id": "postgresql_75_3",
        "database_name": "postgresql_75_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT pk,OCTET_LENGTH(tx),LENGTH(tx) FROM t1; -- OCTET_LENGTH, LENGTH",
        "target_query": "SELECT pk, OCTET_LENGTH(tx), octet_length(tx) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "OCTET_LENGTH",
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "OCTET_LENGTH()",
                "description": "Returns the number of bytes in a string.",
                "examples": [
                    "SELECT OCTET_LENGTH('Hello World');",
                    "SELECT OCTET_LENGTH('Test String') = 11;",
                    "SELECT CASE WHEN OCTET_LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
                ]
            },
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "OCTET_LENGTH()",
                "description": "Returns the number of bytes in a string.",
                "examples": [
                    "SELECT OCTET_LENGTH('Hello World');",
                    "SELECT OCTET_LENGTH('Test String') = 11;",
                    "SELECT CASE WHEN OCTET_LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
                ]
            },
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(tx, text, )\n(pk, int, PRI)\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(tx, text, )\n(pk, integer, PRI)\n"
        ]
    },
    {
        "sql_id": "postgresql_76_2",
        "database_name": "postgresql_76_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "insert ignore t1 values (1, repeat('a',110), repeat('b', 210)); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES (1, REPEAT('a',110), REPEAT('b', 210)) ON CONFLICT DO NOTHING;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(i, int, )\n(a, char(200), UNI)\n(b, text, UNI)\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(i, integer, )\n(a, character(200), )\n(b, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_76_3",
        "database_name": "postgresql_76_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select i, length(a), length(b), char_length(a), char_length(b) from t1; -- LENGTH, CHAR_LENGTH",
        "target_query": "SELECT i, octet_length(a), octet_length(b), char_length(a), char_length(b) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH",
            "CHAR_LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            },
            {
                "expression": "CHAR_LENGTH(expr)",
                "description": "Returns the number of characters in the string, not bytes.",
                "examples": [
                    "SELECT CHAR_LENGTH('abc');",
                    "SELECT CHAR_LENGTH('\u4f60\u597d');",
                    "SELECT CHAR_LENGTH('a\u4f60b\u597dc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            },
            {
                "expression": "CHAR_LENGTH(expr)",
                "description": "Returns the number of characters in a string.",
                "examples": [
                    "SELECT CHAR_LENGTH('abc');",
                    "SELECT CHAR_LENGTH('\u4f60\u597d');",
                    "SELECT CHAR_LENGTH('a\u4f60b\u597dc');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(i, int, )\n(a, char(200), UNI)\n(b, text, UNI)\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(i, integer, )\n(a, character(200), )\n(b, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_76_6",
        "database_name": "postgresql_76_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "insert into t1 values(1, 'a', 'a', NOW()), (1, 'b', 'b', NOW()); -- NOW",
        "target_query": "INSERT INTO t1 VALUES (1, 'a', 'a', CURRENT_TIMESTAMP), (1, 'b', 'b', CURRENT_TIMESTAMP);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "NOW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "In PostgreSQL, CURRENT_TIMESTAMP is used to retrieve the current date and time, equivalent to NOW() in MySQL and MariaDB.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, int, )\n(c2, char(12), )\n(c3, varchar(123), )\n(c4, timestamp, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, integer, )\n(c2, character(12), )\n(c3, character varying(123), )\n(c4, timestamp without time zone, )\n"
        ]
    },
    {
        "sql_id": "postgresql_77_3",
        "database_name": "postgresql_77_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select t1.time,t1.date,t1.timestamp,concat(date,\" \",time),t1.quarter+t1.week, t1.year+timestampadd,  timestampdiff from t1; -- CONCAT",
        "target_query": "select t1.time,t1.date,t1.timestamp,date || ' ' || time,t1.quarter+t1.week, t1.year+timestampadd,  timestampdiff from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(time, time, )\n(date, date, )\n(timestamp, timestamp, )\n(quarter, int, )\n(week, int, )\n(year, int, )\n(timestampadd, int, )\n(timestampdiff, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(time, time without time zone, )\n(date, date, )\n(timestamp, timestamp without time zone, )\n(quarter, integer, )\n(week, integer, )\n(year, integer, )\n(timestampadd, integer, )\n(timestampdiff, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_78_2",
        "database_name": "postgresql_78_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select concat('|',a,'|'), concat('|',b,'|') from t1; -- CONCAT",
        "target_query": "SELECT '|' || a || '|', '|' || b || '|' FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, text, )\n(b, text, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, text, )\n(b, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_78_5",
        "database_name": "postgresql_78_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT HEX(val) FROM t1; -- HEX",
        "target_query": "SELECT encode(val::bytea, 'hex') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(val, text, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(val, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_78_8",
        "database_name": "postgresql_78_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT HEX(a) FROM t1; -- HEX",
        "target_query": "SELECT encode(a::bytea, 'hex') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, varchar(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, character varying(20), )\n"
        ]
    },
    {
        "sql_id": "postgresql_79_3",
        "database_name": "postgresql_79_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT a, date_format(a,'%a') as abday, dayname(a) as day FROM t1 ORDER BY a; -- DATE_FORMAT, DAYNAME",
        "target_query": "SELECT a, TO_CHAR(a, 'Dy') as abday, TO_CHAR(a, 'Day') as day FROM t1 ORDER BY a;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE_FORMAT",
            "DAYNAME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            },
            {
                "expression": "DAYNAME(date)",
                "description": "Returns the full name of the day for a given date.",
                "examples": [
                    "SELECT DAYNAME('2023-11-25');",
                    "SELECT DAYNAME('2022-01-01');",
                    "SELECT DAYNAME('1999-03-14');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(date_expr, format_str)",
                "description": "Formats a date/time value according to a format string using PostgreSQL-style specifiers.",
                "examples": [
                    "SELECT TO_CHAR(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT TO_CHAR(DATE '2023-01-15', 'DD-MM-YYYY');"
                ]
            },
            {
                "expression": "TO_CHAR(date, 'Day')",
                "description": "Returns the full name of the day for a given date using the TO_CHAR function.",
                "examples": [
                    "SELECT TO_CHAR('2023-11-25'::DATE, 'Day');",
                    "SELECT TO_CHAR('2022-01-01'::DATE, 'Day');",
                    "SELECT TO_CHAR('1999-03-14'::DATE, 'Day');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, date, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, date, )\n"
        ]
    },
    {
        "sql_id": "postgresql_79_7",
        "database_name": "postgresql_79_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT a, date_format(a,'%b') as abmon, monthname(a) as mon FROM t1 ORDER BY a; -- DATE_FORMAT, MONTHNAME",
        "target_query": "SELECT a, TO_CHAR(a, 'Mon') as abmon, TO_CHAR(a, 'Month') as mon FROM t1 ORDER BY a;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE_FORMAT",
            "MONTHNAME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            },
            {
                "expression": "MONTHNAME(date)",
                "description": "Returns the full English name of the month for a given date.",
                "examples": [
                    "SELECT MONTHNAME(DATE '2023-05-01') AS mon1;",
                    "SELECT MONTHNAME(STR_TO_DATE('2024-12-31', '%Y-%m-%d')) AS mon2;",
                    "SELECT MONTHNAME(NOW()) AS current_month;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(date_expr, format_str)",
                "description": "Formats a date/time value according to a format string using PostgreSQL-style specifiers.",
                "examples": [
                    "SELECT TO_CHAR(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT TO_CHAR(DATE '2023-01-15', 'DD-MM-YYYY');"
                ]
            },
            {
                "expression": "TO_CHAR(date, 'Month')",
                "description": "Returns the full English name of the month for a given date using formatting.",
                "examples": [
                    "SELECT TO_CHAR(DATE '2023-05-01', 'Month') AS mon1;",
                    "SELECT TO_CHAR(TO_DATE('2024-12-31', 'YYYY-MM-DD'), 'Month') AS mon2;",
                    "SELECT TO_CHAR(CURRENT_DATE, 'Month') AS current_month;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, date, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, date, )\n"
        ]
    },
    {
        "sql_id": "postgresql_79_9",
        "database_name": "postgresql_79_9",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT DATE_FORMAT('2001-01-01', '%w %a %W'); -- DATE_FORMAT",
        "target_query": "SELECT TO_CHAR('2001-01-01'::DATE, 'ID Dy WW');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE_FORMAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(date_expr, format_str)",
                "description": "Formats a date/time value according to a format string using PostgreSQL-style specifiers.",
                "examples": [
                    "SELECT TO_CHAR(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT TO_CHAR(DATE '2023-01-15', 'DD-MM-YYYY');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_79_10",
        "database_name": "postgresql_79_10",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT DATE_FORMAT('2001-01-01', '%c %b %M'); -- DATE_FORMAT",
        "target_query": "SELECT TO_CHAR('2001-01-01'::DATE, 'MM Mon Month');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE_FORMAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(date_expr, format_str)",
                "description": "Formats a date/time value according to a format string using PostgreSQL-style specifiers.",
                "examples": [
                    "SELECT TO_CHAR(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT TO_CHAR(DATE '2023-01-15', 'DD-MM-YYYY');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_79_11",
        "database_name": "postgresql_79_11",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT DATE_FORMAT('2010-03-23 11:00:00','%h %p'); -- DATE_FORMAT",
        "target_query": "SELECT TO_CHAR('2010-03-23 11:00:00'::TIMESTAMP, 'HH12 AM');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE_FORMAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(date_expr, format_str)",
                "description": "Formats a date/time value according to a format string using PostgreSQL-style specifiers.",
                "examples": [
                    "SELECT TO_CHAR(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT TO_CHAR(DATE '2023-01-15', 'DD-MM-YYYY');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_8_0",
        "database_name": "postgresql_8_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select strcmp('','ae'),strcmp('ae',''),strcmp('aeq','q'),strcmp('q','aeq'); -- STRCMP",
        "target_query": "SELECT CASE WHEN '' = 'ae' THEN 0 WHEN '' < 'ae' THEN -1 ELSE 1 END, CASE WHEN 'ae' = '' THEN 0 WHEN 'ae' < '' THEN -1 ELSE 1 END, CASE WHEN 'aeq' = 'q' THEN 0 WHEN 'aeq' < 'q' THEN -1 ELSE 1 END, CASE WHEN 'q' = 'aeq' THEN 0 WHEN 'q' < 'aeq' THEN -1 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "STRCMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "PostgreSQL does not have a direct STRCMP function. The equivalent behavior can be achieved using a CASE statement to compare two strings lexicographically and return -1, 0, or 1 based on the comparison.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_8_1",
        "database_name": "postgresql_8_1",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select strcmp('ss',''),strcmp('','ss'),strcmp('s','sss'),strcmp('q','ssq'); -- STRCMP",
        "target_query": "SELECT CASE WHEN 'ss' = '' THEN 0 WHEN 'ss' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'ss' THEN 0 WHEN '' < 'ss' THEN -1 ELSE 1 END, CASE WHEN 's' = 'sss' THEN 0 WHEN 's' < 'sss' THEN -1 ELSE 1 END, CASE WHEN 'q' = 'ssq' THEN 0 WHEN 'q' < 'ssq' THEN -1 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "STRCMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "PostgreSQL does not have a direct STRCMP function. The equivalent behavior can be achieved using a CASE statement to compare two strings lexicographically and return -1, 0, or 1 based on the comparison.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_8_2",
        "database_name": "postgresql_8_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select strcmp('','af'),strcmp('a',''),strcmp('','aeq'),strcmp('','aeaeq'); -- STRCMP",
        "target_query": "SELECT CASE WHEN '' = 'af' THEN 0 WHEN '' < 'af' THEN -1 ELSE 1 END, CASE WHEN 'a' = '' THEN 0 WHEN 'a' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'aeq' THEN 0 WHEN '' < 'aeq' THEN -1 ELSE 1 END, CASE WHEN '' = 'aeaeq' THEN 0 WHEN '' < 'aeaeq' THEN -1 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "STRCMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "PostgreSQL does not have a direct STRCMP function. The equivalent behavior can be achieved using a CASE statement to compare two strings lexicographically and return -1, 0, or 1 based on the comparison.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_8_3",
        "database_name": "postgresql_8_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select strcmp('ss','a'),strcmp('','ssa'),strcmp('sa','sssb'),strcmp('s',''); -- STRCMP",
        "target_query": "SELECT CASE WHEN 'ss' = 'a' THEN 0 WHEN 'ss' < 'a' THEN -1 ELSE 1 END, CASE WHEN '' = 'ssa' THEN 0 WHEN '' < 'ssa' THEN -1 ELSE 1 END, CASE WHEN 'sa' = 'sssb' THEN 0 WHEN 'sa' < 'sssb' THEN -1 ELSE 1 END, CASE WHEN 's' = '' THEN 0 WHEN 's' < '' THEN -1 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "STRCMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "PostgreSQL does not have a direct STRCMP function. The equivalent behavior can be achieved using a CASE statement to compare two strings lexicographically and return -1, 0, or 1 based on the comparison.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_8_4",
        "database_name": "postgresql_8_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select strcmp('','o'),strcmp('','u'),strcmp('','oeb'); -- STRCMP",
        "target_query": "SELECT CASE WHEN '' = 'o' THEN 0 WHEN '' < 'o' THEN -1 ELSE 1 END, CASE WHEN '' = 'u' THEN 0 WHEN '' < 'u' THEN -1 ELSE 1 END, CASE WHEN '' = 'oeb' THEN 0 WHEN '' < 'oeb' THEN -1 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "STRCMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "PostgreSQL does not have a direct STRCMP function. The equivalent behavior can be achieved using a CASE statement to compare two strings lexicographically and return -1, 0, or 1 based on the comparison.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_8_5",
        "database_name": "postgresql_8_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select strcmp('af',''),strcmp('','a'),strcmp('aeq',''),strcmp('aeaeq',''); -- STRCMP",
        "target_query": "SELECT CASE WHEN 'af' = '' THEN 0 WHEN 'af' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'a' THEN 0 WHEN '' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'aeq' = '' THEN 0 WHEN 'aeq' < '' THEN -1 ELSE 1 END, CASE WHEN 'aeaeq' = '' THEN 0 WHEN 'aeaeq' < '' THEN -1 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "STRCMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "PostgreSQL does not have a direct STRCMP function. The equivalent behavior can be achieved using a CASE statement to compare two strings lexicographically and return -1, 0, or 1 based on the comparison.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_8_6",
        "database_name": "postgresql_8_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select strcmp('a','ss'),strcmp('ssa',''),strcmp('sssb','sa'),strcmp('','s'); -- STRCMP",
        "target_query": "SELECT CASE WHEN 'a' = 'ss' THEN 0 WHEN 'a' < 'ss' THEN -1 ELSE 1 END, CASE WHEN 'ssa' = '' THEN 0 WHEN 'ssa' < '' THEN -1 ELSE 1 END, CASE WHEN 'sssb' = 'sa' THEN 0 WHEN 'sssb' < 'sa' THEN -1 ELSE 1 END, CASE WHEN '' = 's' THEN 0 WHEN '' < 's' THEN -1 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "STRCMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "PostgreSQL does not have a direct STRCMP function. The equivalent behavior can be achieved using a CASE statement to compare two strings lexicographically and return -1, 0, or 1 based on the comparison.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_8_7",
        "database_name": "postgresql_8_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select strcmp('u','a'),strcmp('u',''); -- STRCMP",
        "target_query": "SELECT CASE WHEN 'u' = 'a' THEN 0 WHEN 'u' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'u' = '' THEN 0 WHEN 'u' < '' THEN -1 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "STRCMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "PostgreSQL does not have a direct STRCMP function. The equivalent behavior can be achieved using a CASE statement to compare two strings lexicographically and return -1, 0, or 1 based on the comparison.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_8_8",
        "database_name": "postgresql_8_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select strcmp('s', 'a'), strcmp('a', 'x'); -- STRCMP",
        "target_query": "SELECT CASE WHEN 's' = 'a' THEN 0 WHEN 's' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'a' = 'x' THEN 0 WHEN 'a' < 'x' THEN -1 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "STRCMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "PostgreSQL does not have a direct STRCMP function. The equivalent behavior can be achieved using a CASE statement to compare two strings lexicographically and return -1, 0, or 1 based on the comparison.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_8_13",
        "database_name": "postgresql_8_13",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT FIELD('ue',s1), FIELD('',s1), s1='ue', s1='' FROM t1; -- FIELD",
        "target_query": "SELECT COALESCE(array_position(ARRAY[s1], 'ue'), 0), COALESCE(array_position(ARRAY[s1], ''), 0), s1 = 'ue', s1 = '' FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "FIELD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FIELD(val, val1, val2, ..., valN)",
                "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
                "examples": [
                    "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
                    "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
                    "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(array_position(ARRAY[val1, val2, ..., valN], val), 0)",
                "description": "Returns the index (1-based) of 'val' in the array. Returns 0 if not found, to match MySQL FIELD() behavior.",
                "examples": [
                    "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'c'), 0) AS result;",
                    "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'x'), 0) AS result;",
                    "SELECT COALESCE(array_position(ARRAY['b', 'b', 'b'], 'b'), 0) AS result;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(s1, char(5), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(s1, character(5), )\n"
        ]
    },
    {
        "sql_id": "postgresql_8_17",
        "database_name": "postgresql_8_17",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select * from t1 where length(s1)=2 and s1='oe'; -- LENGTH",
        "target_query": "SELECT * FROM t1 WHERE octet_length(s1) = 2 AND s1 = 'oe';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(s1, char(5), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(s1, character(5), )\n"
        ]
    },
    {
        "sql_id": "postgresql_80_0",
        "database_name": "postgresql_80_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT LPAD(NULL, 5, 'x') AS result; -- LPAD",
        "target_query": "SELECT LPAD(NULL, 5, 'x') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached, just like in MySQL.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_80_1",
        "database_name": "postgresql_80_1",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT LPAD(NULL, NULL, 'x') AS result; -- LPAD",
        "target_query": "SELECT LPAD(NULL, NULL, 'x') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached, just like in MySQL.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_80_2",
        "database_name": "postgresql_80_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT LPAD(NULL, NULL, NULL) AS result; -- LPAD",
        "target_query": "SELECT LPAD(NULL, NULL, NULL) AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached, just like in MySQL.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_80_3",
        "database_name": "postgresql_80_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT LPAD('a', NULL, 'x') AS result; -- LPAD",
        "target_query": "SELECT LPAD('a', NULL, 'x') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached, just like in MySQL.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_80_4",
        "database_name": "postgresql_80_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT LPAD('a', NULL, NULL) AS result; -- LPAD",
        "target_query": "SELECT LPAD('a', NULL, NULL) AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached, just like in MySQL.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_80_5",
        "database_name": "postgresql_80_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT LPAD('a', 5, NULL) AS result; -- LPAD",
        "target_query": "SELECT LPAD('a', 5, NULL) AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached, just like in MySQL.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_80_6",
        "database_name": "postgresql_80_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT LPAD(NULL, 5, NULL) AS result; -- LPAD",
        "target_query": "SELECT LPAD(NULL, 5, NULL) AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached, just like in MySQL.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_80_7",
        "database_name": "postgresql_80_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT LPAD('a', 0, 'x') AS result; -- LPAD",
        "target_query": "SELECT LPAD('a', 0, 'x') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached, just like in MySQL.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_80_8",
        "database_name": "postgresql_80_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT LPAD('a', 0, '') AS result; -- LPAD",
        "target_query": "SELECT LPAD('a', 0, '') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached, just like in MySQL.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_80_9",
        "database_name": "postgresql_80_9",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT LPAD('', 0, 'x') AS result; -- LPAD",
        "target_query": "SELECT LPAD('', 0, 'x') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached, just like in MySQL.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_80_10",
        "database_name": "postgresql_80_10",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT LPAD('', 0, '') AS result; -- LPAD",
        "target_query": "SELECT LPAD('', 0, '') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached, just like in MySQL.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_80_11",
        "database_name": "postgresql_80_11",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT LPAD('a', -1, 'x'); -- LPAD",
        "target_query": "SELECT LPAD('a', -1, 'x');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached, just like in MySQL.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_80_12",
        "database_name": "postgresql_80_12",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT LPAD('123', 5, 'x'); -- LPAD",
        "target_query": "SELECT LPAD('123', 5, 'x');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached, just like in MySQL.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_80_13",
        "database_name": "postgresql_80_13",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT LPAD('a', 5, 'xy'); -- LPAD",
        "target_query": "SELECT LPAD('a', 5, 'xy');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached, just like in MySQL.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_80_14",
        "database_name": "postgresql_80_14",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT LPAD(\"I LOVE SQL\", 20, \" \"); -- LPAD",
        "target_query": "SELECT LPAD('I LOVE SQL', 20, ' ');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached, just like in MySQL.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_80_15",
        "database_name": "postgresql_80_15",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT LPAD(\"I LOVE SQL in the morning\", 20, \" \"); -- LPAD",
        "target_query": "SELECT LPAD('I LOVE SQL in the morning', 20, ' ');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached, just like in MySQL.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_81_2",
        "database_name": "postgresql_81_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 VALUES(REPEAT('a', 1024), 0), (REPEAT('b', 1024), 1),(REPEAT('c', 1024), 2), (REPEAT('d', 1024), 3),(REPEAT('e', 1024), 4), (REPEAT('f', 1024), 5); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES(REPEAT('a', 1024), 0), (REPEAT('b', 1024), 1),(REPEAT('c', 1024), 2), (REPEAT('d', 1024), 3),(REPEAT('e', 1024), 4), (REPEAT('f', 1024), 5);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, longtext, )\n(f2, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, text, )\n(f2, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_81_15",
        "database_name": "postgresql_81_15",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT SUM(LENGTH(f1)) FROM t1; -- LENGTH",
        "target_query": "SELECT SUM(octet_length(f1)) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, longtext, )\n(f2, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, text, )\n(f2, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_82_3",
        "database_name": "postgresql_82_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT COALESCE(d, d), IFNULL(d, d), IF(i, d, d),CASE i WHEN i THEN d ELSE d END, GREATEST(d, d), LEAST(d, d)FROM t1 ORDER BY RAND(); -- COALESCE, IFNULL, IF, GREATEST, LEAST",
        "target_query": "SELECT COALESCE(d, d), COALESCE(d, d), CASE WHEN i IS NOT NULL AND i > 0 THEN d ELSE d END, CASE i WHEN i THEN d ELSE d END, GREATEST(d, d), LEAST(d, d) FROM t1 ORDER BY RANDOM();",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "COALESCE",
            "IFNULL",
            "IF",
            "GREATEST",
            "LEAST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
                "description": "Returns the first non-NULL value, or merges table partitions.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
                    "ALTER TABLE t1 COALESCE PARTITION 2;"
                ]
            },
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            },
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            },
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            },
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...)",
                "description": "Standard SQL COALESCE function for NULL-handling.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;"
                ]
            },
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "PostgreSQL uses COALESCE, which returns the first non-NULL argument. This works exactly like IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            },
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "In PostgreSQL, `IF` is not directly supported. Instead, the `CASE WHEN` expression is used to evaluate a condition and return different values based on whether the condition is true or false.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            },
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            },
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest non-null value among its arguments. NULL values are ignored unless all values are NULL.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(i, int, )\n(d, date, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(i, integer, )\n(d, date, )\n"
        ]
    },
    {
        "sql_id": "postgresql_83_3",
        "database_name": "postgresql_83_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT HEX(c1) FROM AB; -- HEX",
        "target_query": "SELECT encode(c1::bytea, 'hex') FROM AB;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `AB`\nColumns:\n(c1, char(100), )\n"
        ],
        "target_related_schemas": [
            "Table: `ab`\nColumns:\n(c1, character(100), )\n"
        ]
    },
    {
        "sql_id": "postgresql_84_2",
        "database_name": "postgresql_84_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "insert into t5 values (1, date_format('2001-01-01','%W')); -- DATE_FORMAT",
        "target_query": "INSERT INTO t5 VALUES (1, TO_CHAR(DATE '2001-01-01', 'Day'));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE_FORMAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(date_expr, format_str)",
                "description": "Formats a date/time value according to a format string using PostgreSQL-style specifiers.",
                "examples": [
                    "SELECT TO_CHAR(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT TO_CHAR(DATE '2023-01-15', 'DD-MM-YYYY');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t5`\nColumns:\n(c1, int, )\n(c2, varchar(128), )\n"
        ],
        "target_related_schemas": [
            "Table: `t5`\nColumns:\n(c1, integer, )\n(c2, character varying(128), )\n"
        ]
    },
    {
        "sql_id": "postgresql_84_3",
        "database_name": "postgresql_84_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "insert into t5 values (2, date_format('2001-01-01','%W')); -- DATE_FORMAT",
        "target_query": "INSERT INTO t5 VALUES (2, TO_CHAR(DATE '2001-01-01', 'Day'));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE_FORMAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(date_expr, format_str)",
                "description": "Formats a date/time value according to a format string using PostgreSQL-style specifiers.",
                "examples": [
                    "SELECT TO_CHAR(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT TO_CHAR(DATE '2023-01-15', 'DD-MM-YYYY');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t5`\nColumns:\n(c1, int, )\n(c2, varchar(128), )\n"
        ],
        "target_related_schemas": [
            "Table: `t5`\nColumns:\n(c1, integer, )\n(c2, character varying(128), )\n"
        ]
    },
    {
        "sql_id": "postgresql_84_4",
        "database_name": "postgresql_84_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "insert into t5 values (3, date_format('2001-01-01','%W')); -- DATE_FORMAT",
        "target_query": "INSERT INTO t5 VALUES (3, TO_CHAR(DATE '2001-01-01', 'Day'));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE_FORMAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(date_expr, format_str)",
                "description": "Formats a date/time value according to a format string using PostgreSQL-style specifiers.",
                "examples": [
                    "SELECT TO_CHAR(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT TO_CHAR(DATE '2023-01-15', 'DD-MM-YYYY');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t5`\nColumns:\n(c1, int, )\n(c2, varchar(128), )\n"
        ],
        "target_related_schemas": [
            "Table: `t5`\nColumns:\n(c1, integer, )\n(c2, character varying(128), )\n"
        ]
    },
    {
        "sql_id": "postgresql_84_8",
        "database_name": "postgresql_84_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select hex(a) from t1; -- HEX",
        "target_query": "SELECT encode(a::bytea, 'hex') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, varchar(64), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, character varying(64), )\n"
        ]
    },
    {
        "sql_id": "postgresql_84_11",
        "database_name": "postgresql_84_11",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 VALUES (1,USER()); -- USER",
        "target_query": "INSERT INTO t1 VALUES (1, CURRENT_USER);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "USER"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "USER()",
                "description": "Returns the current MySQL user and host in the format 'username@hostname'.",
                "examples": [
                    "SELECT USER();"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CURRENT_USER",
                "description": "Returns the current user executing the query. Similar to MySQL's USER().",
                "examples": [
                    "SELECT CURRENT_USER;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, char(64), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, character(64), )\n"
        ]
    },
    {
        "sql_id": "postgresql_85_2",
        "database_name": "postgresql_85_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 123)); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 123));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, longtext, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_85_3",
        "database_name": "postgresql_85_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 234)); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 234));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, longtext, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_85_4",
        "database_name": "postgresql_85_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 345)); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 345));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, longtext, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_85_5",
        "database_name": "postgresql_85_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 456)); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 456));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, longtext, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_85_6",
        "database_name": "postgresql_85_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT LENGTH(c1) FROM t1; -- LENGTH",
        "target_query": "SELECT octet_length(c1) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, longtext, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_86_1",
        "database_name": "postgresql_86_1",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select NULL=NULL,NULL<>NULL,IFNULL(NULL,1.1)+0,IFNULL(NULL,1) | 0; -- IFNULL",
        "target_query": "SELECT NULL = NULL, NULL <> NULL, COALESCE(NULL, 1.1) + 0, COALESCE(NULL, 1) | 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IFNULL"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "PostgreSQL uses COALESCE, which returns the first non-NULL argument. This works exactly like IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_86_2",
        "database_name": "postgresql_86_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select strcmp(\"a\",NULL),(1<NULL),NULL regexp \"a\",null like \"a%\",\"a%\" like null; -- STRCMP",
        "target_query": "SELECT CASE WHEN 'a' = NULL THEN 0 WHEN 'a' < NULL THEN -1 ELSE 1 END, (1 < NULL), NULL ~ 'a', NULL LIKE 'a%', 'a%' LIKE NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "STRCMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "PostgreSQL does not have a direct STRCMP function. The equivalent behavior can be achieved using a CASE statement to compare two strings lexicographically and return -1, 0, or 1 based on the comparison.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_86_3",
        "database_name": "postgresql_86_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select repeat(\"a\",0),repeat(\"ab\",5+5),repeat(\"ab\",-1),reverse(NULL); -- REPEAT",
        "target_query": "SELECT REPEAT('a', 0), REPEAT('ab', 5 + 5), REPEAT('ab', -1), REVERSE(NULL);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_86_4",
        "database_name": "postgresql_86_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select field(NULL,\"a\",\"b\",\"c\"); -- FIELD",
        "target_query": "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], NULL), 0);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "FIELD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FIELD(val, val1, val2, ..., valN)",
                "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
                "examples": [
                    "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
                    "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
                    "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(array_position(ARRAY[val1, val2, ..., valN], val), 0)",
                "description": "Returns the index (1-based) of 'val' in the array. Returns 0 if not found, to match MySQL FIELD() behavior.",
                "examples": [
                    "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'c'), 0) AS result;",
                    "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'x'), 0) AS result;",
                    "SELECT COALESCE(array_position(ARRAY['b', 'b', 'b'], 'b'), 0) AS result;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_86_9",
        "database_name": "postgresql_86_9",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "CREATE TABLE t2 SELECT IFNULL(a, b) FROM t1; -- IFNULL",
        "target_query": "CREATE TABLE t2 AS SELECT COALESCE(a, b) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IFNULL"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "PostgreSQL uses COALESCE, which returns the first non-NULL argument. This works exactly like IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, decimal(1,0), )\n(b, decimal(1,0), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, numeric(1,0), )\n(b, numeric(1,0), )\n"
        ]
    },
    {
        "sql_id": "postgresql_86_11",
        "database_name": "postgresql_86_11",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "CREATE TABLE t2 SELECT IFNULL(a, NULL) FROM t1; -- IFNULL",
        "target_query": "CREATE TABLE t2 AS SELECT COALESCE(a, NULL) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IFNULL"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "PostgreSQL uses COALESCE, which returns the first non-NULL argument. This works exactly like IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, decimal(1,0), )\n(b, decimal(1,0), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, numeric(1,0), )\n(b, numeric(1,0), )\n"
        ]
    },
    {
        "sql_id": "postgresql_86_13",
        "database_name": "postgresql_86_13",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "CREATE TABLE t2 SELECT IFNULL(NULL, b) FROM t1; -- IFNULL",
        "target_query": "CREATE TABLE t2 AS SELECT COALESCE(NULL, b) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IFNULL"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "PostgreSQL uses COALESCE, which returns the first non-NULL argument. This works exactly like IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, decimal(1,0), )\n(b, decimal(1,0), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, numeric(1,0), )\n(b, numeric(1,0), )\n"
        ]
    },
    {
        "sql_id": "postgresql_87_2",
        "database_name": "postgresql_87_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 VALUES ( repeat( 'a', 10 ), 1),( repeat( 'b', 10 ), 2); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES ( repeat( 'a', 10 ), 1),( repeat( 'b', 10 ), 2);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, varchar(10), )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, character varying(10), )\n(b, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_87_3",
        "database_name": "postgresql_87_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT GROUP_CONCAT(a) FROM t1; -- GROUP_CONCAT",
        "target_query": "SELECT STRING_AGG(a, ',') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GROUP_CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
                "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
                "examples": [
                    "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
                    "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "STRING_AGG(expression, delimiter)",
                "description": "The STRING_AGG function in PostgreSQL concatenates values from multiple rows into a single string, separated by a specified delimiter.",
                "examples": [
                    "SELECT STRING_AGG(name, ', ') FROM students; -- Returns a comma-separated list of names"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, varchar(10), )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, character varying(10), )\n(b, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_87_5",
        "database_name": "postgresql_87_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT UNIX_TIMESTAMP(); -- UNIX_TIMESTAMP",
        "target_query": "SELECT EXTRACT(EPOCH FROM current_timestamp);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Extracts the number of seconds since the Unix epoch from a timestamp using the EPOCH keyword.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_88_0",
        "database_name": "postgresql_88_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select repeat('a',2000); -- REPEAT",
        "target_query": "select repeat('a',2000);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_88_1",
        "database_name": "postgresql_88_1",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT length(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\") as len; -- LENGTH",
        "target_query": "SELECT octet_length('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa') as len;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_88_2",
        "database_name": "postgresql_88_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select length(repeat('a',2000)); -- LENGTH, REPEAT",
        "target_query": "select octet_length(repeat('a',2000));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH",
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            },
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            },
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_88_9",
        "database_name": "postgresql_88_9",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT c11, LENGTH(c12) FROM t1; -- LENGTH",
        "target_query": "SELECT c11, octet_length(c12) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c11, int, )\n(c12, longtext, )\n",
            "Table: `t2`\nColumns:\n(c21, int, )\n(c22, longtext, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c11, integer, )\n(c12, text, )\n",
            "Table: `t2`\nColumns:\n(c21, integer, )\n(c22, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_89_3",
        "database_name": "postgresql_89_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select hex(a) from t1 where a like 'A_'; -- HEX",
        "target_query": "select encode(a::bytea, 'hex') from t1 where a like 'A_';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, varchar(50), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, character varying(50), )\n"
        ]
    },
    {
        "sql_id": "postgresql_89_5",
        "database_name": "postgresql_89_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "explain select hex(a) from t1 where a like 'A_'; -- HEX",
        "target_query": "explain select encode(a::bytea, 'hex') from t1 where a like 'A_';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, varchar(50), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, character varying(50), )\n"
        ]
    },
    {
        "sql_id": "postgresql_89_6",
        "database_name": "postgresql_89_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select hex(a) from t1; -- HEX",
        "target_query": "select encode(a::bytea, 'hex') from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, varchar(50), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, character varying(50), )\n"
        ]
    },
    {
        "sql_id": "postgresql_89_8",
        "database_name": "postgresql_89_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "create table t1 as select to_seconds(null) as to_seconds; -- TO_SECONDS",
        "target_query": "create table t1 as select (EXTRACT(EPOCH FROM NULL::timestamp) + 62167219200) as to_seconds;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TO_SECONDS"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TO_SECONDS(datetime_expr)",
                "description": "Returns the number of seconds since year 0 to the given datetime.",
                "examples": [
                    "SELECT TO_SECONDS('2000-01-01 00:00:00');",
                    "SELECT TO_SECONDS(NOW());",
                    "SELECT TO_SECONDS(NULL);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM ts) + 62167219200",
                "description": "Adds the number of seconds since year 1970 to the seconds between year 0 and 1970 to simulate TO_SECONDS.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2020-12-31 12:00:00') + 62167219200;",
                    "SELECT EXTRACT(EPOCH FROM NOW()) + 62167219200;"
                ]
            }
        ],
        "source_related_schemas": [
            "create table t1 as select to_seconds(null) as to_seconds; -- TO_SECONDS"
        ],
        "target_related_schemas": [
            "create table t1 as select (EXTRACT(EPOCH FROM NULL::timestamp) + 62167219200) as to_seconds;"
        ]
    },
    {
        "sql_id": "postgresql_9_0",
        "database_name": "postgresql_9_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT IF(0,\"ERROR\",\"this\"),IF(1,\"is\",\"ERROR\"),IF(NULL,\"ERROR\",\"a\"),IF(1,2,3),IF(1,2.0,3.0)+0; -- IF",
        "target_query": "SELECT CASE WHEN FALSE THEN 'ERROR' ELSE 'this' END, CASE WHEN TRUE THEN 'is' ELSE 'ERROR' END, CASE WHEN NULL THEN 'ERROR' ELSE 'a' END, (CASE WHEN TRUE THEN 2 ELSE 3 END), (CASE WHEN TRUE THEN 2.0 ELSE 3.0 END) + 0; -- AE",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "In PostgreSQL, `IF` is not directly supported. Instead, the `CASE WHEN` expression is used to evaluate a condition and return different values based on whether the condition is true or false.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_9_4",
        "database_name": "postgresql_9_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT IF(1,st,st) s FROM t1 ORDER BY s; -- IF",
        "target_query": "SELECT CASE WHEN TRUE THEN st ELSE st END AS s FROM t1 ORDER BY s;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "In PostgreSQL, `IF` is not directly supported. Instead, the `CASE WHEN` expression is used to evaluate a condition and return different values based on whether the condition is true or false.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(st, varchar(255), )\n(u, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(st, character varying(255), )\n(u, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_9_5",
        "database_name": "postgresql_9_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT IF(u=1,st,st) s FROM t1 ORDER BY s; -- IF",
        "target_query": "SELECT CASE WHEN u = 1 THEN st ELSE st END AS s FROM t1 ORDER BY s;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "In PostgreSQL, `IF` is not directly supported. Instead, the `CASE WHEN` expression is used to evaluate a condition and return different values based on whether the condition is true or false.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(st, varchar(255), )\n(u, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(st, character varying(255), )\n(u, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_9_7",
        "database_name": "postgresql_9_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select nullif(u, 1) from t1; -- NULLIF",
        "target_query": "select nullif(u, 1) from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "NULLIF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NULLIF(a, b)",
                "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
                "examples": [
                    "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
                    "SELECT NULLIF(YEAR('2021-01-01'), 2021) AS year_check;",
                    "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "NULLIF(a, b)",
                "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
                "examples": [
                    "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
                    "SELECT NULLIF(EXTRACT(YEAR FROM DATE '2021-01-01'), 2021) AS year_check;",
                    "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(st, varchar(255), )\n(u, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(st, character varying(255), )\n(u, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_9_8",
        "database_name": "postgresql_9_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "explain select nullif(u, 1) from t1; -- NULLIF",
        "target_query": "explain select nullif(u, 1) from t1; -- AE",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "NULLIF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NULLIF(a, b)",
                "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
                "examples": [
                    "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
                    "SELECT NULLIF(YEAR('2021-01-01'), 2021) AS year_check;",
                    "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "NULLIF(a, b)",
                "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
                "examples": [
                    "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
                    "SELECT NULLIF(EXTRACT(YEAR FROM DATE '2021-01-01'), 2021) AS year_check;",
                    "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(st, varchar(255), )\n(u, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(st, character varying(255), )\n(u, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_9_12",
        "database_name": "postgresql_9_12",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select sum(if(num is null,0.00,num)) from t1; -- IF",
        "target_query": "SELECT SUM(CASE WHEN num IS NULL THEN 0.00 ELSE num END) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "In PostgreSQL, `IF` is not directly supported. Instead, the `CASE WHEN` expression is used to evaluate a condition and return different values based on whether the condition is true or false.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(num, double(12,2), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(num, numeric(12,2), )\n"
        ]
    },
    {
        "sql_id": "postgresql_9_16",
        "database_name": "postgresql_9_16",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select min(if(y -x > 5,y,NULL)), max(if(y - x > 5,y,NULL)) from t1; -- IF",
        "target_query": "SELECT MIN(CASE WHEN y - x > 5 THEN y ELSE NULL END), MAX(CASE WHEN y - x > 5 THEN y ELSE NULL END) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "In PostgreSQL, `IF` is not directly supported. Instead, the `CASE WHEN` expression is used to evaluate a condition and return different values based on whether the condition is true or false.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(x, int, )\n(y, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(x, integer, )\n(y, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_9_18",
        "database_name": "postgresql_9_18",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT NULLIF(5,5) IS NULL, NULLIF(5,5) IS NOT NULL; -- NULLIF",
        "target_query": "SELECT NULLIF(5,5) IS NULL, NULLIF(5,5) IS NOT NULL; -- AE",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "NULLIF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NULLIF(a, b)",
                "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
                "examples": [
                    "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
                    "SELECT NULLIF(YEAR('2021-01-01'), 2021) AS year_check;",
                    "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "NULLIF(a, b)",
                "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
                "examples": [
                    "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
                    "SELECT NULLIF(EXTRACT(YEAR FROM DATE '2021-01-01'), 2021) AS year_check;",
                    "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_9_21",
        "database_name": "postgresql_9_21",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT id, IF(date IS NULL, '-', FROM_UNIXTIME(date, '%d-%m-%Y')) AS date_ord, text FROM t1 ORDER BY date_ord ASC; -- IF, FROM_UNIXTIME",
        "target_query": "SELECT id, CASE WHEN date IS NULL THEN '-' ELSE TO_CHAR(TO_TIMESTAMP(date), 'DD-MM-YYYY') END AS date_ord, text FROM t1 ORDER BY date_ord ASC;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF",
            "FROM_UNIXTIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            },
            {
                "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
                "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
                "examples": [
                    "SELECT FROM_UNIXTIME(1672531200);",
                    "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
                    "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "In PostgreSQL, `IF` is not directly supported. Instead, the `CASE WHEN` expression is used to evaluate a condition and return different values based on whether the condition is true or false.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            },
            {
                "expression": "TO_TIMESTAMP(unix_timestamp)",
                "description": "Converts a Unix timestamp (number of seconds since 1970-01-01 UTC) to a timestamp with time zone.",
                "examples": [
                    "SELECT TO_TIMESTAMP(1672531200);",
                    "SELECT TO_TIMESTAMP(1672531200.456);",
                    "SELECT id, TO_CHAR(TO_TIMESTAMP(created_at), 'YYYY-MM-DD') AS created_date FROM events;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(id, int, )\n(date, int, )\n(text, varchar(32), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(id, integer, )\n(date, integer, )\n(text, character varying(32), )\n"
        ]
    },
    {
        "sql_id": "postgresql_9_22",
        "database_name": "postgresql_9_22",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT id, IF(date IS NULL, '-', FROM_UNIXTIME(date, '%d-%m-%Y')) AS date_ord, text FROM t1 ORDER BY date_ord DESC; -- IF, FROM_UNIXTIME",
        "target_query": "SELECT id, CASE WHEN date IS NULL THEN '-' ELSE TO_CHAR(TO_TIMESTAMP(date), 'DD-MM-YYYY') END AS date_ord, text FROM t1 ORDER BY date_ord DESC;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF",
            "FROM_UNIXTIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            },
            {
                "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
                "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
                "examples": [
                    "SELECT FROM_UNIXTIME(1672531200);",
                    "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
                    "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "In PostgreSQL, `IF` is not directly supported. Instead, the `CASE WHEN` expression is used to evaluate a condition and return different values based on whether the condition is true or false.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            },
            {
                "expression": "TO_TIMESTAMP(unix_timestamp)",
                "description": "Converts a Unix timestamp (number of seconds since 1970-01-01 UTC) to a timestamp with time zone.",
                "examples": [
                    "SELECT TO_TIMESTAMP(1672531200);",
                    "SELECT TO_TIMESTAMP(1672531200.456);",
                    "SELECT id, TO_CHAR(TO_TIMESTAMP(created_at), 'YYYY-MM-DD') AS created_date FROM events;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(id, int, )\n(date, int, )\n(text, varchar(32), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(id, integer, )\n(date, integer, )\n(text, character varying(32), )\n"
        ]
    },
    {
        "sql_id": "postgresql_9_26",
        "database_name": "postgresql_9_26",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT * FROM (SELECT MAX(IF(1, CAST(c AS UNSIGNED), 0)) FROM t1) AS te; -- IF",
        "target_query": "SELECT * FROM (SELECT MAX(CASE WHEN TRUE THEN CAST(c AS NUMERIC) ELSE 0 END) FROM t1) AS te;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "In PostgreSQL, `IF` is not directly supported. Instead, the `CASE WHEN` expression is used to evaluate a condition and return different values based on whether the condition is true or false.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c, longtext, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_9_27",
        "database_name": "postgresql_9_27",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT * FROM (SELECT MAX(IFNULL(CAST(c AS UNSIGNED), 0)) FROM t1) AS te; -- IFNULL",
        "target_query": "SELECT * FROM (SELECT MAX(COALESCE(CAST(c AS NUMERIC), 0)) FROM t1) AS te;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IFNULL"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "PostgreSQL uses COALESCE, which returns the first non-NULL argument. This works exactly like IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c, longtext, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_9_29",
        "database_name": "postgresql_9_29",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT AVG(NULLIF(YEAR('2001-01-01'),10)); -- NULLIF, YEAR",
        "target_query": "SELECT AVG(NULLIF(EXTRACT(YEAR FROM DATE '2001-01-01'),10)); -- AE",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "NULLIF",
            "YEAR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NULLIF(a, b)",
                "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
                "examples": [
                    "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
                    "SELECT NULLIF(YEAR('2021-01-01'), 2021) AS year_check;",
                    "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
                ]
            },
            {
                "expression": "YEAR(date)",
                "description": "Extracts the year from a date or datetime and returns it as an integer.",
                "examples": [
                    "SELECT YEAR('2023-04-10');",
                    "SELECT YEAR(NOW());",
                    "SELECT YEAR('2022-03-15');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "NULLIF(a, b)",
                "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
                "examples": [
                    "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
                    "SELECT NULLIF(EXTRACT(YEAR FROM DATE '2021-01-01'), 2021) AS year_check;",
                    "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
                ]
            },
            {
                "expression": "EXTRACT(YEAR FROM date)",
                "description": "Extracts the year from a date or datetime and returns it as an integer.",
                "examples": [
                    "SELECT EXTRACT(YEAR FROM DATE '2023-04-10');",
                    "SELECT EXTRACT(YEAR FROM CURRENT_DATE);",
                    "SELECT EXTRACT(YEAR FROM DATE '2022-03-15');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_90_0",
        "database_name": "postgresql_90_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT FROM_DAYS(3652499), FROM_DAYS(3652500), FROM_DAYS(3652501); -- FROM_DAYS",
        "target_query": "SELECT DATE '1970-01-01' + (3652499 - 719528) * INTERVAL '1 day', DATE '1970-01-01' + (3652500 - 719528) * INTERVAL '1 day', DATE '1970-01-01' + (3652501 - 719528) * INTERVAL '1 day';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "FROM_DAYS"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FROM_DAYS(n)",
                "description": "Returns a date corresponding to the number of days since year 0.",
                "examples": [
                    "SELECT FROM_DAYS(1);",
                    "SELECT FROM_DAYS(730000);",
                    "SELECT CONCAT('Date is: ', FROM_DAYS(738000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "DATE '1970-01-01' + (n - 719528) * INTERVAL '1 day'",
                "description": "Simulates MySQL's FROM_DAYS(n) by interpreting n as the number of days since '0000-01-01', then adjusting from PostgreSQL's base date '1970-01-01' (which corresponds to day number 719528).",
                "examples": [
                    "SELECT DATE '1970-01-01' + (1 - 719528) * INTERVAL '1 day';",
                    "SELECT DATE '1970-01-01' + (730000 - 719528) * INTERVAL '1 day';",
                    "SELECT 'Date is: ' || (DATE '1970-01-01' + (738000 - 719528) * INTERVAL '1 day');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_90_1",
        "database_name": "postgresql_90_1",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT FROM_DAYS(42949670), FROM_DAYS(42949671), FROM_DAYS(42949673); -- FROM_DAYS",
        "target_query": "SELECT DATE '1970-01-01' + (42949670 - 719528) * INTERVAL '1 day', DATE '1970-01-01' + (42949671 - 719528) * INTERVAL '1 day', DATE '1970-01-01' + (42949673 - 719528) * INTERVAL '1 day';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "FROM_DAYS"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FROM_DAYS(n)",
                "description": "Returns a date corresponding to the number of days since year 0.",
                "examples": [
                    "SELECT FROM_DAYS(1);",
                    "SELECT FROM_DAYS(730000);",
                    "SELECT CONCAT('Date is: ', FROM_DAYS(738000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "DATE '1970-01-01' + (n - 719528) * INTERVAL '1 day'",
                "description": "Simulates MySQL's FROM_DAYS(n) by interpreting n as the number of days since '0000-01-01', then adjusting from PostgreSQL's base date '1970-01-01' (which corresponds to day number 719528).",
                "examples": [
                    "SELECT DATE '1970-01-01' + (1 - 719528) * INTERVAL '1 day';",
                    "SELECT DATE '1970-01-01' + (730000 - 719528) * INTERVAL '1 day';",
                    "SELECT 'Date is: ' || (DATE '1970-01-01' + (738000 - 719528) * INTERVAL '1 day');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_91_2",
        "database_name": "postgresql_91_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t VALUES (0, REPEAT('x', 120000)), (1, REPEAT('z', 12000)); -- REPEAT",
        "target_query": "INSERT INTO t VALUES (0, REPEAT('x', 120000)), (1, REPEAT('z', 12000));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t`\nColumns:\n(i, int, )\n(b, longtext, )\n"
        ],
        "target_related_schemas": [
            "Table: `t`\nColumns:\n(i, integer, )\n(b, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_91_4",
        "database_name": "postgresql_91_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT LENGTH(b) FROM (SELECT * FROM t INTERSECT SELECT * FROM t) derived; -- LENGTH",
        "target_query": "SELECT octet_length(b) FROM (SELECT * FROM t INTERSECT SELECT * FROM t) derived;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t`\nColumns:\n(i, int, )\n(b, longtext, )\n"
        ],
        "target_related_schemas": [
            "Table: `t`\nColumns:\n(i, integer, )\n(b, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_92_2",
        "database_name": "postgresql_92_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT argument FROM test_log WHERE argument LIKE CONCAT('%azun','dris%'); -- CONCAT",
        "target_query": "SELECT argument FROM test_log WHERE argument LIKE '%azun' || 'dris%';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `test_log`\nColumns:\n(argument, text, )\n"
        ],
        "target_related_schemas": [
            "Table: `test_log`\nColumns:\n(argument, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_93_0",
        "database_name": "postgresql_93_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select row(10,2,3) IN (row(3,2,3), row(1,2,3), row(1,3,3)); -- ROW",
        "target_query": "SELECT ROW(10,2,3) IN (ROW(3,2,3), ROW(1,2,3), ROW(1,3,3));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_93_1",
        "database_name": "postgresql_93_1",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select row(1,2,3) IN (row(3,NULL,3), row(1,2,3), row(1,3,3)); -- ROW",
        "target_query": "SELECT ROW(1,2,3) IN (ROW(3,NULL,3), ROW(1,2,3), ROW(1,3,3));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_93_2",
        "database_name": "postgresql_93_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select row(10,2,3) IN (row(3,NULL,3), row(1,2,3), row(1,3,3)); -- ROW",
        "target_query": "SELECT ROW(10,2,3) IN (ROW(3,NULL,3), ROW(1,2,3), ROW(1,3,3));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_93_12",
        "database_name": "postgresql_93_12",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select row(1,2,row(3,null)) IN (row(3,2,row(3,4)), row(1,2,row(4,5))); -- ROW",
        "target_query": "SELECT ROW(1,2,ROW(3,NULL)) IN (ROW(3,2,ROW(3,4)), ROW(1,2,ROW(4,5)));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_93_14",
        "database_name": "postgresql_93_14",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT ROW(1,2,3)=ROW(1,2,3); -- ROW",
        "target_query": "SELECT ROW(1,2,3)=ROW(1,2,3);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_93_15",
        "database_name": "postgresql_93_15",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT ROW(2,2,3)=ROW(1+1,2,3); -- ROW",
        "target_query": "SELECT ROW(2,2,3)=ROW(1+1,2,3);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_93_16",
        "database_name": "postgresql_93_16",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT ROW(1,2,3)=ROW(1+1,2,3); -- ROW",
        "target_query": "SELECT ROW(1,2,3)=ROW(1+1,2,3);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_93_17",
        "database_name": "postgresql_93_17",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT ROW(1,2,3)<ROW(1+1,2,3); -- ROW",
        "target_query": "SELECT ROW(1,2,3)<ROW(1+1,2,3);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_93_18",
        "database_name": "postgresql_93_18",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT ROW(1,2,3)>ROW(1+1,2,3); -- ROW",
        "target_query": "SELECT ROW(1,2,3)>ROW(1+1,2,3);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_93_19",
        "database_name": "postgresql_93_19",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT ROW(1,2,3)<=ROW(1+1,2,3); -- ROW",
        "target_query": "SELECT ROW(1,2,3)<=ROW(1+1,2,3);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_93_20",
        "database_name": "postgresql_93_20",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT ROW(1,2,3)>=ROW(1+1,2,3); -- ROW",
        "target_query": "SELECT ROW(1,2,3)>=ROW(1+1,2,3);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_93_21",
        "database_name": "postgresql_93_21",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT ROW(1,2,3)<>ROW(1+1,2,3); -- ROW",
        "target_query": "SELECT ROW(1,2,3)<>ROW(1+1,2,3);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_93_22",
        "database_name": "postgresql_93_22",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT ROW(NULL,2,3)=ROW(NULL,2,3); -- ROW",
        "target_query": "SELECT ROW(NULL,2,3)=ROW(NULL,2,3);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_93_23",
        "database_name": "postgresql_93_23",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT ROW(1,2,ROW(3,4,5))=ROW(1,2,ROW(3,4,5)); -- ROW",
        "target_query": "SELECT ROW(1,2,ROW(3,4,5))=ROW(1,2,ROW(3,4,5));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_93_24",
        "database_name": "postgresql_93_24",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT ROW('test',2,3.33)=ROW('test',2,3.33); -- ROW",
        "target_query": "SELECT ROW('test',2,3.33)=ROW('test',2,3.33);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_93_25",
        "database_name": "postgresql_93_25",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT ROW('test',2,ROW(3,33))=ROW('test',2,ROW(3,33)); -- ROW",
        "target_query": "SELECT ROW('test',2,ROW(3,33))=ROW('test',2,ROW(3,33));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_93_26",
        "database_name": "postgresql_93_26",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT ROW('test',2,ROW(3,33))=ROW('test',2,ROW(3,3)); -- ROW",
        "target_query": "SELECT ROW('test',2,ROW(3,33))=ROW('test',2,ROW(3,3));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_94_3",
        "database_name": "postgresql_94_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select * from t1 where ROW(1,2,3)=ROW(a,b,c); -- ROW",
        "target_query": "select * from t1 where ROW(1,2,3)=ROW(a,b,c);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, int, )\n(c, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, integer, )\n(c, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_94_4",
        "database_name": "postgresql_94_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select * from t1 where ROW(0,2,3)=ROW(a,b,c); -- ROW",
        "target_query": "select * from t1 where ROW(0,2,3)=ROW(a,b,c);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, int, )\n(c, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, integer, )\n(c, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_94_5",
        "database_name": "postgresql_94_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select * from t1 where ROW(1,2,3)<ROW(a,b,c); -- ROW",
        "target_query": "select * from t1 where ROW(1,2,3)<ROW(a,b,c);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, int, )\n(c, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, integer, )\n(c, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_94_6",
        "database_name": "postgresql_94_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select ROW(a,2,3) IN(row(1,b,c), row(2,3,1)) from t1; -- ROW",
        "target_query": "select ROW(a,2,3) IN(row(1,b,c), row(2,3,1)) from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, int, )\n(c, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, integer, )\n(c, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_94_7",
        "database_name": "postgresql_94_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select ROW(c,2,3) IN(row(1,b,a), row(2,3,1)) from t1; -- ROW",
        "target_query": "select ROW(c,2,3) IN(row(1,b,a), row(2,3,1)) from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, int, )\n(c, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, integer, )\n(c, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_94_8",
        "database_name": "postgresql_94_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select ROW(a,b,c) IN(row(1,2,3), row(3,2,1)) from t1; -- ROW",
        "target_query": "select ROW(a,b,c) IN(row(1,2,3), row(3,2,1)) from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, int, )\n(c, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, integer, )\n(c, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_94_9",
        "database_name": "postgresql_94_9",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select ROW(1,2,3) IN(row(a,b,c), row(1,2,3)) from t1; -- ROW",
        "target_query": "select ROW(1,2,3) IN(row(a,b,c), row(1,2,3)) from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, int, )\n(c, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, integer, )\n(c, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_94_11",
        "database_name": "postgresql_94_11",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT ROW(1,1,1) = ROW(1,1,1), ROW(1,1,1) = ROW(1,2,1), ROW(1,NULL,1) = ROW(2,2,1), ROW(1,NULL,1) = ROW(1,2,2), ROW(1,NULL,1) = ROW(1,2,1) ; -- ROW",
        "target_query": "SELECT ROW(1,1,1) = ROW(1,1,1), ROW(1,1,1) = ROW(1,2,1), ROW(1,NULL,1) = ROW(2,2,1), ROW(1,NULL,1) = ROW(1,2,2), ROW(1,NULL,1) = ROW(1,2,1);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_95_3",
        "database_name": "postgresql_95_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT ROW(a, 1) IN (SELECT SUM(b), 1) FROM t1 GROUP BY a; -- ROW",
        "target_query": "SELECT ROW(a, 1) IN (SELECT SUM(b), 1) FROM t1 GROUP BY a;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_95_4",
        "database_name": "postgresql_95_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT ROW(a, 1) IN (SELECT SUM(b), 3) FROM t1 GROUP BY a; -- ROW",
        "target_query": "SELECT ROW(a, 1) IN (SELECT SUM(b), 3) FROM t1 GROUP BY a;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_95_8",
        "database_name": "postgresql_95_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT 1 FROM t1 WHERE ROW(a, b) >=ROW('1', (SELECT 1 FROM t1 WHERE a > '1234')); -- ROW",
        "target_query": "SELECT 1 FROM t1 WHERE ROW(a, b) >= ROW('1', (SELECT 1 FROM t1 WHERE a > '1234'));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, tinyint, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, smallint, )\n"
        ]
    },
    {
        "sql_id": "postgresql_95_12",
        "database_name": "postgresql_95_12",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT ROW(1,2) = (SELECT 1,2 FROM t1 WHERE 1 = 0); -- ROW",
        "target_query": "SELECT ROW(1,2) = (SELECT 1,2 FROM t1 WHERE 1 = 0);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(i, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(i, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_95_13",
        "database_name": "postgresql_95_13",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT ROW(1,2) = (SELECT 1,3 FROM t1 WHERE 1 = 0); -- ROW",
        "target_query": "SELECT ROW(1,2) = (SELECT 1,3 FROM t1 WHERE 1 = 0);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(i, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(i, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_95_18",
        "database_name": "postgresql_95_18",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "EXPLAIN SELECT row( min(a), 1 ) = row( a, 1 ) AS al FROM t1 GROUP BY a; -- ROW",
        "target_query": "EXPLAIN SELECT row( min(a), 1 ) = row( a, 1 ) AS al FROM t1 GROUP BY a;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_95_19",
        "database_name": "postgresql_95_19",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT row( min(a), 1 ) = row( a, 1 ) AS al FROM t1 GROUP BY a; -- ROW",
        "target_query": "SELECT row( min(a), 1 ) = row( a, 1 ) AS al FROM t1 GROUP BY a;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_96_0",
        "database_name": "postgresql_96_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT RPAD(NULL, 5, 'x') AS result; -- RPAD",
        "target_query": "SELECT RPAD(NULL, 5, 'x') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "PostgreSQL doesn't have a native RPAD, but can simulate it.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::text, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_96_1",
        "database_name": "postgresql_96_1",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT RPAD(NULL, NULL, 'x') AS result; -- RPAD",
        "target_query": "SELECT RPAD(NULL, NULL, 'x') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "PostgreSQL doesn't have a native RPAD, but can simulate it.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::text, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_96_2",
        "database_name": "postgresql_96_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT RPAD(NULL, NULL, NULL) AS result; -- RPAD",
        "target_query": "SELECT RPAD(NULL, NULL, NULL) AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "PostgreSQL doesn't have a native RPAD, but can simulate it.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::text, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_96_3",
        "database_name": "postgresql_96_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT RPAD('a', NULL, 'x') AS result; -- RPAD",
        "target_query": "SELECT RPAD('a', NULL, 'x') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "PostgreSQL doesn't have a native RPAD, but can simulate it.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::text, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_96_4",
        "database_name": "postgresql_96_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT RPAD('a', NULL, NULL) AS result; -- RPAD",
        "target_query": "SELECT RPAD('a', NULL, NULL) AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "PostgreSQL doesn't have a native RPAD, but can simulate it.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::text, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_96_5",
        "database_name": "postgresql_96_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT RPAD('a', 5, NULL) AS result; -- RPAD",
        "target_query": "SELECT RPAD('a', 5, NULL) AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "PostgreSQL doesn't have a native RPAD, but can simulate it.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::text, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_96_6",
        "database_name": "postgresql_96_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT RPAD(NULL, 5, NULL) AS result; -- RPAD",
        "target_query": "SELECT RPAD(NULL, 5, NULL) AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "PostgreSQL doesn't have a native RPAD, but can simulate it.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::text, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_96_7",
        "database_name": "postgresql_96_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT RPAD('a', 0, 'x') AS result; -- RPAD",
        "target_query": "SELECT RPAD('a', 0, 'x') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "PostgreSQL doesn't have a native RPAD, but can simulate it.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::text, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_96_8",
        "database_name": "postgresql_96_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT RPAD('a', 0, '') AS result; -- RPAD",
        "target_query": "SELECT RPAD('a', 0, '') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "PostgreSQL doesn't have a native RPAD, but can simulate it.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::text, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_96_9",
        "database_name": "postgresql_96_9",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT RPAD('', 0, 'x') AS result; -- RPAD",
        "target_query": "SELECT RPAD('', 0, 'x') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "PostgreSQL doesn't have a native RPAD, but can simulate it.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::text, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_96_10",
        "database_name": "postgresql_96_10",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT RPAD('', 0, '') AS result; -- RPAD",
        "target_query": "SELECT RPAD('', 0, '') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "PostgreSQL doesn't have a native RPAD, but can simulate it.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::text, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_96_11",
        "database_name": "postgresql_96_11",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT RPAD('a', -1, 'x'); -- RPAD",
        "target_query": "SELECT RPAD('a', -1, 'x');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "PostgreSQL doesn't have a native RPAD, but can simulate it.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::text, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_96_12",
        "database_name": "postgresql_96_12",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT RPAD('123456787890', 1, 'x'); -- RPAD",
        "target_query": "SELECT RPAD('123456787890', 1, 'x');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "PostgreSQL doesn't have a native RPAD, but can simulate it.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::text, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_96_13",
        "database_name": "postgresql_96_13",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT RPAD('a', 5, 'xy'); -- RPAD",
        "target_query": "SELECT RPAD('a', 5, 'xy');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "PostgreSQL doesn't have a native RPAD, but can simulate it.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::text, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_96_14",
        "database_name": "postgresql_96_14",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT RPAD(\"I LOVE SQL\", 20, \" \"); -- RPAD",
        "target_query": "SELECT RPAD('I LOVE SQL', 20, ' ');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "PostgreSQL doesn't have a native RPAD, but can simulate it.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::text, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_96_15",
        "database_name": "postgresql_96_15",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT RPAD(\"I LOVE SQL in the morning\", 20, \" \"); -- RPAD",
        "target_query": "SELECT RPAD('I LOVE SQL in the morning', 20, ' ');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "PostgreSQL doesn't have a native RPAD, but can simulate it.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::text, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_97_6",
        "database_name": "postgresql_97_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "EXPLAIN SELECT * FROM t1 WHERE ISNULL(t1.a IN (SELECT t3.a FROM t1 t3)); -- ISNULL",
        "target_query": "EXPLAIN SELECT * FROM t1 WHERE (t1.a IN (SELECT t3.a FROM t1 t3)) IS NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ISNULL"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "ISNULL(expr)",
                "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
                "examples": [
                    "SELECT ISNULL(NULL);",
                    "SELECT ISNULL(5 + NULL);",
                    "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "expr IS NULL",
                "description": "Standard SQL syntax for checking if a value is NULL.",
                "examples": [
                    "SELECT NULL IS NULL;",
                    "SELECT (5 + NULL) IS NULL;",
                    "SELECT CASE WHEN score IS NULL THEN 'N/A' ELSE score::text END FROM students;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_97_7",
        "database_name": "postgresql_97_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT * FROM t1 WHERE ISNULL(t1.a IN (SELECT t3.a FROM t1 t3)); -- ISNULL",
        "target_query": "SELECT * FROM t1 WHERE (t1.a IN (SELECT t3.a FROM t1 t3)) IS NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ISNULL"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "ISNULL(expr)",
                "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
                "examples": [
                    "SELECT ISNULL(NULL);",
                    "SELECT ISNULL(5 + NULL);",
                    "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "expr IS NULL",
                "description": "Standard SQL syntax for checking if a value is NULL.",
                "examples": [
                    "SELECT NULL IS NULL;",
                    "SELECT (5 + NULL) IS NULL;",
                    "SELECT CASE WHEN score IS NULL THEN 'N/A' ELSE score::text END FROM students;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_98_4",
        "database_name": "postgresql_98_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "EXPLAIN SELECT * FROM t1 WHERE (SELECT b FROM t2 WHERE CAST(UUID() AS CHAR) = CAST(t2.a AS CHAR)) > 0; -- UUID",
        "target_query": "EXPLAIN SELECT * FROM t1 WHERE (SELECT b FROM t2 WHERE gen_random_uuid()::TEXT = t2.a::TEXT) > 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UUID"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UUID()",
                "description": "In MySQL, the UUID() function generates a unique 128-bit identifier, typically represented as a string containing numbers and letters, in the standard UUID format.",
                "examples": [
                    "SELECT UUID();",
                    "SELECT CONCAT(UUID(), 'some_random_string');",
                    "SELECT UPPER(UUID());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "gen_random_uuid()",
                "description": "In PostgreSQL, the gen_random_uuid() function generates a unique UUID. It requires the pgcrypto extension to be installed.",
                "examples": [
                    "SELECT gen_random_uuid();",
                    "SELECT CONCAT(gen_random_uuid(), 'some_random_string');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(x, int, )\n(y, int, )\n",
            "Table: `t2`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(x, integer, )\n(y, integer, )\n",
            "Table: `t2`\nColumns:\n(a, integer, )\n(b, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_98_14",
        "database_name": "postgresql_98_14",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ; -- COALESCE",
        "target_query": "SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "COALESCE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
                "description": "Returns the first non-NULL value, or merges table partitions.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
                    "ALTER TABLE t1 COALESCE PARTITION 2;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...)",
                "description": "Standard SQL COALESCE function for NULL-handling.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n",
            "Table: `t3`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n",
            "Table: `t3`\nColumns:\n(a, integer, )\n(b, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_98_15",
        "database_name": "postgresql_98_15",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "EXPLAIN SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ; -- COALESCE",
        "target_query": "EXPLAIN SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "COALESCE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
                "description": "Returns the first non-NULL value, or merges table partitions.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
                    "ALTER TABLE t1 COALESCE PARTITION 2;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...)",
                "description": "Standard SQL COALESCE function for NULL-handling.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n",
            "Table: `t3`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n",
            "Table: `t3`\nColumns:\n(a, integer, )\n(b, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_98_16",
        "database_name": "postgresql_98_16",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT (SELECT IFNULL(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ; -- IFNULL",
        "target_query": "SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IFNULL"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "PostgreSQL uses COALESCE, which returns the first non-NULL argument. This works exactly like IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n",
            "Table: `t3`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n",
            "Table: `t3`\nColumns:\n(a, integer, )\n(b, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_98_17",
        "database_name": "postgresql_98_17",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "EXPLAIN SELECT (SELECT IFNULL(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ; -- IFNULL",
        "target_query": "EXPLAIN SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IFNULL"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "PostgreSQL uses COALESCE, which returns the first non-NULL argument. This works exactly like IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n",
            "Table: `t3`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n",
            "Table: `t3`\nColumns:\n(a, integer, )\n(b, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_99_6",
        "database_name": "postgresql_99_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT TRIM(f1), COUNT(*) FROM table_varchar_pad_space GROUP BY f1; -- TRIM, COUNT",
        "target_query": "SELECT TRIM(f1), COUNT(*) FROM table_varchar_pad_space GROUP BY f1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TRIM",
            "COUNT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            },
            {
                "expression": "COUNT()",
                "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
                "examples": [
                    "EXPLAIN FORMAT=TREE SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
                    "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
                    "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "The TRIM function works in the same way as MySQL, removing unwanted characters from the string. If no character is specified, spaces are removed by default.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            },
            {
                "expression": "COUNT()",
                "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
                "examples": [
                    "EXPLAIN SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
                    "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
                    "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `table_varchar_pad_space`\nColumns:\n(f1, varchar(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `table_varchar_pad_space`\nColumns:\n(f1, character varying(20), )\n"
        ]
    },
    {
        "sql_id": "postgresql_10_3",
        "database_name": "postgresql_10_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select a1,a2,b,min(c) from t1 where (ord(a1) > 97) and (ord(a2) + ord(a1) > 194) and (b = 'a') group by a1,a2,b; -- ORD",
        "target_query": "select a1,a2,b,min(c) from t1 where (ascii(a1) > 97) and (ascii(a2) + ascii(a1) > 194) and (b = 'a') group by a1,a2,b;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ORD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "ORD(string)",
                "description": "The ORD() function returns the Unicode code point of the first character of a string.",
                "examples": [
                    "SELECT ORD('A');",
                    "SELECT ORD('B');",
                    "SELECT ORD('C') > 60;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "ASCII(string)",
                "description": "PostgreSQL uses ASCII() to return the ASCII value of the first byte of a string. For multi-byte characters, custom handling is required.",
                "examples": [
                    "SELECT ASCII('A');",
                    "SELECT ASCII('B');",
                    "SELECT ASCII('C') > 60;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a1, char(64), )\n(a2, char(64), )\n(b, char(16), )\n(c, char(16), )\n(d, char(16), )\n(dummy, char(248), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a1, character(64), )\n(a2, character(64), )\n(b, character(16), )\n(c, character(16), )\n(d, character(16), )\n(dummy, character(248), )\n"
        ]
    },
    {
        "sql_id": "postgresql_10_4",
        "database_name": "postgresql_10_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select concat(a1,min(c)),b from t1 where a1 < 'd' group by a1,a2,b; -- CONCAT",
        "target_query": "select a1 || min(c),b from t1 where a1 < 'd' group by a1,a2,b;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a1, char(64), )\n(a2, char(64), )\n(b, char(16), )\n(c, char(16), )\n(d, char(16), )\n(dummy, char(248), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a1, character(64), )\n(a2, character(64), )\n(b, character(16), )\n(c, character(16), )\n(d, character(16), )\n(dummy, character(248), )\n"
        ]
    },
    {
        "sql_id": "postgresql_10_5",
        "database_name": "postgresql_10_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select concat(a1,min(c)),b,max(c) from t1 where a1 < 'd' group by a1,a2,b; -- CONCAT",
        "target_query": "select a1 || min(c),b,max(c) from t1 where a1 < 'd' group by a1,a2,b;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a1, char(64), )\n(a2, char(64), )\n(b, char(16), )\n(c, char(16), )\n(d, char(16), )\n(dummy, char(248), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a1, character(64), )\n(a2, character(64), )\n(b, character(16), )\n(c, character(16), )\n(d, character(16), )\n(dummy, character(248), )\n"
        ]
    },
    {
        "sql_id": "postgresql_10_6",
        "database_name": "postgresql_10_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select concat(a1,a2),b,min(c),max(c) from t1 where a1 < 'd' group by a1,a2,b; -- CONCAT",
        "target_query": "select a1 || a2,b,min(c),max(c) from t1 where a1 < 'd' group by a1,a2,b;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a1, char(64), )\n(a2, char(64), )\n(b, char(16), )\n(c, char(16), )\n(d, char(16), )\n(dummy, char(248), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a1, character(64), )\n(a2, character(64), )\n(b, character(16), )\n(c, character(16), )\n(d, character(16), )\n(dummy, character(248), )\n"
        ]
    },
    {
        "sql_id": "postgresql_10_7",
        "database_name": "postgresql_10_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select concat(ord(min(b)),ord(max(b))),min(b),max(b) from t1 group by a1,a2; -- CONCAT, ORD",
        "target_query": "select (ascii(min(b))::text || ascii(max(b))::text),min(b),max(b) from t1 group by a1,a2;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT",
            "ORD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            },
            {
                "expression": "ORD(string)",
                "description": "The ORD() function returns the Unicode code point of the first character of a string.",
                "examples": [
                    "SELECT ORD('A');",
                    "SELECT ORD('B');",
                    "SELECT ORD('C') > 60;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            },
            {
                "expression": "ASCII(string)",
                "description": "PostgreSQL uses ASCII() to return the ASCII value of the first byte of a string. For multi-byte characters, custom handling is required.",
                "examples": [
                    "SELECT ASCII('A');",
                    "SELECT ASCII('B');",
                    "SELECT ASCII('C') > 60;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a1, char(64), )\n(a2, char(64), )\n(b, char(16), )\n(c, char(16), )\n(d, char(16), )\n(dummy, char(248), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a1, character(64), )\n(a2, character(64), )\n(b, character(16), )\n(c, character(16), )\n(d, character(16), )\n(dummy, character(248), )\n"
        ]
    },
    {
        "sql_id": "postgresql_11_3",
        "database_name": "postgresql_11_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select Fld1, max(Fld2) from t1 group by Fld1 having std(Fld2) is not null; -- STD",
        "target_query": "select Fld1, max(Fld2) from t1 group by Fld1 having stddev(Fld2) is not null;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "STD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STD(expression)",
                "description": "Calculates the standard deviation for the sample of a given expression.",
                "examples": [
                    "SELECT some_dimension, COUNT(*), MIN(some_expression), MAX(some_expression), SUM(some_expression), AVG(some_expression), STD(some_expression) FROM some_data GROUP BY some_dimension LIMIT 5;",
                    "SELECT another_dimension, COUNT(*), STD(expression1 / expression2) FROM another_data GROUP BY another_dimension ORDER BY another_dimension;",
                    "SELECT ROUND(STD(expression1 / expression2), 5) FROM more_data;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "stddev(expression)",
                "description": "Calculates the standard deviation for the sample of a given expression.",
                "examples": [
                    "SELECT some_dimension, COUNT(*), MIN(some_expression), MAX(some_expression), SUM(some_expression), AVG(some_expression), stddev(some_expression) FROM some_data GROUP BY some_dimension LIMIT 5;",
                    "SELECT another_dimension, COUNT(*), stddev(expression1 / expression2) FROM another_data GROUP BY another_dimension ORDER BY another_dimension;",
                    "SELECT ROUND(stddev(expression1 / expression2), 5) FROM more_data;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(Fld1, int, )\n(Fld2, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(fld1, integer, )\n(fld2, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_11_4",
        "database_name": "postgresql_11_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select Fld1, max(Fld2) from t1 group by Fld1 having variance(Fld2) is not null; -- VARIANCE",
        "target_query": "select Fld1, max(Fld2) from t1 group by Fld1 having variance(Fld2) is not null;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "VARIANCE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "VARIANCE(column1)",
                "description": "In MySQL, the VARIANCE() function calculates the variance of a given column of numeric values. It is used to measure the spread or dispersion of the data in a column.",
                "examples": [
                    "SELECT VARIANCE(column1) AS variance_value FROM some_table;",
                    "SELECT department, VARIANCE(salary) AS department_salary_variance FROM employees GROUP BY department;",
                    "SELECT VARIANCE(price) AS price_variance FROM items;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "VARIANCE(column1)",
                "description": "PostgreSQL has the VARIANCE() function, which calculates the variance for a specified column of numeric data. It returns the population variance (using all data points).",
                "examples": [
                    "SELECT VARIANCE(column1) AS variance_value FROM some_table;",
                    "SELECT department, VARIANCE(salary) AS department_salary_variance FROM employees GROUP BY department;",
                    "SELECT VARIANCE(price) AS price_variance FROM items;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(Fld1, int, )\n(Fld2, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(fld1, integer, )\n(fld2, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_12_8",
        "database_name": "postgresql_12_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "insert into t3 select concat('c-', 1000+A.a, '=w'), concat('c-', 2000+A.a, '=w'),'filler-1' from t2 A; -- CONCAT",
        "target_query": "INSERT INTO t3 SELECT 'c-' || 1000+A.a || '=w', 'c-' || 2000+A.a || '=w', 'filler-1' FROM t2 A;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n",
            "Table: `t2`\nColumns:\n(a, int, )\n",
            "Table: `t3`\nColumns:\n(a, char(8), )\n(b, char(8), )\n(filler, char(200), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n",
            "Table: `t2`\nColumns:\n(a, integer, )\n",
            "Table: `t3`\nColumns:\n(a, character(8), )\n(b, character(8), )\n(filler, character(200), )\n"
        ]
    },
    {
        "sql_id": "postgresql_12_9",
        "database_name": "postgresql_12_9",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "insert into t3 select concat('c-', 1000+A.a, '=w'), concat('c-', 3000+A.a, '=w'),'filler-2' from t2 A; -- CONCAT",
        "target_query": "INSERT INTO t3 SELECT 'c-' || 1000+A.a || '=w', 'c-' || 3000+A.a || '=w', 'filler-2' FROM t2 A;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n",
            "Table: `t2`\nColumns:\n(a, int, )\n",
            "Table: `t3`\nColumns:\n(a, char(8), )\n(b, char(8), )\n(filler, char(200), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n",
            "Table: `t2`\nColumns:\n(a, integer, )\n",
            "Table: `t3`\nColumns:\n(a, character(8), )\n(b, character(8), )\n(filler, character(200), )\n"
        ]
    },
    {
        "sql_id": "postgresql_12_23",
        "database_name": "postgresql_12_23",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "update t1 set b=repeat(char(65+a), 20) where a < 25; -- REPEAT",
        "target_query": "UPDATE t1 SET b=REPEAT((65+a)::char, 20) WHERE a < 25;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t0`\nColumns:\n(a, int, )\n",
            "Table: `t1`\nColumns:\n(a, int, )\n(b, char(20), )\n(filler, char(200), )\n"
        ],
        "target_related_schemas": [
            "Table: `t0`\nColumns:\n(a, integer, )\n",
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, character(20), )\n(filler, character(200), )\n"
        ]
    },
    {
        "sql_id": "postgresql_12_24",
        "database_name": "postgresql_12_24",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "explain select * from t1 where a < 10 and b = repeat(char(65+a), 20); -- REPEAT",
        "target_query": "EXPLAIN SELECT * FROM t1 WHERE a < 10 AND b = REPEAT((65+a)::char, 20);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t0`\nColumns:\n(a, int, )\n",
            "Table: `t1`\nColumns:\n(a, int, )\n(b, char(20), )\n(filler, char(200), )\n"
        ],
        "target_related_schemas": [
            "Table: `t0`\nColumns:\n(a, integer, )\n",
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, character(20), )\n(filler, character(200), )\n"
        ]
    },
    {
        "sql_id": "postgresql_12_25",
        "database_name": "postgresql_12_25",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select * from t1 where a < 10 and b = repeat(char(65+a), 20); -- REPEAT",
        "target_query": "SELECT * FROM t1 WHERE a < 10 AND b = REPEAT((65+a)::char, 20);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t0`\nColumns:\n(a, int, )\n",
            "Table: `t1`\nColumns:\n(a, int, )\n(b, char(20), )\n(filler, char(200), )\n"
        ],
        "target_related_schemas": [
            "Table: `t0`\nColumns:\n(a, integer, )\n",
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, character(20), )\n(filler, character(200), )\n"
        ]
    },
    {
        "sql_id": "postgresql_14_3",
        "database_name": "postgresql_14_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "UPDATE t1 set data=repeat('a',18*1024); -- REPEAT",
        "target_query": "UPDATE t1 SET data = repeat('a', 18*1024)::bytea;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(data, longblob, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(data, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_14_4",
        "database_name": "postgresql_14_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select length(data) from t1; -- LENGTH",
        "target_query": "SELECT octet_length(data) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(data, longblob, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(data, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_14_7",
        "database_name": "postgresql_14_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 (data) VALUES (repeat('a',1*1024)); -- REPEAT",
        "target_query": "INSERT INTO t1 (data) VALUES (repeat('a', 1*1024)::bytea);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(data, longblob, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(data, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_14_8",
        "database_name": "postgresql_14_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 (data) VALUES (repeat('b',16*1024-1024)); -- REPEAT",
        "target_query": "INSERT INTO t1 (data) VALUES (repeat('b', 16*1024 - 1024)::bytea);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(data, longblob, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(data, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_14_10",
        "database_name": "postgresql_14_10",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "UPDATE t1 set data=repeat('c',17*1024); -- REPEAT",
        "target_query": "UPDATE t1 SET data = repeat('c', 17*1024)::bytea;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(data, longblob, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(data, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_14_13",
        "database_name": "postgresql_14_13",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 set data=repeat('a',18*1024); -- REPEAT",
        "target_query": "INSERT INTO t1 (data) VALUES (repeat('a', 18*1024)::bytea);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(data, longblob, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(data, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_14_14",
        "database_name": "postgresql_14_14",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select length(data) from t1; -- LENGTH",
        "target_query": "SELECT octet_length(data) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(data, longblob, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(data, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_15_0",
        "database_name": "postgresql_15_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT UNIX_TIMESTAMP('2011-01-01 00:00:00') as time_t,UNIX_TIMESTAMP('2011-01-01 00:00:00') % 3 as part,1234567890 % 3 as part2; -- UNIX_TIMESTAMP",
        "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2011-01-01 00:00:00') as time_t, EXTRACT(EPOCH FROM TIMESTAMP '2011-01-01 00:00:00') % 3 as part, 1234567890 % 3 as part2;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Extracts the number of seconds since the Unix epoch from a timestamp using the EPOCH keyword.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_15_3",
        "database_name": "postgresql_15_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t3 (a) VALUES (NOW()); -- NOW",
        "target_query": "INSERT INTO t3 (a) VALUES (CURRENT_TIMESTAMP);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "NOW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "In PostgreSQL, CURRENT_TIMESTAMP is used to retrieve the current date and time, equivalent to NOW() in MySQL and MariaDB.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t3`\nColumns:\n(a, timestamp, )\n(b, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t3`\nColumns:\n(a, timestamp without time zone, )\n(b, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_15_13",
        "database_name": "postgresql_15_13",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t2 VALUES (1 + (SELECT a FROM t1),CONCAT(\"subq: \", (SELECT b FROM t1))); -- CONCAT",
        "target_query": "INSERT INTO t2 (a, b) SELECT 1 + a, 'subq: ' || b FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, varchar(64), )\n",
            "Table: `t2`\nColumns:\n(a, int, )\n(b, varchar(64), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, character varying(64), )\n",
            "Table: `t2`\nColumns:\n(a, integer, )\n(b, character varying(64), )\n"
        ]
    },
    {
        "sql_id": "postgresql_16_0",
        "database_name": "postgresql_16_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select USER(),CURRENT_USER(); -- USER, CURRENT_USER",
        "target_query": "SELECT CURRENT_USER, CURRENT_USER;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "USER",
            "CURRENT_USER"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "USER()",
                "description": "Returns the current MySQL user and host in the format 'username@hostname'.",
                "examples": [
                    "SELECT USER();"
                ]
            },
            {
                "expression": "CURRENT_USER()",
                "description": "Returns the account name of the user that the server used to authenticate the current client, in 'user_name@host_name' format.",
                "examples": [
                    "SELECT CURRENT_USER();",
                    "SELECT USER(), CURRENT_USER();",
                    "SELECT CURRENT_USER() = USER();"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CURRENT_USER",
                "description": "Returns the current user executing the query. Similar to MySQL's USER().",
                "examples": [
                    "SELECT CURRENT_USER;"
                ]
            },
            {
                "expression": "CURRENT_USER",
                "description": "Returns the name of the user that the current session is executing as (authenticated role). No parentheses required.",
                "examples": [
                    "SELECT CURRENT_USER;",
                    "SELECT SESSION_USER, CURRENT_USER;",
                    "SELECT CURRENT_USER = SESSION_USER;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_17_2",
        "database_name": "postgresql_17_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a' IN 'abc');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_3",
        "database_name": "postgresql_17_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('b' IN 'abc');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_4",
        "database_name": "postgresql_17_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('c' IN 'abc');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_5",
        "database_name": "postgresql_17_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('d' IN 'abc');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_6",
        "database_name": "postgresql_17_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a' IN NULL);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_7",
        "database_name": "postgresql_17_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION(NULL IN 'a');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_8",
        "database_name": "postgresql_17_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( NULL, NULL ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION(NULL IN NULL);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_9",
        "database_name": "postgresql_17_9",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT hex( concat(regexp_instr( 'a', 'a' )) ); -- HEX, CONCAT, REGEXP_INSTR",
        "target_query": "SELECT encode(('a' || POSITION('a' IN 'a'))::bytea, 'hex');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX",
            "CONCAT",
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            },
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            },
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            },
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            },
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_10",
        "database_name": "postgresql_17_10",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( 1, 'a' ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a' IN '1');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_11",
        "database_name": "postgresql_17_11",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( 1.1, 'a' ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a' IN '1.1');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_12",
        "database_name": "postgresql_17_12",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( 'a', 1 ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('1' IN 'a');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_13",
        "database_name": "postgresql_17_13",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( 'a', 1.1 ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('1.1' IN 'a');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_14",
        "database_name": "postgresql_17_14",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( subject, pattern ) FROM t1; -- REGEXP_INSTR",
        "target_query": "SELECT POSITION(pattern IN subject) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_15",
        "database_name": "postgresql_17_15",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1 ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a+' IN 'abcabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_16",
        "database_name": "postgresql_17_16",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 2 ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a+' IN 'abcabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_17",
        "database_name": "postgresql_17_17",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( 'abcabcabc', 'b+', 1 ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('b+' IN 'abcabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_18",
        "database_name": "postgresql_17_18",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( 'abcabcabc', 'b+', 2 ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('b+' IN 'abcabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_19",
        "database_name": "postgresql_17_19",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( 'abcabcabc', 'b+', 3 ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('b+' IN 'abcabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_20",
        "database_name": "postgresql_17_20",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 2 ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a+' IN 'abcabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_21",
        "database_name": "postgresql_17_21",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 3 ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a+' IN 'abcabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_22",
        "database_name": "postgresql_17_22",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 4 ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a+' IN 'abcabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_23",
        "database_name": "postgresql_17_23",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 4, 2 ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a+' IN 'abcabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_24",
        "database_name": "postgresql_17_24",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( 'a', 'a+', 1, 1, NULL ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a+' IN 'a');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_25",
        "database_name": "postgresql_17_25",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 0 ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a+' IN 'abcabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_26",
        "database_name": "postgresql_17_26",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 1 ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a+' IN 'abcabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_27",
        "database_name": "postgresql_17_27",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( 'aaabcabcabc', 'a+', 1, 1, 1 ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a+' IN 'aaabcabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_28",
        "database_name": "postgresql_17_28",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'c' ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('A+' IN 'aaabcabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_29",
        "database_name": "postgresql_17_29",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'i' ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('A+' IN 'aaabcabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_30",
        "database_name": "postgresql_17_30",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'ci' ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('A+' IN 'aaabcabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_31",
        "database_name": "postgresql_17_31",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'cic' ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('A+' IN 'aaabcabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_17_32",
        "database_name": "postgresql_17_32",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_instr( 'a', 'a+', 1, 1, 1, NULL ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a+' IN 'a');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, char(10), )\n(pattern, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(subject, character(10), )\n(pattern, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_18_0",
        "database_name": "postgresql_18_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_replace( 'aaa', 'a', 'X' ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaa', 'a', 'X', 'g' );",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_REPLACE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, flags)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Uses optional flags like 'g' for global replacement.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 'g');",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 'g');",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 'g');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_18_1",
        "database_name": "postgresql_18_1",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'abc', 'b', 'X', 'g' );",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_REPLACE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, flags)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Uses optional flags like 'g' for global replacement.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 'g');",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 'g');",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 'g');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_18_2",
        "database_name": "postgresql_18_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_replace( NULL, 'a', 'X' ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( NULL, 'a', 'X', 'g' );",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_REPLACE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, flags)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Uses optional flags like 'g' for global replacement.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 'g');",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 'g');",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 'g');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_18_3",
        "database_name": "postgresql_18_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_replace( 'aaa', NULL, 'X' ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaa', NULL, 'X', 'g' );",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_REPLACE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, flags)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Uses optional flags like 'g' for global replacement.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 'g');",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 'g');",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 'g');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_18_4",
        "database_name": "postgresql_18_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_replace( 'aaa', 'a', NULL ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaa', 'a', NULL, 'g' );",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_REPLACE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, flags)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Uses optional flags like 'g' for global replacement.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 'g');",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 'g');",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 'g');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_18_5",
        "database_name": "postgresql_18_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT concat( regexp_replace( 'aaa', 'a', 'X' ), 'x' ); -- CONCAT, REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaa', 'a', 'X', 'g' ) || 'x';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT",
            "REGEXP_REPLACE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            },
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            },
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, flags)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Uses optional flags like 'g' for global replacement.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 'g');",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 'g');",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 'g');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_18_6",
        "database_name": "postgresql_18_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_replace( 'aaa', 'a', 'X', 1 ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaa', 'a', 'X' );",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_REPLACE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, flags)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Uses optional flags like 'g' for global replacement.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 'g');",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 'g');",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 'g');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_18_7",
        "database_name": "postgresql_18_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 1 ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_REPLACE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, flags)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Uses optional flags like 'g' for global replacement.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 'g');",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 'g');",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 'g');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_18_8",
        "database_name": "postgresql_18_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 2 ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_REPLACE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, flags)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Uses optional flags like 'g' for global replacement.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 'g');",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 'g');",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 'g');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_18_9",
        "database_name": "postgresql_18_9",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>', 1, 2 ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<\\1>' );",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_REPLACE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, flags)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Uses optional flags like 'g' for global replacement.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 'g');",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 'g');",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 'g');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_18_10",
        "database_name": "postgresql_18_10",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x', 1, 0 ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x' );",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_REPLACE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, flags)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Uses optional flags like 'g' for global replacement.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 'g');",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 'g');",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 'g');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_18_11",
        "database_name": "postgresql_18_11",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x', 1, 0 ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x' );",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_REPLACE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, flags)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Uses optional flags like 'g' for global replacement.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 'g');",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 'g');",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 'g');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_18_12",
        "database_name": "postgresql_18_12",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_replace( 'aaab', 'b', 'x', 1, 2 ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaab', 'b', 'x' );",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_REPLACE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, flags)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Uses optional flags like 'g' for global replacement.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 'g');",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 'g');",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 'g');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_18_13",
        "database_name": "postgresql_18_13",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_replace( 'aaabccc', 'b', 'x', 1, 2 ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaabccc', 'b', 'x' );",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_REPLACE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, flags)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Uses optional flags like 'g' for global replacement.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 'g');",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 'g');",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 'g');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_18_14",
        "database_name": "postgresql_18_14",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'abc', 'b', 'X', 'g' );",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_REPLACE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, flags)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Uses optional flags like 'g' for global replacement.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 'g');",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 'g');",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 'g');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_18_15",
        "database_name": "postgresql_18_15",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_replace( 'abcbdb', 'b', 'X' ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'abcbdb', 'b', 'X', 'g' );",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_REPLACE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, flags)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Uses optional flags like 'g' for global replacement.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 'g');",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 'g');",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 'g');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_18_16",
        "database_name": "postgresql_18_16",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_replace( 'abcbdb', 'b', 'X', 3 ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'abcbdb', 'b', 'X' );",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_REPLACE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, flags)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Uses optional flags like 'g' for global replacement.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 'g');",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 'g');",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 'g');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_18_17",
        "database_name": "postgresql_18_17",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 1 ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaabcbdb', 'b', 'X' );",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_REPLACE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, flags)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Uses optional flags like 'g' for global replacement.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 'g');",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 'g');",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 'g');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_18_18",
        "database_name": "postgresql_18_18",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 2 ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaabcbdb', 'b', 'X' );",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_REPLACE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, flags)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Uses optional flags like 'g' for global replacement.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 'g');",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 'g');",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 'g');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_18_19",
        "database_name": "postgresql_18_19",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 3 ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaabcbdb', 'b', 'X' );",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_REPLACE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, flags)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Uses optional flags like 'g' for global replacement.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 'g');",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 'g');",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 'g');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_18_20",
        "database_name": "postgresql_18_20",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_replace( 'aaa', 'a', 'X', 2 ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaa', 'a', 'X' );",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_REPLACE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, flags)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Uses optional flags like 'g' for global replacement.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 'g');",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 'g');",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 'g');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_18_21",
        "database_name": "postgresql_18_21",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_replace( 'aaa', 'a', 'XX', 2 ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaa', 'a', 'XX' );",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_REPLACE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, flags)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Uses optional flags like 'g' for global replacement.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 'g');",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 'g');",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 'g');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_19_2",
        "database_name": "postgresql_19_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 VALUES ( regexp_instr('a', 'a'),regexp_instr('a', 'a'),regexp_instr('a', 'a'),regexp_instr('a', 'a') ); -- REGEXP_INSTR",
        "target_query": "INSERT INTO t1 VALUES (POSITION('a' IN 'a'), POSITION('a' IN 'a'), POSITION('a' IN 'a'), POSITION('a' IN 'a'));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "PostgreSQL does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, double, )\n(b, int, )\n(c, char(100), )\n(d, decimal(10,0), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, real, )\n(b, integer, )\n(c, character(100), )\n(d, numeric, )\n"
        ]
    },
    {
        "sql_id": "postgresql_19_6",
        "database_name": "postgresql_19_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 ( c ) VALUES ( regexp_replace('a', 'a', 'a') ); -- REGEXP_REPLACE",
        "target_query": "INSERT INTO t1 (c) VALUES (REGEXP_REPLACE('a', 'a', 'a', 'g'));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_REPLACE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, flags)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Uses optional flags like 'g' for global replacement.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 'g');",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 'g');",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 'g');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, double, )\n(b, int, )\n(c, char(100), )\n(d, decimal(10,0), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, real, )\n(b, integer, )\n(c, character(100), )\n(d, numeric, )\n"
        ]
    },
    {
        "sql_id": "postgresql_19_10",
        "database_name": "postgresql_19_10",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT length(regexp_replace( repeat('a', 'b'), 'a', 'b' )); -- LENGTH, REGEXP_REPLACE, REPEAT",
        "target_query": "SELECT OCTET_LENGTH(REGEXP_REPLACE(REPEAT('a', 3), 'a', 'b', 'g'));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH",
            "REGEXP_REPLACE",
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            },
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            },
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            },
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, flags)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Uses optional flags like 'g' for global replacement.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 'g');",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 'g');",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 'g');"
                ]
            },
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_19_12",
        "database_name": "postgresql_19_12",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 VALUES ( repeat( 'a', 16384 ) ); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES (REPEAT('a', 16384));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, text, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_19_13",
        "database_name": "postgresql_19_13",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT char_length ( regexp_replace( a, 'a', 'b' ) ) FROM t1; -- CHAR_LENGTH, REGEXP_REPLACE",
        "target_query": "SELECT CHAR_LENGTH(REGEXP_REPLACE(a, 'a', 'b', 'g')) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CHAR_LENGTH",
            "REGEXP_REPLACE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CHAR_LENGTH(expr)",
                "description": "Returns the number of characters in the string, not bytes.",
                "examples": [
                    "SELECT CHAR_LENGTH('abc');",
                    "SELECT CHAR_LENGTH('\u4f60\u597d');",
                    "SELECT CHAR_LENGTH('a\u4f60b\u597dc');"
                ]
            },
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CHAR_LENGTH(expr)",
                "description": "Returns the number of characters in a string.",
                "examples": [
                    "SELECT CHAR_LENGTH('abc');",
                    "SELECT CHAR_LENGTH('\u4f60\u597d');",
                    "SELECT CHAR_LENGTH('a\u4f60b\u597dc');"
                ]
            },
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, flags)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Uses optional flags like 'g' for global replacement.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 'g');",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 'g');",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 'g');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, text, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_19_17",
        "database_name": "postgresql_19_17",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT regexp_replace(a, '^([[:alpha:]]+)[[:space:]].*$', '$1') FROM t1; -- REGEXP_REPLACE",
        "target_query": "SELECT REGEXP_REPLACE(a, '^([[:alpha:]]+)[[:space:]].*$', E'\\\\1', 'g') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_REPLACE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, flags)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Uses optional flags like 'g' for global replacement.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 'g');",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 'g');",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 'g');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, varchar(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, character varying(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_19_21",
        "database_name": "postgresql_19_21",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "UPDATE t1 SET a = regexp_replace ( 'b', 'b', 'y' ); -- REGEXP_REPLACE",
        "target_query": "UPDATE t1 SET a = REGEXP_REPLACE('b', 'b', 'y', 'g');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REGEXP_REPLACE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, flags)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Uses optional flags like 'g' for global replacement.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 'g');",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 'g');",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 'g');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, char(3), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, character(3), )\n"
        ]
    },
    {
        "sql_id": "postgresql_20_2",
        "database_name": "postgresql_20_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT SUM(DISTINCT LENGTH(name)) s1 FROM t1; -- LENGTH",
        "target_query": "SELECT SUM(DISTINCT octet_length(name)) s1 FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(id, int, PRI)\n(gender, char(1), )\n(name, varchar(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(id, integer, PRI)\n(gender, character(1), )\n(name, character varying(20), )\n"
        ]
    },
    {
        "sql_id": "postgresql_20_6",
        "database_name": "postgresql_20_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT SUM(DISTINCT LENGTH(name)) s1 FROM t1; -- LENGTH",
        "target_query": "SELECT SUM(DISTINCT octet_length(name)) s1 FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(id, int, PRI)\n(gender, char(1), )\n(name, varchar(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(id, integer, PRI)\n(gender, character(1), )\n(name, character varying(20), )\n"
        ]
    },
    {
        "sql_id": "postgresql_20_10",
        "database_name": "postgresql_20_10",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT (SELECT SUM(DISTINCT LENGTH(name)) FROM t1) FROM t2; -- LENGTH",
        "target_query": "SELECT (SELECT SUM(DISTINCT octet_length(name)) FROM t1) FROM t2;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(id, int, PRI)\n(gender, char(1), )\n(name, varchar(20), )\n",
            "Table: `t2`\nColumns:\n(name, varchar(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(id, integer, PRI)\n(gender, character(1), )\n(name, character varying(20), )\n",
            "Table: `t2`\nColumns:\n(name, character varying(20), )\n"
        ]
    },
    {
        "sql_id": "postgresql_20_13",
        "database_name": "postgresql_20_13",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t2 VALUES (1,'18:19:29',NOW()); -- NOW",
        "target_query": "INSERT INTO t2 VALUES (1, '18:19:29', CURRENT_TIMESTAMP);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "NOW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "In PostgreSQL, CURRENT_TIMESTAMP is used to retrieve the current date and time, equivalent to NOW() in MySQL and MariaDB.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(id, int, PRI)\n(gender, char(1), )\n(name, varchar(20), )\n",
            "Table: `t2`\nColumns:\n(pk, int, PRI)\n(time_nokey, time, )\n(datetime_key, time, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(id, integer, PRI)\n(gender, character(1), )\n(name, character varying(20), )\n",
            "Table: `t2`\nColumns:\n(pk, integer, PRI)\n(time_nokey, time without time zone, )\n(datetime_key, time without time zone, )\n"
        ]
    },
    {
        "sql_id": "postgresql_21_3",
        "database_name": "postgresql_21_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT CONCAT_WS(pkCrash, strCrash) FROM t1; -- CONCAT_WS",
        "target_query": "SELECT concat_ws('-', CAST(pkCrash AS TEXT), strCrash) AS combined FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT_WS"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT_WS(separator, str1, str2, ...)",
                "description": "Concatenates multiple strings with the specified separator. If any argument is NULL, it is ignored.",
                "examples": [
                    "SELECT CONCAT_WS(',', 'apple', 'banana', 'cherry');",
                    "SELECT CONCAT_WS('-', 'hello', 'world');",
                    "SELECT CONCAT_WS(' ', 'this', NULL, 'is', 'a', 'test');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "concat_ws(separator, str1, str2, ...)",
                "description": "Concatenates strings with a separator, ignoring NULL values.",
                "examples": [
                    "SELECT concat_ws(',', 'apple', 'banana', 'cherry');",
                    "SELECT concat_ws('-', 'hello', 'world');",
                    "SELECT concat_ws(' ', 'this', NULL, 'is', 'a', 'test');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(pkCrash, int, PRI)\n(strCrash, varchar(255), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(pkcrash, integer, PRI)\n(strcrash, character varying(255), )\n"
        ]
    },
    {
        "sql_id": "postgresql_21_10",
        "database_name": "postgresql_21_10",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select one.id, two.val, elt(two.val,'one','two') from t1 one, t2 two where two.id=one.id order by one.id; -- ELT",
        "target_query": "SELECT one.id, two.val, CASE WHEN two.val > 0 AND two.val <= array_length(ARRAY['one', 'two'], 1) THEN (ARRAY['one', 'two'])[two.val] ELSE NULL END FROM t1 one, t2 two WHERE two.id=one.id ORDER BY one.id;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ELT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "ELT(2, 'apple', 'banana', 'cherry')",
                "description": "Returns the N-th element from the list, where N is the first argument.",
                "examples": [
                    "SELECT ELT(2, 'apple', 'banana', 'cherry');  -- Returns 'banana'",
                    "SELECT ELT(1, 'red', 'green', 'blue');  -- Returns 'red'",
                    "SELECT ELT(3, 'dog', 'cat', 'bird');  -- Returns 'bird'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN 2 > 0 AND 2 <= array_length(ARRAY['apple', 'banana', 'cherry'], 1) THEN (ARRAY['apple', 'banana', 'cherry'])[2] ELSE NULL END",
                "description": "Uses a CASE statement and an array to return the N-th element.",
                "examples": [
                    "SELECT CASE WHEN 2 > 0 AND 2 <= array_length(ARRAY['apple', 'banana', 'cherry'], 1) THEN (ARRAY['apple', 'banana', 'cherry'])[2] ELSE NULL END;  -- Returns 'banana'",
                    "SELECT CASE WHEN 1 > 0 AND 1 <= array_length(ARRAY['red', 'green', 'blue'], 1) THEN (ARRAY['red', 'green', 'blue'])[1] ELSE NULL END;  -- Returns 'red'",
                    "SELECT CASE WHEN 3 > 0 AND 3 <= array_length(ARRAY['dog', 'cat', 'bird'], 1) THEN (ARRAY['dog', 'cat', 'bird'])[3] ELSE NULL END;  -- Returns 'bird'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(id, int, PRI)\n",
            "Table: `t2`\nColumns:\n(id, int, PRI)\n(val, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(id, integer, )\n",
            "Table: `t2`\nColumns:\n(id, integer, PRI)\n(val, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_22_0",
        "database_name": "postgresql_22_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT LEAST(CAST('01-01-01' AS DATETIME), '01-01:02'); -- LEAST",
        "target_query": "SELECT LEAST(TO_TIMESTAMP('2001-01-01 00:00:00', 'YYYY-MM-DD HH24:MI:SS'), TO_TIMESTAMP('2001-01-01 00:01:02', 'YYYY-MM-DD HH24:MI:SS'));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LEAST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest non-null value among its arguments. NULL values are ignored unless all values are NULL.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_22_1",
        "database_name": "postgresql_22_1",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT LEAST(CAST('2001-12-10' AS DATE), '2001-12/11'); -- LEAST",
        "target_query": "SELECT LEAST('2001-12-10'::DATE, TO_DATE('2001-12-11', 'YYYY-MM-DD'));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LEAST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest non-null value among its arguments. NULL values are ignored unless all values are NULL.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_22_2",
        "database_name": "postgresql_22_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT LEAST(CAST('10:11:12' AS TIME), '10:11:13 '); -- LEAST",
        "target_query": "SELECT LEAST('10:11:12'::TIME, '10:11:13'::TIME);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LEAST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest non-null value among its arguments. NULL values are ignored unless all values are NULL.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_23_0",
        "database_name": "postgresql_23_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select unix_timestamp(utc_timestamp())-unix_timestamp(current_timestamp()); -- UNIX_TIMESTAMP, UTC_TIMESTAMP, CURRENT_TIMESTAMP",
        "target_query": "SELECT EXTRACT(EPOCH FROM CURRENT_TIMESTAMP AT TIME ZONE 'UTC') - EXTRACT(EPOCH FROM CURRENT_TIMESTAMP);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP",
            "UTC_TIMESTAMP",
            "CURRENT_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            },
            {
                "expression": "UTC_TIMESTAMP()",
                "description": "Returns the current UTC date and time as a DATETIME value.",
                "examples": [
                    "SELECT UTC_TIMESTAMP();",
                    "SELECT YEAR(UTC_TIMESTAMP());",
                    "SELECT UNIX_TIMESTAMP(UTC_TIMESTAMP());"
                ]
            },
            {
                "expression": "CURRENT_TIMESTAMP(6)",
                "description": "Returns the current date and time, with precision up to microseconds.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP(6);",
                    "SELECT CURRENT_TIMESTAMP(6) = LOCALTIMESTAMP(6);",
                    "SELECT CURRENT_TIMESTAMP(6) > '2025-01-01 00:00:00.000000';"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Extracts the number of seconds since the Unix epoch from a timestamp using the EPOCH keyword.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            },
            {
                "expression": "CURRENT_TIMESTAMP AT TIME ZONE 'UTC'",
                "description": "Returns the current UTC time by converting the local timestamp to UTC.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP AT TIME ZONE 'UTC';",
                    "SELECT EXTRACT(YEAR FROM CURRENT_TIMESTAMP AT TIME ZONE 'UTC');",
                    "SELECT DATE_PART('epoch', CURRENT_TIMESTAMP AT TIME ZONE 'UTC');"
                ]
            },
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "Returns the current date and time, with precision up to seconds. No microsecond precision.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "SELECT CURRENT_TIMESTAMP = LOCALTIMESTAMP;",
                    "SELECT CURRENT_TIMESTAMP > '2025-01-01 00:00:00';"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_23_3",
        "database_name": "postgresql_23_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "insert into t1 (i, ts) values(unix_timestamp('2003-03-01 00:00:00'),'2003-03-01 00:00:00'); -- UNIX_TIMESTAMP",
        "target_query": "INSERT INTO t1 (i, ts) VALUES(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-01 00:00:00'), '2003-03-01 00:00:00');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Extracts the number of seconds since the Unix epoch from a timestamp using the EPOCH keyword.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(i, int, )\n(ts, timestamp, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(i, integer, )\n(ts, timestamp without time zone, )\n"
        ]
    },
    {
        "sql_id": "postgresql_23_4",
        "database_name": "postgresql_23_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "insert into t1 (i, ts) values(unix_timestamp('2003-03-30 01:59:59'),'2003-03-30 01:59:59'),(unix_timestamp('2003-03-30 02:30:00'),'2003-03-30 02:30:00'),(unix_timestamp('2003-03-30 03:00:00'),'2003-03-30 03:00:00'); -- UNIX_TIMESTAMP",
        "target_query": "INSERT INTO t1 (i, ts) VALUES(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59'), '2003-03-30 01:59:59'), (EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00'), '2003-03-30 02:30:00'), (EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00'), '2003-03-30 03:00:00');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Extracts the number of seconds since the Unix epoch from a timestamp using the EPOCH keyword.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(i, int, )\n(ts, timestamp, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(i, integer, )\n(ts, timestamp without time zone, )\n"
        ]
    },
    {
        "sql_id": "postgresql_23_5",
        "database_name": "postgresql_23_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "insert into t1 (i, ts) values(unix_timestamp(20030330015959),20030330015959),(unix_timestamp(20030330023000),20030330023000),(unix_timestamp(20030330030000),20030330030000); -- UNIX_TIMESTAMP",
        "target_query": "INSERT INTO t1 (i, ts) VALUES(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59'), '2003-03-30 01:59:59'), (EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00'), '2003-03-30 02:30:00'), (EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00'), '2003-03-30 03:00:00');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Extracts the number of seconds since the Unix epoch from a timestamp using the EPOCH keyword.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(i, int, )\n(ts, timestamp, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(i, integer, )\n(ts, timestamp without time zone, )\n"
        ]
    },
    {
        "sql_id": "postgresql_23_6",
        "database_name": "postgresql_23_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "insert into t1 (i, ts) values(unix_timestamp('2003-05-01 00:00:00'),'2003-05-01 00:00:00'); -- UNIX_TIMESTAMP",
        "target_query": "INSERT INTO t1 (i, ts) VALUES(EXTRACT(EPOCH FROM TIMESTAMP '2003-05-01 00:00:00'), '2003-05-01 00:00:00');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Extracts the number of seconds since the Unix epoch from a timestamp using the EPOCH keyword.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(i, int, )\n(ts, timestamp, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(i, integer, )\n(ts, timestamp without time zone, )\n"
        ]
    },
    {
        "sql_id": "postgresql_23_7",
        "database_name": "postgresql_23_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "insert into t1 (i, ts) values(unix_timestamp('2003-10-26 01:00:00'),'2003-10-26 01:00:00'),(unix_timestamp('2003-10-26 02:00:00'),'2003-10-26 02:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'),(unix_timestamp('2003-10-26 04:00:00'),'2003-10-26 04:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'); -- UNIX_TIMESTAMP",
        "target_query": "INSERT INTO t1 (i, ts) VALUES(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 01:00:00'), '2003-10-26 01:00:00'), (EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:00:00'), '2003-10-26 02:00:00'), (EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59'), '2003-10-26 02:59:59'), (EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 04:00:00'), '2003-10-26 04:00:00'), (EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59'), '2003-10-26 02:59:59');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Extracts the number of seconds since the Unix epoch from a timestamp using the EPOCH keyword.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(i, int, )\n(ts, timestamp, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(i, integer, )\n(ts, timestamp without time zone, )\n"
        ]
    },
    {
        "sql_id": "postgresql_23_10",
        "database_name": "postgresql_23_10",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select from_unixtime(362793609); -- FROM_UNIXTIME",
        "target_query": "SELECT TO_TIMESTAMP(362793609);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "FROM_UNIXTIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
                "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
                "examples": [
                    "SELECT FROM_UNIXTIME(1672531200);",
                    "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
                    "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP(unix_timestamp)",
                "description": "Converts a Unix timestamp (number of seconds since 1970-01-01 UTC) to a timestamp with time zone.",
                "examples": [
                    "SELECT TO_TIMESTAMP(1672531200);",
                    "SELECT TO_TIMESTAMP(1672531200.456);",
                    "SELECT id, TO_CHAR(TO_TIMESTAMP(created_at), 'YYYY-MM-DD') AS created_date FROM events;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_23_12",
        "database_name": "postgresql_23_12",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "insert into t1 (ts) values (now()); -- NOW",
        "target_query": "INSERT INTO t1 (ts) VALUES (CURRENT_TIMESTAMP);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "NOW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "In PostgreSQL, CURRENT_TIMESTAMP is used to retrieve the current date and time, equivalent to NOW() in MySQL and MariaDB.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(ts, timestamp, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(ts, timestamp without time zone, )\n"
        ]
    },
    {
        "sql_id": "postgresql_23_15",
        "database_name": "postgresql_23_15",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 VALUES('2003-03-30 01:59:59', 'Before the gap'),('2003-03-30 02:30:00', 'Inside the gap'),('2003-03-30 03:00:00',  'After the gap'); -- UNIX_TIMESTAMP",
        "target_query": "INSERT INTO t1 VALUES('2003-03-30 01:59:59', 'Before the gap'), ('2003-03-30 02:30:00', 'Inside the gap'), ('2003-03-30 03:00:00', 'After the gap');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Extracts the number of seconds since the Unix epoch from a timestamp using the EPOCH keyword.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, timestamp, )\n(b, varchar(30), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, timestamp without time zone, )\n(b, character varying(30), )\n"
        ]
    },
    {
        "sql_id": "postgresql_23_18",
        "database_name": "postgresql_23_18",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT UNIX_TIMESTAMP('2003-03-30 01:59:59'), 'Before the gap' AS b; -- UNIX_TIMESTAMP",
        "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59'), 'Before the gap' AS b;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Extracts the number of seconds since the Unix epoch from a timestamp using the EPOCH keyword.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_23_19",
        "database_name": "postgresql_23_19",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT UNIX_TIMESTAMP('2003-03-30 02:30:00'), 'Inside the gap' AS b; -- UNIX_TIMESTAMP",
        "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00'), 'Inside the gap' AS b;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Extracts the number of seconds since the Unix epoch from a timestamp using the EPOCH keyword.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_23_20",
        "database_name": "postgresql_23_20",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT UNIX_TIMESTAMP('2003-03-30 03:00:00'), 'After the gap' AS b; -- UNIX_TIMESTAMP",
        "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00'), 'After the gap' AS b;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Extracts the number of seconds since the Unix epoch from a timestamp using the EPOCH keyword.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_23_21",
        "database_name": "postgresql_23_21",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT FROM_UNIXTIME(0); -- FROM_UNIXTIME",
        "target_query": "SELECT TO_TIMESTAMP(0);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "FROM_UNIXTIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
                "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
                "examples": [
                    "SELECT FROM_UNIXTIME(1672531200);",
                    "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
                    "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP(unix_timestamp)",
                "description": "Converts a Unix timestamp (number of seconds since 1970-01-01 UTC) to a timestamp with time zone.",
                "examples": [
                    "SELECT TO_TIMESTAMP(1672531200);",
                    "SELECT TO_TIMESTAMP(1672531200.456);",
                    "SELECT id, TO_CHAR(TO_TIMESTAMP(created_at), 'YYYY-MM-DD') AS created_date FROM events;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_23_22",
        "database_name": "postgresql_23_22",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT UNIX_TIMESTAMP(\"1969-12-31 15:59:59\"); -- UNIX_TIMESTAMP",
        "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1969-12-31 15:59:59');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Extracts the number of seconds since the Unix epoch from a timestamp using the EPOCH keyword.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_23_23",
        "database_name": "postgresql_23_23",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT UNIX_TIMESTAMP(\"1969-12-31 16:00:00\"); -- UNIX_TIMESTAMP",
        "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1969-12-31 16:00:00');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Extracts the number of seconds since the Unix epoch from a timestamp using the EPOCH keyword.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_23_24",
        "database_name": "postgresql_23_24",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT UNIX_TIMESTAMP(\"1969-12-31 16:00:01\"); -- UNIX_TIMESTAMP",
        "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1969-12-31 16:00:01');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Extracts the number of seconds since the Unix epoch from a timestamp using the EPOCH keyword.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_23_25",
        "database_name": "postgresql_23_25",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT UNIX_TIMESTAMP(\"1970-01-01 00:00:01\"); -- UNIX_TIMESTAMP",
        "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1970-01-01 00:00:01');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Extracts the number of seconds since the Unix epoch from a timestamp using the EPOCH keyword.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_23_26",
        "database_name": "postgresql_23_26",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT UNIX_TIMESTAMP(\"2022-01-01 16:00:01\"); -- UNIX_TIMESTAMP",
        "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2022-01-01 16:00:01');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Extracts the number of seconds since the Unix epoch from a timestamp using the EPOCH keyword.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_24_3",
        "database_name": "postgresql_24_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select hex(a) from t1; -- HEX",
        "target_query": "SELECT encode(a::text::bytea, 'hex') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bit(64), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bit(64), )\n"
        ]
    },
    {
        "sql_id": "postgresql_24_7",
        "database_name": "postgresql_24_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select hex(a) from t1; -- HEX",
        "target_query": "SELECT encode(a::text::bytea, 'hex') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bit(1), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bit(1), )\n"
        ]
    },
    {
        "sql_id": "postgresql_24_11",
        "database_name": "postgresql_24_11",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select hex(min(a)) from t1; -- HEX, MIN",
        "target_query": "SELECT to_hex(CASE WHEN btrim(a::text, ' \\t\\n\\r\\0') = '' THEN 0 ELSE btrim(a::text, ' \\t\\n\\r\\0')::integer END) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX",
            "MIN"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            },
            {
                "expression": "MIN()",
                "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
                "examples": [
                    "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            },
            {
                "expression": "MIN()",
                "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
                "examples": [
                    "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bit(7), )\n(b, bit(9), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bit(7), )\n(b, bit(9), )\n"
        ]
    },
    {
        "sql_id": "postgresql_24_12",
        "database_name": "postgresql_24_12",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select hex(min(b)) from t1; -- HEX, MIN",
        "target_query": "SELECT to_hex(CASE WHEN btrim(b::text, ' \\t\\n\\r\\0') = '' THEN 0 ELSE btrim(b::text, ' \\t\\n\\r\\0')::integer END) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX",
            "MIN"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            },
            {
                "expression": "MIN()",
                "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
                "examples": [
                    "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            },
            {
                "expression": "MIN()",
                "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
                "examples": [
                    "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bit(7), )\n(b, bit(9), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bit(7), )\n(b, bit(9), )\n"
        ]
    },
    {
        "sql_id": "postgresql_24_13",
        "database_name": "postgresql_24_13",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select hex(min(a)), hex(max(a)), hex(min(b)), hex(max(b)) from t1; -- HEX, MIN, MAX",
        "target_query": "SELECT to_hex(CASE WHEN btrim(a::text, ' \\t\\n\\r\\0') = '' THEN 0 ELSE btrim(a::text, ' \\t\\n\\r\\0')::integer END), to_hex(CASE WHEN btrim(a::text, ' \\t\\n\\r\\0') = '' THEN 0 ELSE btrim(a::text, ' \\t\\n\\r\\0')::integer END), to_hex(CASE WHEN btrim(b::text, ' \\t\\n\\r\\0') = '' THEN 0 ELSE btrim(b::text, ' \\t\\n\\r\\0')::integer END), to_hex(CASE WHEN btrim(b::text, ' \\t\\n\\r\\0') = '' THEN 0 ELSE btrim(b::text, ' \\t\\n\\r\\0')::integer END) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX",
            "MIN",
            "MAX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            },
            {
                "expression": "MIN()",
                "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
                "examples": [
                    "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
                ]
            },
            {
                "expression": "MAX(expr)",
                "description": "Returns the maximum value of the expression in an aggregation context.",
                "examples": [
                    "SELECT MAX(10), MAX(5), MAX(20);",
                    "SELECT MAX('apple'), MAX('banana'), MAX('pear');",
                    "SELECT MAX(ABS(-5)), MAX(ABS(3));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            },
            {
                "expression": "MIN()",
                "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
                "examples": [
                    "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
                ]
            },
            {
                "expression": "MAX(expr)",
                "description": "Returns the largest value of the expression across input rows.",
                "examples": [
                    "SELECT MAX(100), MAX(50), MAX(75);",
                    "SELECT MAX('mango'), MAX('kiwi'), MAX('grape');",
                    "SELECT MAX(CEIL(1.2)), MAX(CEIL(2.8));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bit(7), )\n(b, bit(9), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bit(7), )\n(b, bit(9), )\n"
        ]
    },
    {
        "sql_id": "postgresql_24_17",
        "database_name": "postgresql_24_17",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select hex(min(b)) from t1 where a = 4; -- HEX, MIN",
        "target_query": "SELECT to_hex(b::integer) FROM t1 WHERE a = 4;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX",
            "MIN"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            },
            {
                "expression": "MIN()",
                "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
                "examples": [
                    "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            },
            {
                "expression": "MIN()",
                "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
                "examples": [
                    "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, bit(1), )\n(c, bit(9), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, bit(1), )\n(c, bit(9), )\n"
        ]
    },
    {
        "sql_id": "postgresql_24_18",
        "database_name": "postgresql_24_18",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select hex(min(c)) from t1 where a = 4 and b = 0; -- HEX, MIN",
        "target_query": "SELECT to_hex(CASE WHEN btrim(c::text, ' \\t\\n\\r\\0') = '' THEN 0 ELSE btrim(c::text, ' \\t\\n\\r\\0')::integer END) FROM t1 WHERE a = 4 AND b = B'0';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX",
            "MIN"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            },
            {
                "expression": "MIN()",
                "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
                "examples": [
                    "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            },
            {
                "expression": "MIN()",
                "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
                "examples": [
                    "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, bit(1), )\n(c, bit(9), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, bit(1), )\n(c, bit(9), )\n"
        ]
    },
    {
        "sql_id": "postgresql_24_19",
        "database_name": "postgresql_24_19",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select hex(max(b)) from t1; -- HEX",
        "target_query": "SELECT to_hex(b::integer) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, bit(1), )\n(c, bit(9), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, bit(1), )\n(c, bit(9), )\n"
        ]
    },
    {
        "sql_id": "postgresql_24_23",
        "database_name": "postgresql_24_23",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "update t1 set b= concat(a); -- CONCAT",
        "target_query": "UPDATE t1 SET b = a;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bit(2), )\n(b, bit(2), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bit(2), )\n(b, bit(2), )\n"
        ]
    },
    {
        "sql_id": "postgresql_24_27",
        "database_name": "postgresql_24_27",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT HEX(GROUP_CONCAT(DISTINCT b)) FROM t1 GROUP BY a; -- HEX, GROUP_CONCAT",
        "target_query": "SELECT encode(string_agg(DISTINCT b::text, ',')::bytea, 'hex') FROM t1 GROUP BY a;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX",
            "GROUP_CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            },
            {
                "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
                "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
                "examples": [
                    "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
                    "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            },
            {
                "expression": "STRING_AGG(expression, delimiter)",
                "description": "The STRING_AGG function in PostgreSQL concatenates values from multiple rows into a single string, separated by a specified delimiter.",
                "examples": [
                    "SELECT STRING_AGG(name, ', ') FROM students; -- Returns a comma-separated list of names"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, bit(2), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, bit(2), )\n"
        ]
    },
    {
        "sql_id": "postgresql_25_3",
        "database_name": "postgresql_25_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT HEX(b), i2 FROM t1 WHERE (i2>=100 AND i2<201) AND b=TRUE; -- HEX",
        "target_query": "SELECT encode(b::TEXT::BYTEA, 'hex'), i2 FROM t1 WHERE (i2 >= 100 AND i2 < 201) AND b = B'1';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(b, bit(1), )\n(i2, int, )\n(s, varchar(255), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(b, bit(1), )\n(i2, integer, )\n(s, character varying(255), )\n"
        ]
    },
    {
        "sql_id": "postgresql_25_7",
        "database_name": "postgresql_25_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT HEX(b1), i2 FROM t2 WHERE (i2>=100 AND i2<201) AND b1=TRUE; -- HEX",
        "target_query": "SELECT encode(b1::TEXT::BYTEA, 'hex'), i2 FROM t2 WHERE (i2 >= 100 AND i2 < 201) AND b1 = B'1';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(b, bit(1), )\n(i2, int, )\n(s, varchar(255), )\n",
            "Table: `t2`\nColumns:\n(b1, bit(1), )\n(b2, bit(1), )\n(i2, int, )\n(s, varchar(255), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(b, bit(1), )\n(i2, integer, )\n(s, character varying(255), )\n",
            "Table: `t2`\nColumns:\n(b1, bit(1), )\n(b2, bit(1), )\n(i2, integer, )\n(s, character varying(255), )\n"
        ]
    },
    {
        "sql_id": "postgresql_25_8",
        "database_name": "postgresql_25_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT HEX(b2), i2 FROM t2 WHERE (i2>=100 AND i2<201) AND b2=FALSE; -- HEX",
        "target_query": "SELECT encode(b2::TEXT::BYTEA, 'hex'), i2 FROM t2 WHERE (i2 >= 100 AND i2 < 201) AND b2 = B'0';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(b, bit(1), )\n(i2, int, )\n(s, varchar(255), )\n",
            "Table: `t2`\nColumns:\n(b1, bit(1), )\n(b2, bit(1), )\n(i2, int, )\n(s, varchar(255), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(b, bit(1), )\n(i2, integer, )\n(s, character varying(255), )\n",
            "Table: `t2`\nColumns:\n(b1, bit(1), )\n(b2, bit(1), )\n(i2, integer, )\n(s, character varying(255), )\n"
        ]
    },
    {
        "sql_id": "postgresql_25_13",
        "database_name": "postgresql_25_13",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT HEX(GROUP_CONCAT(DISTINCT b)) FROM t1 GROUP BY a; -- HEX, GROUP_CONCAT",
        "target_query": "SELECT encode(string_agg(DISTINCT b::TEXT, ',')::BYTEA, 'hex') FROM t1 GROUP BY a;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX",
            "GROUP_CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            },
            {
                "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
                "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
                "examples": [
                    "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
                    "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            },
            {
                "expression": "STRING_AGG(expression, delimiter)",
                "description": "The STRING_AGG function in PostgreSQL concatenates values from multiple rows into a single string, separated by a specified delimiter.",
                "examples": [
                    "SELECT STRING_AGG(name, ', ') FROM students; -- Returns a comma-separated list of names"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, bit(2), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, bit(2), )\n"
        ]
    },
    {
        "sql_id": "postgresql_25_15",
        "database_name": "postgresql_25_15",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT HEX(t2.b) FROM t2; -- HEX",
        "target_query": "SELECT encode(t2.b::TEXT::BYTEA, 'hex') FROM t2;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, bit(2), )\n",
            "Table: `t2`\nColumns:\n(b, bit(2), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, bit(2), )\n",
            "Table: `t2`\nColumns:\n(b, bit(2), )\n"
        ]
    },
    {
        "sql_id": "postgresql_25_16",
        "database_name": "postgresql_25_16",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT a, HEX(b) FROM t1 ORDER BY b; -- HEX",
        "target_query": "SELECT a, encode(b::TEXT::BYTEA, 'hex') FROM t1 ORDER BY b;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, bit(2), )\n",
            "Table: `t2`\nColumns:\n(b, bit(2), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, bit(2), )\n",
            "Table: `t2`\nColumns:\n(b, bit(2), )\n"
        ]
    },
    {
        "sql_id": "postgresql_26_3",
        "database_name": "postgresql_26_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select hex(a) from t1 order by a; -- HEX",
        "target_query": "select encode(a, 'hex') from t1 order by a;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, blob, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_26_4",
        "database_name": "postgresql_26_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select hex(concat(a,'\\\\0')) as b from t1 order by concat(a,'\\\\0'); -- HEX, CONCAT",
        "target_query": "select encode(a || '\\\\0', 'hex') as b from t1 order by a || '\\\\0';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX",
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            },
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            },
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, blob, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_26_6",
        "database_name": "postgresql_26_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select hex(a) from t1 order by a; -- HEX",
        "target_query": "select encode(a, 'hex') from t1 order by a;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, varbinary(5), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_26_10",
        "database_name": "postgresql_26_10",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t (c) VALUES (REPEAT('3',65535)); -- REPEAT",
        "target_query": "INSERT INTO t (c) VALUES (REPEAT('3',65535));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t`\nColumns:\n(c, text, )\n"
        ],
        "target_related_schemas": [
            "Table: `t`\nColumns:\n(c, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_26_11",
        "database_name": "postgresql_26_11",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT LENGTH(c), CHAR_LENGTH(c) FROM t; -- LENGTH, CHAR_LENGTH",
        "target_query": "SELECT octet_length(c), CHAR_LENGTH(c) FROM t;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH",
            "CHAR_LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            },
            {
                "expression": "CHAR_LENGTH(expr)",
                "description": "Returns the number of characters in the string, not bytes.",
                "examples": [
                    "SELECT CHAR_LENGTH('abc');",
                    "SELECT CHAR_LENGTH('\u4f60\u597d');",
                    "SELECT CHAR_LENGTH('a\u4f60b\u597dc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            },
            {
                "expression": "CHAR_LENGTH(expr)",
                "description": "Returns the number of characters in a string.",
                "examples": [
                    "SELECT CHAR_LENGTH('abc');",
                    "SELECT CHAR_LENGTH('\u4f60\u597d');",
                    "SELECT CHAR_LENGTH('a\u4f60b\u597dc');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t`\nColumns:\n(c, text, )\n"
        ],
        "target_related_schemas": [
            "Table: `t`\nColumns:\n(c, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_26_16",
        "database_name": "postgresql_26_16",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT LENGTH(c) FROM t2; -- LENGTH",
        "target_query": "SELECT octet_length(c) FROM t2;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t2`\nColumns:\n(id, int, )\n(c, text, )\n"
        ],
        "target_related_schemas": [
            "Table: `t2`\nColumns:\n(id, integer, )\n(c, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_27_0",
        "database_name": "postgresql_27_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select least(-1.1111111111111111111111111,- group_concat(1.7976931348623157E+308)) as foo; -- LEAST, GROUP_CONCAT",
        "target_query": "SELECT LEAST(-1.1111111111111111111111111, -CAST((SELECT STRING_AGG(CAST(1.7976931348623157E+308 AS TEXT), ',') FROM (VALUES (1)) AS dummy) AS DOUBLE PRECISION)) AS foo;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LEAST",
            "GROUP_CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            },
            {
                "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
                "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
                "examples": [
                    "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
                    "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest non-null value among its arguments. NULL values are ignored unless all values are NULL.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            },
            {
                "expression": "STRING_AGG(expression, delimiter)",
                "description": "The STRING_AGG function in PostgreSQL concatenates values from multiple rows into a single string, separated by a specified delimiter.",
                "examples": [
                    "SELECT STRING_AGG(name, ', ') FROM students; -- Returns a comma-separated list of names"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_28_7",
        "database_name": "postgresql_28_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "insert into t1 values (now()); -- NOW",
        "target_query": "insert into t1 values (CURRENT_TIMESTAMP);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "NOW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "In PostgreSQL, CURRENT_TIMESTAMP is used to retrieve the current date and time, equivalent to NOW() in MySQL and MariaDB.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, timestamp, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, timestamp without time zone, )\n"
        ]
    },
    {
        "sql_id": "postgresql_28_8",
        "database_name": "postgresql_28_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select date_format(a,\"%Y %y\"),year(a),year(now()) from t1; -- DATE_FORMAT, YEAR, NOW",
        "target_query": "select TO_CHAR(a, 'YYYY YY'), EXTRACT(YEAR FROM a), EXTRACT(YEAR FROM CURRENT_TIMESTAMP) from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE_FORMAT",
            "YEAR",
            "NOW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            },
            {
                "expression": "YEAR(date)",
                "description": "Extracts the year from a date or datetime and returns it as an integer.",
                "examples": [
                    "SELECT YEAR('2023-04-10');",
                    "SELECT YEAR(NOW());",
                    "SELECT YEAR('2022-03-15');"
                ]
            },
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(date_expr, format_str)",
                "description": "Formats a date/time value according to a format string using PostgreSQL-style specifiers.",
                "examples": [
                    "SELECT TO_CHAR(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT TO_CHAR(DATE '2023-01-15', 'DD-MM-YYYY');"
                ]
            },
            {
                "expression": "EXTRACT(YEAR FROM date)",
                "description": "Extracts the year from a date or datetime and returns it as an integer.",
                "examples": [
                    "SELECT EXTRACT(YEAR FROM DATE '2023-04-10');",
                    "SELECT EXTRACT(YEAR FROM CURRENT_DATE);",
                    "SELECT EXTRACT(YEAR FROM DATE '2022-03-15');"
                ]
            },
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "In PostgreSQL, CURRENT_TIMESTAMP is used to retrieve the current date and time, equivalent to NOW() in MySQL and MariaDB.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, timestamp, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, timestamp without time zone, )\n"
        ]
    },
    {
        "sql_id": "postgresql_28_10",
        "database_name": "postgresql_28_10",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT TIMESTAMP('2000-01-27','23:13:41') - TIMESTAMP('2003-05-16','23:53:29'); -- TIMESTAMP",
        "target_query": "SELECT TO_TIMESTAMP('2000-01-27 23:13:41', 'YYYY-MM-DD HH24:MI:SS') - TO_TIMESTAMP('2003-05-16 23:53:29', 'YYYY-MM-DD HH24:MI:SS');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
                "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
                "examples": [
                    "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP('2023-06-15 10:30:45', 'YYYY-MM-DD HH24:MI:SS')",
                "description": "In PostgreSQL, TO_TIMESTAMP is used to convert a date-time string to a TIMESTAMP value, supporting both with and without timezone.",
                "examples": [
                    "SELECT TO_TIMESTAMP('2023-06-15 10:30:45', 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT TO_TIMESTAMP('2023-06-15 10:30:45+02:00', 'YYYY-MM-DD HH24:MI:SSOF');",
                    "SELECT TO_TIMESTAMP('2023-06-15 10:30:45', 'YYYY-MM-DD HH24:MI:SS') > TO_TIMESTAMP('2023-06-14 10:30:45', 'YYYY-MM-DD HH24:MI:SS');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_30_5",
        "database_name": "postgresql_30_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select length(v),length(c),length(e),length(t) from t1; -- LENGTH",
        "target_query": "SELECT octet_length(v), octet_length(c), octet_length(e), octet_length(t) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(v, varchar(30), )\n(c, char(3), )\n(e, char(3), )\n(t, text, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(v, character varying(30), )\n(c, character(3), )\n(e, character(3), )\n(t, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_30_8",
        "database_name": "postgresql_30_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 VALUES(SUBSTR(f1, 1, 3)); -- SUBSTR",
        "target_query": "INSERT INTO t1 VALUES ('tes');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "SUBSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "description": "The substr(str,pos[,len]) function returns a substring from string str starting at position pos.\nIf len is specified, returns a substring len characters long starting at position pos.\nIf pos is positive, the position is counted from the start of the string.\nIf pos is negative, the position is counted from the end of the string.\nlen must be positive. If len is omitted, returns all characters to the end of the string.\nReturns NULL if any argument is NULL.",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "description": "The SUBSTR function in PostgreSQL extracts a substring from a given string, starting from a specified position and optionally extending for a specified length.",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', 7, 5); -- Returns 'World'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, varchar(100), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, character varying(100), )\n"
        ]
    },
    {
        "sql_id": "postgresql_30_12",
        "database_name": "postgresql_30_12",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT a,(a DIV 2) FROM t1 ORDER BY a; -- DIV",
        "target_query": "SELECT a, FLOOR(a::INTEGER / 2) FROM t1 ORDER BY a;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DIV"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "a DIV b",
                "description": "Performs integer division between two numbers and returns the floor of the quotient.",
                "examples": [
                    "SELECT 10 DIV 3;",
                    "SELECT 5.8 DIV 2;",
                    "SELECT 9 DIV 4 + 1;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "FLOOR(a / b)",
                "description": "Performs floating-point division and applies FLOOR to return integer quotient.",
                "examples": [
                    "SELECT FLOOR(10 / 3);",
                    "SELECT FLOOR(5.8 / 2);",
                    "SELECT FLOOR(9 / 4) + 1;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, char(2), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, character(2), )\n"
        ]
    },
    {
        "sql_id": "postgresql_31_2",
        "database_name": "postgresql_31_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "insert into t1 values (now()); -- NOW",
        "target_query": "INSERT INTO t1 VALUES (EXTRACT(YEAR FROM CURRENT_TIMESTAMP)::SMALLINT);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "NOW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "In PostgreSQL, CURRENT_TIMESTAMP is used to retrieve the current date and time, equivalent to NOW() in MySQL and MariaDB.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(y, year, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(y, smallint, )\n"
        ]
    },
    {
        "sql_id": "postgresql_31_3",
        "database_name": "postgresql_31_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select if(y = now(), 1, 0) from t1; -- IF, NOW",
        "target_query": "SELECT CASE WHEN y = EXTRACT(YEAR FROM CURRENT_TIMESTAMP) THEN 1 ELSE 0 END FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF",
            "NOW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            },
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "In PostgreSQL, `IF` is not directly supported. Instead, the `CASE WHEN` expression is used to evaluate a condition and return different values based on whether the condition is true or false.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            },
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "In PostgreSQL, CURRENT_TIMESTAMP is used to retrieve the current date and time, equivalent to NOW() in MySQL and MariaDB.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(y, year, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(y, smallint, )\n"
        ]
    },
    {
        "sql_id": "postgresql_31_9",
        "database_name": "postgresql_31_9",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT * FROM t4 WHERE yyyy = NOW(); -- NOW",
        "target_query": "SELECT * FROM t4 WHERE yyyy = EXTRACT(YEAR FROM CURRENT_TIMESTAMP);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "NOW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "In PostgreSQL, CURRENT_TIMESTAMP is used to retrieve the current date and time, equivalent to NOW() in MySQL and MariaDB.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t4`\nColumns:\n(yyyy, year, )\n(c4, char(4), )\n"
        ],
        "target_related_schemas": [
            "Table: `t4`\nColumns:\n(yyyy, smallint, )\n(c4, character(4), )\n"
        ]
    },
    {
        "sql_id": "postgresql_31_19",
        "database_name": "postgresql_31_19",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT TIMESTAMPDIFF(QUARTER, LEAST(y1, y2), dbl)FROM t1; -- TIMESTAMPDIFF, LEAST",
        "target_query": "SELECT EXTRACT(QUARTER FROM AGE(d, DATE(LEAST(y1, y2) || '-01-01'))) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIMESTAMPDIFF",
            "LEAST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMESTAMPDIFF(unit, datetime1, datetime2)",
                "description": "Returns the difference between two datetime values in the specified unit.",
                "examples": [
                    "SELECT TIMESTAMPDIFF(YEAR, '2001-01-01', '2005-01-01');  -- 4",
                    "SELECT TIMESTAMPDIFF(MONTH, '2020-01-01', '2020-03-01');  -- 2",
                    "SELECT TIMESTAMPDIFF(DAY, '2020-01-01', '2020-01-31');    -- 30"
                ]
            },
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(unit FROM AGE(datetime2, datetime1))",
                "description": "The AGE function in PostgreSQL returns the interval between two dates or timestamps. The order of arguments is reversed compared to other DBMSs, meaning the earlier date comes second in the AGE function. You can extract the difference in years, months, days, etc. from the interval.",
                "examples": [
                    "SELECT EXTRACT(YEAR FROM AGE('2005-01-01', '2001-01-01'));  -- 4",
                    "SELECT EXTRACT(MONTH FROM AGE('2020-03-01', '2020-01-01'));  -- 2",
                    "SELECT EXTRACT(DAY FROM AGE('2020-01-31', '2020-01-01'));    -- 30"
                ]
            },
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest non-null value among its arguments. NULL values are ignored unless all values are NULL.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(d, date, )\n(y1, year, )\n(y2, year, )\n(dbl, double, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(d, date, )\n(y1, smallint, )\n(y2, smallint, )\n(dbl, double precision, )\n"
        ]
    },
    {
        "sql_id": "postgresql_31_20",
        "database_name": "postgresql_31_20",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT HOUR(GREATEST(y1, y2))FROM t1; -- HOUR, GREATEST",
        "target_query": "SELECT GREATEST(y1, y2) AS max_year FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HOUR",
            "GREATEST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HOUR(expr)",
                "description": "Extracts the hour (0\u201323) from a time or datetime expression.",
                "examples": [
                    "SELECT HOUR('18:45:30');",
                    "SELECT HOUR('2023-10-01 08:15:00');",
                    "SELECT HOUR(CURRENT_TIMESTAMP);"
                ]
            },
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(HOUR FROM expr)",
                "description": "Extracts the hour field from a time or timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(HOUR FROM TIME '18:45:30');",
                    "SELECT EXTRACT(HOUR FROM TIMESTAMP '2023-10-01 08:15:00');",
                    "SELECT EXTRACT(HOUR FROM CURRENT_TIMESTAMP);"
                ]
            },
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(d, date, )\n(y1, year, )\n(y2, year, )\n(dbl, double, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(d, date, )\n(y1, smallint, )\n(y2, smallint, )\n(dbl, double precision, )\n"
        ]
    },
    {
        "sql_id": "postgresql_32_12",
        "database_name": "postgresql_32_12",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT y, CONCAT('\"', c, '\"') FROM t1; -- CONCAT",
        "target_query": "SELECT y, '\"' || c || '\"' FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(y, year, )\n(i, int, )\n(c, varchar(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(y, integer, )\n(i, integer, )\n(c, character varying(20), )\n"
        ]
    },
    {
        "sql_id": "postgresql_33_3",
        "database_name": "postgresql_33_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select hex(b) from t1 order by pk1; -- HEX",
        "target_query": "SELECT encode(decode(b::text, 'hex'), 'hex') AS hex_value FROM t1 ORDER BY pk1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(pk1, int, PRI)\n(b, bit(64), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(pk1, integer, PRI)\n(b, bit(64), )\n"
        ]
    },
    {
        "sql_id": "postgresql_33_7",
        "database_name": "postgresql_33_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select hex(b) from t1 order by pk1; -- HEX",
        "target_query": "SELECT encode(decode(lpad(b::text, 16, '0'), 'hex'), 'hex') AS hex_value FROM t2 ORDER BY pk1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(pk1, int, PRI)\n(b, bit(9), )\n"
        ],
        "target_related_schemas": [
            "Table: `t2`\nColumns:\n(pk1, integer, PRI)\n(b, bit(9), )\n"
        ]
    },
    {
        "sql_id": "postgresql_34_8",
        "database_name": "postgresql_34_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select concat(\"*\",name, \"*\") from t1 order by 1; -- CONCAT",
        "target_query": "select '*' || name || '*' from t1 order by 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(name, char(20), PRI)\n",
            "Table: `t2`\nColumns:\n(name, char(20), PRI)\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(name, character(20), PRI)\n",
            "Table: `t2`\nColumns:\n(name, character(20), PRI)\n"
        ]
    },
    {
        "sql_id": "postgresql_34_9",
        "database_name": "postgresql_34_9",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select min(name),min(concat(\"*\",name,\"*\")),max(name),max(concat(\"*\",name,\"*\")) from t1; -- CONCAT",
        "target_query": "select min(name), min('*' || name || '*'), max(name), max('*' || name || '*') from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(name, char(20), PRI)\n",
            "Table: `t2`\nColumns:\n(name, char(20), PRI)\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(name, character(20), PRI)\n",
            "Table: `t2`\nColumns:\n(name, character(20), PRI)\n"
        ]
    },
    {
        "sql_id": "postgresql_34_14",
        "database_name": "postgresql_34_14",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select concat(\"-\",a,\"-\",b,\"-\") from t1 where a=\"hello\"; -- CONCAT",
        "target_query": "select '-' || a || '-' || b || '-' from t1 where a='hello';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, char(10), )\n(b, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, character(10), )\n(b, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_34_16",
        "database_name": "postgresql_34_16",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select concat(\"-\",a,\"-\",b,\"-\") from t1 where a=\"hello\"; -- CONCAT",
        "target_query": "select '-' || a || '-' || b || '-' from t1 where a='hello';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, char(10), )\n(b, tinytext, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, character(10), )\n(b, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_34_20",
        "database_name": "postgresql_34_20",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select hex(col1) from t1; -- HEX",
        "target_query": "select encode(col1, 'hex') from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(col1, binary(4), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(col1, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_34_22",
        "database_name": "postgresql_34_22",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select hex(col1) from t1; -- HEX",
        "target_query": "select encode(col1, 'hex') from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(col1, binary(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(col1, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_34_24",
        "database_name": "postgresql_34_24",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select hex(col1) from t1; -- HEX",
        "target_query": "select encode(col1, 'hex') from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(col1, binary(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(col1, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_35_2",
        "database_name": "postgresql_35_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029087575'); -- UNHEX",
        "target_query": "INSERT INTO t1 (a) VALUES (decode('1F9480179366F2BF567E1C4B964C1EF029087575', 'hex'));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNHEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNHEX(str)",
                "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
                "examples": [
                    "SELECT HEX(UNHEX('4D7953514C'));",
                    "SELECT UNHEX('48656C6C6F');",
                    "SELECT UNHEX(NULL);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "decode(str, 'hex')",
                "description": "Decodes a hexadecimal string into binary (bytea) using the decode function.",
                "examples": [
                    "SELECT encode(decode('4D7953514C', 'hex'), 'hex');",
                    "SELECT decode('48656C6C6F', 'hex');",
                    "SELECT decode(NULL, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, binary(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_35_3",
        "database_name": "postgresql_35_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029082020'); -- UNHEX",
        "target_query": "INSERT INTO t1 (a) VALUES (decode('1F9480179366F2BF567E1C4B964C1EF029082020', 'hex'));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNHEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNHEX(str)",
                "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
                "examples": [
                    "SELECT HEX(UNHEX('4D7953514C'));",
                    "SELECT UNHEX('48656C6C6F');",
                    "SELECT UNHEX(NULL);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "decode(str, 'hex')",
                "description": "Decodes a hexadecimal string into binary (bytea) using the decode function.",
                "examples": [
                    "SELECT encode(decode('4D7953514C', 'hex'), 'hex');",
                    "SELECT decode('48656C6C6F', 'hex');",
                    "SELECT decode(NULL, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, binary(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_35_4",
        "database_name": "postgresql_35_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029080707'); -- UNHEX",
        "target_query": "INSERT INTO t1 (a) VALUES (decode('1F9480179366F2BF567E1C4B964C1EF029080707', 'hex'));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNHEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNHEX(str)",
                "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
                "examples": [
                    "SELECT HEX(UNHEX('4D7953514C'));",
                    "SELECT UNHEX('48656C6C6F');",
                    "SELECT UNHEX(NULL);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "decode(str, 'hex')",
                "description": "Decodes a hexadecimal string into binary (bytea) using the decode function.",
                "examples": [
                    "SELECT encode(decode('4D7953514C', 'hex'), 'hex');",
                    "SELECT decode('48656C6C6F', 'hex');",
                    "SELECT decode(NULL, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, binary(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_35_5",
        "database_name": "postgresql_35_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT hex(a) FROM t1 order by a; -- HEX",
        "target_query": "SELECT encode(a, 'hex') FROM t1 ORDER BY a;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, binary(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_35_6",
        "database_name": "postgresql_35_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "EXPLAIN SELECT hex(a) FROM t1 order by a; -- HEX",
        "target_query": "EXPLAIN SELECT encode(a, 'hex') FROM t1 ORDER BY a;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, binary(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_35_7",
        "database_name": "postgresql_35_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT hex(a) from t1 WHERE a=unhex('1F9480179366F2BF567E1C4B964C1EF029082020'); -- HEX, UNHEX",
        "target_query": "SELECT encode(a, 'hex') FROM t1 WHERE a = decode('1F9480179366F2BF567E1C4B964C1EF029082020', 'hex');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX",
            "UNHEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            },
            {
                "expression": "UNHEX(str)",
                "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
                "examples": [
                    "SELECT HEX(UNHEX('4D7953514C'));",
                    "SELECT UNHEX('48656C6C6F');",
                    "SELECT UNHEX(NULL);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            },
            {
                "expression": "decode(str, 'hex')",
                "description": "Decodes a hexadecimal string into binary (bytea) using the decode function.",
                "examples": [
                    "SELECT encode(decode('4D7953514C', 'hex'), 'hex');",
                    "SELECT decode('48656C6C6F', 'hex');",
                    "SELECT decode(NULL, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, binary(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_35_8",
        "database_name": "postgresql_35_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT hex(a) from t1 WHERE a=unhex('1F9480179366F2BF567E1C4B964C1EF02908'); -- HEX, UNHEX",
        "target_query": "SELECT encode(a, 'hex') FROM t1 WHERE a = decode('1F9480179366F2BF567E1C4B964C1EF02908', 'hex');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX",
            "UNHEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            },
            {
                "expression": "UNHEX(str)",
                "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
                "examples": [
                    "SELECT HEX(UNHEX('4D7953514C'));",
                    "SELECT UNHEX('48656C6C6F');",
                    "SELECT UNHEX(NULL);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            },
            {
                "expression": "decode(str, 'hex')",
                "description": "Decodes a hexadecimal string into binary (bytea) using the decode function.",
                "examples": [
                    "SELECT encode(decode('4D7953514C', 'hex'), 'hex');",
                    "SELECT decode('48656C6C6F', 'hex');",
                    "SELECT decode(NULL, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, binary(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_36_0",
        "database_name": "postgresql_36_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT IF(NULL AND 1, 1, 2), IF(1 AND NULL, 1, 2); -- IF",
        "target_query": "SELECT CASE WHEN (NULL IS NOT NULL) AND (1 = 1) THEN 1 ELSE 2 END, CASE WHEN (1 = 1) AND (NULL IS NOT NULL) THEN 1 ELSE 2 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "In PostgreSQL, `IF` is not directly supported. Instead, the `CASE WHEN` expression is used to evaluate a condition and return different values based on whether the condition is true or false.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_36_4",
        "database_name": "postgresql_36_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT * FROM t1 WHERE IF(a AND 1, 0, 1); -- IF",
        "target_query": "SELECT * FROM t1 WHERE CASE WHEN (a = 1) AND (1 = 1) THEN 0=1 ELSE 1=1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "In PostgreSQL, `IF` is not directly supported. Instead, the `CASE WHEN` expression is used to evaluate a condition and return different values based on whether the condition is true or false.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_36_5",
        "database_name": "postgresql_36_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT * FROM t1 WHERE IF(1 AND a, 0, 1); -- IF",
        "target_query": "SELECT * FROM t1 WHERE CASE WHEN (1 = 1) AND (a = 1) THEN 0=1 ELSE 1=1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "In PostgreSQL, `IF` is not directly supported. Instead, the `CASE WHEN` expression is used to evaluate a condition and return different values based on whether the condition is true or false.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_36_10",
        "database_name": "postgresql_36_10",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select ifnull(A=1, 'N') as A, ifnull(B=1, 'N') as B, ifnull(not (A=1), 'N') as nA, ifnull(not (B=1), 'N') as nB, ifnull((A=1) and (B=1), 'N') as AB, ifnull(not ((A=1) and (B=1)), 'N') as `n(AB)`, ifnull((not (A=1) or not (B=1)), 'N') as nAonB, ifnull((A=1) or (B=1), 'N') as AoB, ifnull(not((A=1) or (B=1)), 'N') as `n(AoB)`, ifnull(not (A=1) and not (B=1), 'N') as nAnB from t1; -- IFNULL",
        "target_query": "SELECT COALESCE(CASE WHEN a = 1 THEN 'Y' ELSE 'N' END, 'N') AS A, COALESCE(CASE WHEN b = 1 THEN 'Y' ELSE 'N' END, 'N') AS B, COALESCE(CASE WHEN a <> 1 THEN 'Y' ELSE 'N' END, 'N') AS nA, COALESCE(CASE WHEN b <> 1 THEN 'Y' ELSE 'N' END, 'N') AS nB, COALESCE(CASE WHEN (a = 1) AND (b = 1) THEN 'Y' ELSE 'N' END, 'N') AS AB, COALESCE(CASE WHEN NOT ((a = 1) AND (b = 1)) THEN 'Y' ELSE 'N' END, 'N') AS \"n(AB)\", COALESCE(CASE WHEN (a <> 1) OR (b <> 1) THEN 'Y' ELSE 'N' END, 'N') AS nAonB, COALESCE(CASE WHEN (a = 1) OR (b = 1) THEN 'Y' ELSE 'N' END, 'N') AS ABor, COALESCE(CASE WHEN NOT ((a = 1) OR (b = 1)) THEN 'Y' ELSE 'N' END, 'N') AS \"n(ABor)\" FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IFNULL"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "PostgreSQL uses COALESCE, which returns the first non-NULL argument. This works exactly like IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_37_0",
        "database_name": "postgresql_37_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select CONVERT(\"2004-01-22 21:45:33\",DATE); -- CONVERT",
        "target_query": "SELECT CAST('2004-01-22 21:45:33' AS DATE);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONVERT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONVERT(expression USING charset)",
                "description": "Converts data types or changes the character set.",
                "examples": [
                    "SELECT CONVERT('Hello World' USING utf8);",
                    "SELECT CONVERT(1234, CHAR);",
                    "SELECT CONVERT(column_name USING latin1) FROM my_table;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CAST(expression AS target_type)",
                "description": "PostgreSQL uses CAST for type conversion. No direct equivalent for CONVERT TO CHARACTER SET.",
                "examples": [
                    "SELECT CAST('Hello World' AS TEXT);",
                    "SELECT CAST(1234 AS TEXT);",
                    "SELECT column_name::TEXT FROM my_table;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_37_1",
        "database_name": "postgresql_37_1",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select timediff(cast('2004-12-30 12:00:00' as time), '12:00:00'); -- TIMEDIFF",
        "target_query": "SELECT (CAST('2004-12-30 12:00:00' AS TIMESTAMP) - INTERVAL '12:00:00')::TIME;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIMEDIFF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMEDIFF('12:00:00', '10:00:00')",
                "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
                "examples": [
                    "SELECT TIMEDIFF('12:00:00', '10:00:00');",
                    "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
                    "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "(timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::TIME",
                "description": "PostgreSQL does not have a direct TIMEDIFF function, but time differences can be calculated by subtracting one timestamp from another and casting the result to a TIME.",
                "examples": [
                    "SELECT (timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::TIME;",
                    "SELECT (NOW() - timestamp '2023-06-15 10:00:00')::INTERVAL;",
                    "SELECT (timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::INTERVAL;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_37_2",
        "database_name": "postgresql_37_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select timediff(cast('1 12:00:00' as time), '12:00:00'); -- TIMEDIFF",
        "target_query": "SELECT (CAST('2004-01-01 12:00:00' AS TIMESTAMP) - INTERVAL '12:00:00')::TIME;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIMEDIFF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMEDIFF('12:00:00', '10:00:00')",
                "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
                "examples": [
                    "SELECT TIMEDIFF('12:00:00', '10:00:00');",
                    "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
                    "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "(timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::TIME",
                "description": "PostgreSQL does not have a direct TIMEDIFF function, but time differences can be calculated by subtracting one timestamp from another and casting the result to a TIME.",
                "examples": [
                    "SELECT (timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::TIME;",
                    "SELECT (NOW() - timestamp '2023-06-15 10:00:00')::INTERVAL;",
                    "SELECT (timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::INTERVAL;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_37_3",
        "database_name": "postgresql_37_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select cast(concat('12345','6789') as unsigned); -- CONCAT",
        "target_query": "SELECT CAST('12345' || '6789' AS INTEGER);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_37_4",
        "database_name": "postgresql_37_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select cast(concat('12345','6789') as signed); -- CONCAT",
        "target_query": "SELECT CAST('12345' || '6789' AS INTEGER);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_37_5",
        "database_name": "postgresql_37_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select cast(repeat('1',9) as unsigned); -- REPEAT",
        "target_query": "SELECT CAST(REPEAT('1', 9) AS INTEGER);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_37_6",
        "database_name": "postgresql_37_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select cast(repeat('1',9) as signed); -- REPEAT",
        "target_query": "SELECT CAST(REPEAT('1', 9) AS INTEGER);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_37_7",
        "database_name": "postgresql_37_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select isnull(date(NULL)), isnull(cast(NULL as DATE)); -- ISNULL, DATE",
        "target_query": "SELECT (NULL IS NULL), (CAST(NULL AS DATE) IS NULL);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ISNULL",
            "DATE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "ISNULL(expr)",
                "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
                "examples": [
                    "SELECT ISNULL(NULL);",
                    "SELECT ISNULL(5 + NULL);",
                    "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
                ]
            },
            {
                "expression": "DATE()",
                "description": "In MySQL, the DATE function extracts the date part from a DATETIME or TIMESTAMP value.",
                "examples": [
                    "SELECT DATE('2023-05-01 12:34:56') AS result;",
                    "SELECT DATE(NOW()) AS current_date_result;",
                    "SELECT DATE(CAST('2023-05-01' AS DATETIME)) AS date_from_datetime;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "expr IS NULL",
                "description": "Standard SQL syntax for checking if a value is NULL.",
                "examples": [
                    "SELECT NULL IS NULL;",
                    "SELECT (5 + NULL) IS NULL;",
                    "SELECT CASE WHEN score IS NULL THEN 'N/A' ELSE score::text END FROM students;"
                ]
            },
            {
                "expression": "CAST()",
                "description": "In PostgreSQL, the DATE type can be cast directly from a DATETIME or TIMESTAMP using CAST.",
                "examples": [
                    "SELECT '2023-05-01 12:34:56'::DATE AS result;",
                    "SELECT CURRENT_DATE AS current_date_result;",
                    "SELECT CAST('2023-05-01' AS DATE) AS date_from_datetime;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_37_8",
        "database_name": "postgresql_37_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select hex(cast('a' as binary(2))); -- HEX",
        "target_query": "SELECT encode(CAST('a' AS BYTEA), 'hex');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_37_12",
        "database_name": "postgresql_37_12",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT cast(date(d1) as signed) FROM t1; -- DATE",
        "target_query": "SELECT CAST(TO_CHAR(d1::DATE, 'YYYYMMDD') AS INTEGER) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE()",
                "description": "In MySQL, the DATE function extracts the date part from a DATETIME or TIMESTAMP value.",
                "examples": [
                    "SELECT DATE('2023-05-01 12:34:56') AS result;",
                    "SELECT DATE(NOW()) AS current_date_result;",
                    "SELECT DATE(CAST('2023-05-01' AS DATETIME)) AS date_from_datetime;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CAST()",
                "description": "In PostgreSQL, the DATE type can be cast directly from a DATETIME or TIMESTAMP using CAST.",
                "examples": [
                    "SELECT '2023-05-01 12:34:56'::DATE AS result;",
                    "SELECT CURRENT_DATE AS current_date_result;",
                    "SELECT CAST('2023-05-01' AS DATE) AS date_from_datetime;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(d1, datetime, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(d1, timestamp without time zone, )\n"
        ]
    },
    {
        "sql_id": "postgresql_37_16",
        "database_name": "postgresql_37_16",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT HOUR(f1),MINUTE(f1),SECOND(f1) FROM t1; -- HOUR, MINUTE, SECOND",
        "target_query": "SELECT EXTRACT(HOUR FROM f1::TIMESTAMP), EXTRACT(MINUTE FROM f1::TIMESTAMP), EXTRACT(SECOND FROM f1::TIMESTAMP) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HOUR",
            "MINUTE",
            "SECOND"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HOUR(expr)",
                "description": "Extracts the hour (0\u201323) from a time or datetime expression.",
                "examples": [
                    "SELECT HOUR('18:45:30');",
                    "SELECT HOUR('2023-10-01 08:15:00');",
                    "SELECT HOUR(CURRENT_TIMESTAMP);"
                ]
            },
            {
                "expression": "MINUTE()",
                "description": "Extracts the minute part from a time or datetime value.",
                "examples": [
                    "SELECT MINUTE('12:34:56');",
                    "SELECT MINUTE('2025-01-01 10:30:00');",
                    "SELECT MINUTE(NULL);"
                ]
            },
            {
                "expression": "SECOND(time)",
                "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
                "examples": [
                    "SELECT SECOND('10:11:12');",
                    "SELECT SECOND(4.99999999991e0);",
                    "SELECT SECOND(CAST('2007-07-19' AS DATE));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(HOUR FROM expr)",
                "description": "Extracts the hour field from a time or timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(HOUR FROM TIME '18:45:30');",
                    "SELECT EXTRACT(HOUR FROM TIMESTAMP '2023-10-01 08:15:00');",
                    "SELECT EXTRACT(HOUR FROM CURRENT_TIMESTAMP);"
                ]
            },
            {
                "expression": "EXTRACT(MINUTE FROM ...)",
                "description": "Extracts the minute part from a time or timestamp value. Works with both time and timestamp types.",
                "examples": [
                    "SELECT EXTRACT(MINUTE FROM '2025-01-01 12:34:56'::timestamp);",
                    "SELECT EXTRACT(MINUTE FROM '12:34:56'::time);",
                    "SELECT EXTRACT(MINUTE FROM NULL::timestamp);"
                ]
            },
            {
                "expression": "EXTRACT(SECOND FROM time)",
                "description": "Extracts the second part from a TIME or INTERVAL value. Cannot be applied directly to DATE type.",
                "examples": [
                    "SELECT EXTRACT(SECOND FROM TIME '10:11:12');",
                    "SELECT EXTRACT(SECOND FROM INTERVAL '4.99999999991');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, date, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, date, )\n"
        ]
    },
    {
        "sql_id": "postgresql_37_18",
        "database_name": "postgresql_37_18",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT HOUR(CAST('2007-07-19' AS DATE)),MINUTE(CAST('2007-07-19' AS DATE)),SECOND(CAST('2007-07-19' AS DATE)); -- HOUR, MINUTE, SECOND",
        "target_query": "SELECT EXTRACT(HOUR FROM CAST('2007-07-19' AS TIMESTAMP)), EXTRACT(MINUTE FROM CAST('2007-07-19' AS TIMESTAMP)), EXTRACT(SECOND FROM CAST('2007-07-19' AS TIMESTAMP));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HOUR",
            "MINUTE",
            "SECOND"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HOUR(expr)",
                "description": "Extracts the hour (0\u201323) from a time or datetime expression.",
                "examples": [
                    "SELECT HOUR('18:45:30');",
                    "SELECT HOUR('2023-10-01 08:15:00');",
                    "SELECT HOUR(CURRENT_TIMESTAMP);"
                ]
            },
            {
                "expression": "MINUTE()",
                "description": "Extracts the minute part from a time or datetime value.",
                "examples": [
                    "SELECT MINUTE('12:34:56');",
                    "SELECT MINUTE('2025-01-01 10:30:00');",
                    "SELECT MINUTE(NULL);"
                ]
            },
            {
                "expression": "SECOND(time)",
                "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
                "examples": [
                    "SELECT SECOND('10:11:12');",
                    "SELECT SECOND(4.99999999991e0);",
                    "SELECT SECOND(CAST('2007-07-19' AS DATE));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(HOUR FROM expr)",
                "description": "Extracts the hour field from a time or timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(HOUR FROM TIME '18:45:30');",
                    "SELECT EXTRACT(HOUR FROM TIMESTAMP '2023-10-01 08:15:00');",
                    "SELECT EXTRACT(HOUR FROM CURRENT_TIMESTAMP);"
                ]
            },
            {
                "expression": "EXTRACT(MINUTE FROM ...)",
                "description": "Extracts the minute part from a time or timestamp value. Works with both time and timestamp types.",
                "examples": [
                    "SELECT EXTRACT(MINUTE FROM '2025-01-01 12:34:56'::timestamp);",
                    "SELECT EXTRACT(MINUTE FROM '12:34:56'::time);",
                    "SELECT EXTRACT(MINUTE FROM NULL::timestamp);"
                ]
            },
            {
                "expression": "EXTRACT(SECOND FROM time)",
                "description": "Extracts the second part from a TIME or INTERVAL value. Cannot be applied directly to DATE type.",
                "examples": [
                    "SELECT EXTRACT(SECOND FROM TIME '10:11:12');",
                    "SELECT EXTRACT(SECOND FROM INTERVAL '4.99999999991');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_37_19",
        "database_name": "postgresql_37_19",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT HOUR(CAST(NULL AS DATE)),MINUTE(CAST(NULL AS DATE)),SECOND(CAST(NULL AS DATE)); -- HOUR, MINUTE, SECOND",
        "target_query": "SELECT EXTRACT(HOUR FROM CAST(NULL AS TIMESTAMP)), EXTRACT(MINUTE FROM CAST(NULL AS TIMESTAMP)), EXTRACT(SECOND FROM CAST(NULL AS TIMESTAMP));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HOUR",
            "MINUTE",
            "SECOND"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HOUR(expr)",
                "description": "Extracts the hour (0\u201323) from a time or datetime expression.",
                "examples": [
                    "SELECT HOUR('18:45:30');",
                    "SELECT HOUR('2023-10-01 08:15:00');",
                    "SELECT HOUR(CURRENT_TIMESTAMP);"
                ]
            },
            {
                "expression": "MINUTE()",
                "description": "Extracts the minute part from a time or datetime value.",
                "examples": [
                    "SELECT MINUTE('12:34:56');",
                    "SELECT MINUTE('2025-01-01 10:30:00');",
                    "SELECT MINUTE(NULL);"
                ]
            },
            {
                "expression": "SECOND(time)",
                "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
                "examples": [
                    "SELECT SECOND('10:11:12');",
                    "SELECT SECOND(4.99999999991e0);",
                    "SELECT SECOND(CAST('2007-07-19' AS DATE));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(HOUR FROM expr)",
                "description": "Extracts the hour field from a time or timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(HOUR FROM TIME '18:45:30');",
                    "SELECT EXTRACT(HOUR FROM TIMESTAMP '2023-10-01 08:15:00');",
                    "SELECT EXTRACT(HOUR FROM CURRENT_TIMESTAMP);"
                ]
            },
            {
                "expression": "EXTRACT(MINUTE FROM ...)",
                "description": "Extracts the minute part from a time or timestamp value. Works with both time and timestamp types.",
                "examples": [
                    "SELECT EXTRACT(MINUTE FROM '2025-01-01 12:34:56'::timestamp);",
                    "SELECT EXTRACT(MINUTE FROM '12:34:56'::time);",
                    "SELECT EXTRACT(MINUTE FROM NULL::timestamp);"
                ]
            },
            {
                "expression": "EXTRACT(SECOND FROM time)",
                "description": "Extracts the second part from a TIME or INTERVAL value. Cannot be applied directly to DATE type.",
                "examples": [
                    "SELECT EXTRACT(SECOND FROM TIME '10:11:12');",
                    "SELECT EXTRACT(SECOND FROM INTERVAL '4.99999999991');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_37_20",
        "database_name": "postgresql_37_20",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT HOUR(NULL),MINUTE(NULL),SECOND(NULL); -- HOUR, MINUTE, SECOND",
        "target_query": "SELECT EXTRACT(HOUR FROM NULL::TIMESTAMP), EXTRACT(MINUTE FROM NULL::TIMESTAMP), EXTRACT(SECOND FROM NULL::TIMESTAMP);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HOUR",
            "MINUTE",
            "SECOND"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HOUR(expr)",
                "description": "Extracts the hour (0\u201323) from a time or datetime expression.",
                "examples": [
                    "SELECT HOUR('18:45:30');",
                    "SELECT HOUR('2023-10-01 08:15:00');",
                    "SELECT HOUR(CURRENT_TIMESTAMP);"
                ]
            },
            {
                "expression": "MINUTE()",
                "description": "Extracts the minute part from a time or datetime value.",
                "examples": [
                    "SELECT MINUTE('12:34:56');",
                    "SELECT MINUTE('2025-01-01 10:30:00');",
                    "SELECT MINUTE(NULL);"
                ]
            },
            {
                "expression": "SECOND(time)",
                "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
                "examples": [
                    "SELECT SECOND('10:11:12');",
                    "SELECT SECOND(4.99999999991e0);",
                    "SELECT SECOND(CAST('2007-07-19' AS DATE));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(HOUR FROM expr)",
                "description": "Extracts the hour field from a time or timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(HOUR FROM TIME '18:45:30');",
                    "SELECT EXTRACT(HOUR FROM TIMESTAMP '2023-10-01 08:15:00');",
                    "SELECT EXTRACT(HOUR FROM CURRENT_TIMESTAMP);"
                ]
            },
            {
                "expression": "EXTRACT(MINUTE FROM ...)",
                "description": "Extracts the minute part from a time or timestamp value. Works with both time and timestamp types.",
                "examples": [
                    "SELECT EXTRACT(MINUTE FROM '2025-01-01 12:34:56'::timestamp);",
                    "SELECT EXTRACT(MINUTE FROM '12:34:56'::time);",
                    "SELECT EXTRACT(MINUTE FROM NULL::timestamp);"
                ]
            },
            {
                "expression": "EXTRACT(SECOND FROM time)",
                "description": "Extracts the second part from a TIME or INTERVAL value. Cannot be applied directly to DATE type.",
                "examples": [
                    "SELECT EXTRACT(SECOND FROM TIME '10:11:12');",
                    "SELECT EXTRACT(SECOND FROM INTERVAL '4.99999999991');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_37_21",
        "database_name": "postgresql_37_21",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT CONVERT('a', CHAR(2049)); -- CONVERT",
        "target_query": "SELECT CAST('a' AS CHAR(2049));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONVERT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONVERT(expression USING charset)",
                "description": "Converts data types or changes the character set.",
                "examples": [
                    "SELECT CONVERT('Hello World' USING utf8);",
                    "SELECT CONVERT(1234, CHAR);",
                    "SELECT CONVERT(column_name USING latin1) FROM my_table;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CAST(expression AS target_type)",
                "description": "PostgreSQL uses CAST for type conversion. No direct equivalent for CONVERT TO CHARACTER SET.",
                "examples": [
                    "SELECT CAST('Hello World' AS TEXT);",
                    "SELECT CAST(1234 AS TEXT);",
                    "SELECT column_name::TEXT FROM my_table;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_37_22",
        "database_name": "postgresql_37_22",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT CONCAT(\"value=\", CAST(\"3.4e5\" AS FLOAT)); -- CONCAT",
        "target_query": "SELECT 'value=' || CAST('3.4e5' AS FLOAT);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_37_23",
        "database_name": "postgresql_37_23",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT MAKETIME(1, 2, CAST(\"1.6\" AS FLOAT)); -- MAKETIME",
        "target_query": "SELECT TO_TIMESTAMP('01:02:01.6', 'HH24:MI:SS.US')::TIME;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MAKETIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MAKETIME(hours, minutes, seconds)",
                "description": "Creates a time value from the provided hours, minutes, and seconds.",
                "examples": [
                    "SELECT MAKETIME(1, 30, 45);",
                    "SELECT MAKETIME(12, 0, 0);",
                    "SELECT MAKETIME(23, 59, 59);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP('HH24:MI:SS', 'HH24:MI:SS')::TIME",
                "description": "PostgreSQL doesn't have a direct MAKETIME function, but TO_TIMESTAMP can be used to generate a time from string input.",
                "examples": [
                    "SELECT TO_TIMESTAMP('01:30:45', 'HH24:MI:SS')::TIME;",
                    "SELECT TO_TIMESTAMP('12:00:00', 'HH24:MI:SS')::TIME;",
                    "SELECT TO_TIMESTAMP('23:59:59', 'HH24:MI:SS')::TIME;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_38_3",
        "database_name": "postgresql_38_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT STRCMP(a, b) FROM t1; -- STRCMP",
        "target_query": "SELECT CASE WHEN CAST(a AS VARCHAR) = b THEN 0 WHEN CAST(a AS VARCHAR) < b THEN -1 ELSE 1 END FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "STRCMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "PostgreSQL does not have a direct STRCMP function. The equivalent behavior can be achieved using a CASE statement to compare two strings lexicographically and return -1, 0, or 1 based on the comparison.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, year, )\n(b, varchar(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, smallint, )\n(b, character varying(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_38_5",
        "database_name": "postgresql_38_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT CAST(JSON_EXTRACT('{\\\"key_year\\\":1934}', '$.key_year') AS YEAR); -- JSON_EXTRACT",
        "target_query": "SELECT CAST('{\"key_year\":1934}'::jsonb #> '{key_year}' AS SMALLINT);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "JSON_EXTRACT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "JSON_EXTRACT(json_doc, path)",
                "description": "Extracts data from a JSON document at the specified path(s). Supports dot notation and wildcards.",
                "examples": [
                    "SELECT JSON_EXTRACT('{\"user\": {\"name\": \"Alice\"}}', '$.user.name');",
                    "SELECT JSON_EXTRACT('{\"items\": [10, 20, 30]}', '$.items[1]');",
                    "SELECT JSON_EXTRACT('{\"a\": {\"b\": [1, 2]}}', '$.a.b[0]');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "jsonb_path_query(jsonb_column, path) or jsonb_column #> path_array",
                "description": "Extracts JSON sub-elements using path expressions. Use '#>' for direct path access or 'jsonb_path_query()' for JSONPath-style queries.",
                "examples": [
                    "SELECT '{\"user\": {\"name\": \"Alice\"}}'::jsonb #> '{user,name}';",
                    "SELECT ('{\"items\": [10, 20, 30]}'::jsonb -> 'items') -> 1;",
                    "SELECT jsonb_path_query('{\"a\": {\"b\": [1, 2]}}'::jsonb, '$.a.b[0]');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_38_6",
        "database_name": "postgresql_38_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT CAST(1988 AS YEAR), REPEAT(CAST(1988 AS YEAR), 3) AS c2; -- REPEAT",
        "target_query": "SELECT CAST(1988 AS SMALLINT), REPEAT(CAST(1988 AS VARCHAR), 3) AS c2;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_38_7",
        "database_name": "postgresql_38_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT CONCAT('x', CAST(1988 AS YEAR)); -- CONCAT",
        "target_query": "SELECT 'x' || CAST(1988 AS SMALLINT);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_38_8",
        "database_name": "postgresql_38_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT TIME_TO_SEC(CAST('2030' AS YEAR)); -- TIME_TO_SEC",
        "target_query": "SELECT EXTRACT(EPOCH FROM CAST('20:30' AS TIME));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIME_TO_SEC"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIME_TO_SEC(time)",
                "description": "Converts a time value (HH:MM:SS) to the total number of seconds.",
                "examples": [
                    "SELECT TIME_TO_SEC('15:12:22');",
                    "SELECT TIME_TO_SEC('00:01:00');",
                    "SELECT SEC_TO_TIME(TIME_TO_SEC('15:12:22') - TIME_TO_SEC('14:12:22'));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM time)",
                "description": "Extracts the number of seconds from a time value.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM TIME '15:12:22');",
                    "SELECT EXTRACT(EPOCH FROM TIME '00:01:00');",
                    "SELECT TO_CHAR(TO_TIMESTAMP(EXTRACT(EPOCH FROM TIME '15:12:22') - EXTRACT(EPOCH FROM TIME '14:12:22')), 'HH24:MI:SS');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_38_9",
        "database_name": "postgresql_38_9",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT TIMESTAMPADD(MINUTE, 1, CAST(1988 AS YEAR)); -- TIMESTAMPADD",
        "target_query": "SELECT CAST('1988-01-01' AS TIMESTAMP) + INTERVAL '1 minute';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIMESTAMPADD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMESTAMPADD(unit, interval, datetime_expr)",
                "description": "Adds a time interval to a date or timestamp expression using the specified unit.",
                "examples": [
                    "SELECT TIMESTAMPADD(DAY, 2, '2023-01-01');",
                    "SELECT TIMESTAMPADD(MINUTE, -5, '2023-05-10 12:00:00');",
                    "SELECT TIMESTAMPADD(YEAR, 1, '2020-06-15');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "datetime_expr + INTERVAL 'n unit'",
                "description": "Adds a time interval to a timestamp or date using SQL standard INTERVAL syntax.",
                "examples": [
                    "SELECT DATE '2023-01-01' + INTERVAL '2 day';",
                    "SELECT TIMESTAMP '2023-05-10 12:00:00' + INTERVAL '-5 minute';",
                    "SELECT DATE '2020-06-15' + INTERVAL '1 year';"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_38_10",
        "database_name": "postgresql_38_10",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT CAST(STR_TO_DATE('nope','%d-%m-%Y') AS YEAR); -- STR_TO_DATE",
        "target_query": "SELECT CAST(EXTRACT(YEAR FROM TO_DATE('2025-01-01', 'YYYY-MM-DD')) AS SMALLINT);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "STR_TO_DATE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STR_TO_DATE('09:22', '%H:%i')",
                "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
                "examples": [
                    "SELECT STR_TO_DATE('12:45', '%H:%i');",
                    "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
                    "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP('09:22', 'HH24:MI')",
                "description": "Converts the string '09:22' to a TIME type using TO_TIMESTAMP, with format 'HH24:MI' in PostgreSQL.",
                "examples": [
                    "SELECT TO_TIMESTAMP('12:45', 'HH24:MI');",
                    "SELECT TO_DATE('2000-01-01', 'YYYY-MM-DD');",
                    "SELECT TO_TIMESTAMP('2023-05-06 12:34:56', 'YYYY-MM-DD HH24:MI:SS');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_38_13",
        "database_name": "postgresql_38_13",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT 1 FROM t WHERE CAST(a AS UNSIGNED INTEGER) = 1 AND a = IF(TRUE, NULL, 1); -- IF",
        "target_query": "SELECT 1 FROM t WHERE a = 1 AND a = CASE WHEN TRUE THEN NULL ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "In PostgreSQL, `IF` is not directly supported. Instead, the `CASE WHEN` expression is used to evaluate a condition and return different values based on whether the condition is true or false.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t`\nColumns:\n(a, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t`\nColumns:\n(a, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_40_3",
        "database_name": "postgresql_40_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT hex(a),STRCMP(a,'a'), STRCMP(a,'a ') FROM t1; -- HEX, STRCMP",
        "target_query": "SELECT encode(a::bytea, 'hex'), CASE WHEN a = 'a' THEN 0 WHEN a < 'a' THEN -1 ELSE 1 END, CASE WHEN a = 'a ' THEN 0 WHEN a < 'a ' THEN -1 ELSE 1 END FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX",
            "STRCMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            },
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            },
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "PostgreSQL does not have a direct STRCMP function. The equivalent behavior can be achieved using a CASE statement to compare two strings lexicographically and return -1, 0, or 1 based on the comparison.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_40_7",
        "database_name": "postgresql_40_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT CONCAT(b,c), CONCAT(b,c) = '0101' FROM t1; -- CONCAT",
        "target_query": "SELECT CAST(b AS VARCHAR) || CAST(c AS VARCHAR), (CAST(b AS VARCHAR) || CAST(c AS VARCHAR)) = '0101' FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(b, int(2) unsigned zerofill, )\n(c, int(2) unsigned zerofill, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(b, integer, )\n(c, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_40_8",
        "database_name": "postgresql_40_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "EXPLAIN SELECT b,c FROM t1 WHERE b = 1 AND CONCAT(b,c) = '0101'; -- CONCAT",
        "target_query": "EXPLAIN SELECT b, c FROM t1 WHERE b = 1 AND (CAST(b AS VARCHAR) || CAST(c AS VARCHAR)) = '0101';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(b, int(2) unsigned zerofill, )\n(c, int(2) unsigned zerofill, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(b, integer, )\n(c, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_40_9",
        "database_name": "postgresql_40_9",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT b,c FROM t1 WHERE b = 1 AND CONCAT(b,c) = '0101'; -- CONCAT",
        "target_query": "SELECT b, c FROM t1 WHERE b = 1 AND (CAST(b AS VARCHAR) || CAST(c AS VARCHAR)) = '0101';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(b, int(2) unsigned zerofill, )\n(c, int(2) unsigned zerofill, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(b, integer, )\n(c, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_40_12",
        "database_name": "postgresql_40_12",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 VALUES (NOW()),(NOW()),(NOW()); -- NOW",
        "target_query": "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP),(CURRENT_TIMESTAMP),(CURRENT_TIMESTAMP);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "NOW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "In PostgreSQL, CURRENT_TIMESTAMP is used to retrieve the current date and time, equivalent to NOW() in MySQL and MariaDB.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, timestamp, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, timestamp without time zone, )\n"
        ]
    },
    {
        "sql_id": "postgresql_40_16",
        "database_name": "postgresql_40_16",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT ROW('1', '1') > ROW(a, '1') FROM t1; -- ROW",
        "target_query": "SELECT ROW('1', '1') > ROW(a, '1') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_40_17",
        "database_name": "postgresql_40_17",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT ROW(a, '1') > ROW('1', '1') FROM t1; -- ROW",
        "target_query": "SELECT ROW(a, '1') > ROW('1', '1') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "PostgreSQL supports ROW to group multiple values, and comparisons can be made using IN or equality checks. Subqueries must return only one column.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_41_3",
        "database_name": "postgresql_41_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select count(distinct if(f1,3,f2)) from t1; -- COUNT, IF",
        "target_query": "SELECT count(distinct CASE WHEN f1 != 0 THEN 3 ELSE f2 END) from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "COUNT",
            "IF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COUNT()",
                "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
                "examples": [
                    "EXPLAIN FORMAT=TREE SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
                    "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
                    "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
                ]
            },
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COUNT()",
                "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
                "examples": [
                    "EXPLAIN SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
                    "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
                    "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
                ]
            },
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "In PostgreSQL, `IF` is not directly supported. Instead, the `CASE WHEN` expression is used to evaluate a condition and return different values based on whether the condition is true or false.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, int, )\n(f2, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, integer, )\n(f2, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_42_0",
        "database_name": "postgresql_42_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT inet6_ntoa(inet_ntoa('1')); -- INET6_NTOA, INET_NTOA",
        "target_query": "SELECT host(((1 >> 24) || '.' || ((1 >> 16) & 255) || '.' || ((1 >> 8) & 255) || '.' || (1 & 255))::inet);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "INET6_NTOA",
            "INET_NTOA"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "INET6_NTOA(CAST(ip AS BINARY(16)))",
                "description": "Converts a 16-byte binary IPv6 address to its textual representation in standard IPv6 format.",
                "examples": [
                    "SELECT INET6_NTOA(CAST('::1' AS BINARY(16)));",
                    "SELECT INET6_NTOA(CAST('2001:0db8:85a3:0000:0000:8a2e:0370:7334' AS BINARY(16)));",
                    "SELECT INET6_NTOA(CAST('fe80::1ff:fe23:4567:890a' AS BINARY(16)));"
                ]
            },
            {
                "expression": "INET_NTOA(ip)",
                "description": "The INET_NTOA function converts an integer representation of an IPv4 address to a standard dotted-decimal format string.",
                "examples": [
                    "SELECT INET_NTOA(3232235776);",
                    "SELECT INET_NTOA(16777343);",
                    "SELECT INET_NTOA(2886733345);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "host(ip::inet)",
                "description": "PostgreSQL uses the host() function or ::text to convert an inet type (IPv6 address) to its string representation.",
                "examples": [
                    "SELECT host('::1'::inet);",
                    "SELECT host('2001:0db8:85a3:0000:0000:8a2e:0370:7334'::inet);",
                    "SELECT host('fe80::1ff:fe23:4567:890a'::inet);"
                ]
            },
            {
                "expression": "(integer_ip >> 24) || '.' || ((integer_ip >> 16) & 255) || '.' || ((integer_ip >> 8) & 255) || '.' || (integer_ip & 255)",
                "description": "PostgreSQL does not have a direct INET_NTOA function. However, you can use bitwise operations to convert an integer to a dotted-decimal IP address string.",
                "examples": [
                    "SELECT (3232235776 >> 24) || '.' || ((3232235776 >> 16) & 255) || '.' || ((3232235776 >> 8) & 255) || '.' || (3232235776 & 255);",
                    "SELECT (16777343 >> 24) || '.' || ((16777343 >> 16) & 255) || '.' || ((16777343 >> 8) & 255) || '.' || (16777343 & 255);",
                    "SELECT (2886733345 >> 24) || '.' || ((2886733345 >> 16) & 255) || '.' || ((2886733345 >> 8) & 255) || '.' || (2886733345 & 255);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_42_4",
        "database_name": "postgresql_42_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT HEX(v) FROM t1; -- HEX",
        "target_query": "SELECT encode(v::bytea, 'hex') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(v, varchar(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(v, character varying(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_43_3",
        "database_name": "postgresql_43_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select concat(name,space(level)), concat(name, repeat(' ',level)) from t1; -- CONCAT, SPACE, REPEAT",
        "target_query": "select name || REPEAT(' ', level), name || REPEAT(' ', level) from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT",
            "SPACE",
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            },
            {
                "expression": "SPACE(n)",
                "description": "Returns a string consisting of n space characters.",
                "examples": [
                    "SELECT LENGTH(SPACE(5));",
                    "SELECT CONCAT('A', SPACE(3), 'B');",
                    "SELECT CONCAT(REPEAT('-', 2), SPACE(4), '!');"
                ]
            },
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            },
            {
                "expression": "REPEAT(' ', n)",
                "description": "Returns a string consisting of n space characters by repeating a space character.",
                "examples": [
                    "SELECT LENGTH(REPEAT(' ', 5));",
                    "SELECT CONCAT('A', REPEAT(' ', 3), 'B');",
                    "SELECT CONCAT(REPEAT('-', 2), REPEAT(' ', 4), '!');"
                ]
            },
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(name, varchar(10), )\n(level, smallint, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(name, character varying(10), )\n(level, smallint, )\n"
        ]
    },
    {
        "sql_id": "postgresql_43_5",
        "database_name": "postgresql_43_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "create table t1 select repeat('a',4000) a; -- REPEAT",
        "target_query": "create table t1 as select REPEAT('a',4000) a;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "create table t1 select repeat('a',4000) a; -- REPEAT"
        ],
        "target_related_schemas": [
            "create table t1 as select REPEAT('a',4000) a;"
        ]
    },
    {
        "sql_id": "postgresql_43_14",
        "database_name": "postgresql_43_14",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT",
        "target_query": "CREATE TABLE head AS SELECT b1.b || b2.b AS head FROM t1 b1, t1 b2;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(b, varchar(2), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(b, character varying(2), )\n"
        ]
    },
    {
        "sql_id": "postgresql_43_15",
        "database_name": "postgresql_43_15",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "CREATE TABLE tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2; -- CONCAT",
        "target_query": "CREATE TABLE tail AS SELECT b1.b || b2.b AS tail FROM t1 b1, t1 b2;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `head`\nColumns:\n(head, varchar(4), )\n",
            "Table: `t1`\nColumns:\n(b, varchar(2), )\n"
        ],
        "target_related_schemas": [
            "Table: `head`\nColumns:\n(head, text, )\n",
            "Table: `t1`\nColumns:\n(b, character varying(2), )\n"
        ]
    },
    {
        "sql_id": "postgresql_43_17",
        "database_name": "postgresql_43_17",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT inet6_ntoa(inet_ntoa('1')); -- INET6_NTOA, INET_NTOA",
        "target_query": "SELECT host(((1 >> 24) || '.' || ((1 >> 16) & 255) || '.' || ((1 >> 8) & 255) || '.' || (1 & 255))::inet);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "INET6_NTOA",
            "INET_NTOA"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "INET6_NTOA(CAST(ip AS BINARY(16)))",
                "description": "Converts a 16-byte binary IPv6 address to its textual representation in standard IPv6 format.",
                "examples": [
                    "SELECT INET6_NTOA(CAST('::1' AS BINARY(16)));",
                    "SELECT INET6_NTOA(CAST('2001:0db8:85a3:0000:0000:8a2e:0370:7334' AS BINARY(16)));",
                    "SELECT INET6_NTOA(CAST('fe80::1ff:fe23:4567:890a' AS BINARY(16)));"
                ]
            },
            {
                "expression": "INET_NTOA(ip)",
                "description": "The INET_NTOA function converts an integer representation of an IPv4 address to a standard dotted-decimal format string.",
                "examples": [
                    "SELECT INET_NTOA(3232235776);",
                    "SELECT INET_NTOA(16777343);",
                    "SELECT INET_NTOA(2886733345);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "host(ip::inet)",
                "description": "PostgreSQL uses the host() function or ::text to convert an inet type (IPv6 address) to its string representation.",
                "examples": [
                    "SELECT host('::1'::inet);",
                    "SELECT host('2001:0db8:85a3:0000:0000:8a2e:0370:7334'::inet);",
                    "SELECT host('fe80::1ff:fe23:4567:890a'::inet);"
                ]
            },
            {
                "expression": "(integer_ip >> 24) || '.' || ((integer_ip >> 16) & 255) || '.' || ((integer_ip >> 8) & 255) || '.' || (integer_ip & 255)",
                "description": "PostgreSQL does not have a direct INET_NTOA function. However, you can use bitwise operations to convert an integer to a dotted-decimal IP address string.",
                "examples": [
                    "SELECT (3232235776 >> 24) || '.' || ((3232235776 >> 16) & 255) || '.' || ((3232235776 >> 8) & 255) || '.' || (3232235776 & 255);",
                    "SELECT (16777343 >> 24) || '.' || ((16777343 >> 16) & 255) || '.' || ((16777343 >> 8) & 255) || '.' || (16777343 & 255);",
                    "SELECT (2886733345 >> 24) || '.' || ((2886733345 >> 16) & 255) || '.' || ((2886733345 >> 8) & 255) || '.' || (2886733345 & 255);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `head`\nColumns:\n(head, varchar(4), )\n",
            "Table: `tail`\nColumns:\n(tail, varchar(4), )\n"
        ],
        "target_related_schemas": [
            "Table: `head`\nColumns:\n(head, text, )\n",
            "Table: `tail`\nColumns:\n(tail, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_44_3",
        "database_name": "postgresql_44_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT GROUP_CONCAT(IFNULL(a,'')) FROM t1; -- GROUP_CONCAT, IFNULL",
        "target_query": "SELECT STRING_AGG(COALESCE(a::text,''), ',') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GROUP_CONCAT",
            "IFNULL"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
                "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
                "examples": [
                    "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
                    "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
                ]
            },
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "STRING_AGG(expression, delimiter)",
                "description": "The STRING_AGG function in PostgreSQL concatenates values from multiple rows into a single string, separated by a specified delimiter.",
                "examples": [
                    "SELECT STRING_AGG(name, ', ') FROM students; -- Returns a comma-separated list of names"
                ]
            },
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "PostgreSQL uses COALESCE, which returns the first non-NULL argument. This works exactly like IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, mediumint, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_44_4",
        "database_name": "postgresql_44_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT GROUP_CONCAT(IF(a,a,'')) FROM t1; -- GROUP_CONCAT, IF",
        "target_query": "SELECT STRING_AGG(CASE WHEN a!=0 THEN a::text ELSE '' END, ',') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GROUP_CONCAT",
            "IF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
                "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
                "examples": [
                    "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
                    "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
                ]
            },
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "STRING_AGG(expression, delimiter)",
                "description": "The STRING_AGG function in PostgreSQL concatenates values from multiple rows into a single string, separated by a specified delimiter.",
                "examples": [
                    "SELECT STRING_AGG(name, ', ') FROM students; -- Returns a comma-separated list of names"
                ]
            },
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "In PostgreSQL, `IF` is not directly supported. Instead, the `CASE WHEN` expression is used to evaluate a condition and return different values based on whether the condition is true or false.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, mediumint, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_44_5",
        "database_name": "postgresql_44_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT GROUP_CONCAT(CASE WHEN a THEN a ELSE '' END) FROM t1; -- GROUP_CONCAT",
        "target_query": "SELECT STRING_AGG(CASE WHEN a!=0 THEN a::text ELSE '' END, ',') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GROUP_CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
                "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
                "examples": [
                    "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
                    "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "STRING_AGG(expression, delimiter)",
                "description": "The STRING_AGG function in PostgreSQL concatenates values from multiple rows into a single string, separated by a specified delimiter.",
                "examples": [
                    "SELECT STRING_AGG(name, ', ') FROM students; -- Returns a comma-separated list of names"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, mediumint, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_44_6",
        "database_name": "postgresql_44_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT COALESCE(a,'') FROM t1 GROUP BY 1; -- COALESCE",
        "target_query": "SELECT COALESCE(a::text,'') FROM t1 GROUP BY 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "COALESCE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
                "description": "Returns the first non-NULL value, or merges table partitions.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
                    "ALTER TABLE t1 COALESCE PARTITION 2;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...)",
                "description": "Standard SQL COALESCE function for NULL-handling.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, mediumint, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_44_8",
        "database_name": "postgresql_44_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "CREATE TABLE t2 AS SELECT CONCAT_WS(1,2,3) FROM t1; -- CONCAT_WS",
        "target_query": "CREATE TABLE t2 AS SELECT concat_ws('1', '2', '3') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT_WS"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT_WS(separator, str1, str2, ...)",
                "description": "Concatenates multiple strings with the specified separator. If any argument is NULL, it is ignored.",
                "examples": [
                    "SELECT CONCAT_WS(',', 'apple', 'banana', 'cherry');",
                    "SELECT CONCAT_WS('-', 'hello', 'world');",
                    "SELECT CONCAT_WS(' ', 'this', NULL, 'is', 'a', 'test');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "concat_ws(separator, str1, str2, ...)",
                "description": "Concatenates strings with a separator, ignoring NULL values.",
                "examples": [
                    "SELECT concat_ws(',', 'apple', 'banana', 'cherry');",
                    "SELECT concat_ws('-', 'hello', 'world');",
                    "SELECT concat_ws(' ', 'this', NULL, 'is', 'a', 'test');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, mediumint, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_44_10",
        "database_name": "postgresql_44_10",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "CREATE TABLE t2 AS SELECT LCASE(a) FROM t1; -- LCASE",
        "target_query": "CREATE TABLE t2 AS SELECT LOWER(a::text) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LCASE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LCASE(str)",
                "description": "Converts all characters in a string to lowercase. Equivalent to LOWER(str).",
                "examples": [
                    "SELECT LCASE('TeSt');",
                    "SELECT LCASE(CONCAT('A', 'B', 'C'));",
                    "SELECT LCASE(456);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LOWER(str)",
                "description": "Returns a lowercased version of the input string.",
                "examples": [
                    "SELECT LOWER('TeSt');",
                    "SELECT LOWER(CONCAT('A', 'B', 'C'));",
                    "SELECT LOWER('456');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, mediumint, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_44_12",
        "database_name": "postgresql_44_12",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "CREATE TABLE t2 AS SELECT UCASE(a) FROM t1; -- UCASE",
        "target_query": "CREATE TABLE t2 AS SELECT UPPER(a::text) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UCASE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UCASE(str)",
                "description": "Returns the string `str` with all characters converted to uppercase. UCASE is a synonym for UPPER.",
                "examples": [
                    "SELECT UCASE('hello world');",
                    "SELECT UCASE(CONCAT('abc', '123'));",
                    "SELECT UCASE(REPLACE('test case', 'case', 'CASE'));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "UPPER(str)",
                "description": "Converts all letters in the input string to uppercase.",
                "examples": [
                    "SELECT UPPER('hello world');",
                    "SELECT UPPER(CONCAT('abc', '123'));",
                    "SELECT UPPER(REPLACE('test case', 'case', 'CASE'));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, mediumint, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_44_14",
        "database_name": "postgresql_44_14",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "CREATE TABLE t2 AS SELECT REPEAT(1,2) FROM t1; -- REPEAT",
        "target_query": "CREATE TABLE t2 AS SELECT REPEAT('1', 2) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, mediumint, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_44_16",
        "database_name": "postgresql_44_16",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "CREATE TABLE t2 AS SELECT ELT(1,111,222,333) FROM t1; -- ELT",
        "target_query": "CREATE TABLE t2 AS SELECT CASE WHEN 1 > 0 AND 1 <= array_length(ARRAY[111, 222, 333], 1) THEN (ARRAY[111, 222, 333])[1] ELSE NULL END FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ELT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "ELT(2, 'apple', 'banana', 'cherry')",
                "description": "Returns the N-th element from the list, where N is the first argument.",
                "examples": [
                    "SELECT ELT(2, 'apple', 'banana', 'cherry');  -- Returns 'banana'",
                    "SELECT ELT(1, 'red', 'green', 'blue');  -- Returns 'red'",
                    "SELECT ELT(3, 'dog', 'cat', 'bird');  -- Returns 'bird'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN 2 > 0 AND 2 <= array_length(ARRAY['apple', 'banana', 'cherry'], 1) THEN (ARRAY['apple', 'banana', 'cherry'])[2] ELSE NULL END",
                "description": "Uses a CASE statement and an array to return the N-th element.",
                "examples": [
                    "SELECT CASE WHEN 2 > 0 AND 2 <= array_length(ARRAY['apple', 'banana', 'cherry'], 1) THEN (ARRAY['apple', 'banana', 'cherry'])[2] ELSE NULL END;  -- Returns 'banana'",
                    "SELECT CASE WHEN 1 > 0 AND 1 <= array_length(ARRAY['red', 'green', 'blue'], 1) THEN (ARRAY['red', 'green', 'blue'])[1] ELSE NULL END;  -- Returns 'red'",
                    "SELECT CASE WHEN 3 > 0 AND 3 <= array_length(ARRAY['dog', 'cat', 'bird'], 1) THEN (ARRAY['dog', 'cat', 'bird'])[3] ELSE NULL END;  -- Returns 'bird'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, mediumint, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_45_2",
        "database_name": "postgresql_45_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT HEX(a) FROM t1; -- HEX",
        "target_query": "SELECT encode(a::bytea, 'hex') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_45_6",
        "database_name": "postgresql_45_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT HEX(a) FROM t2; -- HEX",
        "target_query": "SELECT encode(a::bytea, 'hex') FROM t2;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, char(10), )\n",
            "Table: `t2`\nColumns:\n(a, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, text, )\n",
            "Table: `t2`\nColumns:\n(a, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_45_11",
        "database_name": "postgresql_45_11",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select * from t1 where a=lpad('xxx',10,' '); -- LPAD",
        "target_query": "SELECT * FROM t1 WHERE a=LPAD('xxx',10,' ');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached, just like in MySQL.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, char(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, character(20), )\n"
        ]
    },
    {
        "sql_id": "postgresql_45_15",
        "database_name": "postgresql_45_15",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select ifnull(c1,''), ifnull(null,c1) from t1; -- IFNULL",
        "target_query": "SELECT COALESCE(c1,''), COALESCE(NULL,c1) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IFNULL"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "PostgreSQL uses COALESCE, which returns the first non-NULL argument. This works exactly like IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_45_16",
        "database_name": "postgresql_45_16",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select if(1,c1,''), if(0,c1,'') from t1; -- IF",
        "target_query": "SELECT CASE WHEN 1!=0 THEN c1 ELSE '' END, CASE WHEN 0!=0 THEN c1 ELSE '' END FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "In PostgreSQL, `IF` is not directly supported. Instead, the `CASE WHEN` expression is used to evaluate a condition and return different values based on whether the condition is true or false.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_45_17",
        "database_name": "postgresql_45_17",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select coalesce('',c1), coalesce(null,c1) from t1; -- COALESCE",
        "target_query": "SELECT COALESCE('',c1), COALESCE(NULL,c1) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "COALESCE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
                "description": "Returns the first non-NULL value, or merges table partitions.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
                    "ALTER TABLE t1 COALESCE PARTITION 2;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...)",
                "description": "Standard SQL COALESCE function for NULL-handling.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_45_18",
        "database_name": "postgresql_45_18",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select least(c1,''), greatest(c1,'') from t1; -- LEAST, GREATEST",
        "target_query": "SELECT LEAST(c1,''), GREATEST(c1,'') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LEAST",
            "GREATEST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            },
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest non-null value among its arguments. NULL values are ignored unless all values are NULL.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            },
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_45_19",
        "database_name": "postgresql_45_19",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select locate(c1,''), locate('',c1) from t1; -- LOCATE",
        "target_query": "SELECT POSITION(c1 IN ''), POSITION('' IN c1) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LOCATE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LOCATE(substr, str[, start_position])",
                "description": "Returns the position of the first occurrence of substring 'substr' in string 'str'. If 'start_position' is provided, the search starts from that position.",
                "examples": [
                    "select locate('a', 'banana', 2);",
                    "select locate('foo', 'foobar', 2);",
                    "select locate('ab', 'abcab', 3);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION(substr IN str)",
                "description": "Returns the position of the first occurrence of substring 'substr' in string 'str'. If not found, returns 0. PostgreSQL does not support 'start_position'.",
                "examples": [
                    "select position('a' IN 'banana');",
                    "select position('foo' IN 'foobar');",
                    "select position('ab' IN 'abcab');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_45_20",
        "database_name": "postgresql_45_20",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select field(c1,''),field('',c1) from t1; -- FIELD",
        "target_query": "SELECT COALESCE(array_position(ARRAY[c1,''], c1), 0), COALESCE(array_position(ARRAY['',c1], ''), 0) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "FIELD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FIELD(val, val1, val2, ..., valN)",
                "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
                "examples": [
                    "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
                    "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
                    "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(array_position(ARRAY[val1, val2, ..., valN], val), 0)",
                "description": "Returns the index (1-based) of 'val' in the array. Returns 0 if not found, to match MySQL FIELD() behavior.",
                "examples": [
                    "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'c'), 0) AS result;",
                    "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'x'), 0) AS result;",
                    "SELECT COALESCE(array_position(ARRAY['b', 'b', 'b'], 'b'), 0) AS result;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_45_21",
        "database_name": "postgresql_45_21",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select concat(c1,''), concat('',c1) from t1; -- CONCAT",
        "target_query": "SELECT c1 || '', '' || c1 FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_45_22",
        "database_name": "postgresql_45_22",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select concat_ws(c1,'',''), concat_ws('',c1,'') from t1; -- CONCAT_WS",
        "target_query": "SELECT concat_ws(c1,'',''), concat_ws('',c1,'') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT_WS"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT_WS(separator, str1, str2, ...)",
                "description": "Concatenates multiple strings with the specified separator. If any argument is NULL, it is ignored.",
                "examples": [
                    "SELECT CONCAT_WS(',', 'apple', 'banana', 'cherry');",
                    "SELECT CONCAT_WS('-', 'hello', 'world');",
                    "SELECT CONCAT_WS(' ', 'this', NULL, 'is', 'a', 'test');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "concat_ws(separator, str1, str2, ...)",
                "description": "Concatenates strings with a separator, ignoring NULL values.",
                "examples": [
                    "SELECT concat_ws(',', 'apple', 'banana', 'cherry');",
                    "SELECT concat_ws('-', 'hello', 'world');",
                    "SELECT concat_ws(' ', 'this', NULL, 'is', 'a', 'test');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_45_23",
        "database_name": "postgresql_45_23",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select elt(1,c1,''),elt(1,'',c1) from t1; -- ELT",
        "target_query": "SELECT CASE WHEN 1 > 0 AND 1 <= array_length(ARRAY[c1,''], 1) THEN (ARRAY[c1,''])[1] ELSE NULL END, CASE WHEN 1 > 0 AND 1 <= array_length(ARRAY['',c1], 1) THEN (ARRAY['',c1])[1] ELSE NULL END FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ELT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "ELT(2, 'apple', 'banana', 'cherry')",
                "description": "Returns the N-th element from the list, where N is the first argument.",
                "examples": [
                    "SELECT ELT(2, 'apple', 'banana', 'cherry');  -- Returns 'banana'",
                    "SELECT ELT(1, 'red', 'green', 'blue');  -- Returns 'red'",
                    "SELECT ELT(3, 'dog', 'cat', 'bird');  -- Returns 'bird'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN 2 > 0 AND 2 <= array_length(ARRAY['apple', 'banana', 'cherry'], 1) THEN (ARRAY['apple', 'banana', 'cherry'])[2] ELSE NULL END",
                "description": "Uses a CASE statement and an array to return the N-th element.",
                "examples": [
                    "SELECT CASE WHEN 2 > 0 AND 2 <= array_length(ARRAY['apple', 'banana', 'cherry'], 1) THEN (ARRAY['apple', 'banana', 'cherry'])[2] ELSE NULL END;  -- Returns 'banana'",
                    "SELECT CASE WHEN 1 > 0 AND 1 <= array_length(ARRAY['red', 'green', 'blue'], 1) THEN (ARRAY['red', 'green', 'blue'])[1] ELSE NULL END;  -- Returns 'red'",
                    "SELECT CASE WHEN 3 > 0 AND 3 <= array_length(ARRAY['dog', 'cat', 'bird'], 1) THEN (ARRAY['dog', 'cat', 'bird'])[3] ELSE NULL END;  -- Returns 'bird'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_45_24",
        "database_name": "postgresql_45_24",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select lpad(c1,3,'x'), lpad('x',3,c1) from t1; -- LPAD",
        "target_query": "SELECT LPAD(c1,3,'x'), LPAD('x',3,c1) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached, just like in MySQL.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_45_25",
        "database_name": "postgresql_45_25",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select rpad(c1,3,'x'), rpad('x',3,c1) from t1; -- RPAD",
        "target_query": "SELECT RPAD(c1,3,'x'), RPAD('x',3,c1) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "PostgreSQL doesn't have a native RPAD, but can simulate it.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::text, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, char(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, character(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_46_0",
        "database_name": "postgresql_46_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select str_to_date(concat('15-01-2001',' 2:59:58.999'),concat('%d-%m-%Y',' ','%H:%i:%s.%f')); -- STR_TO_DATE, CONCAT",
        "target_query": "SELECT TO_TIMESTAMP('15-01-2001' || ' 2:59:58.999', 'DD-MM-YYYY HH24:MI:SS.US');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "STR_TO_DATE",
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STR_TO_DATE('09:22', '%H:%i')",
                "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
                "examples": [
                    "SELECT STR_TO_DATE('12:45', '%H:%i');",
                    "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
                    "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
                ]
            },
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP('09:22', 'HH24:MI')",
                "description": "Converts the string '09:22' to a TIME type using TO_TIMESTAMP, with format 'HH24:MI' in PostgreSQL.",
                "examples": [
                    "SELECT TO_TIMESTAMP('12:45', 'HH24:MI');",
                    "SELECT TO_DATE('2000-01-01', 'YYYY-MM-DD');",
                    "SELECT TO_TIMESTAMP('2023-05-06 12:34:56', 'YYYY-MM-DD HH24:MI:SS');"
                ]
            },
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_46_1",
        "database_name": "postgresql_46_1",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select STR_TO_DATE('2004.12.12 22.30.59','%Y.%m.%d %T'); -- STR_TO_DATE",
        "target_query": "SELECT TO_TIMESTAMP('2004.12.12 22.30.59', 'YYYY.MM.DD HH24:MI:SS');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "STR_TO_DATE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STR_TO_DATE('09:22', '%H:%i')",
                "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
                "examples": [
                    "SELECT STR_TO_DATE('12:45', '%H:%i');",
                    "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
                    "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP('09:22', 'HH24:MI')",
                "description": "Converts the string '09:22' to a TIME type using TO_TIMESTAMP, with format 'HH24:MI' in PostgreSQL.",
                "examples": [
                    "SELECT TO_TIMESTAMP('12:45', 'HH24:MI');",
                    "SELECT TO_DATE('2000-01-01', 'YYYY-MM-DD');",
                    "SELECT TO_TIMESTAMP('2023-05-06 12:34:56', 'YYYY-MM-DD HH24:MI:SS');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_46_11",
        "database_name": "postgresql_46_11",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select concat('',str_to_date('8:11:2 03-01-02','%H:%i:%S %y-%m-%d')); -- CONCAT, STR_TO_DATE",
        "target_query": "SELECT '' || TO_TIMESTAMP('8:11:2 03-01-02', 'HH24:MI:SS YY-MM-DD');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT",
            "STR_TO_DATE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            },
            {
                "expression": "STR_TO_DATE('09:22', '%H:%i')",
                "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
                "examples": [
                    "SELECT STR_TO_DATE('12:45', '%H:%i');",
                    "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
                    "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            },
            {
                "expression": "TO_TIMESTAMP('09:22', 'HH24:MI')",
                "description": "Converts the string '09:22' to a TIME type using TO_TIMESTAMP, with format 'HH24:MI' in PostgreSQL.",
                "examples": [
                    "SELECT TO_TIMESTAMP('12:45', 'HH24:MI');",
                    "SELECT TO_DATE('2000-01-01', 'YYYY-MM-DD');",
                    "SELECT TO_TIMESTAMP('2023-05-06 12:34:56', 'YYYY-MM-DD HH24:MI:SS');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(date1, char(30), )\n(format1, char(30), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(date1, character(30), )\n(format1, character(30), )\n"
        ]
    },
    {
        "sql_id": "postgresql_46_15",
        "database_name": "postgresql_46_15",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select date_format(d,\"%d\") from t1 order by 1; -- DATE_FORMAT",
        "target_query": "SELECT TO_CHAR(d, 'DD') FROM t1 ORDER BY 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE_FORMAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(date_expr, format_str)",
                "description": "Formats a date/time value according to a format string using PostgreSQL-style specifiers.",
                "examples": [
                    "SELECT TO_CHAR(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT TO_CHAR(DATE '2023-01-15', 'DD-MM-YYYY');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(d, date, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(d, date, )\n"
        ]
    },
    {
        "sql_id": "postgresql_46_17",
        "database_name": "postgresql_46_17",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select date_format('2004-01-01','%W (%a), %e %M (%b) %Y'); -- DATE_FORMAT",
        "target_query": "SELECT TO_CHAR('2004-01-01'::DATE, 'FMDay (Dy), FMDD FMMonth (Mon) YYYY');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE_FORMAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(date_expr, format_str)",
                "description": "Formats a date/time value according to a format string using PostgreSQL-style specifiers.",
                "examples": [
                    "SELECT TO_CHAR(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT TO_CHAR(DATE '2023-01-15', 'DD-MM-YYYY');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_47_0",
        "database_name": "postgresql_47_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT TIME_FORMAT(\"24:00:00\", '%r'); -- TIME_FORMAT",
        "target_query": "SELECT TO_CHAR(TIME '24:00:00', 'HH12:MI:SS AM');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIME_FORMAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIME_FORMAT(time, format)",
                "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
                "examples": [
                    "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
                    "SELECT TIME_FORMAT('18:05:07', '%r');",
                    "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(time, format)",
                "description": "Formats a TIME value using PostgreSQL's TO_CHAR and a format string.",
                "examples": [
                    "SELECT TO_CHAR(TIME '18:05:07', 'HH24:MI:SS');",
                    "SELECT TO_CHAR(TIME '18:05:07', 'HH12:MI:SS AM');",
                    "SELECT TO_CHAR(TIME '18:05:07', 'MI:SS');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_47_1",
        "database_name": "postgresql_47_1",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT TIME_FORMAT(\"00:00:00\", '%r'); -- TIME_FORMAT",
        "target_query": "SELECT TO_CHAR(TIME '00:00:00', 'HH12:MI:SS AM');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIME_FORMAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIME_FORMAT(time, format)",
                "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
                "examples": [
                    "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
                    "SELECT TIME_FORMAT('18:05:07', '%r');",
                    "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(time, format)",
                "description": "Formats a TIME value using PostgreSQL's TO_CHAR and a format string.",
                "examples": [
                    "SELECT TO_CHAR(TIME '18:05:07', 'HH24:MI:SS');",
                    "SELECT TO_CHAR(TIME '18:05:07', 'HH12:MI:SS AM');",
                    "SELECT TO_CHAR(TIME '18:05:07', 'MI:SS');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_47_2",
        "database_name": "postgresql_47_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT TIME_FORMAT(\"12:00:00\", '%r'); -- TIME_FORMAT",
        "target_query": "SELECT TO_CHAR(TIME '12:00:00', 'HH12:MI:SS AM');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIME_FORMAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIME_FORMAT(time, format)",
                "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
                "examples": [
                    "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
                    "SELECT TIME_FORMAT('18:05:07', '%r');",
                    "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(time, format)",
                "description": "Formats a TIME value using PostgreSQL's TO_CHAR and a format string.",
                "examples": [
                    "SELECT TO_CHAR(TIME '18:05:07', 'HH24:MI:SS');",
                    "SELECT TO_CHAR(TIME '18:05:07', 'HH12:MI:SS AM');",
                    "SELECT TO_CHAR(TIME '18:05:07', 'MI:SS');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_47_3",
        "database_name": "postgresql_47_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT TIME_FORMAT(\"15:00:00\", '%r'); -- TIME_FORMAT",
        "target_query": "SELECT TO_CHAR(TIME '15:00:00', 'HH12:MI:SS AM');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIME_FORMAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIME_FORMAT(time, format)",
                "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
                "examples": [
                    "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
                    "SELECT TIME_FORMAT('18:05:07', '%r');",
                    "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(time, format)",
                "description": "Formats a TIME value using PostgreSQL's TO_CHAR and a format string.",
                "examples": [
                    "SELECT TO_CHAR(TIME '18:05:07', 'HH24:MI:SS');",
                    "SELECT TO_CHAR(TIME '18:05:07', 'HH12:MI:SS AM');",
                    "SELECT TO_CHAR(TIME '18:05:07', 'MI:SS');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_47_4",
        "database_name": "postgresql_47_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT TIME_FORMAT(\"01:00:00\", '%r'); -- TIME_FORMAT",
        "target_query": "SELECT TO_CHAR(TIME '01:00:00', 'HH12:MI:SS AM');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIME_FORMAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIME_FORMAT(time, format)",
                "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
                "examples": [
                    "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
                    "SELECT TIME_FORMAT('18:05:07', '%r');",
                    "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(time, format)",
                "description": "Formats a TIME value using PostgreSQL's TO_CHAR and a format string.",
                "examples": [
                    "SELECT TO_CHAR(TIME '18:05:07', 'HH24:MI:SS');",
                    "SELECT TO_CHAR(TIME '18:05:07', 'HH12:MI:SS AM');",
                    "SELECT TO_CHAR(TIME '18:05:07', 'MI:SS');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_47_6",
        "database_name": "postgresql_47_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT TIME_FORMAT(\"00:00:00\", '%l %p'); -- TIME_FORMAT",
        "target_query": "SELECT TO_CHAR(TIME '00:00:00', 'HH12 AM');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIME_FORMAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIME_FORMAT(time, format)",
                "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
                "examples": [
                    "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
                    "SELECT TIME_FORMAT('18:05:07', '%r');",
                    "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(time, format)",
                "description": "Formats a TIME value using PostgreSQL's TO_CHAR and a format string.",
                "examples": [
                    "SELECT TO_CHAR(TIME '18:05:07', 'HH24:MI:SS');",
                    "SELECT TO_CHAR(TIME '18:05:07', 'HH12:MI:SS AM');",
                    "SELECT TO_CHAR(TIME '18:05:07', 'MI:SS');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_47_7",
        "database_name": "postgresql_47_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT TIME_FORMAT(\"01:00:00\", '%l %p'); -- TIME_FORMAT",
        "target_query": "SELECT TO_CHAR(TIME '01:00:00', 'HH12 AM');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIME_FORMAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIME_FORMAT(time, format)",
                "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
                "examples": [
                    "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
                    "SELECT TIME_FORMAT('18:05:07', '%r');",
                    "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(time, format)",
                "description": "Formats a TIME value using PostgreSQL's TO_CHAR and a format string.",
                "examples": [
                    "SELECT TO_CHAR(TIME '18:05:07', 'HH24:MI:SS');",
                    "SELECT TO_CHAR(TIME '18:05:07', 'HH12:MI:SS AM');",
                    "SELECT TO_CHAR(TIME '18:05:07', 'MI:SS');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_47_8",
        "database_name": "postgresql_47_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT TIME_FORMAT(\"12:00:00\", '%l %p'); -- TIME_FORMAT",
        "target_query": "SELECT TO_CHAR(TIME '12:00:00', 'HH12 AM');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIME_FORMAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIME_FORMAT(time, format)",
                "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
                "examples": [
                    "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
                    "SELECT TIME_FORMAT('18:05:07', '%r');",
                    "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(time, format)",
                "description": "Formats a TIME value using PostgreSQL's TO_CHAR and a format string.",
                "examples": [
                    "SELECT TO_CHAR(TIME '18:05:07', 'HH24:MI:SS');",
                    "SELECT TO_CHAR(TIME '18:05:07', 'HH12:MI:SS AM');",
                    "SELECT TO_CHAR(TIME '18:05:07', 'MI:SS');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_47_9",
        "database_name": "postgresql_47_9",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT TIME_FORMAT(\"23:00:00\", '%l %p'); -- TIME_FORMAT",
        "target_query": "SELECT TO_CHAR(TIME '23:00:00', 'HH12 AM');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIME_FORMAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIME_FORMAT(time, format)",
                "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
                "examples": [
                    "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
                    "SELECT TIME_FORMAT('18:05:07', '%r');",
                    "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(time, format)",
                "description": "Formats a TIME value using PostgreSQL's TO_CHAR and a format string.",
                "examples": [
                    "SELECT TO_CHAR(TIME '18:05:07', 'HH24:MI:SS');",
                    "SELECT TO_CHAR(TIME '18:05:07', 'HH12:MI:SS AM');",
                    "SELECT TO_CHAR(TIME '18:05:07', 'MI:SS');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_47_10",
        "database_name": "postgresql_47_10",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT TIME_FORMAT(\"24:00:00\", '%l %p'); -- TIME_FORMAT",
        "target_query": "SELECT TO_CHAR(TIME '24:00:00', 'HH12 AM');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIME_FORMAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIME_FORMAT(time, format)",
                "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
                "examples": [
                    "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
                    "SELECT TIME_FORMAT('18:05:07', '%r');",
                    "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(time, format)",
                "description": "Formats a TIME value using PostgreSQL's TO_CHAR and a format string.",
                "examples": [
                    "SELECT TO_CHAR(TIME '18:05:07', 'HH24:MI:SS');",
                    "SELECT TO_CHAR(TIME '18:05:07', 'HH12:MI:SS AM');",
                    "SELECT TO_CHAR(TIME '18:05:07', 'MI:SS');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_47_13",
        "database_name": "postgresql_47_13",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select str_to_date('04 /30/2004', '%m /%d/%Y'); -- STR_TO_DATE",
        "target_query": "SELECT TO_TIMESTAMP('04 /30/2004', 'MM /DD/YYYY');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "STR_TO_DATE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STR_TO_DATE('09:22', '%H:%i')",
                "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
                "examples": [
                    "SELECT STR_TO_DATE('12:45', '%H:%i');",
                    "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
                    "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP('09:22', 'HH24:MI')",
                "description": "Converts the string '09:22' to a TIME type using TO_TIMESTAMP, with format 'HH24:MI' in PostgreSQL.",
                "examples": [
                    "SELECT TO_TIMESTAMP('12:45', 'HH24:MI');",
                    "SELECT TO_DATE('2000-01-01', 'YYYY-MM-DD');",
                    "SELECT TO_TIMESTAMP('2023-05-06 12:34:56', 'YYYY-MM-DD HH24:MI:SS');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_47_14",
        "database_name": "postgresql_47_14",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select str_to_date('04/30 /2004', '%m /%d /%Y'); -- STR_TO_DATE",
        "target_query": "SELECT TO_TIMESTAMP('04/30 /2004', 'MM /DD /YYYY');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "STR_TO_DATE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STR_TO_DATE('09:22', '%H:%i')",
                "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
                "examples": [
                    "SELECT STR_TO_DATE('12:45', '%H:%i');",
                    "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
                    "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP('09:22', 'HH24:MI')",
                "description": "Converts the string '09:22' to a TIME type using TO_TIMESTAMP, with format 'HH24:MI' in PostgreSQL.",
                "examples": [
                    "SELECT TO_TIMESTAMP('12:45', 'HH24:MI');",
                    "SELECT TO_DATE('2000-01-01', 'YYYY-MM-DD');",
                    "SELECT TO_TIMESTAMP('2023-05-06 12:34:56', 'YYYY-MM-DD HH24:MI:SS');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_47_15",
        "database_name": "postgresql_47_15",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select str_to_date('04/30/2004 ', '%m/%d/%Y '); -- STR_TO_DATE",
        "target_query": "SELECT TO_TIMESTAMP('04/30/2004 ', 'MM/DD/YYYY ');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "STR_TO_DATE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STR_TO_DATE('09:22', '%H:%i')",
                "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
                "examples": [
                    "SELECT STR_TO_DATE('12:45', '%H:%i');",
                    "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
                    "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP('09:22', 'HH24:MI')",
                "description": "Converts the string '09:22' to a TIME type using TO_TIMESTAMP, with format 'HH24:MI' in PostgreSQL.",
                "examples": [
                    "SELECT TO_TIMESTAMP('12:45', 'HH24:MI');",
                    "SELECT TO_DATE('2000-01-01', 'YYYY-MM-DD');",
                    "SELECT TO_TIMESTAMP('2023-05-06 12:34:56', 'YYYY-MM-DD HH24:MI:SS');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_47_18",
        "database_name": "postgresql_47_18",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT DATE_FORMAT(\"2009-01-01\",'%W %d %M %Y') as valid_date; -- DATE_FORMAT",
        "target_query": "SELECT TO_CHAR(DATE '2009-01-01', 'Day DD Month YYYY') AS valid_date;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE_FORMAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(date_expr, format_str)",
                "description": "Formats a date/time value according to a format string using PostgreSQL-style specifiers.",
                "examples": [
                    "SELECT TO_CHAR(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT TO_CHAR(DATE '2023-01-15', 'DD-MM-YYYY');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_48_0",
        "database_name": "postgresql_48_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT JSON_EXTRACT('{\"id\": \"3\", \"$name\": \"Barney\"}', \"$.id\"); -- JSON_EXTRACT",
        "target_query": "SELECT '{\"id\": \"3\", \"$name\": \"Barney\"}'::jsonb #> '{id}';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "JSON_EXTRACT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "JSON_EXTRACT(json_doc, path)",
                "description": "Extracts data from a JSON document at the specified path(s). Supports dot notation and wildcards.",
                "examples": [
                    "SELECT JSON_EXTRACT('{\"user\": {\"name\": \"Alice\"}}', '$.user.name');",
                    "SELECT JSON_EXTRACT('{\"items\": [10, 20, 30]}', '$.items[1]');",
                    "SELECT JSON_EXTRACT('{\"a\": {\"b\": [1, 2]}}', '$.a.b[0]');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "jsonb_path_query(jsonb_column, path) or jsonb_column #> path_array",
                "description": "Extracts JSON sub-elements using path expressions. Use '#>' for direct path access or 'jsonb_path_query()' for JSONPath-style queries.",
                "examples": [
                    "SELECT '{\"user\": {\"name\": \"Alice\"}}'::jsonb #> '{user,name}';",
                    "SELECT ('{\"items\": [10, 20, 30]}'::jsonb -> 'items') -> 1;",
                    "SELECT jsonb_path_query('{\"a\": {\"b\": [1, 2]}}'::jsonb, '$.a.b[0]');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_48_1",
        "database_name": "postgresql_48_1",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT JSON_EXTRACT('{\"id\": \"3\", \"$name\": \"$Barney\"}', \"$.$name\"); -- JSON_EXTRACT",
        "target_query": "SELECT '{\"id\": \"3\", \"$name\": \"$Barney\"}'::jsonb #> '{$name}';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "JSON_EXTRACT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "JSON_EXTRACT(json_doc, path)",
                "description": "Extracts data from a JSON document at the specified path(s). Supports dot notation and wildcards.",
                "examples": [
                    "SELECT JSON_EXTRACT('{\"user\": {\"name\": \"Alice\"}}', '$.user.name');",
                    "SELECT JSON_EXTRACT('{\"items\": [10, 20, 30]}', '$.items[1]');",
                    "SELECT JSON_EXTRACT('{\"a\": {\"b\": [1, 2]}}', '$.a.b[0]');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "jsonb_path_query(jsonb_column, path) or jsonb_column #> path_array",
                "description": "Extracts JSON sub-elements using path expressions. Use '#>' for direct path access or 'jsonb_path_query()' for JSONPath-style queries.",
                "examples": [
                    "SELECT '{\"user\": {\"name\": \"Alice\"}}'::jsonb #> '{user,name}';",
                    "SELECT ('{\"items\": [10, 20, 30]}'::jsonb -> 'items') -> 1;",
                    "SELECT jsonb_path_query('{\"a\": {\"b\": [1, 2]}}'::jsonb, '$.a.b[0]');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_49_5",
        "database_name": "postgresql_49_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select concat('|', text1, '|') as c from t1 where text1='teststring' or text1 like 'teststring_%' order by c; -- CONCAT",
        "target_query": "SELECT '|' || text1 || '|' AS c FROM t1 WHERE text1='teststring' OR text1 LIKE 'teststring_%' ORDER BY c;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(text1, char(32), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(text1, character(32), )\n"
        ]
    },
    {
        "sql_id": "postgresql_49_6",
        "database_name": "postgresql_49_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select concat('|', text1, '|') from t1 where text1='teststring' or text1 > 'teststring\\\\t'; -- CONCAT",
        "target_query": "SELECT '|' || text1 || '|' FROM t1 WHERE text1='teststring' OR text1 > 'teststring\\\\t';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(text1, char(32), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(text1, character(32), )\n"
        ]
    },
    {
        "sql_id": "postgresql_49_7",
        "database_name": "postgresql_49_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select text1, length(text1) from t1 order by text1; -- LENGTH",
        "target_query": "SELECT text1, octet_length(text1) FROM t1 ORDER BY text1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(text1, char(32), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(text1, character(32), )\n"
        ]
    },
    {
        "sql_id": "postgresql_49_9",
        "database_name": "postgresql_49_9",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select concat('|', text1, '|') from t1 order by text1; -- CONCAT",
        "target_query": "SELECT '|' || text1 || '|' FROM t1 ORDER BY text1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(text1, char(32), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(text1, character(32), )\n"
        ]
    },
    {
        "sql_id": "postgresql_49_10",
        "database_name": "postgresql_49_10",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select concat('|', text1, '|') from t1 where text1='teststring' or text1 > 'teststring\\\\t'; -- CONCAT",
        "target_query": "SELECT '|' || text1 || '|' FROM t1 WHERE text1='teststring' OR text1 > 'teststring\\\\t';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(text1, char(32), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(text1, character(32), )\n"
        ]
    },
    {
        "sql_id": "postgresql_49_11",
        "database_name": "postgresql_49_11",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select concat('|', text1, '|') from t1 where text1='teststring'; -- CONCAT",
        "target_query": "SELECT '|' || text1 || '|' FROM t1 WHERE text1='teststring';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(text1, char(32), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(text1, character(32), )\n"
        ]
    },
    {
        "sql_id": "postgresql_49_12",
        "database_name": "postgresql_49_12",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select concat('|', text1, '|') from t1 where text1='teststring '; -- CONCAT",
        "target_query": "SELECT '|' || text1 || '|' FROM t1 WHERE text1='teststring ';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(text1, char(32), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(text1, character(32), )\n"
        ]
    },
    {
        "sql_id": "postgresql_50_3",
        "database_name": "postgresql_50_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT CONCAT(\"Let's create some new events from the name of \", USER()); -- CONCAT, USER",
        "target_query": "SELECT 'Let''s create some new events from the name of ' || CURRENT_USER;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT",
            "USER"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            },
            {
                "expression": "USER()",
                "description": "Returns the current MySQL user and host in the format 'username@hostname'.",
                "examples": [
                    "SELECT USER();"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            },
            {
                "expression": "CURRENT_USER",
                "description": "Returns the current user executing the query. Similar to MySQL's USER().",
                "examples": [
                    "SELECT CURRENT_USER;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_51_2",
        "database_name": "postgresql_51_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 VALUES ( 2, REPEAT('-', 104) ); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES ( 2, REPEAT('-', 104)::BYTEA );",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, int, )\n(f2, longblob, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, integer, )\n(f2, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_51_3",
        "database_name": "postgresql_51_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 VALUES ( 1, REPEAT('x', 104) ); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES ( 1, REPEAT('x', 104)::BYTEA );",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, int, )\n(f2, longblob, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, integer, )\n(f2, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_51_7",
        "database_name": "postgresql_51_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT CONCAT(f1, '') AS dummy FROM t1 ORDER BY dummy; -- CONCAT",
        "target_query": "SELECT f1 || '' AS dummy FROM t1 ORDER BY dummy;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, varchar(100), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, character varying(100), )\n"
        ]
    },
    {
        "sql_id": "postgresql_51_11",
        "database_name": "postgresql_51_11",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT * FROM t1 ORDER BY UNIX_TIMESTAMP(f1); -- UNIX_TIMESTAMP",
        "target_query": "SELECT * FROM t1 ORDER BY EXTRACT(EPOCH FROM f1);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Extracts the number of seconds since the Unix epoch from a timestamp using the EPOCH keyword.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, date, )\n"
        ]
    },
    {
        "sql_id": "postgresql_51_18",
        "database_name": "postgresql_51_18",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 VALUES (1, REPEAT('x', 40001)); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES (1, REPEAT('x', 40001));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, text, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_51_19",
        "database_name": "postgresql_51_19",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 VALUES (2, REPEAT('x', 40002)); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES (2, REPEAT('x', 40002));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, text, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_51_20",
        "database_name": "postgresql_51_20",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 VALUES (3, REPEAT('x', 40003)); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES (3, REPEAT('x', 40003));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, text, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_51_21",
        "database_name": "postgresql_51_21",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 VALUES (4, REPEAT('x', 40005)); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES (4, REPEAT('x', 40005));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, text, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_51_22",
        "database_name": "postgresql_51_22",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 VALUES (5, REPEAT('x', 40008)); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES (5, REPEAT('x', 40008));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, text, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_51_23",
        "database_name": "postgresql_51_23",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 VALUES (6, REPEAT('x', 40013)); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES (6, REPEAT('x', 40013));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, text, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_51_24",
        "database_name": "postgresql_51_24",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT a, LENGTH(b) FROM t1 ORDER BY a DESC; -- LENGTH",
        "target_query": "SELECT a, octet_length(b) FROM t1 ORDER BY a DESC;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, text, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_52_13",
        "database_name": "postgresql_52_13",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) > 3; -- LENGTH",
        "target_query": "EXPLAIN SELECT * FROM t1 WHERE octet_length(t1.vc) > 3;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(col1_idx, int, )\n(col2_idx, int, )\n(col3, int, )\n(col4, int, )\n(vc, varchar(30), )\n(vc_ft, varchar(30), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(col1_idx, integer, )\n(col2_idx, integer, )\n(col3, integer, )\n(col4, integer, )\n(vc, character varying(30), )\n(vc_ft, character varying(30), )\n"
        ]
    },
    {
        "sql_id": "postgresql_52_14",
        "database_name": "postgresql_52_14",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) = 3; -- LENGTH",
        "target_query": "EXPLAIN SELECT * FROM t1 WHERE octet_length(t1.vc) = 3;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(col1_idx, int, )\n(col2_idx, int, )\n(col3, int, )\n(col4, int, )\n(vc, varchar(30), )\n(vc_ft, varchar(30), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(col1_idx, integer, )\n(col2_idx, integer, )\n(col3, integer, )\n(col4, integer, )\n(vc, character varying(30), )\n(vc_ft, character varying(30), )\n"
        ]
    },
    {
        "sql_id": "postgresql_52_15",
        "database_name": "postgresql_52_15",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) IS NULL; -- LENGTH",
        "target_query": "EXPLAIN SELECT * FROM t1 WHERE octet_length(t1.vc) IS NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(col1_idx, int, )\n(col2_idx, int, )\n(col3, int, )\n(col4, int, )\n(vc, varchar(30), )\n(vc_ft, varchar(30), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(col1_idx, integer, )\n(col2_idx, integer, )\n(col3, integer, )\n(col4, integer, )\n(vc, character varying(30), )\n(vc_ft, character varying(30), )\n"
        ]
    },
    {
        "sql_id": "postgresql_52_16",
        "database_name": "postgresql_52_16",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) IS NOT NULL; -- LENGTH",
        "target_query": "EXPLAIN SELECT * FROM t1 WHERE octet_length(t1.vc) IS NOT NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(col1_idx, int, )\n(col2_idx, int, )\n(col3, int, )\n(col4, int, )\n(vc, varchar(30), )\n(vc_ft, varchar(30), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(col1_idx, integer, )\n(col2_idx, integer, )\n(col3, integer, )\n(col4, integer, )\n(vc, character varying(30), )\n(vc_ft, character varying(30), )\n"
        ]
    },
    {
        "sql_id": "postgresql_53_12",
        "database_name": "postgresql_53_12",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t VALUES(REPEAT(x'0a',1000)); -- REPEAT",
        "target_query": "INSERT INTO t VALUES((REPEAT(E'A\\\\000\\\\000\\\\000BBBBBBBB',1000))::BYTEA);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t`\nColumns:\n(b, blob, )\n"
        ],
        "target_related_schemas": [
            "Table: `t`\nColumns:\n(b, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_53_15",
        "database_name": "postgresql_53_15",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t VALUES(1, REPEAT('2', 257)), (1, REPEAT('1', 257)); -- REPEAT",
        "target_query": "INSERT INTO t VALUES(1,REPEAT('2',257)::BYTEA),(1,REPEAT('1',257)::BYTEA);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t`\nColumns:\n(gid, int, )\n(a, varbinary(514), )\n"
        ],
        "target_related_schemas": [
            "Table: `t`\nColumns:\n(gid, integer, )\n(a, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_53_18",
        "database_name": "postgresql_53_18",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t VALUES(1, REPEAT('2', 255)), (1, REPEAT('1', 255)); -- REPEAT",
        "target_query": "INSERT INTO t VALUES(1,REPEAT('2',255)::BYTEA),(1,REPEAT('1',255)::BYTEA);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t`\nColumns:\n(gid, int, )\n(a, varbinary(511), )\n"
        ],
        "target_related_schemas": [
            "Table: `t`\nColumns:\n(gid, integer, )\n(a, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_53_21",
        "database_name": "postgresql_53_21",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t VALUES(1, REPEAT('2', 32750), REPEAT('1', 32750)); -- REPEAT",
        "target_query": "INSERT INTO t VALUES(1,REPEAT('2',32750)::BYTEA,REPEAT('1',32750)::BYTEA);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t`\nColumns:\n(gid, int, )\n(a, varbinary(65500), )\n(b, blob, )\n"
        ],
        "target_related_schemas": [
            "Table: `t`\nColumns:\n(gid, integer, )\n(a, bytea, )\n(b, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_54_2",
        "database_name": "postgresql_54_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "insert t1 values (NULL), ('A\\0\\0\\0BBBBBBBB'), (SPACE(50000)), (SPACE(50000)); -- SPACE",
        "target_query": "INSERT INTO t1 values (NULL), (E'A\\\\000\\\\000\\\\000BBBBBBBB'), (REPEAT(' ', 50000)::BYTEA), (REPEAT(' ', 50000)::BYTEA);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "SPACE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SPACE(n)",
                "description": "Returns a string consisting of n space characters.",
                "examples": [
                    "SELECT LENGTH(SPACE(5));",
                    "SELECT CONCAT('A', SPACE(3), 'B');",
                    "SELECT CONCAT(REPEAT('-', 2), SPACE(4), '!');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(' ', n)",
                "description": "Returns a string consisting of n space characters by repeating a space character.",
                "examples": [
                    "SELECT LENGTH(REPEAT(' ', 5));",
                    "SELECT CONCAT('A', REPEAT(' ', 3), 'B');",
                    "SELECT CONCAT(REPEAT('-', 2), REPEAT(' ', 4), '!');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, blob, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_54_3",
        "database_name": "postgresql_54_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select length(a) from t1; -- LENGTH",
        "target_query": "select octet_length(a) from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, blob, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bytea, )\n"
        ]
    },
    {
        "sql_id": "postgresql_55_3",
        "database_name": "postgresql_55_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select * from t1 where concat(A,C,B,D) = 'AAAA2003-03-011051'; -- CONCAT",
        "target_query": "SELECT * FROM t1 WHERE a || c || b || d = 'AAAA2003-03-011051';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, char(4), )\n(b, double, )\n(c, date, )\n(d, tinyint, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, character(4), )\n(b, double precision, )\n(c, date, )\n(d, smallint, )\n"
        ]
    },
    {
        "sql_id": "postgresql_55_5",
        "database_name": "postgresql_55_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select 'a' union select concat('a', -4); -- CONCAT",
        "target_query": "SELECT 'a' UNION SELECT 'a' || -4;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_55_6",
        "database_name": "postgresql_55_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select 'a' union select concat('a', -4.5); -- CONCAT",
        "target_query": "SELECT 'a' UNION SELECT 'a' || -4.5;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_55_7",
        "database_name": "postgresql_55_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select 'a' union select concat('a', -(4 + 1)); -- CONCAT",
        "target_query": "SELECT 'a' UNION SELECT 'a' || -(4 + 1);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_55_8",
        "database_name": "postgresql_55_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select 'a' union select concat('a', 4 - 5); -- CONCAT",
        "target_query": "SELECT 'a' UNION SELECT 'a' || (4 - 5);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_55_11",
        "database_name": "postgresql_55_11",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select 'a' union select concat('a', -0); -- CONCAT",
        "target_query": "SELECT 'a' UNION SELECT 'a' || -0;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_55_12",
        "database_name": "postgresql_55_12",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select 'a' union select concat('a', -0.0); -- CONCAT",
        "target_query": "SELECT 'a' UNION SELECT 'a' || -0.0;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_55_13",
        "database_name": "postgresql_55_13",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select 'a' union select concat('a', -0.0000); -- CONCAT",
        "target_query": "SELECT 'a' UNION SELECT 'a' || -0.0000;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_55_14",
        "database_name": "postgresql_55_14",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select concat((select x from (select 'a' as x) as t1 ),(select y from (select 'b' as y) as t2 )) from (select 1 union select 2 )as t3; -- CONCAT",
        "target_query": "SELECT (SELECT x FROM (SELECT 'a' AS x) AS t1) || (SELECT y FROM (SELECT 'b' AS y) AS t2) FROM (SELECT 1 UNION SELECT 2) AS t3;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_55_17",
        "database_name": "postgresql_55_17",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select concat(f1, 2) a from t1 union select 'x' a from t1; -- CONCAT",
        "target_query": "SELECT f1 || 2 AS a FROM t1 UNION SELECT 'x' AS a FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, varchar(6), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, character varying(6), )\n"
        ]
    },
    {
        "sql_id": "postgresql_55_21",
        "database_name": "postgresql_55_21",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT * FROM t1 WHERE CONCAT(c1,' ',c2) REGEXP 'First.*'; -- CONCAT",
        "target_query": "SELECT * FROM t1 WHERE c1 || ' ' || c2 ~ 'First.*';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, varchar(100), )\n(c2, varchar(100), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, character varying(100), )\n(c2, character varying(100), )\n"
        ]
    },
    {
        "sql_id": "postgresql_56_2",
        "database_name": "postgresql_56_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "insert into t1 values (date_add(NULL, INTERVAL 1 DAY)); -- DATE_ADD",
        "target_query": "insert into t1 values (CAST(NULL AS DATE) + INTERVAL '1 day');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE_ADD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_ADD(datetime_expr, INTERVAL expr unit)",
                "description": "Adds a time interval to a date or datetime value.",
                "examples": [
                    "SELECT DATE_ADD('2020-01-01', INTERVAL 10 DAY);",
                    "SELECT DATE_ADD('2020-01-01 12:00:00', INTERVAL 3 HOUR);",
                    "SELECT DATE_ADD('2020-12-31', INTERVAL 1 MONTH);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "timestamp_expr + INTERVAL 'expr unit'",
                "description": "Adds an interval to a timestamp using standard SQL interval literals.",
                "examples": [
                    "SELECT TIMESTAMP '2020-01-01' + INTERVAL '10 day';",
                    "SELECT TIMESTAMP '2020-01-01 12:00:00' + INTERVAL '3 hour';",
                    "SELECT TIMESTAMP '2020-12-31' + INTERVAL '1 month';"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(d, date, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(d, date, )\n"
        ]
    },
    {
        "sql_id": "postgresql_56_3",
        "database_name": "postgresql_56_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "insert into t1 values (date_add('2000-01-04', INTERVAL NULL DAY)); -- DATE_ADD",
        "target_query": "insert into t1 values (TIMESTAMP '2000-01-04' + INTERVAL '1 day');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE_ADD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_ADD(datetime_expr, INTERVAL expr unit)",
                "description": "Adds a time interval to a date or datetime value.",
                "examples": [
                    "SELECT DATE_ADD('2020-01-01', INTERVAL 10 DAY);",
                    "SELECT DATE_ADD('2020-01-01 12:00:00', INTERVAL 3 HOUR);",
                    "SELECT DATE_ADD('2020-12-31', INTERVAL 1 MONTH);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "timestamp_expr + INTERVAL 'expr unit'",
                "description": "Adds an interval to a timestamp using standard SQL interval literals.",
                "examples": [
                    "SELECT TIMESTAMP '2020-01-01' + INTERVAL '10 day';",
                    "SELECT TIMESTAMP '2020-01-01 12:00:00' + INTERVAL '3 hour';",
                    "SELECT TIMESTAMP '2020-12-31' + INTERVAL '1 month';"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(d, date, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(d, date, )\n"
        ]
    },
    {
        "sql_id": "postgresql_56_4",
        "database_name": "postgresql_56_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "insert into t1 values (date_add(NULL, INTERVAL 1 DAY)); -- DATE_ADD",
        "target_query": "insert into t1 values (CAST(NULL AS DATE) + INTERVAL '1 day');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE_ADD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_ADD(datetime_expr, INTERVAL expr unit)",
                "description": "Adds a time interval to a date or datetime value.",
                "examples": [
                    "SELECT DATE_ADD('2020-01-01', INTERVAL 10 DAY);",
                    "SELECT DATE_ADD('2020-01-01 12:00:00', INTERVAL 3 HOUR);",
                    "SELECT DATE_ADD('2020-12-31', INTERVAL 1 MONTH);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "timestamp_expr + INTERVAL 'expr unit'",
                "description": "Adds an interval to a timestamp using standard SQL interval literals.",
                "examples": [
                    "SELECT TIMESTAMP '2020-01-01' + INTERVAL '10 day';",
                    "SELECT TIMESTAMP '2020-01-01 12:00:00' + INTERVAL '3 hour';",
                    "SELECT TIMESTAMP '2020-12-31' + INTERVAL '1 month';"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(d, date, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(d, date, )\n"
        ]
    },
    {
        "sql_id": "postgresql_56_5",
        "database_name": "postgresql_56_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "insert into t1 values (date_add('2000-01-04', INTERVAL 1 DAY)); -- DATE_ADD",
        "target_query": "insert into t1 values (TIMESTAMP '2000-01-04' + INTERVAL '1 day');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE_ADD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_ADD(datetime_expr, INTERVAL expr unit)",
                "description": "Adds a time interval to a date or datetime value.",
                "examples": [
                    "SELECT DATE_ADD('2020-01-01', INTERVAL 10 DAY);",
                    "SELECT DATE_ADD('2020-01-01 12:00:00', INTERVAL 3 HOUR);",
                    "SELECT DATE_ADD('2020-12-31', INTERVAL 1 MONTH);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "timestamp_expr + INTERVAL 'expr unit'",
                "description": "Adds an interval to a timestamp using standard SQL interval literals.",
                "examples": [
                    "SELECT TIMESTAMP '2020-01-01' + INTERVAL '10 day';",
                    "SELECT TIMESTAMP '2020-01-01 12:00:00' + INTERVAL '3 hour';",
                    "SELECT TIMESTAMP '2020-12-31' + INTERVAL '1 month';"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(d, date, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(d, date, )\n"
        ]
    },
    {
        "sql_id": "postgresql_56_7",
        "database_name": "postgresql_56_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT DATE(ts) = CURRENT_DATE + INTERVAL '1' DAY AS is_tomorrow, TIME(ts)FROM (SELECT ADDDATE(TIME'00:00:00', INTERVAL 1 DAY) AS ts) AS dt; -- DATE",
        "target_query": "SELECT ((CURRENT_DATE + ts)::DATE = CURRENT_DATE + INTERVAL '1 day') AS is_tomorrow,ts FROM (SELECT TIME '00:00:00' + INTERVAL '1 day' AS ts) AS dt;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE()",
                "description": "In MySQL, the DATE function extracts the date part from a DATETIME or TIMESTAMP value.",
                "examples": [
                    "SELECT DATE('2023-05-01 12:34:56') AS result;",
                    "SELECT DATE(NOW()) AS current_date_result;",
                    "SELECT DATE(CAST('2023-05-01' AS DATETIME)) AS date_from_datetime;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CAST()",
                "description": "In PostgreSQL, the DATE type can be cast directly from a DATETIME or TIMESTAMP using CAST.",
                "examples": [
                    "SELECT '2023-05-01 12:34:56'::DATE AS result;",
                    "SELECT CURRENT_DATE AS current_date_result;",
                    "SELECT CAST('2023-05-01' AS DATE) AS date_from_datetime;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_57_3",
        "database_name": "postgresql_57_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select * from t1 where isnull(to_days(mydate)); -- ISNULL, TO_DAYS",
        "target_query": "SELECT * FROM t1 WHERE (mydate - DATE '1970-01-01')::int + 719528 IS NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ISNULL",
            "TO_DAYS"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "ISNULL(expr)",
                "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
                "examples": [
                    "SELECT ISNULL(NULL);",
                    "SELECT ISNULL(5 + NULL);",
                    "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
                ]
            },
            {
                "expression": "TO_DAYS(date)",
                "description": "Returns the number of days since 0000-01-01 for a given date.",
                "examples": [
                    "SELECT TO_DAYS('2024-05-07');",
                    "SELECT TO_DAYS(CURDATE());",
                    "SELECT TO_DAYS('1999-12-31 23:59:59');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "expr IS NULL",
                "description": "Standard SQL syntax for checking if a value is NULL.",
                "examples": [
                    "SELECT NULL IS NULL;",
                    "SELECT (5 + NULL) IS NULL;",
                    "SELECT CASE WHEN score IS NULL THEN 'N/A' ELSE score::text END FROM students;"
                ]
            },
            {
                "expression": "(date - DATE '1970-01-01')::int + 719528",
                "description": "Computes the number of days since 0000-01-01 by offsetting from 1970-01-01.",
                "examples": [
                    "SELECT (DATE '2024-05-07' - DATE '1970-01-01')::int + 719528;",
                    "SELECT (CURRENT_DATE - DATE '1970-01-01')::int + 719528;",
                    "SELECT (DATE '1999-12-31' - DATE '1970-01-01')::int + 719528;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(id, int, PRI)\n(mydate, date, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(id, integer, PRI)\n(mydate, date, )\n"
        ]
    },
    {
        "sql_id": "postgresql_57_13",
        "database_name": "postgresql_57_13",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select * from t3 left join(t2 outr2 join t2 outr join t1)on (outr.pk = t3.pk) and (t1.col_int_key = t3.pk) and isnull(t1.col_date_key)and (outr2.pk <> t3.pk); -- ISNULL",
        "target_query": "SELECT * FROM t3 LEFT JOIN t2 AS outr2 ON (outr2.pk <> t3.pk) LEFT JOIN t2 AS outr ON (outr.pk = t3.pk) LEFT JOIN t1 ON (t1.col_int_key = t3.pk) AND (t1.col_date_key IS NULL);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ISNULL"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "ISNULL(expr)",
                "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
                "examples": [
                    "SELECT ISNULL(NULL);",
                    "SELECT ISNULL(5 + NULL);",
                    "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "expr IS NULL",
                "description": "Standard SQL syntax for checking if a value is NULL.",
                "examples": [
                    "SELECT NULL IS NULL;",
                    "SELECT (5 + NULL) IS NULL;",
                    "SELECT CASE WHEN score IS NULL THEN 'N/A' ELSE score::text END FROM students;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(pk, int, PRI)\n(col_int_key, int, )\n(col_date_key, date, )\n",
            "Table: `t2`\nColumns:\n(pk, int, PRI)\n",
            "Table: `t3`\nColumns:\n(pk, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(pk, integer, PRI)\n(col_int_key, integer, )\n(col_date_key, date, )\n",
            "Table: `t2`\nColumns:\n(pk, integer, PRI)\n",
            "Table: `t3`\nColumns:\n(pk, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_57_14",
        "database_name": "postgresql_57_14",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select * from t3 join(t2 outr2 join t2 outr join t1)on (outr.pk = t3.pk) and (t1.col_int_key = t3.pk) and isnull(t1.col_date_key)and (outr2.pk <> t3.pk) ; -- ISNULL",
        "target_query": "SELECT * FROM t3 JOIN t2 AS outr2 ON (outr2.pk <> t3.pk) JOIN t2 AS outr ON (outr.pk = t3.pk) JOIN t1 ON (t1.col_int_key = t3.pk) AND (t1.col_date_key IS NULL);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ISNULL"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "ISNULL(expr)",
                "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
                "examples": [
                    "SELECT ISNULL(NULL);",
                    "SELECT ISNULL(5 + NULL);",
                    "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "expr IS NULL",
                "description": "Standard SQL syntax for checking if a value is NULL.",
                "examples": [
                    "SELECT NULL IS NULL;",
                    "SELECT (5 + NULL) IS NULL;",
                    "SELECT CASE WHEN score IS NULL THEN 'N/A' ELSE score::text END FROM students;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(pk, int, PRI)\n(col_int_key, int, )\n(col_date_key, date, )\n",
            "Table: `t2`\nColumns:\n(pk, int, PRI)\n",
            "Table: `t3`\nColumns:\n(pk, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(pk, integer, PRI)\n(col_int_key, integer, )\n(col_date_key, date, )\n",
            "Table: `t2`\nColumns:\n(pk, integer, PRI)\n",
            "Table: `t3`\nColumns:\n(pk, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_58_4",
        "database_name": "postgresql_58_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "explain select * from t1 where a like concat('abc','%'); -- CONCAT",
        "target_query": "EXPLAIN SELECT * FROM t1 WHERE a LIKE 'abc' || '%';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, varchar(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, character varying(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_58_5",
        "database_name": "postgresql_58_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select * from t1 where a like concat(\"abc\",\"%\"); -- CONCAT",
        "target_query": "SELECT * FROM t1 WHERE a LIKE 'abc' || '%';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, varchar(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, character varying(10), )\n"
        ]
    },
    {
        "sql_id": "postgresql_59_0",
        "database_name": "postgresql_59_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL); -- LN",
        "target_query": "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LN"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LN(x)",
                "description": "The LN() function returns the natural logarithm of x. If x is less than or equal to 0, it returns NULL.",
                "examples": [
                    "select ln(exp(10));",
                    "select exp(ln(sqrt(10)) * 2);",
                    "select ln(-1);",
                    "select ln(0);",
                    "select ln(NULL);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LN(x)",
                "description": "In PostgreSQL, the LN() function behaves similarly to MySQL, returning the natural logarithm of x, and returns NULL for non-positive values.",
                "examples": [
                    "select ln(exp(10));",
                    "select exp(ln(sqrt(10)) * 2);",
                    "select ln(NULL);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_59_1",
        "database_name": "postgresql_59_1",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select log2(8),log2(15),log2(NULL); -- LOG2",
        "target_query": "select log(2, 8),log(2, 15);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LOG2"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LOG2(number)",
                "description": "Returns the logarithm of a number with base 2. Returns NULL for zero or negative numbers.",
                "examples": [
                    "SELECT LOG2(8);",
                    "SELECT LOG2(15);",
                    "SELECT LOG2(-2);",
                    "SELECT LOG2(0);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LOG(2, number)",
                "description": "Returns the logarithm of a number with base 2. Returns NULL for zero or negative numbers.",
                "examples": [
                    "SELECT LOG(2, 8);",
                    "SELECT LOG(2, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_59_2",
        "database_name": "postgresql_59_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select pow(10,log10(10)),power(2,4); -- POW, POWER",
        "target_query": "select power(10,log10(10)),power(2,4);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "POW",
            "POWER"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "POW(3, 3)",
                "description": "POW(x, y) in MySQL is used to calculate x raised to the power of y. It returns the result of x^y.",
                "examples": [
                    "SELECT POW(3, 3);",
                    "SELECT POW(5, 4);",
                    "SELECT POW(x, 2) FROM some_table;"
                ]
            },
            {
                "expression": "SELECT POW(10, 2), POWER(2, 3), POWER(3, 3);",
                "description": "Calculates the power of a number: POW(10, 2) returns 100, POWER(2, 3) returns 8, POWER(3, 3) returns 27.",
                "examples": [
                    "SELECT POW(5, 2);",
                    "SELECT POWER(3, 4);",
                    "SELECT POWER(10, 0);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POWER(3, 3)",
                "description": "In PostgreSQL, the POWER() function is used to calculate x raised to the power of y, similar to MySQL's POW() function.",
                "examples": [
                    "SELECT POWER(3, 3);",
                    "SELECT POWER(5, 4);",
                    "SELECT POWER(x, 2) FROM some_table;"
                ]
            },
            {
                "expression": "SELECT POW(10, 2), POW(2, 3), POW(3, 3);",
                "description": "Calculates the power of a number: POW(10, 2) returns 100, POW(2, 3) returns 8, POW(3, 3) returns 27.",
                "examples": [
                    "SELECT POW(5, 2);",
                    "SELECT POW(3, 4);",
                    "SELECT POW(10, 0);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_59_3",
        "database_name": "postgresql_59_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select ceil(0.09); -- CEIL",
        "target_query": "select ceil(0.09);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CEIL"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CEIL(x)",
                "description": "Returns the smallest integer value not less than x (rounds up).",
                "examples": [
                    "SELECT CEIL(1.3);",
                    "SELECT CEIL(-2.8);",
                    "SELECT CEIL(RAND() * 100);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CEIL(x)",
                "description": "Rounds x upward to the nearest integer.",
                "examples": [
                    "SELECT CEIL(1.3);",
                    "SELECT CEIL(-2.8);",
                    "SELECT CEIL(random() * 100);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_59_4",
        "database_name": "postgresql_59_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select ceil(0.000000000000000009); -- CEIL",
        "target_query": "select ceil(0.000000000000000009);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CEIL"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CEIL(x)",
                "description": "Returns the smallest integer value not less than x (rounds up).",
                "examples": [
                    "SELECT CEIL(1.3);",
                    "SELECT CEIL(-2.8);",
                    "SELECT CEIL(RAND() * 100);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CEIL(x)",
                "description": "Rounds x upward to the nearest integer.",
                "examples": [
                    "SELECT CEIL(1.3);",
                    "SELECT CEIL(-2.8);",
                    "SELECT CEIL(random() * 100);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_59_7",
        "database_name": "postgresql_59_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "insert into t1 values ('http://www.foo.com/', now()); -- NOW",
        "target_query": "insert into t1 values ('http://www.foo.com/', current_timestamp);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "NOW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "In PostgreSQL, CURRENT_TIMESTAMP is used to retrieve the current date and time, equivalent to NOW() in MySQL and MariaDB.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, varchar(90), )\n(ts, datetime, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, character varying(90), )\n(ts, timestamp without time zone, )\n"
        ]
    },
    {
        "sql_id": "postgresql_59_8",
        "database_name": "postgresql_59_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select a from t1 where a='http://www.foo.com/' order by abs(timediff(ts, 0)); -- TIMEDIFF",
        "target_query": "SELECT a FROM t1 WHERE a = 'http://www.foo.com/' ORDER BY ABS(EXTRACT(EPOCH FROM (ts - timestamp '1970-01-01 00:00:00')));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIMEDIFF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMEDIFF('12:00:00', '10:00:00')",
                "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
                "examples": [
                    "SELECT TIMEDIFF('12:00:00', '10:00:00');",
                    "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
                    "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "(timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::TIME",
                "description": "PostgreSQL does not have a direct TIMEDIFF function, but time differences can be calculated by subtracting one timestamp from another and casting the result to a TIME.",
                "examples": [
                    "SELECT (timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::TIME;",
                    "SELECT (NOW() - timestamp '2023-06-15 10:00:00')::INTERVAL;",
                    "SELECT (timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::INTERVAL;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, varchar(90), )\n(ts, datetime, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, character varying(90), )\n(ts, timestamp without time zone, )\n"
        ]
    },
    {
        "sql_id": "postgresql_59_10",
        "database_name": "postgresql_59_10",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select mod(cast(-2 as unsigned), 3), mod(18446744073709551614, 3), mod(-2, 3); -- MOD",
        "target_query": "select mod(cast(-2 as bigint), 3), mod(18446744073709551614, 3), mod(-2, 3);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MOD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MOD(N, M) \u6216 N % M",
                "description": "Returns the remainder of N divided by M. Returns NULL if M = 0.",
                "examples": [
                    "SELECT MOD(10, 3);",
                    "SELECT 10 % 3;",
                    "SELECT MOD(5, 0);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "MOD(N, M) \u6216 N % M",
                "description": "Computes the remainder of N divided by M.",
                "examples": [
                    "SELECT MOD(9, 4);",
                    "SELECT 9 % 4;",
                    "SELECT MOD(5, 0);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_59_11",
        "database_name": "postgresql_59_11",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select mod(5, cast(-2 as unsigned)), mod(5, 18446744073709551614), mod(5, -2); -- MOD",
        "target_query": "select mod(5, cast(-2 as bigint)), mod(5, 18446744073709551614), mod(5, -2);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MOD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MOD(N, M) \u6216 N % M",
                "description": "Returns the remainder of N divided by M. Returns NULL if M = 0.",
                "examples": [
                    "SELECT MOD(10, 3);",
                    "SELECT 10 % 3;",
                    "SELECT MOD(5, 0);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "MOD(N, M) \u6216 N % M",
                "description": "Computes the remainder of N divided by M.",
                "examples": [
                    "SELECT MOD(9, 4);",
                    "SELECT 9 % 4;",
                    "SELECT MOD(5, 0);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_59_12",
        "database_name": "postgresql_59_12",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select pow(cast(-2 as unsigned), 5), pow(18446744073709551614, 5), pow(-2, 5); -- POW",
        "target_query": "select power(cast(-2 as bigint), 5), power(18446744073709551614, 5), power(-2, 5);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "POW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "POW(3, 3)",
                "description": "POW(x, y) in MySQL is used to calculate x raised to the power of y. It returns the result of x^y.",
                "examples": [
                    "SELECT POW(3, 3);",
                    "SELECT POW(5, 4);",
                    "SELECT POW(x, 2) FROM some_table;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POWER(3, 3)",
                "description": "In PostgreSQL, the POWER() function is used to calculate x raised to the power of y, similar to MySQL's POW() function.",
                "examples": [
                    "SELECT POWER(3, 3);",
                    "SELECT POWER(5, 4);",
                    "SELECT POWER(x, 2) FROM some_table;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_60_0",
        "database_name": "postgresql_60_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT ROUND(LEAST(15, -4939092, 0.2704)); -- LEAST, STDDEV",
        "target_query": "SELECT ROUND(LEAST(15, -4939092, 0.2704));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LEAST",
            "STDDEV"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            },
            {
                "expression": "STDDEV(amount)",
                "description": "The STDDEV function calculates the standard deviation of a numeric column in a database. It returns a measure of the amount of variation or dispersion of a set of values.",
                "examples": [
                    "SELECT STDDEV(amount) FROM sales;",
                    "SELECT STDDEV(amount) OVER (ROWS 2 PRECEDING) FROM sales;",
                    "SELECT id, STDDEV(amount) OVER (PARTITION BY region ORDER BY amount) AS region_stddev FROM sales;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest non-null value among its arguments. NULL values are ignored unless all values are NULL.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            },
            {
                "expression": "STDDEV(amount)",
                "description": "The STDDEV function calculates the standard deviation of a numeric column in a database. It returns a measure of the amount of variation or dispersion of a set of values.",
                "examples": [
                    "SELECT STDDEV(amount) FROM sales;",
                    "SELECT STDDEV(amount) OVER (ROWS 2 PRECEDING) FROM sales;",
                    "SELECT id, STDDEV(amount) OVER (PARTITION BY region ORDER BY amount) AS region_stddev FROM sales;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_60_1",
        "database_name": "postgresql_60_1",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select (1.175494351E-37 div 1.7976931348623157E+308); -- DIV",
        "target_query": "SELECT FLOOR(1.175494351E-37 / 1.7976931348623157E+308);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DIV"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "a DIV b",
                "description": "Performs integer division between two numbers and returns the floor of the quotient.",
                "examples": [
                    "SELECT 10 DIV 3;",
                    "SELECT 5.8 DIV 2;",
                    "SELECT 9 DIV 4 + 1;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "FLOOR(a / b)",
                "description": "Performs floating-point division and applies FLOOR to return integer quotient.",
                "examples": [
                    "SELECT FLOOR(10 / 3);",
                    "SELECT FLOOR(5.8 / 2);",
                    "SELECT FLOOR(9 / 4) + 1;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_60_4",
        "database_name": "postgresql_60_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "INSERT INTO t1 VALUES (ln(1)); -- LN",
        "target_query": "INSERT INTO t1 VALUES (ln(1));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LN"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LN(x)",
                "description": "The LN() function returns the natural logarithm of x. If x is less than or equal to 0, it returns NULL.",
                "examples": [
                    "select ln(exp(10));",
                    "select exp(ln(sqrt(10)) * 2);",
                    "select ln(-1);",
                    "select ln(0);",
                    "select ln(NULL);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LN(x)",
                "description": "In PostgreSQL, the LN() function behaves similarly to MySQL, returning the natural logarithm of x, and returns NULL for non-positive values.",
                "examples": [
                    "select ln(exp(10));",
                    "select exp(ln(sqrt(10)) * 2);",
                    "select ln(NULL);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, double, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, double precision, )\n"
        ]
    },
    {
        "sql_id": "postgresql_60_6",
        "database_name": "postgresql_60_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT floor(ceil(123456789)); -- CEIL",
        "target_query": "SELECT floor(ceil(123456789));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CEIL"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CEIL(x)",
                "description": "Returns the smallest integer value not less than x (rounds up).",
                "examples": [
                    "SELECT CEIL(1.3);",
                    "SELECT CEIL(-2.8);",
                    "SELECT CEIL(RAND() * 100);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CEIL(x)",
                "description": "Rounds x upward to the nearest integer.",
                "examples": [
                    "SELECT CEIL(1.3);",
                    "SELECT CEIL(-2.8);",
                    "SELECT CEIL(random() * 100);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_60_7",
        "database_name": "postgresql_60_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select cast(pow(2,63)-1024 as signed) as pp; -- POW",
        "target_query": "SELECT cast(POWER(2,63)-1024 as bigint) as pp;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "POW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "POW(3, 3)",
                "description": "POW(x, y) in MySQL is used to calculate x raised to the power of y. It returns the result of x^y.",
                "examples": [
                    "SELECT POW(3, 3);",
                    "SELECT POW(5, 4);",
                    "SELECT POW(x, 2) FROM some_table;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POWER(3, 3)",
                "description": "In PostgreSQL, the POWER() function is used to calculate x raised to the power of y, similar to MySQL's POW() function.",
                "examples": [
                    "SELECT POWER(3, 3);",
                    "SELECT POWER(5, 4);",
                    "SELECT POWER(x, 2) FROM some_table;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_60_8",
        "database_name": "postgresql_60_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select cast(1-pow(2,63) as signed) as qq; -- POW",
        "target_query": "SELECT cast(1-POWER(2,63) as bigint) as qq;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "POW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "POW(3, 3)",
                "description": "POW(x, y) in MySQL is used to calculate x raised to the power of y. It returns the result of x^y.",
                "examples": [
                    "SELECT POW(3, 3);",
                    "SELECT POW(5, 4);",
                    "SELECT POW(x, 2) FROM some_table;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POWER(3, 3)",
                "description": "In PostgreSQL, the POWER() function is used to calculate x raised to the power of y, similar to MySQL's POW() function.",
                "examples": [
                    "SELECT POWER(3, 3);",
                    "SELECT POWER(5, 4);",
                    "SELECT POWER(x, 2) FROM some_table;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_60_12",
        "database_name": "postgresql_60_12",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT * FROM t0 WHERE CAST(COALESCE(t0.c0, -1) AS UNSIGNED); -- COALESCE",
        "target_query": "SELECT * FROM t0 WHERE CAST(COALESCE(t0.c0, -1) AS BIGINT) > 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "COALESCE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
                "description": "Returns the first non-NULL value, or merges table partitions.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
                    "ALTER TABLE t1 COALESCE PARTITION 2;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...)",
                "description": "Standard SQL COALESCE function for NULL-handling.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t0`\nColumns:\n(c0, bigint unsigned, )\n"
        ],
        "target_related_schemas": [
            "Table: `t0`\nColumns:\n(c0, bigint, )\n"
        ]
    },
    {
        "sql_id": "postgresql_60_13",
        "database_name": "postgresql_60_13",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT * FROM t0 WHERE CAST(IFNULL(t0.c0, -1) AS UNSIGNED); -- IFNULL",
        "target_query": "SELECT * FROM t0 WHERE CAST(COALESCE(t0.c0, -1) AS BIGINT)> 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IFNULL"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "PostgreSQL uses COALESCE, which returns the first non-NULL argument. This works exactly like IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t0`\nColumns:\n(c0, bigint unsigned, )\n"
        ],
        "target_related_schemas": [
            "Table: `t0`\nColumns:\n(c0, bigint, )\n"
        ]
    },
    {
        "sql_id": "postgresql_60_14",
        "database_name": "postgresql_60_14",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT CAST(COALESCE(t0.c0, -1) AS UNSIGNED) IS TRUE FROM t0; -- COALESCE",
        "target_query": "SELECT CAST(COALESCE(t0.c0, -1) AS BIGINT) !=0 FROM t0;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "COALESCE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
                "description": "Returns the first non-NULL value, or merges table partitions.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
                    "ALTER TABLE t1 COALESCE PARTITION 2;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...)",
                "description": "Standard SQL COALESCE function for NULL-handling.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t0`\nColumns:\n(c0, bigint unsigned, )\n"
        ],
        "target_related_schemas": [
            "Table: `t0`\nColumns:\n(c0, bigint, )\n"
        ]
    },
    {
        "sql_id": "postgresql_60_15",
        "database_name": "postgresql_60_15",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT CAST(COALESCE(t0.c0, -1) AS UNSIGNED) FROM t0; -- COALESCE",
        "target_query": "SELECT CAST(COALESCE(t0.c0, -1) AS BIGINT) FROM t0;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "COALESCE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
                "description": "Returns the first non-NULL value, or merges table partitions.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
                    "ALTER TABLE t1 COALESCE PARTITION 2;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...)",
                "description": "Standard SQL COALESCE function for NULL-handling.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t0`\nColumns:\n(c0, bigint unsigned, )\n"
        ],
        "target_related_schemas": [
            "Table: `t0`\nColumns:\n(c0, bigint, )\n"
        ]
    },
    {
        "sql_id": "postgresql_61_0",
        "database_name": "postgresql_61_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select md5('a'), hex(md5('a')); -- MD5, HEX",
        "target_query": "SELECT MD5('a'), encode(MD5('a')::bytea, 'hex');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MD5",
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            },
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            },
            {
                "expression": "to_hex(N) \u6216 encode(BYTEA, 'hex')",
                "description": "Converts integers using to_hex() and binary data (BYTEA) using encode(..., 'hex') to hexadecimal representation.",
                "examples": [
                    "SELECT to_hex(255);",
                    "SELECT encode('abc'::bytea, 'hex');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_61_2",
        "database_name": "postgresql_61_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "create table t1 as select md5('a') as c1; -- MD5",
        "target_query": "CREATE TABLE t1 AS SELECT MD5('a') AS c1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MD5"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            }
        ],
        "source_related_schemas": [
            "create table t1 as select md5('a') as c1; -- MD5"
        ],
        "target_related_schemas": [
            "CREATE TABLE t1 AS SELECT MD5('a') AS c1;"
        ]
    },
    {
        "sql_id": "postgresql_61_4",
        "database_name": "postgresql_61_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select md5('hello'); -- MD5",
        "target_query": "SELECT MD5('hello');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MD5"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_61_5",
        "database_name": "postgresql_61_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "explain select md5('hello'); -- MD5",
        "target_query": "EXPLAIN SELECT MD5('hello');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MD5"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_61_6",
        "database_name": "postgresql_61_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select length(unhex(md5(\"abrakadabra\"))); -- LENGTH, UNHEX, MD5",
        "target_query": "SELECT octet_length(decode(MD5('abrakadabra'), 'hex'));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH",
            "UNHEX",
            "MD5"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            },
            {
                "expression": "UNHEX(str)",
                "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
                "examples": [
                    "SELECT HEX(UNHEX('4D7953514C'));",
                    "SELECT UNHEX('48656C6C6F');",
                    "SELECT UNHEX(NULL);"
                ]
            },
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            },
            {
                "expression": "decode(str, 'hex')",
                "description": "Decodes a hexadecimal string into binary (bytea) using the decode function.",
                "examples": [
                    "SELECT encode(decode('4D7953514C', 'hex'), 'hex');",
                    "SELECT decode('48656C6C6F', 'hex');",
                    "SELECT decode(NULL, 'hex');"
                ]
            },
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_61_8",
        "database_name": "postgresql_61_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "insert into t1 values ( 'test',md5('test')), ('test', md5('test')); -- MD5",
        "target_query": "insert into t1 values ( 'test',md5('test')), ('test', md5('test'));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MD5"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, varchar(4), )\n(f2, varchar(64), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, character varying(4), )\n(f2, character varying(64), )\n"
        ]
    },
    {
        "sql_id": "postgresql_61_9",
        "database_name": "postgresql_61_9",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select * from t1 where f1='test' and (f2= md5(\"test\") or f2= md5(\"Test\")); -- MD5",
        "target_query": "SELECT * FROM t1 WHERE f1 = 'test' AND (f2 = MD5('test') OR f2 = MD5('TEST'));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MD5"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, varchar(4), )\n(f2, varchar(64), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, character varying(4), )\n(f2, character varying(64), )\n"
        ]
    },
    {
        "sql_id": "postgresql_61_10",
        "database_name": "postgresql_61_10",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select * from t1 where f1='test' and (f2= md5(\"TEST\") or f2= md5(\"test\")); -- MD5",
        "target_query": "SELECT * FROM t1 WHERE f1 = 'test' AND (f2 = MD5('TEST') OR f2 = MD5('test'));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MD5"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, varchar(4), )\n(f2, varchar(64), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, character varying(4), )\n(f2, character varying(64), )\n"
        ]
    },
    {
        "sql_id": "postgresql_62_0",
        "database_name": "postgresql_62_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select inet_ntoa(4294902271),inet_ntoa(511); -- INET_NTOA",
        "target_query": "SELECT (4294902271 >> 24) || '.' || ((4294902271 >> 16) & 255) || '.' || ((4294902271 >> 8) & 255) || '.' || (4294902271 & 255), (511 >> 24) || '.' || ((511 >> 16) & 255) || '.' || ((511 >> 8) & 255) || '.' || (511 & 255);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "INET_NTOA"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "INET_NTOA(ip)",
                "description": "The INET_NTOA function converts an integer representation of an IPv4 address to a standard dotted-decimal format string.",
                "examples": [
                    "SELECT INET_NTOA(3232235776);",
                    "SELECT INET_NTOA(16777343);",
                    "SELECT INET_NTOA(2886733345);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "(integer_ip >> 24) || '.' || ((integer_ip >> 16) & 255) || '.' || ((integer_ip >> 8) & 255) || '.' || (integer_ip & 255)",
                "description": "PostgreSQL does not have a direct INET_NTOA function. However, you can use bitwise operations to convert an integer to a dotted-decimal IP address string.",
                "examples": [
                    "SELECT (3232235776 >> 24) || '.' || ((3232235776 >> 16) & 255) || '.' || ((3232235776 >> 8) & 255) || '.' || (3232235776 & 255);",
                    "SELECT (16777343 >> 24) || '.' || ((16777343 >> 16) & 255) || '.' || ((16777343 >> 8) & 255) || '.' || (16777343 & 255);",
                    "SELECT (2886733345 >> 24) || '.' || ((2886733345 >> 16) & 255) || '.' || ((2886733345 >> 8) & 255) || '.' || (2886733345 & 255);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_62_4",
        "database_name": "postgresql_62_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select a from t1 where mid(a+0,6,3) in ( mid(20040106123400,6,3) ); -- MID",
        "target_query": "SELECT a FROM t1 WHERE SUBSTRING(TO_CHAR(a, '0000') FROM 6 FOR 3) IN (SUBSTRING(CAST(20040106123400 AS TEXT) FROM 6 FOR 3));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MID"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MID(str, pos, len)",
                "description": "Extracts a substring from the string `str`, starting at position `pos`, with length `len`.",
                "examples": [
                    "SELECT MID('ABCDEFGHIJKL', 5, 3);",
                    "SELECT CONCAT(MID('hello_world', 1, 5), MID('hello_world', 7, 5));",
                    "SELECT MID('  padded_text  ', 3, 6);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SUBSTRING(str FROM pos FOR len)",
                "description": "Extracts a substring starting at character position `pos` for `len` characters using standard SQL syntax.",
                "examples": [
                    "SELECT SUBSTRING('ABCDEFGHIJKL' FROM 5 FOR 3);",
                    "SELECT CONCAT(SUBSTRING('hello_world' FROM 1 FOR 5), SUBSTRING('hello_world' FROM 7 FOR 5));",
                    "SELECT SUBSTRING('  padded_text  ' FROM 3 FOR 6);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, timestamp, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, timestamp without time zone, )\n"
        ]
    },
    {
        "sql_id": "postgresql_62_5",
        "database_name": "postgresql_62_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select a from t1 where mid(a+0,6,3) = ( mid(20040106123400,6,3) ); -- MID",
        "target_query": "SELECT a FROM t1 WHERE SUBSTRING(TO_CHAR(a, '0000') FROM 6 FOR 3) = (SUBSTRING(CAST(20040106123400 AS TEXT) FROM 6 FOR 3));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MID"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MID(str, pos, len)",
                "description": "Extracts a substring from the string `str`, starting at position `pos`, with length `len`.",
                "examples": [
                    "SELECT MID('ABCDEFGHIJKL', 5, 3);",
                    "SELECT CONCAT(MID('hello_world', 1, 5), MID('hello_world', 7, 5));",
                    "SELECT MID('  padded_text  ', 3, 6);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SUBSTRING(str FROM pos FOR len)",
                "description": "Extracts a substring starting at character position `pos` for `len` characters using standard SQL syntax.",
                "examples": [
                    "SELECT SUBSTRING('ABCDEFGHIJKL' FROM 5 FOR 3);",
                    "SELECT CONCAT(SUBSTRING('hello_world' FROM 1 FOR 5), SUBSTRING('hello_world' FROM 7 FOR 5));",
                    "SELECT SUBSTRING('  padded_text  ' FROM 3 FOR 6);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, timestamp, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, timestamp without time zone, )\n"
        ]
    },
    {
        "sql_id": "postgresql_62_11",
        "database_name": "postgresql_62_11",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select min(a) from t1 group by inet_ntoa(a); -- MIN, INET_NTOA",
        "target_query": "SELECT MIN(a) FROM t1 GROUP BY (a >> 24) || '.' || ((a >> 16) & 255) || '.' || ((a >> 8) & 255) || '.' || (a & 255);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MIN",
            "INET_NTOA"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MIN()",
                "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
                "examples": [
                    "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
                ]
            },
            {
                "expression": "INET_NTOA(ip)",
                "description": "The INET_NTOA function converts an integer representation of an IPv4 address to a standard dotted-decimal format string.",
                "examples": [
                    "SELECT INET_NTOA(3232235776);",
                    "SELECT INET_NTOA(16777343);",
                    "SELECT INET_NTOA(2886733345);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "MIN()",
                "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
                "examples": [
                    "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
                ]
            },
            {
                "expression": "(integer_ip >> 24) || '.' || ((integer_ip >> 16) & 255) || '.' || ((integer_ip >> 8) & 255) || '.' || (integer_ip & 255)",
                "description": "PostgreSQL does not have a direct INET_NTOA function. However, you can use bitwise operations to convert an integer to a dotted-decimal IP address string.",
                "examples": [
                    "SELECT (3232235776 >> 24) || '.' || ((3232235776 >> 16) & 255) || '.' || ((3232235776 >> 8) & 255) || '.' || (3232235776 & 255);",
                    "SELECT (16777343 >> 24) || '.' || ((16777343 >> 16) & 255) || '.' || ((16777343 >> 8) & 255) || '.' || (16777343 & 255);",
                    "SELECT (2886733345 >> 24) || '.' || ((2886733345 >> 16) & 255) || '.' || ((2886733345 >> 8) & 255) || '.' || (2886733345 & 255);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_62_15",
        "database_name": "postgresql_62_15",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT DISTINCT LEAST(a, (SELECT b FROM t1 LIMIT 1)) FROM t1 UNION SELECT 1; -- LEAST",
        "target_query": "SELECT DISTINCT LEAST(a, (SELECT CAST(b AS INT) FROM t1 LIMIT 1)) FROM t1 UNION SELECT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LEAST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest non-null value among its arguments. NULL values are ignored unless all values are NULL.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, longblob, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, character varying, )\n"
        ]
    },
    {
        "sql_id": "postgresql_62_16",
        "database_name": "postgresql_62_16",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT DISTINCT GREATEST(a, (SELECT b FROM t1 LIMIT 1)) FROM t1 UNION SELECT 1; -- GREATEST",
        "target_query": "SELECT DISTINCT GREATEST(a, (SELECT CAST(b AS INT) FROM t1 LIMIT 1)) FROM t1 UNION SELECT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GREATEST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, longblob, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n(b, character varying, )\n"
        ]
    },
    {
        "sql_id": "postgresql_63_0",
        "database_name": "postgresql_63_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select 1+1,1-1,1+1*2,8/5,8%5,mod(8,5),-(1+1)*-2; -- MOD",
        "target_query": "select 1+1,1-1,1+1*2,8/5,8%5,mod(8,5),-(1+1)*-2;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MOD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MOD(N, M) \u6216 N % M",
                "description": "Returns the remainder of N divided by M. Returns NULL if M = 0.",
                "examples": [
                    "SELECT MOD(10, 3);",
                    "SELECT 10 % 3;",
                    "SELECT MOD(5, 0);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "MOD(N, M) \u6216 N % M",
                "description": "Computes the remainder of N divided by M.",
                "examples": [
                    "SELECT MOD(9, 4);",
                    "SELECT 9 % 4;",
                    "SELECT MOD(5, 0);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_63_1",
        "database_name": "postgresql_63_1",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select 1 | (1+1),5 & 3,bit_count(7) ; -- BIT_COUNT",
        "target_query": "select 1|(1+1),5&3,length(replace((7::bit(32))::text,'0',''));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "BIT_COUNT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "BIT_COUNT(N)",
                "description": "Returns the number of bits set to 1 in the binary representation of the given integer.",
                "examples": [
                    "SELECT BIT_COUNT(0);",
                    "SELECT BIT_COUNT(1);",
                    "SELECT BIT_COUNT(15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "length(replace((N::bit(32))::text, '0', ''))",
                "description": "Counts the number of 1-bits by converting the integer to a 32-bit string and counting the '1's.",
                "examples": [
                    "SELECT length(replace((0::bit(32))::text, '0', ''));",
                    "SELECT length(replace((1::bit(32))::text, '0', ''));",
                    "SELECT length(replace((15::bit(32))::text, '0', ''));"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_63_7",
        "database_name": "postgresql_63_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select t1.a, t2.a, t2.b, bit_count(t2.b) from t1 left join t2 on t1.a=t2.a; -- BIT_COUNT",
        "target_query": "select t1.a,t2.a,t2.b,length(replace((t2.b::bit(32))::text,'0','')) from t1 left join t2 on t1.a=t2.a;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "BIT_COUNT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "BIT_COUNT(N)",
                "description": "Returns the number of bits set to 1 in the binary representation of the given integer.",
                "examples": [
                    "SELECT BIT_COUNT(0);",
                    "SELECT BIT_COUNT(1);",
                    "SELECT BIT_COUNT(15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "length(replace((N::bit(32))::text, '0', ''))",
                "description": "Counts the number of 1-bits by converting the integer to a 32-bit string and counting the '1's.",
                "examples": [
                    "SELECT length(replace((0::bit(32))::text, '0', ''));",
                    "SELECT length(replace((1::bit(32))::text, '0', ''));",
                    "SELECT length(replace((15::bit(32))::text, '0', ''));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n",
            "Table: `t2`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, integer, )\n",
            "Table: `t2`\nColumns:\n(a, integer, )\n(b, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_64_0",
        "database_name": "postgresql_64_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select date_format(\"1997-12-31 23:59:59.000002\", \"%f\"); -- DATE_FORMAT",
        "target_query": "SELECT TO_CHAR(TIMESTAMP '1997-12-31 23:59:59.000002', 'MS');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE_FORMAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(date_expr, format_str)",
                "description": "Formats a date/time value according to a format string using PostgreSQL-style specifiers.",
                "examples": [
                    "SELECT TO_CHAR(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT TO_CHAR(DATE '2023-01-15', 'DD-MM-YYYY');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_64_1",
        "database_name": "postgresql_64_1",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select datediff(\"1997-12-31 23:59:59.000001\",\"1997-12-30\"); -- DATEDIFF",
        "target_query": "SELECT EXTRACT(DAY FROM DATE '1997-12-31') - EXTRACT(DAY FROM DATE '1997-12-30');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATEDIFF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATEDIFF(date1, date2)",
                "description": "Returns the number of days between two date or datetime expressions (date1 - date2), ignoring time part.",
                "examples": [
                    "SELECT DATEDIFF('2025-12-31', '2025-12-01');",
                    "SELECT DATEDIFF('2025-01-01', '2024-12-31');",
                    "SELECT DATEDIFF(NULL, '2025-01-01');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(DAY FROM DATE date1) - EXTRACT(DAY FROM DATE date2)",
                "description": "Calculates the number of days between two date. This is achieved by extracting the day component from the dates and subtracting the results.",
                "examples": [
                    "SELECT EXTRACT(DAY FROM DATE '2025-12-31') - EXTRACT(DAY FROM DATE '2025-12-01');",
                    "SELECT EXTRACT(DAY FROM DATE '2025-01-01') - EXTRACT(DAY FROM DATE '2024-12-31');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_64_3",
        "database_name": "postgresql_64_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select makedate(03,1); -- MAKEDATE",
        "target_query": "SELECT make_date(3, 1, 1) + (1 - 1) * INTERVAL '1 day';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MAKEDATE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MAKEDATE(year, day_of_year)",
                "description": "Returns a date from the given year and day of the year.",
                "examples": [
                    "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
                    "SELECT MAKEDATE(2025, 100) AS specific_date;",
                    "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "make_date(year, 1, 1) + (day_of_year - 1) * INTERVAL '1 day'",
                "description": "Returns a date from the given year and day of the year, created by adding intervals.",
                "examples": [
                    "SELECT make_date(2009, 1, 1) + (1 - 1) * INTERVAL '1 day' AS first_day_of_year;",
                    "SELECT make_date(2025, 1, 1) + (100 - 1) * INTERVAL '1 day' AS specific_date;",
                    "SELECT make_date(2020, 1, 1) + (366 - 1) * INTERVAL '1 day' AS last_day_of_year;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_64_5",
        "database_name": "postgresql_64_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select makedate(1997,1); -- MAKEDATE",
        "target_query": "SELECT make_date(1997, 1, 1) + (1 - 1) * INTERVAL '1 day';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MAKEDATE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MAKEDATE(year, day_of_year)",
                "description": "Returns a date from the given year and day of the year.",
                "examples": [
                    "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
                    "SELECT MAKEDATE(2025, 100) AS specific_date;",
                    "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "make_date(year, 1, 1) + (day_of_year - 1) * INTERVAL '1 day'",
                "description": "Returns a date from the given year and day of the year, created by adding intervals.",
                "examples": [
                    "SELECT make_date(2009, 1, 1) + (1 - 1) * INTERVAL '1 day' AS first_day_of_year;",
                    "SELECT make_date(2025, 1, 1) + (100 - 1) * INTERVAL '1 day' AS specific_date;",
                    "SELECT make_date(2020, 1, 1) + (366 - 1) * INTERVAL '1 day' AS last_day_of_year;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_64_6",
        "database_name": "postgresql_64_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select makedate(1997,0); -- MAKEDATE",
        "target_query": "SELECT make_date(1997, 1, 1) + (0 - 1) * INTERVAL '1 day';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MAKEDATE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MAKEDATE(year, day_of_year)",
                "description": "Returns a date from the given year and day of the year.",
                "examples": [
                    "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
                    "SELECT MAKEDATE(2025, 100) AS specific_date;",
                    "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "make_date(year, 1, 1) + (day_of_year - 1) * INTERVAL '1 day'",
                "description": "Returns a date from the given year and day of the year, created by adding intervals.",
                "examples": [
                    "SELECT make_date(2009, 1, 1) + (1 - 1) * INTERVAL '1 day' AS first_day_of_year;",
                    "SELECT make_date(2025, 1, 1) + (100 - 1) * INTERVAL '1 day' AS specific_date;",
                    "SELECT make_date(2020, 1, 1) + (366 - 1) * INTERVAL '1 day' AS last_day_of_year;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_64_7",
        "database_name": "postgresql_64_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select makedate(9999,365); -- MAKEDATE",
        "target_query": "SELECT make_date(9999, 1, 1) + (365 - 1) * INTERVAL '1 day';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MAKEDATE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MAKEDATE(year, day_of_year)",
                "description": "Returns a date from the given year and day of the year.",
                "examples": [
                    "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
                    "SELECT MAKEDATE(2025, 100) AS specific_date;",
                    "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "make_date(year, 1, 1) + (day_of_year - 1) * INTERVAL '1 day'",
                "description": "Returns a date from the given year and day of the year, created by adding intervals.",
                "examples": [
                    "SELECT make_date(2009, 1, 1) + (1 - 1) * INTERVAL '1 day' AS first_day_of_year;",
                    "SELECT make_date(2025, 1, 1) + (100 - 1) * INTERVAL '1 day' AS specific_date;",
                    "SELECT make_date(2020, 1, 1) + (366 - 1) * INTERVAL '1 day' AS last_day_of_year;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_64_8",
        "database_name": "postgresql_64_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select makedate(9999,366); -- MAKEDATE",
        "target_query": "SELECT make_date(9999, 1, 1) + (366 - 1) * INTERVAL '1 day';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MAKEDATE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MAKEDATE(year, day_of_year)",
                "description": "Returns a date from the given year and day of the year.",
                "examples": [
                    "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
                    "SELECT MAKEDATE(2025, 100) AS specific_date;",
                    "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "make_date(year, 1, 1) + (day_of_year - 1) * INTERVAL '1 day'",
                "description": "Returns a date from the given year and day of the year, created by adding intervals.",
                "examples": [
                    "SELECT make_date(2009, 1, 1) + (1 - 1) * INTERVAL '1 day' AS first_day_of_year;",
                    "SELECT make_date(2025, 1, 1) + (100 - 1) * INTERVAL '1 day' AS specific_date;",
                    "SELECT make_date(2020, 1, 1) + (366 - 1) * INTERVAL '1 day' AS last_day_of_year;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_64_9",
        "database_name": "postgresql_64_9",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select makedate(100,1); -- MAKEDATE",
        "target_query": "SELECT make_date(100, 1, 1) + (1 - 1) * INTERVAL '1 day';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MAKEDATE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MAKEDATE(year, day_of_year)",
                "description": "Returns a date from the given year and day of the year.",
                "examples": [
                    "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
                    "SELECT MAKEDATE(2025, 100) AS specific_date;",
                    "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "make_date(year, 1, 1) + (day_of_year - 1) * INTERVAL '1 day'",
                "description": "Returns a date from the given year and day of the year, created by adding intervals.",
                "examples": [
                    "SELECT make_date(2009, 1, 1) + (1 - 1) * INTERVAL '1 day' AS first_day_of_year;",
                    "SELECT make_date(2025, 1, 1) + (100 - 1) * INTERVAL '1 day' AS specific_date;",
                    "SELECT make_date(2020, 1, 1) + (366 - 1) * INTERVAL '1 day' AS last_day_of_year;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_64_10",
        "database_name": "postgresql_64_10",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select subtime(\"1997-12-31 23:59:59.000001\", \"1 1:1:1.000002\"); -- SUBTIME",
        "target_query": "SELECT TIMESTAMP '1997-12-31 23:59:59.000001' - INTERVAL '1 day 1 hour 1 minute 1.000002 seconds';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "SUBTIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SUBTIME(expr1, expr2)",
                "description": "Subtracts a time/datetime interval from the given time or datetime.",
                "examples": [
                    "SELECT SUBTIME('12:00:00', '01:30:00');",
                    "SELECT SUBTIME('2025-01-01 10:00:00', '00:00:01');",
                    "SELECT SUBTIME('05:00:00', '05:00:00');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "expr1 - interval",
                "description": "Subtracts a time or interval from a timestamp or time.",
                "examples": [
                    "SELECT TIME '12:00:00' - INTERVAL '01:30:00';",
                    "SELECT TIMESTAMP '2025-01-01 10:00:00' - INTERVAL '1 SECOND';",
                    "SELECT TIME '05:00:00' - INTERVAL '05:00:00';"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_64_11",
        "database_name": "postgresql_64_11",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select subtime(\"1997-12-31 23:59:59.999999\", \"1998-01-01 01:01:01.999999\"); -- SUBTIME",
        "target_query": "SELECT TIMESTAMP '1997-12-31 23:59:59.999999' - TIMESTAMP '1998-01-01 01:01:01.999999';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "SUBTIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SUBTIME(expr1, expr2)",
                "description": "Subtracts a time/datetime interval from the given time or datetime.",
                "examples": [
                    "SELECT SUBTIME('12:00:00', '01:30:00');",
                    "SELECT SUBTIME('2025-01-01 10:00:00', '00:00:01');",
                    "SELECT SUBTIME('05:00:00', '05:00:00');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "expr1 - interval",
                "description": "Subtracts a time or interval from a timestamp or time.",
                "examples": [
                    "SELECT TIME '12:00:00' - INTERVAL '01:30:00';",
                    "SELECT TIMESTAMP '2025-01-01 10:00:00' - INTERVAL '1 SECOND';",
                    "SELECT TIME '05:00:00' - INTERVAL '05:00:00';"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_64_12",
        "database_name": "postgresql_64_12",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select subtime(\"01:00:00.999999\", \"02:00:00.999998\"); -- SUBTIME",
        "target_query": "SELECT TIME '01:00:00.999999' - INTERVAL '2 hours 0 minutes 0.999998 seconds';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "SUBTIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SUBTIME(expr1, expr2)",
                "description": "Subtracts a time/datetime interval from the given time or datetime.",
                "examples": [
                    "SELECT SUBTIME('12:00:00', '01:30:00');",
                    "SELECT SUBTIME('2025-01-01 10:00:00', '00:00:01');",
                    "SELECT SUBTIME('05:00:00', '05:00:00');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "expr1 - interval",
                "description": "Subtracts a time or interval from a timestamp or time.",
                "examples": [
                    "SELECT TIME '12:00:00' - INTERVAL '01:30:00';",
                    "SELECT TIMESTAMP '2025-01-01 10:00:00' - INTERVAL '1 SECOND';",
                    "SELECT TIME '05:00:00' - INTERVAL '05:00:00';"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_64_13",
        "database_name": "postgresql_64_13",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select subtime(\"02:01:01.999999\", \"01:01:01.999999\"); -- SUBTIME",
        "target_query": "SELECT TIME '02:01:01.999999' - INTERVAL '1 hour 1 minute 1.999999 seconds';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "SUBTIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SUBTIME(expr1, expr2)",
                "description": "Subtracts a time/datetime interval from the given time or datetime.",
                "examples": [
                    "SELECT SUBTIME('12:00:00', '01:30:00');",
                    "SELECT SUBTIME('2025-01-01 10:00:00', '00:00:01');",
                    "SELECT SUBTIME('05:00:00', '05:00:00');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "expr1 - interval",
                "description": "Subtracts a time or interval from a timestamp or time.",
                "examples": [
                    "SELECT TIME '12:00:00' - INTERVAL '01:30:00';",
                    "SELECT TIMESTAMP '2025-01-01 10:00:00' - INTERVAL '1 SECOND';",
                    "SELECT TIME '05:00:00' - INTERVAL '05:00:00';"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_64_14",
        "database_name": "postgresql_64_14",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select timediff(\"1997-01-01 23:59:59.000001\",\"1995-12-31 23:59:59.000002\"); -- TIMEDIFF",
        "target_query": "SELECT (TIMESTAMP '1997-01-01 23:59:59.000001' - TIMESTAMP '1995-12-31 23:59:59.000002')::TIME;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIMEDIFF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMEDIFF('12:00:00', '10:00:00')",
                "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
                "examples": [
                    "SELECT TIMEDIFF('12:00:00', '10:00:00');",
                    "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
                    "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "(timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::TIME",
                "description": "PostgreSQL does not have a direct TIMEDIFF function, but time differences can be calculated by subtracting one timestamp from another and casting the result to a TIME.",
                "examples": [
                    "SELECT (timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::TIME;",
                    "SELECT (NOW() - timestamp '2023-06-15 10:00:00')::INTERVAL;",
                    "SELECT (timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::INTERVAL;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_64_15",
        "database_name": "postgresql_64_15",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select timediff(\"1997-12-31 23:59:59.000001\",\"1997-12-30 01:01:01.000002\"); -- TIMEDIFF",
        "target_query": "SELECT (TIMESTAMP '1997-12-31 23:59:59.000001' - TIMESTAMP '1997-12-30 01:01:01.000002')::TIME;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIMEDIFF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMEDIFF('12:00:00', '10:00:00')",
                "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
                "examples": [
                    "SELECT TIMEDIFF('12:00:00', '10:00:00');",
                    "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
                    "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "(timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::TIME",
                "description": "PostgreSQL does not have a direct TIMEDIFF function, but time differences can be calculated by subtracting one timestamp from another and casting the result to a TIME.",
                "examples": [
                    "SELECT (timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::TIME;",
                    "SELECT (NOW() - timestamp '2023-06-15 10:00:00')::INTERVAL;",
                    "SELECT (timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::INTERVAL;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_64_16",
        "database_name": "postgresql_64_16",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select timediff(\"1997-12-31 23:59:59.000001\",\"23:59:59.000001\"); -- TIMEDIFF",
        "target_query": "SELECT (TIMESTAMP '1997-12-31 23:59:59.000001' - TIME '23:59:59.000001')::TIME;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIMEDIFF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMEDIFF('12:00:00', '10:00:00')",
                "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
                "examples": [
                    "SELECT TIMEDIFF('12:00:00', '10:00:00');",
                    "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
                    "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "(timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::TIME",
                "description": "PostgreSQL does not have a direct TIMEDIFF function, but time differences can be calculated by subtracting one timestamp from another and casting the result to a TIME.",
                "examples": [
                    "SELECT (timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::TIME;",
                    "SELECT (NOW() - timestamp '2023-06-15 10:00:00')::INTERVAL;",
                    "SELECT (timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::INTERVAL;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_64_17",
        "database_name": "postgresql_64_17",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select timediff(\"2000:01:01 00:00:00\", \"2000:01:01 00:00:00.000001\"); -- TIMEDIFF",
        "target_query": "SELECT (TIMESTAMP '2000-01-01 00:00:00' - TIMESTAMP '2000-01-01 00:00:00.000001')::TIME;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIMEDIFF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMEDIFF('12:00:00', '10:00:00')",
                "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
                "examples": [
                    "SELECT TIMEDIFF('12:00:00', '10:00:00');",
                    "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
                    "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "(timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::TIME",
                "description": "PostgreSQL does not have a direct TIMEDIFF function, but time differences can be calculated by subtracting one timestamp from another and casting the result to a TIME.",
                "examples": [
                    "SELECT (timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::TIME;",
                    "SELECT (NOW() - timestamp '2023-06-15 10:00:00')::INTERVAL;",
                    "SELECT (timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::INTERVAL;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_64_18",
        "database_name": "postgresql_64_18",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select timediff(\"2005-01-11 15:48:49.999999\", \"2005-01-11 15:48:50\"); --  TIMEDIFF",
        "target_query": "SELECT (TIMESTAMP '2005-01-11 15:48:49.999999' - TIMESTAMP '2005-01-11 15:48:50')::TIME;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIMEDIFF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMEDIFF('12:00:00', '10:00:00')",
                "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
                "examples": [
                    "SELECT TIMEDIFF('12:00:00', '10:00:00');",
                    "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
                    "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "(timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::TIME",
                "description": "PostgreSQL does not have a direct TIMEDIFF function, but time differences can be calculated by subtracting one timestamp from another and casting the result to a TIME.",
                "examples": [
                    "SELECT (timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::TIME;",
                    "SELECT (NOW() - timestamp '2023-06-15 10:00:00')::INTERVAL;",
                    "SELECT (timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::INTERVAL;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_65_0",
        "database_name": "postgresql_65_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select maketime(10,11,12); -- MAKETIME",
        "target_query": "SELECT TO_TIMESTAMP('10:11:12', 'HH24:MI:SS')::TIME;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MAKETIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MAKETIME(hours, minutes, seconds)",
                "description": "Creates a time value from the provided hours, minutes, and seconds.",
                "examples": [
                    "SELECT MAKETIME(1, 30, 45);",
                    "SELECT MAKETIME(12, 0, 0);",
                    "SELECT MAKETIME(23, 59, 59);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP('HH24:MI:SS', 'HH24:MI:SS')::TIME",
                "description": "PostgreSQL doesn't have a direct MAKETIME function, but TO_TIMESTAMP can be used to generate a time from string input.",
                "examples": [
                    "SELECT TO_TIMESTAMP('01:30:45', 'HH24:MI:SS')::TIME;",
                    "SELECT TO_TIMESTAMP('12:00:00', 'HH24:MI:SS')::TIME;",
                    "SELECT TO_TIMESTAMP('23:59:59', 'HH24:MI:SS')::TIME;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_65_1",
        "database_name": "postgresql_65_1",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select maketime(20,11,12); -- MAKETIME",
        "target_query": "SELECT TO_TIMESTAMP('20:11:12', 'HH24:MI:SS')::TIME;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MAKETIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MAKETIME(hours, minutes, seconds)",
                "description": "Creates a time value from the provided hours, minutes, and seconds.",
                "examples": [
                    "SELECT MAKETIME(1, 30, 45);",
                    "SELECT MAKETIME(12, 0, 0);",
                    "SELECT MAKETIME(23, 59, 59);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP('HH24:MI:SS', 'HH24:MI:SS')::TIME",
                "description": "PostgreSQL doesn't have a direct MAKETIME function, but TO_TIMESTAMP can be used to generate a time from string input.",
                "examples": [
                    "SELECT TO_TIMESTAMP('01:30:45', 'HH24:MI:SS')::TIME;",
                    "SELECT TO_TIMESTAMP('12:00:00', 'HH24:MI:SS')::TIME;",
                    "SELECT TO_TIMESTAMP('23:59:59', 'HH24:MI:SS')::TIME;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_65_3",
        "database_name": "postgresql_65_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select timestamp(\"2001-12-01\", \"01:01:01.999999\"); -- TIMESTAMP",
        "target_query": "SELECT TO_TIMESTAMP('2001-12-01 01:01:01.999999', 'YYYY-MM-DD HH24:MI:SS.US');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
                "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
                "examples": [
                    "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP('2023-06-15 10:30:45', 'YYYY-MM-DD HH24:MI:SS')",
                "description": "In PostgreSQL, TO_TIMESTAMP is used to convert a date-time string to a TIMESTAMP value, supporting both with and without timezone.",
                "examples": [
                    "SELECT TO_TIMESTAMP('2023-06-15 10:30:45', 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT TO_TIMESTAMP('2023-06-15 10:30:45+02:00', 'YYYY-MM-DD HH24:MI:SSOF');",
                    "SELECT TO_TIMESTAMP('2023-06-15 10:30:45', 'YYYY-MM-DD HH24:MI:SS') > TO_TIMESTAMP('2023-06-14 10:30:45', 'YYYY-MM-DD HH24:MI:SS');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_65_4",
        "database_name": "postgresql_65_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select timestamp(\"2001-10-01\", \"01:01:01.000001\"); -- TIMESTAMP",
        "target_query": "SELECT TO_TIMESTAMP('2001-10-01 01:01:01.000001', 'YYYY-MM-DD HH24:MI:SS.US');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
                "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
                "examples": [
                    "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP('2023-06-15 10:30:45', 'YYYY-MM-DD HH24:MI:SS')",
                "description": "In PostgreSQL, TO_TIMESTAMP is used to convert a date-time string to a TIMESTAMP value, supporting both with and without timezone.",
                "examples": [
                    "SELECT TO_TIMESTAMP('2023-06-15 10:30:45', 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT TO_TIMESTAMP('2023-06-15 10:30:45+02:00', 'YYYY-MM-DD HH24:MI:SSOF');",
                    "SELECT TO_TIMESTAMP('2023-06-15 10:30:45', 'YYYY-MM-DD HH24:MI:SS') > TO_TIMESTAMP('2023-06-14 10:30:45', 'YYYY-MM-DD HH24:MI:SS');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_65_5",
        "database_name": "postgresql_65_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select timestamp(\"2001-12-01\", \"20:01:01\"); -- TIMESTAMP",
        "target_query": "SELECT TO_TIMESTAMP('2001-12-01 20:01:01', 'YYYY-MM-DD HH24:MI:SS');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
                "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
                "examples": [
                    "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP('2023-06-15 10:30:45', 'YYYY-MM-DD HH24:MI:SS')",
                "description": "In PostgreSQL, TO_TIMESTAMP is used to convert a date-time string to a TIMESTAMP value, supporting both with and without timezone.",
                "examples": [
                    "SELECT TO_TIMESTAMP('2023-06-15 10:30:45', 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT TO_TIMESTAMP('2023-06-15 10:30:45+02:00', 'YYYY-MM-DD HH24:MI:SSOF');",
                    "SELECT TO_TIMESTAMP('2023-06-15 10:30:45', 'YYYY-MM-DD HH24:MI:SS') > TO_TIMESTAMP('2023-06-14 10:30:45', 'YYYY-MM-DD HH24:MI:SS');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_65_6",
        "database_name": "postgresql_65_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select timestamp(\"2001-12-01\"); -- TIMESTAMP",
        "target_query": "SELECT TO_TIMESTAMP('2001-12-01', 'YYYY-MM-DD');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
                "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
                "examples": [
                    "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP('2023-06-15 10:30:45', 'YYYY-MM-DD HH24:MI:SS')",
                "description": "In PostgreSQL, TO_TIMESTAMP is used to convert a date-time string to a TIMESTAMP value, supporting both with and without timezone.",
                "examples": [
                    "SELECT TO_TIMESTAMP('2023-06-15 10:30:45', 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT TO_TIMESTAMP('2023-06-15 10:30:45+02:00', 'YYYY-MM-DD HH24:MI:SSOF');",
                    "SELECT TO_TIMESTAMP('2023-06-15 10:30:45', 'YYYY-MM-DD HH24:MI:SS') > TO_TIMESTAMP('2023-06-14 10:30:45', 'YYYY-MM-DD HH24:MI:SS');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_65_7",
        "database_name": "postgresql_65_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select day(\"1997-12-31 23:59:59.000001\"); -- DAY",
        "target_query": "SELECT EXTRACT(DAY FROM TIMESTAMP '1997-12-31 23:59:59.000001');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DAY"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DAY(date_expr)",
                "description": "Returns the day of the month (1-31) from a date or datetime expression.",
                "examples": [
                    "SELECT DAY('2023-10-15');",
                    "SELECT DAY(NOW());",
                    "SELECT DAY(CAST('2024-02-29 12:34:56' AS DATE));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(DAY FROM date_expr)",
                "description": "Extracts the day of the month from a date or timestamp value as a numeric value.",
                "examples": [
                    "SELECT EXTRACT(DAY FROM DATE '2023-10-15');",
                    "SELECT EXTRACT(DAY FROM CURRENT_DATE);",
                    "SELECT EXTRACT(DAY FROM TIMESTAMP '2024-02-29 08:00:00');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_65_8",
        "database_name": "postgresql_65_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select time(\"1997-12-31 23:59:59.000001\"); -- TIME",
        "target_query": "SELECT TO_CHAR(TIMESTAMP '1997-12-31 23:59:59.000001', 'HH24:MI:SS.US');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
                "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
                "examples": [
                    "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
                    "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
                    "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(time_expr, 'HH24:MI:SS')",
                "description": "In PostgreSQL, the time() function does not support SQLite-style modifiers directly within a function call. To modify time values, PostgreSQL uses the INTERVAL type for time adjustments, and the TO_CHAR function for formatting. The time expression returns the time formatted as 'HH:MI:SS'. Milliseconds can be included using 'SS.US' in the format string.",
                "examples": [
                    "SELECT TO_CHAR(NOW()::time, 'HH24:MI:SS'); -- Returns the current time formatted as 'HH:MM:SS'.",
                    "SELECT TO_CHAR(NOW()::time + INTERVAL '1 hour', 'HH24:MI:SS'); -- Returns the time one hour after the current time.",
                    "SELECT TO_CHAR('14:16:00'::time + INTERVAL '0.123 second', 'HH24:MI:SS.US'); -- Returns '14:16:00.123' with milliseconds."
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_65_12",
        "database_name": "postgresql_65_12",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT TIMEDIFF(t1, t4) As ttt, TIMEDIFF(t2, t3) As qqq,TIMEDIFF(t3, t2) As eee, TIMEDIFF(t2, t4) As rrr from test; -- TIMEDIFF",
        "target_query": "SELECT (t1 - t4)::TIME AS ttt, ((CURRENT_DATE + t2) - (CURRENT_DATE + t3))::TIME AS qqq, ((CURRENT_DATE + t3) - (CURRENT_DATE + t2))::TIME AS eee, ((CURRENT_DATE + t2) - t4)::TIME AS rrr FROM test;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIMEDIFF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMEDIFF('12:00:00', '10:00:00')",
                "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
                "examples": [
                    "SELECT TIMEDIFF('12:00:00', '10:00:00');",
                    "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
                    "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "(timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::TIME",
                "description": "PostgreSQL does not have a direct TIMEDIFF function, but time differences can be calculated by subtracting one timestamp from another and casting the result to a TIME.",
                "examples": [
                    "SELECT (timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::TIME;",
                    "SELECT (NOW() - timestamp '2023-06-15 10:00:00')::INTERVAL;",
                    "SELECT (timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::INTERVAL;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `test`\nColumns:\n(t1, datetime, )\n(t2, time, )\n(t3, time, )\n(t4, datetime, )\n"
        ],
        "target_related_schemas": [
            "Table: `test`\nColumns:\n(t1, timestamp without time zone, )\n(t2, time without time zone, )\n(t3, time without time zone, )\n(t4, timestamp without time zone, )\n"
        ]
    },
    {
        "sql_id": "postgresql_65_13",
        "database_name": "postgresql_65_13",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select str_to_date(\"2003-01-02 10:11:12.0012\", \"%Y-%m-%d %H:%i:%S.%f\"); -- STR_TO_DATE",
        "target_query": "SELECT TO_TIMESTAMP('2003-01-02 10:11:12.0012', 'YYYY-MM-DD HH24:MI:SS.US');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "STR_TO_DATE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STR_TO_DATE('09:22', '%H:%i')",
                "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
                "examples": [
                    "SELECT STR_TO_DATE('12:45', '%H:%i');",
                    "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
                    "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP('09:22', 'HH24:MI')",
                "description": "Converts the string '09:22' to a TIME type using TO_TIMESTAMP, with format 'HH24:MI' in PostgreSQL.",
                "examples": [
                    "SELECT TO_TIMESTAMP('12:45', 'HH24:MI');",
                    "SELECT TO_DATE('2000-01-01', 'YYYY-MM-DD');",
                    "SELECT TO_TIMESTAMP('2023-05-06 12:34:56', 'YYYY-MM-DD HH24:MI:SS');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `test`\nColumns:\n(t1, datetime, )\n(t2, time, )\n(t3, time, )\n(t4, datetime, )\n"
        ],
        "target_related_schemas": [
            "Table: `test`\nColumns:\n(t1, timestamp without time zone, )\n(t2, time without time zone, )\n(t3, time without time zone, )\n(t4, timestamp without time zone, )\n"
        ]
    },
    {
        "sql_id": "postgresql_65_14",
        "database_name": "postgresql_65_14",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select timediff('2008-09-29 20:10:10','2008-09-30 20:10:10'),time('00:00:00'); -- TIMEDIFF, TIME",
        "target_query": "SELECT (TIMESTAMP '2008-09-29 20:10:10' - TIMESTAMP '2008-09-30 20:10:10')::TIME, TIME '00:00:00';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIMEDIFF",
            "TIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMEDIFF('12:00:00', '10:00:00')",
                "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
                "examples": [
                    "SELECT TIMEDIFF('12:00:00', '10:00:00');",
                    "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
                    "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
                ]
            },
            {
                "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
                "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
                "examples": [
                    "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
                    "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
                    "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "(timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::TIME",
                "description": "PostgreSQL does not have a direct TIMEDIFF function, but time differences can be calculated by subtracting one timestamp from another and casting the result to a TIME.",
                "examples": [
                    "SELECT (timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::TIME;",
                    "SELECT (NOW() - timestamp '2023-06-15 10:00:00')::INTERVAL;",
                    "SELECT (timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::INTERVAL;"
                ]
            },
            {
                "expression": "TO_CHAR(time_expr, 'HH24:MI:SS')",
                "description": "In PostgreSQL, the time() function does not support SQLite-style modifiers directly within a function call. To modify time values, PostgreSQL uses the INTERVAL type for time adjustments, and the TO_CHAR function for formatting. The time expression returns the time formatted as 'HH:MI:SS'. Milliseconds can be included using 'SS.US' in the format string.",
                "examples": [
                    "SELECT TO_CHAR(NOW()::time, 'HH24:MI:SS'); -- Returns the current time formatted as 'HH:MM:SS'.",
                    "SELECT TO_CHAR(NOW()::time + INTERVAL '1 hour', 'HH24:MI:SS'); -- Returns the time one hour after the current time.",
                    "SELECT TO_CHAR('14:16:00'::time + INTERVAL '0.123 second', 'HH24:MI:SS.US'); -- Returns '14:16:00.123' with milliseconds."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `test`\nColumns:\n(t1, datetime, )\n(t2, time, )\n(t3, time, )\n(t4, datetime, )\n"
        ],
        "target_related_schemas": [
            "Table: `test`\nColumns:\n(t1, timestamp without time zone, )\n(t2, time without time zone, )\n(t3, time without time zone, )\n(t4, timestamp without time zone, )\n"
        ]
    },
    {
        "sql_id": "postgresql_65_15",
        "database_name": "postgresql_65_15",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select timediff('2008-09-29 20:10:10','2008-09-30 20:10:10')>time('00:00:00'); -- TIMEDIFF, TIME",
        "target_query": "SELECT (TIMESTAMP '2008-09-29 20:10:10' - TIMESTAMP '2008-09-30 20:10:10')::TIME > TIME '00:00:00';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIMEDIFF",
            "TIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMEDIFF('12:00:00', '10:00:00')",
                "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
                "examples": [
                    "SELECT TIMEDIFF('12:00:00', '10:00:00');",
                    "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
                    "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
                ]
            },
            {
                "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
                "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
                "examples": [
                    "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
                    "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
                    "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "(timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::TIME",
                "description": "PostgreSQL does not have a direct TIMEDIFF function, but time differences can be calculated by subtracting one timestamp from another and casting the result to a TIME.",
                "examples": [
                    "SELECT (timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::TIME;",
                    "SELECT (NOW() - timestamp '2023-06-15 10:00:00')::INTERVAL;",
                    "SELECT (timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::INTERVAL;"
                ]
            },
            {
                "expression": "TO_CHAR(time_expr, 'HH24:MI:SS')",
                "description": "In PostgreSQL, the time() function does not support SQLite-style modifiers directly within a function call. To modify time values, PostgreSQL uses the INTERVAL type for time adjustments, and the TO_CHAR function for formatting. The time expression returns the time formatted as 'HH:MI:SS'. Milliseconds can be included using 'SS.US' in the format string.",
                "examples": [
                    "SELECT TO_CHAR(NOW()::time, 'HH24:MI:SS'); -- Returns the current time formatted as 'HH:MM:SS'.",
                    "SELECT TO_CHAR(NOW()::time + INTERVAL '1 hour', 'HH24:MI:SS'); -- Returns the time one hour after the current time.",
                    "SELECT TO_CHAR('14:16:00'::time + INTERVAL '0.123 second', 'HH24:MI:SS.US'); -- Returns '14:16:00.123' with milliseconds."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `test`\nColumns:\n(t1, datetime, )\n(t2, time, )\n(t3, time, )\n(t4, datetime, )\n"
        ],
        "target_related_schemas": [
            "Table: `test`\nColumns:\n(t1, timestamp without time zone, )\n(t2, time without time zone, )\n(t3, time without time zone, )\n(t4, timestamp without time zone, )\n"
        ]
    },
    {
        "sql_id": "postgresql_65_16",
        "database_name": "postgresql_65_16",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select timediff('2008-09-29 20:10:10','2008-09-30 20:10:10')<time('00:00:00'); -- TIMEDIFF, TIME",
        "target_query": "SELECT (TIMESTAMP '2008-09-29 20:10:10' - TIMESTAMP '2008-09-30 20:10:10')::TIME < TIME '00:00:00';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIMEDIFF",
            "TIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMEDIFF('12:00:00', '10:00:00')",
                "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
                "examples": [
                    "SELECT TIMEDIFF('12:00:00', '10:00:00');",
                    "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
                    "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
                ]
            },
            {
                "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
                "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
                "examples": [
                    "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
                    "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
                    "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "(timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::TIME",
                "description": "PostgreSQL does not have a direct TIMEDIFF function, but time differences can be calculated by subtracting one timestamp from another and casting the result to a TIME.",
                "examples": [
                    "SELECT (timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::TIME;",
                    "SELECT (NOW() - timestamp '2023-06-15 10:00:00')::INTERVAL;",
                    "SELECT (timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')::INTERVAL;"
                ]
            },
            {
                "expression": "TO_CHAR(time_expr, 'HH24:MI:SS')",
                "description": "In PostgreSQL, the time() function does not support SQLite-style modifiers directly within a function call. To modify time values, PostgreSQL uses the INTERVAL type for time adjustments, and the TO_CHAR function for formatting. The time expression returns the time formatted as 'HH:MI:SS'. Milliseconds can be included using 'SS.US' in the format string.",
                "examples": [
                    "SELECT TO_CHAR(NOW()::time, 'HH24:MI:SS'); -- Returns the current time formatted as 'HH:MM:SS'.",
                    "SELECT TO_CHAR(NOW()::time + INTERVAL '1 hour', 'HH24:MI:SS'); -- Returns the time one hour after the current time.",
                    "SELECT TO_CHAR('14:16:00'::time + INTERVAL '0.123 second', 'HH24:MI:SS.US'); -- Returns '14:16:00.123' with milliseconds."
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `test`\nColumns:\n(t1, datetime, )\n(t2, time, )\n(t3, time, )\n(t4, datetime, )\n"
        ],
        "target_related_schemas": [
            "Table: `test`\nColumns:\n(t1, timestamp without time zone, )\n(t2, time without time zone, )\n(t3, time without time zone, )\n(t4, timestamp without time zone, )\n"
        ]
    },
    {
        "sql_id": "postgresql_66_0",
        "database_name": "postgresql_66_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT CAST(time('23:42:12') AS DECIMAL); -- TIME",
        "target_query": "SELECT TO_CHAR('23:42:12'::TIME, 'HH24:MI:SS');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
                "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
                "examples": [
                    "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
                    "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
                    "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(time_expr, 'HH24:MI:SS')",
                "description": "In PostgreSQL, the time() function does not support SQLite-style modifiers directly within a function call. To modify time values, PostgreSQL uses the INTERVAL type for time adjustments, and the TO_CHAR function for formatting. The time expression returns the time formatted as 'HH:MI:SS'. Milliseconds can be included using 'SS.US' in the format string.",
                "examples": [
                    "SELECT TO_CHAR(NOW()::time, 'HH24:MI:SS'); -- Returns the current time formatted as 'HH:MM:SS'.",
                    "SELECT TO_CHAR(NOW()::time + INTERVAL '1 hour', 'HH24:MI:SS'); -- Returns the time one hour after the current time.",
                    "SELECT TO_CHAR('14:16:00'::time + INTERVAL '0.123 second', 'HH24:MI:SS.US'); -- Returns '14:16:00.123' with milliseconds."
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_66_1",
        "database_name": "postgresql_66_1",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT sec_to_time(86399)=TIME('23:59:59'); -- SEC_TO_TIME, TIME",
        "target_query": "SELECT TO_CHAR(TO_TIMESTAMP(86399), 'HH24:MI:SS') = TO_CHAR('23:59:59'::time, 'HH24:MI:SS');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "SEC_TO_TIME",
            "TIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SEC_TO_TIME(seconds)",
                "description": "Converts the given number of seconds into a time value in the format HH:MM:SS. Wraps around if seconds exceed 86400.",
                "examples": [
                    "SELECT SEC_TO_TIME(3661); -- Returns '01:01:01'",
                    "SELECT SEC_TO_TIME(3600); -- Returns '01:00:00'",
                    "SELECT SEC_TO_TIME(86400); -- Returns '00:00:00'"
                ]
            },
            {
                "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
                "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
                "examples": [
                    "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
                    "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
                    "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(TO_TIMESTAMP(seconds), 'HH24:MI:SS')",
                "description": "Converts the given number of seconds into a time format by using the TO_TIMESTAMP function and formatting the result.",
                "examples": [
                    "SELECT TO_CHAR(TO_TIMESTAMP(3661), 'HH24:MI:SS'); -- Returns '01:01:01'",
                    "SELECT TO_CHAR(TO_TIMESTAMP(3600), 'HH24:MI:SS'); -- Returns '01:00:00'",
                    "SELECT TO_CHAR(TO_TIMESTAMP(86400), 'HH24:MI:SS'); -- Returns '00:00:00'"
                ]
            },
            {
                "expression": "TO_CHAR(time_expr, 'HH24:MI:SS')",
                "description": "In PostgreSQL, the time() function does not support SQLite-style modifiers directly within a function call. To modify time values, PostgreSQL uses the INTERVAL type for time adjustments, and the TO_CHAR function for formatting. The time expression returns the time formatted as 'HH:MI:SS'. Milliseconds can be included using 'SS.US' in the format string.",
                "examples": [
                    "SELECT TO_CHAR(NOW()::time, 'HH24:MI:SS'); -- Returns the current time formatted as 'HH:MM:SS'.",
                    "SELECT TO_CHAR(NOW()::time + INTERVAL '1 hour', 'HH24:MI:SS'); -- Returns the time one hour after the current time.",
                    "SELECT TO_CHAR('14:16:00'::time + INTERVAL '0.123 second', 'HH24:MI:SS.US'); -- Returns '14:16:00.123' with milliseconds."
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_66_2",
        "database_name": "postgresql_66_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT sec_to_time(86399)='23:59:59'; -- SEC_TO_TIME",
        "target_query": "SELECT TO_CHAR(TO_TIMESTAMP(86399), 'HH24:MI:SS') = '23:59:59';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "SEC_TO_TIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SEC_TO_TIME(seconds)",
                "description": "Converts the given number of seconds into a time value in the format HH:MM:SS. Wraps around if seconds exceed 86400.",
                "examples": [
                    "SELECT SEC_TO_TIME(3661); -- Returns '01:01:01'",
                    "SELECT SEC_TO_TIME(3600); -- Returns '01:00:00'",
                    "SELECT SEC_TO_TIME(86400); -- Returns '00:00:00'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(TO_TIMESTAMP(seconds), 'HH24:MI:SS')",
                "description": "Converts the given number of seconds into a time format by using the TO_TIMESTAMP function and formatting the result.",
                "examples": [
                    "SELECT TO_CHAR(TO_TIMESTAMP(3661), 'HH24:MI:SS'); -- Returns '01:01:01'",
                    "SELECT TO_CHAR(TO_TIMESTAMP(3600), 'HH24:MI:SS'); -- Returns '01:00:00'",
                    "SELECT TO_CHAR(TO_TIMESTAMP(86400), 'HH24:MI:SS'); -- Returns '00:00:00'"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_66_3",
        "database_name": "postgresql_66_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT time(sec_to_time(86399))=TIME('23:59:59'); -- TIME, SEC_TO_TIME",
        "target_query": "SELECT TO_CHAR(TO_TIMESTAMP(86399), 'HH24:MI:SS') = TO_CHAR('23:59:59'::time, 'HH24:MI:SS');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIME",
            "SEC_TO_TIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
                "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
                "examples": [
                    "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
                    "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
                    "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
                ]
            },
            {
                "expression": "SEC_TO_TIME(seconds)",
                "description": "Converts the given number of seconds into a time value in the format HH:MM:SS. Wraps around if seconds exceed 86400.",
                "examples": [
                    "SELECT SEC_TO_TIME(3661); -- Returns '01:01:01'",
                    "SELECT SEC_TO_TIME(3600); -- Returns '01:00:00'",
                    "SELECT SEC_TO_TIME(86400); -- Returns '00:00:00'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(time_expr, 'HH24:MI:SS')",
                "description": "In PostgreSQL, the time() function does not support SQLite-style modifiers directly within a function call. To modify time values, PostgreSQL uses the INTERVAL type for time adjustments, and the TO_CHAR function for formatting. The time expression returns the time formatted as 'HH:MI:SS'. Milliseconds can be included using 'SS.US' in the format string.",
                "examples": [
                    "SELECT TO_CHAR(NOW()::time, 'HH24:MI:SS'); -- Returns the current time formatted as 'HH:MM:SS'.",
                    "SELECT TO_CHAR(NOW()::time + INTERVAL '1 hour', 'HH24:MI:SS'); -- Returns the time one hour after the current time.",
                    "SELECT TO_CHAR('14:16:00'::time + INTERVAL '0.123 second', 'HH24:MI:SS.US'); -- Returns '14:16:00.123' with milliseconds."
                ]
            },
            {
                "expression": "TO_CHAR(TO_TIMESTAMP(seconds), 'HH24:MI:SS')",
                "description": "Converts the given number of seconds into a time format by using the TO_TIMESTAMP function and formatting the result.",
                "examples": [
                    "SELECT TO_CHAR(TO_TIMESTAMP(3661), 'HH24:MI:SS'); -- Returns '01:01:01'",
                    "SELECT TO_CHAR(TO_TIMESTAMP(3600), 'HH24:MI:SS'); -- Returns '01:00:00'",
                    "SELECT TO_CHAR(TO_TIMESTAMP(86400), 'HH24:MI:SS'); -- Returns '00:00:00'"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_66_4",
        "database_name": "postgresql_66_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT maketime(1,0,1)='01:00:01'; -- MAKETIME",
        "target_query": "SELECT TO_TIMESTAMP('01:00:01', 'HH24:MI:SS')::TIME = '01:00:01';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MAKETIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MAKETIME(hours, minutes, seconds)",
                "description": "Creates a time value from the provided hours, minutes, and seconds.",
                "examples": [
                    "SELECT MAKETIME(1, 30, 45);",
                    "SELECT MAKETIME(12, 0, 0);",
                    "SELECT MAKETIME(23, 59, 59);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP('HH24:MI:SS', 'HH24:MI:SS')::TIME",
                "description": "PostgreSQL doesn't have a direct MAKETIME function, but TO_TIMESTAMP can be used to generate a time from string input.",
                "examples": [
                    "SELECT TO_TIMESTAMP('01:30:45', 'HH24:MI:SS')::TIME;",
                    "SELECT TO_TIMESTAMP('12:00:00', 'HH24:MI:SS')::TIME;",
                    "SELECT TO_TIMESTAMP('23:59:59', 'HH24:MI:SS')::TIME;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_66_5",
        "database_name": "postgresql_66_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT TIME(maketime(1,0,1))=CAST('01:00:01' AS TIME); -- TIME, MAKETIME",
        "target_query": "SELECT TO_CHAR(TO_TIMESTAMP('01:00:01', 'HH24:MI:SS')::TIME, 'HH24:MI:SS') = TO_CHAR(CAST('01:00:01' AS TIME), 'HH24:MI:SS');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIME",
            "MAKETIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
                "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
                "examples": [
                    "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
                    "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
                    "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
                ]
            },
            {
                "expression": "MAKETIME(hours, minutes, seconds)",
                "description": "Creates a time value from the provided hours, minutes, and seconds.",
                "examples": [
                    "SELECT MAKETIME(1, 30, 45);",
                    "SELECT MAKETIME(12, 0, 0);",
                    "SELECT MAKETIME(23, 59, 59);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_CHAR(time_expr, 'HH24:MI:SS')",
                "description": "In PostgreSQL, the time() function does not support SQLite-style modifiers directly within a function call. To modify time values, PostgreSQL uses the INTERVAL type for time adjustments, and the TO_CHAR function for formatting. The time expression returns the time formatted as 'HH:MI:SS'. Milliseconds can be included using 'SS.US' in the format string.",
                "examples": [
                    "SELECT TO_CHAR(NOW()::time, 'HH24:MI:SS'); -- Returns the current time formatted as 'HH:MM:SS'.",
                    "SELECT TO_CHAR(NOW()::time + INTERVAL '1 hour', 'HH24:MI:SS'); -- Returns the time one hour after the current time.",
                    "SELECT TO_CHAR('14:16:00'::time + INTERVAL '0.123 second', 'HH24:MI:SS.US'); -- Returns '14:16:00.123' with milliseconds."
                ]
            },
            {
                "expression": "TO_TIMESTAMP('HH24:MI:SS', 'HH24:MI:SS')::TIME",
                "description": "PostgreSQL doesn't have a direct MAKETIME function, but TO_TIMESTAMP can be used to generate a time from string input.",
                "examples": [
                    "SELECT TO_TIMESTAMP('01:30:45', 'HH24:MI:SS')::TIME;",
                    "SELECT TO_TIMESTAMP('12:00:00', 'HH24:MI:SS')::TIME;",
                    "SELECT TO_TIMESTAMP('23:59:59', 'HH24:MI:SS')::TIME;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_66_6",
        "database_name": "postgresql_66_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT maketime(1,0,1)=CAST('01:00:01' AS TIME); -- MAKETIME",
        "target_query": "SELECT TO_TIMESTAMP('01:00:01', 'HH24:MI:SS')::TIME = CAST('01:00:01' AS TIME);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MAKETIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MAKETIME(hours, minutes, seconds)",
                "description": "Creates a time value from the provided hours, minutes, and seconds.",
                "examples": [
                    "SELECT MAKETIME(1, 30, 45);",
                    "SELECT MAKETIME(12, 0, 0);",
                    "SELECT MAKETIME(23, 59, 59);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP('HH24:MI:SS', 'HH24:MI:SS')::TIME",
                "description": "PostgreSQL doesn't have a direct MAKETIME function, but TO_TIMESTAMP can be used to generate a time from string input.",
                "examples": [
                    "SELECT TO_TIMESTAMP('01:30:45', 'HH24:MI:SS')::TIME;",
                    "SELECT TO_TIMESTAMP('12:00:00', 'HH24:MI:SS')::TIME;",
                    "SELECT TO_TIMESTAMP('23:59:59', 'HH24:MI:SS')::TIME;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_67_0",
        "database_name": "postgresql_67_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select elt(2,1),field(NULL,\"a\",\"b\",\"c\"); -- ELT, FIELD",
        "target_query": "SELECT CASE WHEN 2 > 0 AND 2 <= array_length(ARRAY[1], 1) THEN (ARRAY[1])[2] ELSE NULL END, COALESCE(array_position(ARRAY['a', 'b', 'c'], NULL), 0);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ELT",
            "FIELD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "ELT(2, 'apple', 'banana', 'cherry')",
                "description": "Returns the N-th element from the list, where N is the first argument.",
                "examples": [
                    "SELECT ELT(2, 'apple', 'banana', 'cherry');  -- Returns 'banana'",
                    "SELECT ELT(1, 'red', 'green', 'blue');  -- Returns 'red'",
                    "SELECT ELT(3, 'dog', 'cat', 'bird');  -- Returns 'bird'"
                ]
            },
            {
                "expression": "FIELD(val, val1, val2, ..., valN)",
                "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
                "examples": [
                    "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
                    "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
                    "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN 2 > 0 AND 2 <= array_length(ARRAY['apple', 'banana', 'cherry'], 1) THEN (ARRAY['apple', 'banana', 'cherry'])[2] ELSE NULL END",
                "description": "Uses a CASE statement and an array to return the N-th element.",
                "examples": [
                    "SELECT CASE WHEN 2 > 0 AND 2 <= array_length(ARRAY['apple', 'banana', 'cherry'], 1) THEN (ARRAY['apple', 'banana', 'cherry'])[2] ELSE NULL END;  -- Returns 'banana'",
                    "SELECT CASE WHEN 1 > 0 AND 1 <= array_length(ARRAY['red', 'green', 'blue'], 1) THEN (ARRAY['red', 'green', 'blue'])[1] ELSE NULL END;  -- Returns 'red'",
                    "SELECT CASE WHEN 3 > 0 AND 3 <= array_length(ARRAY['dog', 'cat', 'bird'], 1) THEN (ARRAY['dog', 'cat', 'bird'])[3] ELSE NULL END;  -- Returns 'bird'"
                ]
            },
            {
                "expression": "COALESCE(array_position(ARRAY[val1, val2, ..., valN], val), 0)",
                "description": "Returns the index (1-based) of 'val' in the array. Returns 0 if not found, to match MySQL FIELD() behavior.",
                "examples": [
                    "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'c'), 0) AS result;",
                    "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'x'), 0) AS result;",
                    "SELECT COALESCE(array_position(ARRAY['b', 'b', 'b'], 'b'), 0) AS result;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_67_1",
        "database_name": "postgresql_67_1",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select field(\"b\",\"a\",NULL),field(1,0,NULL)+0,field(1.0,0.0,NULL)+0.0,field(1.0e1,0.0e1,NULL)+0.0e1; -- FIELD",
        "target_query": "SELECT COALESCE(array_position(ARRAY['a', NULL], 'b'), 0), COALESCE(array_position(ARRAY[0, NULL], 1), 0), COALESCE(array_position(ARRAY[0.0, NULL], 1.0), 0), COALESCE(array_position(ARRAY[0.0e1, NULL], 1.0e1), 0);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "FIELD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FIELD(val, val1, val2, ..., valN)",
                "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
                "examples": [
                    "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
                    "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
                    "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(array_position(ARRAY[val1, val2, ..., valN], val), 0)",
                "description": "Returns the index (1-based) of 'val' in the array. Returns 0 if not found, to match MySQL FIELD() behavior.",
                "examples": [
                    "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'c'), 0) AS result;",
                    "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'x'), 0) AS result;",
                    "SELECT COALESCE(array_position(ARRAY['b', 'b', 'b'], 'b'), 0) AS result;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_67_2",
        "database_name": "postgresql_67_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select field(NULL,\"a\",NULL),field(NULL,0,NULL)+0,field(NULL,0.0,NULL)+0.0,field(NULL,0.0e1,NULL)+0.0e1; -- FIELD",
        "target_query": "SELECT COALESCE(array_position(ARRAY['a', NULL], NULL), 0), COALESCE(array_position(ARRAY[0, NULL], NULL), 0), COALESCE(array_position(ARRAY[0.0, NULL], NULL), 0), COALESCE(array_position(ARRAY[0.0e1, NULL], NULL), 0);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "FIELD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FIELD(val, val1, val2, ..., valN)",
                "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
                "examples": [
                    "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
                    "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
                    "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(array_position(ARRAY[val1, val2, ..., valN], val), 0)",
                "description": "Returns the index (1-based) of 'val' in the array. Returns 0 if not found, to match MySQL FIELD() behavior.",
                "examples": [
                    "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'c'), 0) AS result;",
                    "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'x'), 0) AS result;",
                    "SELECT COALESCE(array_position(ARRAY['b', 'b', 'b'], 'b'), 0) AS result;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_67_9",
        "database_name": "postgresql_67_9",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select one.id, elt(two.val,'one','two') from t1 one, t2 two where two.id=one.id; -- ELT",
        "target_query": "SELECT one.id, CASE WHEN two.val > 0 AND two.val <= array_length(ARRAY['one', 'two'], 1) THEN (ARRAY['one', 'two'])[two.val] ELSE NULL END FROM t1 one, t2 two WHERE two.id = one.id;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ELT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "ELT(2, 'apple', 'banana', 'cherry')",
                "description": "Returns the N-th element from the list, where N is the first argument.",
                "examples": [
                    "SELECT ELT(2, 'apple', 'banana', 'cherry');  -- Returns 'banana'",
                    "SELECT ELT(1, 'red', 'green', 'blue');  -- Returns 'red'",
                    "SELECT ELT(3, 'dog', 'cat', 'bird');  -- Returns 'bird'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN 2 > 0 AND 2 <= array_length(ARRAY['apple', 'banana', 'cherry'], 1) THEN (ARRAY['apple', 'banana', 'cherry'])[2] ELSE NULL END",
                "description": "Uses a CASE statement and an array to return the N-th element.",
                "examples": [
                    "SELECT CASE WHEN 2 > 0 AND 2 <= array_length(ARRAY['apple', 'banana', 'cherry'], 1) THEN (ARRAY['apple', 'banana', 'cherry'])[2] ELSE NULL END;  -- Returns 'banana'",
                    "SELECT CASE WHEN 1 > 0 AND 1 <= array_length(ARRAY['red', 'green', 'blue'], 1) THEN (ARRAY['red', 'green', 'blue'])[1] ELSE NULL END;  -- Returns 'red'",
                    "SELECT CASE WHEN 3 > 0 AND 3 <= array_length(ARRAY['dog', 'cat', 'bird'], 1) THEN (ARRAY['dog', 'cat', 'bird'])[3] ELSE NULL END;  -- Returns 'bird'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(id, int, PRI)\n",
            "Table: `t2`\nColumns:\n(id, int, PRI)\n(val, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(id, integer, )\n",
            "Table: `t2`\nColumns:\n(id, integer, PRI)\n(val, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_67_10",
        "database_name": "postgresql_67_10",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select one.id, elt(two.val,'one','two') from t1 one, t2 two where two.id=one.id order by one.id; -- ELT",
        "target_query": "SELECT one.id, CASE WHEN two.val > 0 AND two.val <= array_length(ARRAY['one', 'two'], 1) THEN (ARRAY['one', 'two'])[two.val] ELSE NULL END FROM t1 one, t2 two WHERE two.id = one.id ORDER BY one.id;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ELT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "ELT(2, 'apple', 'banana', 'cherry')",
                "description": "Returns the N-th element from the list, where N is the first argument.",
                "examples": [
                    "SELECT ELT(2, 'apple', 'banana', 'cherry');  -- Returns 'banana'",
                    "SELECT ELT(1, 'red', 'green', 'blue');  -- Returns 'red'",
                    "SELECT ELT(3, 'dog', 'cat', 'bird');  -- Returns 'bird'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN 2 > 0 AND 2 <= array_length(ARRAY['apple', 'banana', 'cherry'], 1) THEN (ARRAY['apple', 'banana', 'cherry'])[2] ELSE NULL END",
                "description": "Uses a CASE statement and an array to return the N-th element.",
                "examples": [
                    "SELECT CASE WHEN 2 > 0 AND 2 <= array_length(ARRAY['apple', 'banana', 'cherry'], 1) THEN (ARRAY['apple', 'banana', 'cherry'])[2] ELSE NULL END;  -- Returns 'banana'",
                    "SELECT CASE WHEN 1 > 0 AND 1 <= array_length(ARRAY['red', 'green', 'blue'], 1) THEN (ARRAY['red', 'green', 'blue'])[1] ELSE NULL END;  -- Returns 'red'",
                    "SELECT CASE WHEN 3 > 0 AND 3 <= array_length(ARRAY['dog', 'cat', 'bird'], 1) THEN (ARRAY['dog', 'cat', 'bird'])[3] ELSE NULL END;  -- Returns 'bird'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(id, int, PRI)\n",
            "Table: `t2`\nColumns:\n(id, int, PRI)\n(val, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(id, integer, )\n",
            "Table: `t2`\nColumns:\n(id, integer, PRI)\n(val, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_68_3",
        "database_name": "postgresql_68_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT CONCAT('\"',CONCAT_WS('\";\"',title,prio,category,program,bugdesc,created,modified,bugstatus,submitter),'\"') FROM t1; -- CONCAT, CONCAT_WS",
        "target_query": "SELECT '\"'||concat_ws('\";\"',title,prio,category,program,bugdesc,created,modified,bugstatus,submitter)||'\"' FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT",
            "CONCAT_WS"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            },
            {
                "expression": "CONCAT_WS(separator, str1, str2, ...)",
                "description": "Concatenates multiple strings with the specified separator. If any argument is NULL, it is ignored.",
                "examples": [
                    "SELECT CONCAT_WS(',', 'apple', 'banana', 'cherry');",
                    "SELECT CONCAT_WS('-', 'hello', 'world');",
                    "SELECT CONCAT_WS(' ', 'this', NULL, 'is', 'a', 'test');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            },
            {
                "expression": "concat_ws(separator, str1, str2, ...)",
                "description": "Concatenates strings with a separator, ignoring NULL values.",
                "examples": [
                    "SELECT concat_ws(',', 'apple', 'banana', 'cherry');",
                    "SELECT concat_ws('-', 'hello', 'world');",
                    "SELECT concat_ws(' ', 'this', NULL, 'is', 'a', 'test');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(id, int, )\n(title, varchar(255), )\n(prio, int, )\n(category, int, )\n(program, int, )\n(bugdesc, text, )\n(created, datetime, )\n(modified, timestamp, )\n(bugstatus, int, )\n(submitter, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(id, integer, )\n(title, character varying(255), )\n(prio, integer, )\n(category, integer, )\n(program, integer, )\n(bugdesc, text, )\n(created, timestamp without time zone, )\n(modified, timestamp without time zone, )\n(bugstatus, integer, )\n(submitter, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_68_4",
        "database_name": "postgresql_68_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT CONCAT('\"',CONCAT_WS('\";\"',title,prio,category,program,bugstatus,submitter),'\"') FROM t1; -- CONCAT, CONCAT_WS",
        "target_query": "SELECT '\"'||concat_ws('\";\"',title,prio,category,program,bugstatus,submitter)||'\"' FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT",
            "CONCAT_WS"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            },
            {
                "expression": "CONCAT_WS(separator, str1, str2, ...)",
                "description": "Concatenates multiple strings with the specified separator. If any argument is NULL, it is ignored.",
                "examples": [
                    "SELECT CONCAT_WS(',', 'apple', 'banana', 'cherry');",
                    "SELECT CONCAT_WS('-', 'hello', 'world');",
                    "SELECT CONCAT_WS(' ', 'this', NULL, 'is', 'a', 'test');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            },
            {
                "expression": "concat_ws(separator, str1, str2, ...)",
                "description": "Concatenates strings with a separator, ignoring NULL values.",
                "examples": [
                    "SELECT concat_ws(',', 'apple', 'banana', 'cherry');",
                    "SELECT concat_ws('-', 'hello', 'world');",
                    "SELECT concat_ws(' ', 'this', NULL, 'is', 'a', 'test');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(id, int, )\n(title, varchar(255), )\n(prio, int, )\n(category, int, )\n(program, int, )\n(bugdesc, text, )\n(created, datetime, )\n(modified, timestamp, )\n(bugstatus, int, )\n(submitter, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(id, integer, )\n(title, character varying(255), )\n(prio, integer, )\n(category, integer, )\n(program, integer, )\n(bugdesc, text, )\n(created, timestamp without time zone, )\n(modified, timestamp without time zone, )\n(bugstatus, integer, )\n(submitter, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_68_5",
        "database_name": "postgresql_68_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT CONCAT_WS('\";\"',title,prio,category,program,bugdesc,created,modified,bugstatus,submitter) FROM t1; -- CONCAT_WS",
        "target_query": "SELECT concat_ws('\";\"',title,prio,category,program,bugdesc,created,modified,bugstatus,submitter) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT_WS"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT_WS(separator, str1, str2, ...)",
                "description": "Concatenates multiple strings with the specified separator. If any argument is NULL, it is ignored.",
                "examples": [
                    "SELECT CONCAT_WS(',', 'apple', 'banana', 'cherry');",
                    "SELECT CONCAT_WS('-', 'hello', 'world');",
                    "SELECT CONCAT_WS(' ', 'this', NULL, 'is', 'a', 'test');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "concat_ws(separator, str1, str2, ...)",
                "description": "Concatenates strings with a separator, ignoring NULL values.",
                "examples": [
                    "SELECT concat_ws(',', 'apple', 'banana', 'cherry');",
                    "SELECT concat_ws('-', 'hello', 'world');",
                    "SELECT concat_ws(' ', 'this', NULL, 'is', 'a', 'test');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(id, int, )\n(title, varchar(255), )\n(prio, int, )\n(category, int, )\n(program, int, )\n(bugdesc, text, )\n(created, datetime, )\n(modified, timestamp, )\n(bugstatus, int, )\n(submitter, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(id, integer, )\n(title, character varying(255), )\n(prio, integer, )\n(category, integer, )\n(program, integer, )\n(bugdesc, text, )\n(created, timestamp without time zone, )\n(modified, timestamp without time zone, )\n(bugstatus, integer, )\n(submitter, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_68_10",
        "database_name": "postgresql_68_10",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT CONCAT(\"</a>\",RPAD(\"\",(55-LENGTH(title)),\".\")) from t1; -- CONCAT, RPAD, LENGTH",
        "target_query": "SELECT '</a>'||RPAD('',(55-octet_length(title)),'.') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT",
            "RPAD",
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            },
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            },
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates multiple strings using either the || operator or the built-in CONCAT() function (from version 9.1 onwards). Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT name || '_' || id FROM users;"
                ]
            },
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "PostgreSQL doesn't have a native RPAD, but can simulate it.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::text, 5, '0');"
                ]
            },
            {
                "expression": "octet_length(str)",
                "description": "Returns the number of bytes in a string. Use this instead of 'length()' to replicate MySQL's LENGTH() behavior.",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(title, text, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(title, text, )\n"
        ]
    },
    {
        "sql_id": "postgresql_69_0",
        "database_name": "postgresql_69_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select 0=0,1>0,1>=1,1<0,1<=0,1!=0,strcmp(\"abc\",\"abcd\"),strcmp(\"b\",\"a\"),strcmp(\"a\",\"a\") ; -- STRCMP",
        "target_query": "SELECT 0=0, 1>0, 1>=1, 1<0, 1<=0, 1!=0, CASE WHEN 'abc' = 'abcd' THEN 0 WHEN 'abc' < 'abcd' THEN -1 ELSE 1 END, CASE WHEN 'b' = 'a' THEN 0 WHEN 'b' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'a' = 'a' THEN 0 WHEN 'a' < 'a' THEN -1 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "STRCMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "PostgreSQL does not have a direct STRCMP function. The equivalent behavior can be achieved using a CASE statement to compare two strings lexicographically and return -1, 0, or 1 based on the comparison.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_69_4",
        "database_name": "postgresql_69_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT GREATEST(d,d) FROM t1 WHERE k=2; -- GREATEST",
        "target_query": "SELECT GREATEST(d, d) FROM t1 WHERE k=2;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GREATEST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(d, varchar(6), )\n(k, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(d, character varying(6), )\n(k, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_69_6",
        "database_name": "postgresql_69_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select (12 mod 1) <=> null  as 'col'; -- MOD",
        "target_query": "SELECT (12 % 1) IS NULL AS col;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MOD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MOD(N, M) \u6216 N % M",
                "description": "Returns the remainder of N divided by M. Returns NULL if M = 0.",
                "examples": [
                    "SELECT MOD(10, 3);",
                    "SELECT 10 % 3;",
                    "SELECT MOD(5, 0);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "MOD(N, M) \u6216 N % M",
                "description": "Computes the remainder of N divided by M.",
                "examples": [
                    "SELECT MOD(9, 4);",
                    "SELECT 9 % 4;",
                    "SELECT MOD(5, 0);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_69_7",
        "database_name": "postgresql_69_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select (12 mod 1) is null   as 'col'; -- MOD",
        "target_query": "SELECT (12 % 1) IS NULL AS col;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MOD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MOD(N, M) \u6216 N % M",
                "description": "Returns the remainder of N divided by M. Returns NULL if M = 0.",
                "examples": [
                    "SELECT MOD(10, 3);",
                    "SELECT 10 % 3;",
                    "SELECT MOD(5, 0);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "MOD(N, M) \u6216 N % M",
                "description": "Computes the remainder of N divided by M.",
                "examples": [
                    "SELECT MOD(9, 4);",
                    "SELECT 9 % 4;",
                    "SELECT MOD(5, 0);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_69_8",
        "database_name": "postgresql_69_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select mod(12.0, 1)         as 'col'; -- MOD",
        "target_query": "SELECT MOD(12.0, 1) AS col;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MOD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MOD(N, M) \u6216 N % M",
                "description": "Returns the remainder of N divided by M. Returns NULL if M = 0.",
                "examples": [
                    "SELECT MOD(10, 3);",
                    "SELECT 10 % 3;",
                    "SELECT MOD(5, 0);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "MOD(N, M) \u6216 N % M",
                "description": "Computes the remainder of N divided by M.",
                "examples": [
                    "SELECT MOD(9, 4);",
                    "SELECT 9 % 4;",
                    "SELECT MOD(5, 0);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_69_9",
        "database_name": "postgresql_69_9",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "select mod(12, 1.0)         as 'col'; -- MOD",
        "target_query": "SELECT MOD(12, 1.0) AS col;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MOD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MOD(N, M) \u6216 N % M",
                "description": "Returns the remainder of N divided by M. Returns NULL if M = 0.",
                "examples": [
                    "SELECT MOD(10, 3);",
                    "SELECT 10 % 3;",
                    "SELECT MOD(5, 0);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "MOD(N, M) \u6216 N % M",
                "description": "Computes the remainder of N divided by M.",
                "examples": [
                    "SELECT MOD(9, 4);",
                    "SELECT 9 % 4;",
                    "SELECT MOD(5, 0);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_69_10",
        "database_name": "postgresql_69_10",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT greatest( 123456789 , 234567890 ) as g; -- GREATEST",
        "target_query": "SELECT GREATEST(123456789, 234567890) AS g;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GREATEST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_69_11",
        "database_name": "postgresql_69_11",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT least   ( 123456789 , 234567890 ) as l; -- LEAST",
        "target_query": "SELECT LEAST(123456789, 234567890) AS l;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LEAST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest non-null value among its arguments. NULL values are ignored unless all values are NULL.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_69_12",
        "database_name": "postgresql_69_12",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT greatest (123456789, -1, 234567890 ) as g; -- GREATEST",
        "target_query": "SELECT GREATEST(123456789, -1, 234567890) AS g;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GREATEST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_69_13",
        "database_name": "postgresql_69_13",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT least    (123456789, -1, 234567890 ) as l; -- LEAST",
        "target_query": "SELECT LEAST(123456789, -1, 234567890) AS l;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LEAST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest non-null value among its arguments. NULL values are ignored unless all values are NULL.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_69_14",
        "database_name": "postgresql_69_14",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "CREATE TABLE t1 AS SELECT greatest(-1, 123456789); -- GREATEST",
        "target_query": "CREATE TABLE t1 AS SELECT GREATEST(-1, 123456789);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GREATEST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [
            "CREATE TABLE t1 AS SELECT greatest(-1, 123456789); -- GREATEST"
        ],
        "target_related_schemas": [
            "CREATE TABLE t1 AS SELECT GREATEST(-1, 123456789);"
        ]
    },
    {
        "sql_id": "postgresql_70_0",
        "database_name": "postgresql_70_0",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT GREATEST('11', '5', '2'); -- GREATEST",
        "target_query": "SELECT GREATEST('11', '5', '2');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GREATEST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_70_1",
        "database_name": "postgresql_70_1",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT GREATEST('11', 5, 2); -- GREATEST",
        "target_query": "SELECT GREATEST('11', 5, 2);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GREATEST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_70_2",
        "database_name": "postgresql_70_2",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT GREATEST(11, 5, 2); -- GREATEST",
        "target_query": "SELECT GREATEST(11, 5, 2);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GREATEST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_70_3",
        "database_name": "postgresql_70_3",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT LEAST('11', '5', '2'); -- LEAST",
        "target_query": "SELECT LEAST('11', '5', '2');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LEAST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest non-null value among its arguments. NULL values are ignored unless all values are NULL.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_70_4",
        "database_name": "postgresql_70_4",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT LEAST('11', 5, 2); -- LEAST",
        "target_query": "SELECT LEAST('11', 5, 2);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LEAST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest non-null value among its arguments. NULL values are ignored unless all values are NULL.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_70_5",
        "database_name": "postgresql_70_5",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT LEAST(11, 5, 2); -- LEAST",
        "target_query": "SELECT LEAST(11, 5, 2);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LEAST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest non-null value among its arguments. NULL values are ignored unless all values are NULL.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_70_6",
        "database_name": "postgresql_70_6",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT GREATEST('11', '5', '2') + 0; -- GREATEST",
        "target_query": "SELECT GREATEST('11', '5', '2')::INTEGER + 0 ;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GREATEST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_70_7",
        "database_name": "postgresql_70_7",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT GREATEST('11', 5, 2) + 0; -- GREATEST",
        "target_query": "SELECT GREATEST('11', 5, 2)::INTEGER + 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GREATEST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_70_8",
        "database_name": "postgresql_70_8",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT GREATEST(11, 5, 2) + 0; -- GREATEST",
        "target_query": "SELECT GREATEST(11, 5, 2)::INTEGER + 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GREATEST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_70_9",
        "database_name": "postgresql_70_9",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT GREATEST('11', '5', '2') + 0.00; -- GREATEST",
        "target_query": "SELECT GREATEST('11', '5', '2')::INTEGER + 0.00;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GREATEST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_70_10",
        "database_name": "postgresql_70_10",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT GREATEST('11', 5, 2) + 0.00; -- GREATEST",
        "target_query": "SELECT GREATEST('11', 5, 2)::INTEGER + 0.00;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GREATEST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_70_11",
        "database_name": "postgresql_70_11",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT GREATEST(11, 5, 2) + 0.00; -- GREATEST",
        "target_query": "SELECT GREATEST(11, 5, 2)::INTEGER + 0.00;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GREATEST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "postgresql_70_15",
        "database_name": "postgresql_70_15",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT greatest(18446744073709551615, NULL)FROM t0017; -- GREATEST",
        "target_query": "SELECT GREATEST(18446744073709551615, NULL) FROM t0017;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GREATEST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t0017`\nColumns:\n(c0002, bigint, )\n"
        ],
        "target_related_schemas": [
            "Table: `t0017`\nColumns:\n(c0002, bigint, )\n"
        ]
    },
    {
        "sql_id": "postgresql_70_20",
        "database_name": "postgresql_70_20",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT * FROM t1 WHERE (GREATEST(c1, c2) = 42) AND (c2 = 1); -- GREATEST",
        "target_query": "SELECT * FROM t1 WHERE (GREATEST(c1, c2) = 42) AND (c2 = 1);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GREATEST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, int, )\n(c2, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, integer, )\n(c2, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_70_27",
        "database_name": "postgresql_70_27",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT SUM(LEAST(a, b)) FROM t1; -- LEAST",
        "target_query": "SELECT SUM(LEAST(a, b)) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LEAST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest non-null value among its arguments. NULL values are ignored unless all values are NULL.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, double, )\n(b, double, )\n",
            "Table: `t2`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, double precision, )\n(b, double precision, )\n",
            "Table: `t2`\nColumns:\n(a, integer, )\n(b, integer, )\n"
        ]
    },
    {
        "sql_id": "postgresql_70_28",
        "database_name": "postgresql_70_28",
        "source_dialect": "mysql",
        "target_dialect": "postgresql",
        "source_query": "SELECT SUM(LEAST(a, b)) FROM t2; -- LEAST",
        "target_query": "SELECT SUM(LEAST(a, b)) FROM t2;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LEAST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest non-null value among its arguments. NULL values are ignored unless all values are NULL.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, double, )\n(b, double, )\n",
            "Table: `t2`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, double precision, )\n(b, double precision, )\n",
            "Table: `t2`\nColumns:\n(a, integer, )\n(b, integer, )\n"
        ]
    }
]