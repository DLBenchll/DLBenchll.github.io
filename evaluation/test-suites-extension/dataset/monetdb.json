[
  {
    "sql_id": "monetdb_100_7",
    "database_name": "monetdb_100_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT TIMESTAMP( '2001-01-01 00:00:00' ); -- TIMESTAMP",
    "target_query": "SELECT CAST('2001-01-01 00:00:00' AS TIMESTAMP);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
        "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
        "examples": [
          "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CAST('2023-06-15 10:30:45' AS TIMESTAMP)",
        "description": "MonetDB uses CAST to convert a date-time string to a TIMESTAMP value.",
        "examples": [
          "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP);",
          "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP);",
          "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP) > CAST('2023-06-14 10:30:45' AS TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_100_10",
    "database_name": "monetdb_100_10",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT DATEDIFF( '2007-12-31 23:59:59', '2007-12-30  00:00:00' ); -- DATEDIFF",
    "target_query": "SELECT DATE '2007-12-31 23:59:59' - DATE '2007-12-30 00:00:00';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATEDIFF(date1, date2)",
        "description": "Returns the number of days between two date or datetime expressions (date1 - date2), ignoring time part.",
        "examples": [
          "SELECT DATEDIFF('2025-12-31', '2025-12-01');",
          "SELECT DATEDIFF('2025-01-01', '2024-12-31');",
          "SELECT DATEDIFF(NULL, '2025-01-01');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "date1 - date2",
        "description": "Subtracting one DATE from another returns the day difference as an integer.",
        "examples": [
          "SELECT DATE '2025-12-31' - DATE '2025-12-01';",
          "SELECT DATE '2025-01-01' - DATE '2024-12-31';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_100_11",
    "database_name": "monetdb_100_11",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT TIMEDIFF( '2000:01:01 00:00:00','2000:01:01 00:00:00' ); -- TIMEDIFF",
    "target_query": "SELECT EXTRACT(EPOCH FROM timestamp '2000-01-01 00:00:00' - timestamp '2000-01-01 00:00:00');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')",
        "description": "MonetDB does not have a TIMEDIFF function but supports using EXTRACT to calculate the time difference in seconds.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');",
          "SELECT EXTRACT(EPOCH FROM NOW() - timestamp '2023-06-15 10:00:00');",
          "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_100_12",
    "database_name": "monetdb_100_12",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT DATE_FORMAT( '2009-10-10 23:59:59', '%W %M %Y' ); -- DATE_FORMAT",
    "target_query": "SELECT sys.timestamp_to_str(TIMESTAMP '2009-10-10 23:59:59', 'W MM YYYY');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
        "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
        "examples": [
          "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_100_13",
    "database_name": "monetdb_100_13",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT TIME( '2003-12-31 23:59:59' ); -- TIME",
    "target_query": "SELECT sys.time_to_str(TIMESTAMP '2003-12-31 23:59:59', '%H:%M:%S');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
        "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
        "examples": [
          "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
          "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "sys.time_to_str(time-value, format)",
        "description": "In MonetDB, the TIME function from SQLite can be emulated using sys.time_to_str to format TIME values as strings in the format 'HH:MM:SS' or 'HH:MM:SS.SSS'. Time arithmetic can be performed using sql_add with INTERVAL expressions.",
        "examples": [
          "SELECT sys.time_to_str(CURRENT_TIME, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
          "SELECT sys.time_to_str(sql_add(CURRENT_TIME, interval '1' hour), '%H:%M:%S'); -- Returns the time one hour after the current time.",
          "SELECT sys.time_to_str(time '14:16:00', '%H:%M:%S.000'); -- Returns '14:16:00.000' with milliseconds."
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_100_15",
    "database_name": "monetdb_100_15",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT TIMESTAMPADD(MINUTE, 1, '2003-01-02 23:59:59' ); -- TIMESTAMPADD",
    "target_query": "SELECT TIMESTAMP '2003-01-02 23:59:59' + INTERVAL '1' MINUTE;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMPADD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMPADD(unit, interval, datetime_expr)",
        "description": "Adds a time interval to a date or timestamp expression using the specified unit.",
        "examples": [
          "SELECT TIMESTAMPADD(DAY, 2, '2023-01-01');",
          "SELECT TIMESTAMPADD(MINUTE, -5, '2023-05-10 12:00:00');",
          "SELECT TIMESTAMPADD(YEAR, 1, '2020-06-15');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "datetime_expr + INTERVAL 'n' unit",
        "description": "Adds a time interval to a timestamp or date using SQL standard INTERVAL syntax with integer value and time unit.",
        "examples": [
          "SELECT DATE '2023-01-01' + INTERVAL '2' DAY;",
          "SELECT TIMESTAMP '2023-05-10 12:00:00' + INTERVAL '-5' MINUTE;",
          "SELECT DATE '2020-06-15' + INTERVAL '1' YEAR;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_100_16",
    "database_name": "monetdb_100_16",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT TIMESTAMPDIFF(MONTH, '2003-02-01 23:59:59', '2003-05-01' ); -- TIMESTAMPDIFF",
    "target_query": "SELECT CAST(DATE '2003-05-01' AS DATE) - CAST(DATE '2003-02-01 23:59:59' AS DATE);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMPDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMPDIFF(unit, datetime1, datetime2)",
        "description": "Returns the difference between two datetime values in the specified unit.",
        "examples": [
          "SELECT TIMESTAMPDIFF(YEAR, '2001-01-01', '2005-01-01');  -- 4",
          "SELECT TIMESTAMPDIFF(MONTH, '2020-01-01', '2020-03-01');  -- 2",
          "SELECT TIMESTAMPDIFF(DAY, '2020-01-01', '2020-01-31');    -- 30"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CAST(end_date AS DATE) - CAST(start_date AS DATE)",
        "description": "MonetDB calculates the difference between two dates using UNIX timestamps (seconds since '1970-01-01 00:00:00'). The result is returned in seconds. For example, the difference between '2005-01-01' and '2001-01-01' in MonetDB is calculated in seconds, and this must be converted manually into days, months, or years by further calculations.",
        "examples": [
          "SELECT CAST(DATE '2005-01-01' AS DATE) - CAST(DATE '2001-01-01' AS DATE);  -- 126230400 seconds"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_100_17",
    "database_name": "monetdb_100_17",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT TO_SECONDS( '2009-11-29 23:59:59' ); -- TO_SECONDS",
    "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2009-11-29 23:59:59') + 62167219200;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TO_SECONDS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TO_SECONDS(datetime_expr)",
        "description": "Returns the number of seconds since year 0 to the given datetime.",
        "examples": [
          "SELECT TO_SECONDS('2000-01-01 00:00:00');",
          "SELECT TO_SECONDS(NOW());",
          "SELECT TO_SECONDS(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM ts) + 62167219200",
        "description": "Converts timestamp to the number of seconds since the year 0 by extracting the Unix epoch and adding the seconds from year 0 to 1970.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2020-12-31 12:00:00') + 62167219200;",
          "SELECT EXTRACT(EPOCH FROM NOW()) + 62167219200;",
          "SELECT CASE WHEN NULL IS NULL THEN NULL ELSE EXTRACT(EPOCH FROM NULL) + 62167219200 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_101_7",
    "database_name": "monetdb_101_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select length(concat('*',s1,'*',s2,'*')) from t1; -- LENGTH, CONCAT",
    "target_query": "select octet_length('*' || s1 || '*' || s2 || '*') from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH",
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      },
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      },
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (s1 blob, s2 blob);"
    ],
    "target_related_schemas": [
      "create table t1 (s1 blob, s2 blob);"
    ]
  },
  {
    "sql_id": "monetdb_101_12",
    "database_name": "monetdb_101_12",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select convert(123456789,unsigned); -- CONVERT",
    "target_query": "select CAST(123456789 AS BIGINT);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONVERT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONVERT(expression USING charset)",
        "description": "Converts data types or changes the character set.",
        "examples": [
          "SELECT CONVERT('Hello World' USING utf8);",
          "SELECT CONVERT(1234, CHAR);",
          "SELECT CONVERT(column_name USING latin1) FROM my_table;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CAST(expression AS target_type)",
        "description": "MonetDB uses CAST for type conversion. No direct equivalent for CONVERT TO CHARACTER SET.",
        "examples": [
          "SELECT CAST('Hello World' AS TEXT);",
          "SELECT CAST(1234 AS VARCHAR);",
          "SELECT CAST(column_name AS TEXT) FROM my_table;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_102_2",
    "database_name": "monetdb_102_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 VALUES (DATE(NOW()), 1); -- DATE, NOW",
    "target_query": "INSERT INTO t1 VALUES (CAST(CURRENT_TIMESTAMP AS DATE), 1);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE",
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE()",
        "description": "In MySQL, the DATE function extracts the date part from a DATETIME or TIMESTAMP value.",
        "examples": [
          "SELECT DATE('2023-05-01 12:34:56') AS result;",
          "SELECT DATE(NOW()) AS current_date_result;",
          "SELECT DATE(CAST('2023-05-01' AS DATETIME)) AS date_from_datetime;"
        ]
      },
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CAST()",
        "description": "MonetDB uses the CAST function to extract a DATE from a DATETIME or TIMESTAMP.",
        "examples": [
          "SELECT CAST('2023-05-01 12:34:56' AS DATE) AS result;",
          "SELECT CAST(NOW() AS DATE) AS current_date_result;",
          "SELECT CAST('2023-05-01' AS DATE) AS date_from_datetime;"
        ]
      },
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT);"
    ]
  },
  {
    "sql_id": "monetdb_102_3",
    "database_name": "monetdb_102_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT COUNT(*) FROM t1 WHERE a = NOW(); -- COUNT, NOW",
    "target_query": "SELECT COUNT(*) FROM t1 WHERE a = CURRENT_TIMESTAMP;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COUNT",
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN FORMAT=TREE SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      },
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      },
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT);"
    ]
  },
  {
    "sql_id": "monetdb_102_4",
    "database_name": "monetdb_102_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 VALUES (DATE(NOW()), 2); -- DATE, NOW",
    "target_query": "INSERT INTO t1 VALUES (CAST(CURRENT_TIMESTAMP AS DATE), 2);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE",
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE()",
        "description": "In MySQL, the DATE function extracts the date part from a DATETIME or TIMESTAMP value.",
        "examples": [
          "SELECT DATE('2023-05-01 12:34:56') AS result;",
          "SELECT DATE(NOW()) AS current_date_result;",
          "SELECT DATE(CAST('2023-05-01' AS DATETIME)) AS date_from_datetime;"
        ]
      },
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CAST()",
        "description": "MonetDB uses the CAST function to extract a DATE from a DATETIME or TIMESTAMP.",
        "examples": [
          "SELECT CAST('2023-05-01 12:34:56' AS DATE) AS result;",
          "SELECT CAST(NOW() AS DATE) AS current_date_result;",
          "SELECT CAST('2023-05-01' AS DATE) AS date_from_datetime;"
        ]
      },
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT);"
    ]
  },
  {
    "sql_id": "monetdb_102_5",
    "database_name": "monetdb_102_5",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT COUNT(*) FROM t1 WHERE a = NOW(); -- COUNT, NOW",
    "target_query": "SELECT COUNT(*) FROM t1 WHERE a = CURRENT_TIMESTAMP;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COUNT",
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN FORMAT=TREE SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      },
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      },
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT);"
    ]
  },
  {
    "sql_id": "monetdb_102_6",
    "database_name": "monetdb_102_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT COUNT(*) FROM t1 WHERE a = NOW() AND b = 1; -- COUNT, NOW",
    "target_query": "SELECT COUNT(*) FROM t1 WHERE a = CURRENT_TIMESTAMP AND b = 1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COUNT",
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN FORMAT=TREE SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      },
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      },
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT);"
    ]
  },
  {
    "sql_id": "monetdb_102_8",
    "database_name": "monetdb_102_8",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "CREATE TABLE t1 SELECT curdate() AS f1; -- CURDATE",
    "target_query": "CREATE TABLE t1 AS SELECT current_date AS f1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CURDATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CURDATE()",
        "description": "Returns the current date without the time component.",
        "examples": [
          "SELECT CURDATE();",
          "SELECT CONCAT('Today\\'s date is: ', CURDATE());",
          "SELECT 1 WHERE CURDATE() = CURDATE();"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "current_date",
        "description": "Returns the current date without the time component, equivalent to MySQL's CURDATE().",
        "examples": [
          "SELECT current_date;",
          "SELECT CONCAT('Today\\'s date is: ', current_date);",
          "SELECT 1 WHERE current_date = current_date;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 SELECT curdate() AS f1; -- CURDATE"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 AS SELECT current_date AS f1;"
    ]
  },
  {
    "sql_id": "monetdb_102_9",
    "database_name": "monetdb_102_9",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT hour(f1), minute(f1), second(f1) FROM t1; -- HOUR, MINUTE, SECOND",
    "target_query": "SELECT EXTRACT(HOUR FROM f1), \"minute\"(f1), EXTRACT(SECOND FROM f1) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HOUR",
      "MINUTE",
      "SECOND"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HOUR(expr)",
        "description": "Extracts the hour (0–23) from a time or datetime expression.",
        "examples": [
          "SELECT HOUR('18:45:30');",
          "SELECT HOUR('2023-10-01 08:15:00');",
          "SELECT HOUR(CURRENT_TIMESTAMP);"
        ]
      },
      {
        "expression": "MINUTE()",
        "description": "Extracts the minute part from a time or datetime value.",
        "examples": [
          "SELECT MINUTE('12:34:56');",
          "SELECT MINUTE('2025-01-01 10:30:00');",
          "SELECT MINUTE(NULL);"
        ]
      },
      {
        "expression": "SECOND(time)",
        "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
        "examples": [
          "SELECT SECOND('10:11:12');",
          "SELECT SECOND(4.99999999991e0);",
          "SELECT SECOND(CAST('2007-07-19' AS DATE));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(HOUR FROM expr)",
        "description": "Returns the hour component of a time or timestamp expression.",
        "examples": [
          "SELECT EXTRACT(HOUR FROM TIME '18:45:30');",
          "SELECT EXTRACT(HOUR FROM TIMESTAMP '2023-10-01 08:15:00');",
          "SELECT EXTRACT(HOUR FROM CURRENT_TIMESTAMP);"
        ]
      },
      {
        "expression": "\"minute\"()",
        "description": "Extracts the minute part from a time or timestamp value. In MonetDB, the function is used with the input explicitly cast to either `time` or `timestamp`.",
        "examples": [
          "SELECT \"minute\"(time '12:34:56');",
          "SELECT \"minute\"(timestamp '2025-01-01 10:30:00');",
          "SELECT \"minute\"(NULL);"
        ]
      },
      {
        "expression": "EXTRACT(SECOND FROM time)",
        "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
        "examples": [
          "SELECT EXTRACT(SECOND FROM TIME '10:11:12');",
          "SELECT EXTRACT(SECOND FROM CAST('2007-07-19' AS DATE));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 SELECT curdate() AS f1; -- CURDATE"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 AS SELECT current_date AS f1;"
    ]
  },
  {
    "sql_id": "monetdb_102_18",
    "database_name": "monetdb_102_18",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT 1 FROM (SELECT MAKEDATE(2011,0)) a; -- MAKEDATE",
    "target_query": "SELECT 1 FROM (SELECT DATE '2011-01-01' + INTERVAL '-1' DAY) a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKEDATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKEDATE(year, day_of_year)",
        "description": "Returns a date from the given year and day of the year.",
        "examples": [
          "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
          "SELECT MAKEDATE(2025, 100) AS specific_date;",
          "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "DATE 'year-01-01' + INTERVAL 'day_of_year - 1' DAY",
        "description": "Returns a date from the given year and day of the year by adding interval days to January 1st.",
        "examples": [
          "SELECT DATE '2009-01-01' AS first_day_of_year;",
          "SELECT DATE '2025-01-01' + INTERVAL '99' DAY AS specific_date;",
          "SELECT DATE '2020-01-01' + INTERVAL '365' DAY AS last_day_of_year;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_2_2",
    "database_name": "monetdb_2_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "WITH recursive qn as (select 1 as n, cast('x' as char(100)) as un union all select 1+n, concat(un,'x') from qn where n<10) select * from qn; -- CONCAT",
    "target_query": "WITH recursive qn as (select 1 as n, cast('x' as char(100)) as un union all select 1+n, un || 'x' from qn where n<10) select * from qn; -- CONCAT",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t(c char(3), vc varchar(3), b binary(3), vb varbinary(3));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t(c VARCHAR, vc VARCHAR, b BLOB, vb BLOB);"
    ]
  },
  {
    "sql_id": "monetdb_3_2",
    "database_name": "monetdb_3_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT IF (COUNT(*) > 0, \"YES\", \"NO\") AS \"IMPLICIT COMMIT\" FROM trans; -- IF",
    "target_query": "SELECT CASE WHEN COUNT(*) > 0 THEN 'YES' ELSE 'NO' END AS \"IMPLICIT COMMIT\" FROM trans; -- CASE WHEN",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE trans (a INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE trans (a INT);"
    ]
  },
  {
    "sql_id": "monetdb_4_4",
    "database_name": "monetdb_4_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775807 AND TRIM(a) = b; -- TRIM",
    "target_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775807 AND TRIM(CAST(a AS VARCHAR)) = b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TRIM"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "MonetDB's TRIM function operates the same way as in MySQL and other databases. It removes unwanted characters from the start and/or end of a string.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (id INT AUTO_INCREMENT PRIMARY KEY,a BIGINT(20) UNSIGNED,b VARCHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id SERIAL, a BIGINT, b VARCHAR(20));"
    ]
  },
  {
    "sql_id": "monetdb_4_5",
    "database_name": "monetdb_4_5",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775806 AND TRIM(a) = b; -- TRIM",
    "target_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775806 AND TRIM(CAST(a AS VARCHAR)) = b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TRIM"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "MonetDB's TRIM function operates the same way as in MySQL and other databases. It removes unwanted characters from the start and/or end of a string.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (id INT AUTO_INCREMENT PRIMARY KEY,a BIGINT(20) UNSIGNED,b VARCHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id SERIAL, a BIGINT, b VARCHAR(20));"
    ]
  },
  {
    "sql_id": "monetdb_4_6",
    "database_name": "monetdb_4_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775805 AND TRIM(a) = b; -- TRIM",
    "target_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775805 AND TRIM(CAST(a AS VARCHAR)) = b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TRIM"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "MonetDB's TRIM function operates the same way as in MySQL and other databases. It removes unwanted characters from the start and/or end of a string.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (id INT AUTO_INCREMENT PRIMARY KEY,a BIGINT(20) UNSIGNED,b VARCHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id SERIAL, a BIGINT, b VARCHAR(20));"
    ]
  },
  {
    "sql_id": "monetdb_4_7",
    "database_name": "monetdb_4_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 0 AND TRIM(a) = b; -- TRIM",
    "target_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 0 AND TRIM(CAST(a AS VARCHAR)) = b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TRIM"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "MonetDB's TRIM function operates the same way as in MySQL and other databases. It removes unwanted characters from the start and/or end of a string.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (id INT AUTO_INCREMENT PRIMARY KEY,a BIGINT(20) UNSIGNED,b VARCHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id SERIAL, a BIGINT, b VARCHAR(20));"
    ]
  },
  {
    "sql_id": "monetdb_4_11",
    "database_name": "monetdb_4_11",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT * FROM t1 WHERE coalesce(a) BETWEEN 0 and 0.9; -- COALESCE",
    "target_query": "SELECT * FROM t1 WHERE COALESCE(a, NULL) BETWEEN 0 AND 0.9;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...)",
        "description": "Standard SQL COALESCE function is supported.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a BIGINT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a BIGINT);"
    ]
  },
  {
    "sql_id": "monetdb_4_12",
    "database_name": "monetdb_4_12",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT * FROM t1 WHERE coalesce(a)=0.9; -- COALESCE",
    "target_query": "SELECT * FROM t1 WHERE COALESCE(a, NULL) = 0.9;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...)",
        "description": "Standard SQL COALESCE function is supported.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a BIGINT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a BIGINT);"
    ]
  },
  {
    "sql_id": "monetdb_4_13",
    "database_name": "monetdb_4_13",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT * FROM t1 WHERE coalesce(a) in (0.8,0.9); -- COALESCE",
    "target_query": "SELECT * FROM t1 WHERE COALESCE(a, NULL) IN (0.8, 0.9);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...)",
        "description": "Standard SQL COALESCE function is supported.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a BIGINT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a BIGINT);"
    ]
  },
  {
    "sql_id": "monetdb_6_5",
    "database_name": "monetdb_6_5",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "CREATE TABLE t1 SELECT repeat('a',4000) a; -- REPEAT",
    "target_query": "CREATE TABLE t1 AS SELECT REPEAT('a', 4000) AS a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 SELECT repeat('a',4000) a; -- REPEAT"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 AS SELECT REPEAT('a', 4000) AS a;"
    ]
  },
  {
    "sql_id": "monetdb_6_12",
    "database_name": "monetdb_6_12",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT",
    "target_query": "CREATE TABLE head AS SELECT b1.b || b2.b AS head FROM t1 b1, t1 b2; -- CONCAT",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT"
    ],
    "target_related_schemas": [
      "CREATE TABLE head AS SELECT b1.b || b2.b AS head FROM t1 b1, t1 b2; -- CONCAT"
    ]
  },
  {
    "sql_id": "monetdb_6_13",
    "database_name": "monetdb_6_13",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "CREATE TABLE tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2; -- CONCAT",
    "target_query": "CREATE TABLE tail AS SELECT b1.b || b2.b AS tail FROM t1 b1, t1 b2; -- CONCAT",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT",
      "CREATE TABLE tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2; -- CONCAT"
    ],
    "target_related_schemas": [
      "CREATE TABLE head AS SELECT b1.b || b2.b AS head FROM t1 b1, t1 b2; -- CONCAT",
      "CREATE TABLE tail AS SELECT b1.b || b2.b AS tail FROM t1 b1, t1 b2; -- CONCAT"
    ]
  },
  {
    "sql_id": "monetdb_6_19",
    "database_name": "monetdb_6_19",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT COUNT(*) FROM t1 WHERE a<>'' AND OCTET_LENGTH(a)=2; -- OCTET_LENGTH",
    "target_query": "SELECT COUNT(*) FROM t1 WHERE a<>'' AND LENGTH(a)=2; -- OCTET_LENGTH (MonetDB uses LENGTH instead of OCTET_LENGTH)",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "OCTET_LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "OCTET_LENGTH()",
        "description": "Returns the number of bytes in a string.",
        "examples": [
          "SELECT OCTET_LENGTH('Hello World');",
          "SELECT OCTET_LENGTH('Test String') = 11;",
          "SELECT CASE WHEN OCTET_LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LENGTH()",
        "description": "Returns the number of bytes in a string.",
        "examples": [
          "SELECT LENGTH('Hello World');",
          "SELECT LENGTH('Test String') = 11;",
          "SELECT CASE WHEN LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 AS SELECT '111111' AS code, ' ' AS a LIMIT 1;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 AS SELECT '111111' AS code, ' ' AS a LIMIT 1;"
    ]
  },
  {
    "sql_id": "monetdb_6_20",
    "database_name": "monetdb_6_20",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT * FROM t1 WHERE CHAR_LENGTH(a)=2; -- CHAR_LENGTH",
    "target_query": "SELECT * FROM t1 WHERE char_length(a)=2; -- CHAR_LENGTH",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CHAR_LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CHAR_LENGTH(expr)",
        "description": "Returns the number of characters in the string, not bytes.",
        "examples": [
          "SELECT CHAR_LENGTH('abc');",
          "SELECT CHAR_LENGTH('你好');",
          "SELECT CHAR_LENGTH('a你b好c');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "char_length(expr)",
        "description": "Returns the number of characters in a string (char_length and length are equivalent).",
        "examples": [
          "SELECT char_length('abc');",
          "SELECT char_length('你好');",
          "SELECT char_length('a你b好c');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 AS SELECT '111111' AS code, ' ' AS a LIMIT 1;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 AS SELECT '111111' AS code, ' ' AS a LIMIT 1;"
    ]
  },
  {
    "sql_id": "monetdb_6_21",
    "database_name": "monetdb_6_21",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT COUNT(*) FROM t1 WHERE a<>'' AND OCTET_LENGTH(a)=3; -- OCTET_LENGTH",
    "target_query": "SELECT COUNT(*) FROM t1 WHERE a<>'' AND LENGTH(a)=3; -- OCTET_LENGTH (MonetDB uses LENGTH instead of OCTET_LENGTH)",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "OCTET_LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "OCTET_LENGTH()",
        "description": "Returns the number of bytes in a string.",
        "examples": [
          "SELECT OCTET_LENGTH('Hello World');",
          "SELECT OCTET_LENGTH('Test String') = 11;",
          "SELECT CASE WHEN OCTET_LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LENGTH()",
        "description": "Returns the number of bytes in a string.",
        "examples": [
          "SELECT LENGTH('Hello World');",
          "SELECT LENGTH('Test String') = 11;",
          "SELECT CASE WHEN LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 AS SELECT '111111' AS code, ' ' AS a LIMIT 1;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 AS SELECT '111111' AS code, ' ' AS a LIMIT 1;"
    ]
  },
  {
    "sql_id": "monetdb_7_4",
    "database_name": "monetdb_7_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT c1, LENGTH(c1) FROM h; -- LENGTH",
    "target_query": "SELECT c1, octet_length(c1) FROM h; -- LENGTH",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ]
  },
  {
    "sql_id": "monetdb_7_5",
    "database_name": "monetdb_7_5",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT c1, LPAD(c1, 20, ' ') FROM h; -- LPAD",
    "target_query": "SELECT c1, CONCAT(REPEAT(' ', GREATEST(0, 20 - LENGTH(c1))), c1) FROM h;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
        "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
        "examples": [
          "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
          "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
          "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ]
  },
  {
    "sql_id": "monetdb_7_6",
    "database_name": "monetdb_7_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT c1, RPAD(c1, 20, '52') FROM h; -- RPAD",
    "target_query": "SELECT c1, RPAD(c1, 20, '52') FROM h; -- RPAD",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "MonetDB can simulate RPAD by concatenating strings.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ]
  },
  {
    "sql_id": "monetdb_7_9",
    "database_name": "monetdb_7_9",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT INSTR(c1, 'h') FROM h; -- INSTR",
    "target_query": "SELECT POSITION('h' in c1) FROM h; -- INSTR",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "INSTR(str, substr)",
        "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
        "examples": [
          "SELECT INSTR('foobar', 'bar');  -- Returns 4",
          "SELECT INSTR('foobar', 'baz');  -- Returns 0",
          "SELECT INSTR('foobar', '');     -- Returns 1",
          "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position(substr in str)",
        "description": "Returns the position of substr in str (1-based). Returns 0 if not found.",
        "examples": [
          "SELECT position('bar' in 'foobar');   -- Returns 4",
          "SELECT position('x' in 'abc');        -- Returns 0"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ]
  },
  {
    "sql_id": "monetdb_7_10",
    "database_name": "monetdb_7_10",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT INSTR(c1, '') FROM h; -- INSTR",
    "target_query": "SELECT POSITION('' in c1) FROM h; -- INSTR",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "INSTR(str, substr)",
        "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
        "examples": [
          "SELECT INSTR('foobar', 'bar');  -- Returns 4",
          "SELECT INSTR('foobar', 'baz');  -- Returns 0",
          "SELECT INSTR('foobar', '');     -- Returns 1",
          "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position(substr in str)",
        "description": "Returns the position of substr in str (1-based). Returns 0 if not found.",
        "examples": [
          "SELECT position('bar' in 'foobar');   -- Returns 4",
          "SELECT position('x' in 'abc');        -- Returns 0"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ]
  },
  {
    "sql_id": "monetdb_7_11",
    "database_name": "monetdb_7_11",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT INSTR(c1, '52') FROM h; -- INSTR",
    "target_query": "SELECT POSITION('52' in c1) FROM h; -- INSTR",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "INSTR(str, substr)",
        "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
        "examples": [
          "SELECT INSTR('foobar', 'bar');  -- Returns 4",
          "SELECT INSTR('foobar', 'baz');  -- Returns 0",
          "SELECT INSTR('foobar', '');     -- Returns 1",
          "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position(substr in str)",
        "description": "Returns the position of substr in str (1-based). Returns 0 if not found.",
        "examples": [
          "SELECT position('bar' in 'foobar');   -- Returns 4",
          "SELECT position('x' in 'abc');        -- Returns 0"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ]
  },
  {
    "sql_id": "monetdb_7_12",
    "database_name": "monetdb_7_12",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT INSTR(c1, '54') FROM h; -- INSTR",
    "target_query": "SELECT POSITION('54' in c1) FROM h; -- INSTR",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "INSTR(str, substr)",
        "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
        "examples": [
          "SELECT INSTR('foobar', 'bar');  -- Returns 4",
          "SELECT INSTR('foobar', 'baz');  -- Returns 0",
          "SELECT INSTR('foobar', '');     -- Returns 1",
          "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position(substr in str)",
        "description": "Returns the position of substr in str (1-based). Returns 0 if not found.",
        "examples": [
          "SELECT position('bar' in 'foobar');   -- Returns 4",
          "SELECT position('x' in 'abc');        -- Returns 0"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ]
  },
  {
    "sql_id": "monetdb_7_13",
    "database_name": "monetdb_7_13",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT INSTR(c1, '31') FROM h; -- INSTR",
    "target_query": "SELECT POSITION('31' in c1) FROM h; -- INSTR",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "INSTR(str, substr)",
        "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
        "examples": [
          "SELECT INSTR('foobar', 'bar');  -- Returns 4",
          "SELECT INSTR('foobar', 'baz');  -- Returns 0",
          "SELECT INSTR('foobar', '');     -- Returns 1",
          "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position(substr in str)",
        "description": "Returns the position of substr in str (1-based). Returns 0 if not found.",
        "examples": [
          "SELECT position('bar' in 'foobar');   -- Returns 4",
          "SELECT position('x' in 'abc');        -- Returns 0"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ]
  },
  {
    "sql_id": "monetdb_7_23",
    "database_name": "monetdb_7_23",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT c1, TRIM(c1) FROM h; -- TRIM",
    "target_query": "SELECT c1, TRIM(c1) FROM h; -- TRIM",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TRIM"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "MonetDB's TRIM function operates the same way as in MySQL and other databases. It removes unwanted characters from the start and/or end of a string.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ]
  },
  {
    "sql_id": "monetdb_71_0",
    "database_name": "monetdb_71_0",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select from_unixtime(123456789); -- FROM_UNIXTIME",
    "target_query": "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '123456789' SECOND;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FROM_UNIXTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
        "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
          "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '<seconds>' SECOND",
        "description": "Adds seconds to the UNIX epoch by using an INTERVAL expression with a string constant representing the number of seconds.",
        "examples": [
          "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000' SECOND;",
          "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000.987' SECOND;",
          "SELECT CAST(TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000' SECOND AS STRING);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_71_1",
    "database_name": "monetdb_71_1",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select from_unixtime(234567890); -- FROM_UNIXTIME",
    "target_query": "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '234567890' SECOND;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FROM_UNIXTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
        "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
          "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '<seconds>' SECOND",
        "description": "Adds seconds to the UNIX epoch by using an INTERVAL expression with a string constant representing the number of seconds.",
        "examples": [
          "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000' SECOND;",
          "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000.987' SECOND;",
          "SELECT CAST(TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000' SECOND AS STRING);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_71_2",
    "database_name": "monetdb_71_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select from_unixtime(1); -- FROM_UNIXTIME",
    "target_query": "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1' SECOND;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FROM_UNIXTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
        "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
          "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '<seconds>' SECOND",
        "description": "Adds seconds to the UNIX epoch by using an INTERVAL expression with a string constant representing the number of seconds.",
        "examples": [
          "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000' SECOND;",
          "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000.987' SECOND;",
          "SELECT CAST(TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000' SECOND AS STRING);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_72_4",
    "database_name": "monetdb_72_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "EXPLAIN SELECT * FROM t WHERE CONCAT(x,x) = 'XX'; -- CONCAT",
    "target_query": "EXPLAIN SELECT * FROM t WHERE x || x = 'XX';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t(x VARCHAR(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t(x VARCHAR(10));"
    ]
  },
  {
    "sql_id": "monetdb_74_2",
    "database_name": "monetdb_74_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "insert into t1(f1) select if(max(f1) is null, '2000',max(f1)) from t1; -- IF, MAX",
    "target_query": "insert into t1(f1) select CASE WHEN max(f1) is null THEN '2000' ELSE max(f1) END from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF",
      "MAX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      },
      {
        "expression": "MAX(expr)",
        "description": "Returns the maximum value of the expression in an aggregation context.",
        "examples": [
          "SELECT MAX(10), MAX(5), MAX(20);",
          "SELECT MAX('apple'), MAX('banana'), MAX('pear');",
          "SELECT MAX(ABS(-5)), MAX(ABS(3));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      },
      {
        "expression": "MAX(expr)",
        "description": "Aggregates the maximum value of the input expression.",
        "examples": [
          "SELECT MAX(2), MAX(4), MAX(8);",
          "SELECT MAX('lion'), MAX('tiger'), MAX('bear');",
          "SELECT MAX(sqrt(16)), MAX(sqrt(25));"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1(f1 varchar(5));"
    ],
    "target_related_schemas": [
      "create table t1(f1 varchar(5));"
    ]
  },
  {
    "sql_id": "monetdb_74_6",
    "database_name": "monetdb_74_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT (SELECT SUM(LENGTH(c)) FROM t1 WHERE c='13_characters') FROM t1; -- LENGTH",
    "target_query": "SELECT (SELECT SUM(octet_length(c)) FROM t1 WHERE c='13_characters') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (c VARCHAR(30));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c VARCHAR(30));"
    ]
  },
  {
    "sql_id": "monetdb_74_9",
    "database_name": "monetdb_74_9",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t2 (d)SELECT (SELECT SUM(LENGTH(c)) FROM t1 WHERE c='13_characters') FROM t1; -- LENGTH",
    "target_query": "INSERT INTO t2 (d)SELECT (SELECT SUM(octet_length(c)) FROM t1 WHERE c='13_characters') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 (d VARCHAR(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (d VARCHAR(10));"
    ]
  },
  {
    "sql_id": "monetdb_74_10",
    "database_name": "monetdb_74_10",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t2 (d)SELECT (SELECT SUM(LENGTH(c)) FROM t1 WHERE c='7_chars') FROM t1; -- LENGTH",
    "target_query": "INSERT INTO t2 (d)SELECT (SELECT SUM(octet_length(c)) FROM t1 WHERE c='7_chars') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 (d VARCHAR(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (d VARCHAR(10));"
    ]
  },
  {
    "sql_id": "monetdb_75_2",
    "database_name": "monetdb_75_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 VALUES('valid-string',1),(UNHEX('11'),2); -- UNHEX",
    "target_query": "INSERT INTO t1 VALUES('valid-string',1),(NULL,2);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNHEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNHEX(str)",
        "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT HEX(UNHEX('4D7953514C'));",
          "SELECT UNHEX('48656C6C6F');",
          "SELECT UNHEX(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "",
        "description": "",
        "examples": []
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (tx TEXT NULL,pk INTEGER PRIMARY KEY);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (tx TEXT NULL,pk INTEGER PRIMARY KEY);"
    ]
  },
  {
    "sql_id": "monetdb_75_3",
    "database_name": "monetdb_75_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT pk,OCTET_LENGTH(tx),LENGTH(tx) FROM t1; -- OCTET_LENGTH, LENGTH",
    "target_query": "SELECT pk,LENGTH(tx),octet_length(tx) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "OCTET_LENGTH",
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "OCTET_LENGTH()",
        "description": "Returns the number of bytes in a string.",
        "examples": [
          "SELECT OCTET_LENGTH('Hello World');",
          "SELECT OCTET_LENGTH('Test String') = 11;",
          "SELECT CASE WHEN OCTET_LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
        ]
      },
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LENGTH()",
        "description": "Returns the number of bytes in a string.",
        "examples": [
          "SELECT LENGTH('Hello World');",
          "SELECT LENGTH('Test String') = 11;",
          "SELECT CASE WHEN LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
        ]
      },
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (tx TEXT NULL,pk INTEGER PRIMARY KEY);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (tx TEXT NULL,pk INTEGER PRIMARY KEY);"
    ]
  },
  {
    "sql_id": "monetdb_76_2",
    "database_name": "monetdb_76_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "insert ignore t1 values (1, repeat('a',110), repeat('b', 210)); -- REPEAT",
    "target_query": "insert into t1 values (1, repeat('a',110), repeat('b', 210));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (i int, a char(200), b text, unique (a), unique (b(300)));"
    ],
    "target_related_schemas": [
      "create table t1 (i int, a char(200), b text, unique (a), unique (b));"
    ]
  },
  {
    "sql_id": "monetdb_76_3",
    "database_name": "monetdb_76_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select i, length(a), length(b), char_length(a), char_length(b) from t1; -- LENGTH, CHAR_LENGTH",
    "target_query": "select i, octet_length(a), octet_length(b), char_length(a), char_length(b) from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH",
      "CHAR_LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      },
      {
        "expression": "CHAR_LENGTH(expr)",
        "description": "Returns the number of characters in the string, not bytes.",
        "examples": [
          "SELECT CHAR_LENGTH('abc');",
          "SELECT CHAR_LENGTH('你好');",
          "SELECT CHAR_LENGTH('a你b好c');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      },
      {
        "expression": "char_length(expr)",
        "description": "Returns the number of characters in a string (char_length and length are equivalent).",
        "examples": [
          "SELECT char_length('abc');",
          "SELECT char_length('你好');",
          "SELECT char_length('a你b好c');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (i int, a char(200), b text, unique (a), unique (b(300)));"
    ],
    "target_related_schemas": [
      "create table t1 (i int, a char(200), b text, unique (a), unique (b));"
    ]
  },
  {
    "sql_id": "monetdb_76_6",
    "database_name": "monetdb_76_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "insert into t1 values(1, 'a', 'a', NOW()), (1, 'b', 'b', NOW()); -- NOW",
    "target_query": "insert into t1 values(1, 'a', 'a', CURRENT_TIMESTAMP), (1, 'b', 'b', CURRENT_TIMESTAMP);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 int,c2 char(12),c3 varchar(123),c4 timestamp NOT NULL);"
    ],
    "target_related_schemas": [
      "create table t1 (c1 int,c2 char(12),c3 varchar(123),c4 timestamp NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_77_3",
    "database_name": "monetdb_77_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select t1.time,t1.date,t1.timestamp,concat(date,\" \",time),t1.quarter+t1.week, t1.year+timestampadd,  timestampdiff from t1; -- CONCAT",
    "target_query": "select t1.\"time\",t1.\"date\",t1.\"timestamp\",\"date\" || ' ' || \"time\",t1.\"quarter\"+t1.\"week\", t1.\"year\"+\"timestampadd\",  timestampdiff from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (time time, date date, timestamp timestamp,quarter int, week int, year int, timestampadd int, timestampdiff int);"
    ],
    "target_related_schemas": [
      "create table t1 (\"time\" time, \"date\" date, \"timestamp\" timestamp,\"quarter\" int, \"week\" int, \"year\" int, \"timestampadd\" int, \"timestampdiff\" int);"
    ]
  },
  {
    "sql_id": "monetdb_78_2",
    "database_name": "monetdb_78_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select concat('|',a,'|'), concat('|',b,'|') from t1; -- CONCAT",
    "target_query": "SELECT '|' || a || '|' AS a, '|' || b || '|' AS b FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a text, b text);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a TEXT, b TEXT);"
    ]
  },
  {
    "sql_id": "monetdb_79_3",
    "database_name": "monetdb_79_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT a, date_format(a,'%a') as abday, dayname(a) as day FROM t1 ORDER BY a; -- DATE_FORMAT, DAYNAME",
    "target_query": "SELECT a, sys.timestamp_to_str(a, 'DY') as abday, dayname(a) as \"day\" FROM t1 ORDER BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT",
      "DAYNAME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      },
      {
        "expression": "DAYNAME(date)",
        "description": "Returns the full name of the day for a given date.",
        "examples": [
          "SELECT DAYNAME('2023-11-25');",
          "SELECT DAYNAME('2022-01-01');",
          "SELECT DAYNAME('1999-03-14');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
        "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
        "examples": [
          "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
        ]
      },
      {
        "expression": "dayname(date)",
        "description": "MonetDB has a built-in function `dayname` that returns the full name of the day for a given date.",
        "examples": [
          "SELECT dayname(CAST('2023-11-25' AS DATE));",
          "SELECT dayname(CAST('2022-01-01' AS DATE));",
          "SELECT dayname(CAST('1999-03-14' AS DATE));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a DATE);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a DATE);"
    ]
  },
  {
    "sql_id": "monetdb_79_7",
    "database_name": "monetdb_79_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT a, date_format(a,'%b') as abmon, monthname(a) as mon FROM t1 ORDER BY a; -- DATE_FORMAT, MONTHNAME",
    "target_query": "SELECT a, sys.timestamp_to_str(a, 'MON') as abmon, monthname(a) as mon FROM t1 ORDER BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT",
      "MONTHNAME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      },
      {
        "expression": "MONTHNAME(date)",
        "description": "Returns the full English name of the month for a given date.",
        "examples": [
          "SELECT MONTHNAME(DATE '2023-05-01') AS mon1;",
          "SELECT MONTHNAME(STR_TO_DATE('2024-12-31', '%Y-%m-%d')) AS mon2;",
          "SELECT MONTHNAME(NOW()) AS current_month;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
        "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
        "examples": [
          "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
        ]
      },
      {
        "expression": "monthName(date)",
        "description": "Returns the full English name of the month for a given date.",
        "examples": [
          "SELECT monthName(DATE '2023-05-01') AS mon1;",
          "SELECT monthName(DATE '2024-12-31') AS mon2;",
          "SELECT monthName(now()) AS current_month"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a DATE);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a DATE);"
    ]
  },
  {
    "sql_id": "monetdb_79_9",
    "database_name": "monetdb_79_9",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT DATE_FORMAT('2001-01-01', '%w %a %W'); -- DATE_FORMAT",
    "target_query": "SELECT sys.timestamp_to_str(TIMESTAMP '2001-01-01', 'D DY WW');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
        "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
        "examples": [
          "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_79_10",
    "database_name": "monetdb_79_10",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT DATE_FORMAT('2001-01-01', '%c %b %M'); -- DATE_FORMAT",
    "target_query": "SELECT sys.timestamp_to_str(TIMESTAMP '2001-01-01', 'MM MON MONTH');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
        "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
        "examples": [
          "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_79_11",
    "database_name": "monetdb_79_11",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT DATE_FORMAT('2010-03-23 11:00:00','%h %p'); -- DATE_FORMAT",
    "target_query": "SELECT sys.timestamp_to_str(TIMESTAMP '2010-03-23 11:00:00', 'HH12 AM');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
        "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
        "examples": [
          "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_8_0",
    "database_name": "monetdb_8_0",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select strcmp('','ae'),strcmp('ae',''),strcmp('aeq','q'),strcmp('q','aeq'); -- STRCMP",
    "target_query": "SELECT CASE WHEN '' = 'ae' THEN 0 WHEN '' < 'ae' THEN -1 ELSE 1 END, CASE WHEN 'ae' = '' THEN 0 WHEN 'ae' < '' THEN -1 ELSE 1 END, CASE WHEN 'aeq' = 'q' THEN 0 WHEN 'aeq' < 'q' THEN -1 ELSE 1 END, CASE WHEN 'q' = 'aeq' THEN 0 WHEN 'q' < 'aeq' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "MonetDB does not have a direct STRCMP function. This behavior can be simulated using a CASE statement to compare two strings lexicographically.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_8_1",
    "database_name": "monetdb_8_1",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select strcmp('ss',''),strcmp('','ss'),strcmp('s','sss'),strcmp('q','ssq'); -- STRCMP",
    "target_query": "SELECT CASE WHEN 'ss' = '' THEN 0 WHEN 'ss' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'ss' THEN 0 WHEN '' < 'ss' THEN -1 ELSE 1 END, CASE WHEN 's' = 'sss' THEN 0 WHEN 's' < 'sss' THEN -1 ELSE 1 END, CASE WHEN 'q' = 'ssq' THEN 0 WHEN 'q' < 'ssq' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "MonetDB does not have a direct STRCMP function. This behavior can be simulated using a CASE statement to compare two strings lexicographically.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_8_2",
    "database_name": "monetdb_8_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select strcmp('','af'),strcmp('a',''),strcmp('','aeq'),strcmp('','aeaeq'); -- STRCMP",
    "target_query": "SELECT CASE WHEN '' = 'af' THEN 0 WHEN '' < 'af' THEN -1 ELSE 1 END, CASE WHEN 'a' = '' THEN 0 WHEN 'a' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'aeq' THEN 0 WHEN '' < 'aeq' THEN -1 ELSE 1 END, CASE WHEN '' = 'aeaeq' THEN 0 WHEN '' < 'aeaeq' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "MonetDB does not have a direct STRCMP function. This behavior can be simulated using a CASE statement to compare two strings lexicographically.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_8_3",
    "database_name": "monetdb_8_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select strcmp('ss','a'),strcmp('','ssa'),strcmp('sa','sssb'),strcmp('s',''); -- STRCMP",
    "target_query": "SELECT CASE WHEN 'ss' = 'a' THEN 0 WHEN 'ss' < 'a' THEN -1 ELSE 1 END, CASE WHEN '' = 'ssa' THEN 0 WHEN '' < 'ssa' THEN -1 ELSE 1 END, CASE WHEN 'sa' = 'sssb' THEN 0 WHEN 'sa' < 'sssb' THEN -1 ELSE 1 END, CASE WHEN 's' = '' THEN 0 WHEN 's' < '' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "MonetDB does not have a direct STRCMP function. This behavior can be simulated using a CASE statement to compare two strings lexicographically.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_8_4",
    "database_name": "monetdb_8_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select strcmp('','o'),strcmp('','u'),strcmp('','oeb'); -- STRCMP",
    "target_query": "SELECT CASE WHEN '' = 'o' THEN 0 WHEN '' < 'o' THEN -1 ELSE 1 END, CASE WHEN '' = 'u' THEN 0 WHEN '' < 'u' THEN -1 ELSE 1 END, CASE WHEN '' = 'oeb' THEN 0 WHEN '' < 'oeb' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "MonetDB does not have a direct STRCMP function. This behavior can be simulated using a CASE statement to compare two strings lexicographically.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_8_5",
    "database_name": "monetdb_8_5",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select strcmp('af',''),strcmp('','a'),strcmp('aeq',''),strcmp('aeaeq',''); -- STRCMP",
    "target_query": "SELECT CASE WHEN 'af' = '' THEN 0 WHEN 'af' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'a' THEN 0 WHEN '' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'aeq' = '' THEN 0 WHEN 'aeq' < '' THEN -1 ELSE 1 END, CASE WHEN 'aeaeq' = '' THEN 0 WHEN 'aeaeq' < '' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "MonetDB does not have a direct STRCMP function. This behavior can be simulated using a CASE statement to compare two strings lexicographically.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_8_6",
    "database_name": "monetdb_8_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select strcmp('a','ss'),strcmp('ssa',''),strcmp('sssb','sa'),strcmp('','s'); -- STRCMP",
    "target_query": "SELECT CASE WHEN 'a' = 'ss' THEN 0 WHEN 'a' < 'ss' THEN -1 ELSE 1 END, CASE WHEN 'ssa' = '' THEN 0 WHEN 'ssa' < '' THEN -1 ELSE 1 END, CASE WHEN 'sssb' = 'sa' THEN 0 WHEN 'sssb' < 'sa' THEN -1 ELSE 1 END, CASE WHEN '' = 's' THEN 0 WHEN '' < 's' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "MonetDB does not have a direct STRCMP function. This behavior can be simulated using a CASE statement to compare two strings lexicographically.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_8_7",
    "database_name": "monetdb_8_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select strcmp('u','a'),strcmp('u',''); -- STRCMP",
    "target_query": "SELECT CASE WHEN 'u' = 'a' THEN 0 WHEN 'u' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'u' = '' THEN 0 WHEN 'u' < '' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "MonetDB does not have a direct STRCMP function. This behavior can be simulated using a CASE statement to compare two strings lexicographically.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_8_8",
    "database_name": "monetdb_8_8",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select strcmp('s', 'a'), strcmp('a', 'x'); -- STRCMP",
    "target_query": "SELECT CASE WHEN 's' = 'a' THEN 0 WHEN 's' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'a' = 'x' THEN 0 WHEN 'a' < 'x' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "MonetDB does not have a direct STRCMP function. This behavior can be simulated using a CASE statement to compare two strings lexicographically.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_8_17",
    "database_name": "monetdb_8_17",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select * from t1 where length(s1)=2 and s1='oe'; -- LENGTH",
    "target_query": "select * from t1 where octet_length(s1)=2 and s1='oe'; -- LENGTH",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (s1 char(5));"
    ],
    "target_related_schemas": [
      "create table t1 (s1 char(5));"
    ]
  },
  {
    "sql_id": "monetdb_80_0",
    "database_name": "monetdb_80_0",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT LPAD(NULL, 5, 'x') AS result; -- LPAD",
    "target_query": "SELECT CONCAT(REPEAT('x', GREATEST(0, 5 - LENGTH(NULL))), NULL) AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
        "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
        "examples": [
          "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
          "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
          "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_80_1",
    "database_name": "monetdb_80_1",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT LPAD(NULL, NULL, 'x') AS result; -- LPAD",
    "target_query": "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
        "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
        "examples": [
          "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
          "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
          "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_80_2",
    "database_name": "monetdb_80_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT LPAD(NULL, NULL, NULL) AS result; -- LPAD",
    "target_query": "SELECT CONCAT(REPEAT(NULL, GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
        "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
        "examples": [
          "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
          "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
          "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_80_3",
    "database_name": "monetdb_80_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT LPAD('a', NULL, 'x') AS result; -- LPAD",
    "target_query": "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH('a'))), 'a') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
        "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
        "examples": [
          "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
          "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
          "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_80_4",
    "database_name": "monetdb_80_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT LPAD('a', NULL, NULL) AS result; -- LPAD",
    "target_query": "SELECT CONCAT(REPEAT(NULL, GREATEST(0, NULL - LENGTH('a'))), 'a') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
        "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
        "examples": [
          "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
          "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
          "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_80_5",
    "database_name": "monetdb_80_5",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT LPAD('a', 5, NULL) AS result; -- LPAD",
    "target_query": "SELECT CONCAT(REPEAT(NULL, GREATEST(0, 5 - LENGTH('a'))), 'a') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
        "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
        "examples": [
          "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
          "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
          "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_80_6",
    "database_name": "monetdb_80_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT LPAD(NULL, 5, NULL) AS result; -- LPAD",
    "target_query": "SELECT CONCAT(REPEAT(NULL, GREATEST(0, 5 - LENGTH(NULL))), NULL) AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
        "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
        "examples": [
          "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
          "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
          "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_80_7",
    "database_name": "monetdb_80_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT LPAD('a', 0, 'x') AS result; -- LPAD",
    "target_query": "SELECT CONCAT(REPEAT('x', GREATEST(0, 0 - LENGTH('a'))), 'a') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
        "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
        "examples": [
          "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
          "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
          "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_80_8",
    "database_name": "monetdb_80_8",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT LPAD('a', 0, '') AS result; -- LPAD",
    "target_query": "SELECT CONCAT(REPEAT('', GREATEST(0, 0 - LENGTH('a'))), 'a') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
        "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
        "examples": [
          "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
          "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
          "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_80_9",
    "database_name": "monetdb_80_9",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT LPAD('', 0, 'x') AS result; -- LPAD",
    "target_query": "SELECT CONCAT(REPEAT('x', GREATEST(0, 0 - LENGTH(''))), '') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
        "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
        "examples": [
          "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
          "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
          "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_80_10",
    "database_name": "monetdb_80_10",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT LPAD('', 0, '') AS result; -- LPAD",
    "target_query": "SELECT CONCAT(REPEAT('', GREATEST(0, 0 - LENGTH(''))), '') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
        "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
        "examples": [
          "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
          "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
          "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_80_11",
    "database_name": "monetdb_80_11",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT LPAD('a', -1, 'x'); -- LPAD",
    "target_query": "SELECT CONCAT(REPEAT('x', GREATEST(0, -1 - LENGTH('a'))), 'a');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
        "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
        "examples": [
          "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
          "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
          "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_80_12",
    "database_name": "monetdb_80_12",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT LPAD('123', 5, 'x'); -- LPAD",
    "target_query": "SELECT CONCAT(REPEAT('x', GREATEST(0, 5 - LENGTH('123'))), '123');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
        "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
        "examples": [
          "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
          "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
          "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_80_13",
    "database_name": "monetdb_80_13",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT LPAD('a', 5, 'xy'); -- LPAD",
    "target_query": "SELECT CONCAT(REPEAT('xy', GREATEST(0, 5 - LENGTH('a'))), 'a');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
        "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
        "examples": [
          "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
          "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
          "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_80_14",
    "database_name": "monetdb_80_14",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT LPAD(\"I LOVE SQL\", 20, \" \"); -- LPAD",
    "target_query": "SELECT CONCAT(REPEAT(' ', GREATEST(0, 20 - LENGTH('I LOVE SQL'))), 'I LOVE SQL');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
        "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
        "examples": [
          "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
          "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
          "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_80_15",
    "database_name": "monetdb_80_15",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT LPAD(\"I LOVE SQL in the morning\", 20, \" \"); -- LPAD",
    "target_query": "SELECT CONCAT(REPEAT(' ', GREATEST(0, 20 - LENGTH('I LOVE SQL in the morning'))), 'I LOVE SQL in the morning');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
        "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
        "examples": [
          "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
          "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
          "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_81_2",
    "database_name": "monetdb_81_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 VALUES(REPEAT('a', 1024), 0), (REPEAT('b', 1024), 1),(REPEAT('c', 1024), 2), (REPEAT('d', 1024), 3),(REPEAT('e', 1024), 4), (REPEAT('f', 1024), 5); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES(REPEAT('a', 1024), 0), (REPEAT('b', 1024), 1),(REPEAT('c', 1024), 2), (REPEAT('d', 1024), 3),(REPEAT('e', 1024), 4), (REPEAT('f', 1024), 5);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (f1 LONGTEXT , f2  INTEGER);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (f1 TEXT , f2 INTEGER);"
    ]
  },
  {
    "sql_id": "monetdb_81_15",
    "database_name": "monetdb_81_15",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT SUM(LENGTH(f1)) FROM t1; -- LENGTH",
    "target_query": "SELECT SUM(octet_length(f1)) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (f1 LONGTEXT , f2  INTEGER);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (f1 TEXT , f2 INTEGER);"
    ]
  },
  {
    "sql_id": "monetdb_82_3",
    "database_name": "monetdb_82_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT COALESCE(d, d), IFNULL(d, d), IF(i, d, d),CASE i WHEN i THEN d ELSE d END, GREATEST(d, d), LEAST(d, d)FROM t1 ORDER BY RAND(); -- COALESCE, IFNULL, IF, GREATEST, LEAST",
    "target_query": "SELECT COALESCE(d, d), COALESCE(d, d), CASE WHEN i THEN d ELSE d END, CASE i WHEN i THEN d ELSE d END, GREATEST(d, d), CASE WHEN d <= d THEN d ELSE d END FROM t1 ORDER BY RAND();",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE",
      "IFNULL",
      "IF",
      "GREATEST",
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      },
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      },
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      },
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      },
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...)",
        "description": "Standard SQL COALESCE function is supported.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1;"
        ]
      },
      {
        "expression": "COALESCE(expr1, expr2)",
        "description": "MonetDB also uses COALESCE to return the first non-NULL value. This works the same way as IFNULL in MySQL.",
        "examples": [
          "SELECT COALESCE(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      },
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      },
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      },
      {
        "expression": "CASE WHEN ... THEN ... END",
        "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
        "examples": [
          "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
          "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
          "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (i INT, d DATE);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (i INT, d DATE);"
    ]
  },
  {
    "sql_id": "monetdb_84_2",
    "database_name": "monetdb_84_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "insert into t5 values (1, date_format('2001-01-01','%W')); -- DATE_FORMAT",
    "target_query": "insert into t5 values (1, sys.timestamp_to_str(TIMESTAMP '2001-01-01', 'DAY'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
        "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
        "examples": [
          "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t5 (c1 int, c2 varchar(128) not null);"
    ],
    "target_related_schemas": [
      "create table t5 (c1 int, c2 varchar(128) not null);"
    ]
  },
  {
    "sql_id": "monetdb_84_3",
    "database_name": "monetdb_84_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "insert into t5 values (2, date_format('2001-01-01','%W')); -- DATE_FORMAT",
    "target_query": "insert into t5 values (2, sys.timestamp_to_str(TIMESTAMP '2001-01-01', 'DAY'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
        "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
        "examples": [
          "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t5 (c1 int, c2 varchar(128) not null);"
    ],
    "target_related_schemas": [
      "create table t5 (c1 int, c2 varchar(128) not null);"
    ]
  },
  {
    "sql_id": "monetdb_84_4",
    "database_name": "monetdb_84_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "insert into t5 values (3, date_format('2001-01-01','%W')); -- DATE_FORMAT",
    "target_query": "insert into t5 values (3, sys.timestamp_to_str(TIMESTAMP '2001-01-01', 'DAY'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
        "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
        "examples": [
          "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t5 (c1 int, c2 varchar(128) not null);"
    ],
    "target_related_schemas": [
      "create table t5 (c1 int, c2 varchar(128) not null);"
    ]
  },
  {
    "sql_id": "monetdb_85_2",
    "database_name": "monetdb_85_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 123)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 123));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (c1 LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 TEXT);"
    ]
  },
  {
    "sql_id": "monetdb_85_3",
    "database_name": "monetdb_85_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 234)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 234));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (c1 LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 TEXT);"
    ]
  },
  {
    "sql_id": "monetdb_85_4",
    "database_name": "monetdb_85_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 345)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 345));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (c1 LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 TEXT);"
    ]
  },
  {
    "sql_id": "monetdb_85_5",
    "database_name": "monetdb_85_5",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 456)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 456));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (c1 LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 TEXT);"
    ]
  },
  {
    "sql_id": "monetdb_85_6",
    "database_name": "monetdb_85_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT LENGTH(c1) FROM t1; -- LENGTH",
    "target_query": "SELECT octet_length(c1) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (c1 LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 TEXT);"
    ]
  },
  {
    "sql_id": "monetdb_86_1",
    "database_name": "monetdb_86_1",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select NULL=NULL,NULL<>NULL,IFNULL(NULL,1.1)+0,IFNULL(NULL,1) | 0; -- IFNULL",
    "target_query": "SELECT NULL = NULL, NULL <> NULL, COALESCE(NULL, 1.1) + 0, COALESCE(NULL, 1) | 0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2)",
        "description": "MonetDB also uses COALESCE to return the first non-NULL value. This works the same way as IFNULL in MySQL.",
        "examples": [
          "SELECT COALESCE(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_86_4",
    "database_name": "monetdb_86_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select field(NULL,\"a\",\"b\",\"c\"); -- FIELD",
    "target_query": "SELECT FIELD(NULL, 'a', 'b', 'c');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FIELD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FIELD(val, val1, val2, ..., valN)",
        "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
        "examples": [
          "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "FIELD(val, val1, val2, ..., valN)",
        "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found. This behaves the same as MySQL FIELD().",
        "examples": [
          "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_86_9",
    "database_name": "monetdb_86_9",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "CREATE TABLE t2 SELECT IFNULL(a, b) FROM t1; -- IFNULL",
    "target_query": "CREATE TABLE t2 AS SELECT COALESCE(a, b) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2)",
        "description": "MonetDB also uses COALESCE to return the first non-NULL value. This works the same way as IFNULL in MySQL.",
        "examples": [
          "SELECT COALESCE(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 SELECT IFNULL(a, b) FROM t1; -- IFNULL"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 AS SELECT COALESCE(a, b) FROM t1;"
    ]
  },
  {
    "sql_id": "monetdb_86_11",
    "database_name": "monetdb_86_11",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "CREATE TABLE t2 SELECT IFNULL(a, NULL) FROM t1; -- IFNULL",
    "target_query": "CREATE TABLE t2 AS SELECT COALESCE(a, NULL) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2)",
        "description": "MonetDB also uses COALESCE to return the first non-NULL value. This works the same way as IFNULL in MySQL.",
        "examples": [
          "SELECT COALESCE(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 SELECT IFNULL(a, NULL) FROM t1; -- IFNULL"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 AS SELECT COALESCE(a, NULL) FROM t1;"
    ]
  },
  {
    "sql_id": "monetdb_86_13",
    "database_name": "monetdb_86_13",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "CREATE TABLE t2 SELECT IFNULL(NULL, b) FROM t1; -- IFNULL",
    "target_query": "CREATE TABLE t2 AS SELECT COALESCE(NULL, b) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2)",
        "description": "MonetDB also uses COALESCE to return the first non-NULL value. This works the same way as IFNULL in MySQL.",
        "examples": [
          "SELECT COALESCE(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 SELECT IFNULL(NULL, b) FROM t1; -- IFNULL"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 AS SELECT COALESCE(NULL, b) FROM t1;"
    ]
  },
  {
    "sql_id": "monetdb_87_2",
    "database_name": "monetdb_87_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 VALUES ( repeat( 'a', 10 ), 1),( repeat( 'b', 10 ), 2); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES ( repeat( 'a', 10 ), 1),( repeat( 'b', 10 ), 2);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1( a VARCHAR( 10 ), b INT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1( a VARCHAR( 10 ), b INT );"
    ]
  },
  {
    "sql_id": "monetdb_87_3",
    "database_name": "monetdb_87_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT GROUP_CONCAT(a) FROM t1; -- GROUP_CONCAT",
    "target_query": "SELECT GROUP_CONCAT(a) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GROUP_CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
        "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "group_concat(X) group_concat(X,Y)",
        "description": "The group_concat(X,Y) function returns a string which is the concatenation of all non-NULL values of X. If parameter Y is present, it is used as the separator between values. A comma (\",\") is used as the default separator if Y is omitted.\n\nThe order of concatenated elements is arbitrary unless an ORDER BY clause is explicitly used.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns names separated by commas",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by ' | '",
          "SELECT department, group_concat(name, '; ') FROM employees GROUP BY department; -- Groups names by department"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1( a VARCHAR( 10 ), b INT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1( a VARCHAR( 10 ), b INT );"
    ]
  },
  {
    "sql_id": "monetdb_88_0",
    "database_name": "monetdb_88_0",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select repeat('a',2000); -- REPEAT",
    "target_query": "select repeat('a',2000);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_88_1",
    "database_name": "monetdb_88_1",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT length(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\") as len; -- LENGTH",
    "target_query": "SELECT octet_length('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa') as len;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_88_2",
    "database_name": "monetdb_88_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select length(repeat('a',2000)); -- LENGTH, REPEAT",
    "target_query": "select octet_length(repeat('a',2000));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH",
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      },
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      },
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_88_9",
    "database_name": "monetdb_88_9",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT c11, LENGTH(c12) FROM t1; -- LENGTH",
    "target_query": "SELECT c11, octet_length(c12) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 (c21 INT NOT NULL, c22 LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (c21 INT NOT NULL, c22 TEXT);"
    ]
  },
  {
    "sql_id": "monetdb_89_8",
    "database_name": "monetdb_89_8",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "create table t1 as select to_seconds(null) as to_seconds; -- TO_SECONDS",
    "target_query": "create table t1 as select CASE WHEN NULL IS NULL THEN NULL ELSE EXTRACT(EPOCH FROM NULL) + 62167219200 END as to_seconds;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TO_SECONDS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TO_SECONDS(datetime_expr)",
        "description": "Returns the number of seconds since year 0 to the given datetime.",
        "examples": [
          "SELECT TO_SECONDS('2000-01-01 00:00:00');",
          "SELECT TO_SECONDS(NOW());",
          "SELECT TO_SECONDS(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM ts) + 62167219200",
        "description": "Converts timestamp to the number of seconds since the year 0 by extracting the Unix epoch and adding the seconds from year 0 to 1970.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2020-12-31 12:00:00') + 62167219200;",
          "SELECT EXTRACT(EPOCH FROM NOW()) + 62167219200;",
          "SELECT CASE WHEN NULL IS NULL THEN NULL ELSE EXTRACT(EPOCH FROM NULL) + 62167219200 END;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 as select to_seconds(null) as to_seconds; -- TO_SECONDS"
    ],
    "target_related_schemas": [
      "create table t1 as select CASE WHEN NULL IS NULL THEN NULL ELSE EXTRACT(EPOCH FROM NULL) + 62167219200 END as to_seconds;"
    ]
  },
  {
    "sql_id": "monetdb_9_0",
    "database_name": "monetdb_9_0",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT IF(0,\"ERROR\",\"this\"),IF(1,\"is\",\"ERROR\"),IF(NULL,\"ERROR\",\"a\"),IF(1,2,3),IF(1,2.0,3.0)+0; -- IF",
    "target_query": "SELECT CASE WHEN 0 THEN 'ERROR' ELSE 'this' END, CASE WHEN 1 THEN 'is' ELSE 'ERROR' END, CASE WHEN NULL THEN 'ERROR' ELSE 'a' END, CASE WHEN 1 THEN 2 ELSE 3 END, CASE WHEN 1 THEN 2.0 ELSE 3.0 END + 0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_9_4",
    "database_name": "monetdb_9_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT IF(1,st,st) s FROM t1 ORDER BY s; -- IF",
    "target_query": "SELECT CASE WHEN 1 THEN st ELSE st END AS s FROM t1 ORDER BY s;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_9_5",
    "database_name": "monetdb_9_5",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT IF(u=1,st,st) s FROM t1 ORDER BY s; -- IF",
    "target_query": "SELECT CASE WHEN u=1 THEN st ELSE st END AS s FROM t1 ORDER BY s;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_9_7",
    "database_name": "monetdb_9_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select nullif(u, 1) from t1; -- NULLIF",
    "target_query": "SELECT NULLIF(u, 1) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NULLIF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NULLIF(a, b)",
        "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
        "examples": [
          "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
          "SELECT NULLIF(YEAR('2021-01-01'), 2021) AS year_check;",
          "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "NULLIF(a, b)",
        "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
        "examples": [
          "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
          "SELECT NULLIF(EXTRACT(YEAR FROM DATE '2021-01-01'), 2021) AS year_check;",
          "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_9_8",
    "database_name": "monetdb_9_8",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "explain select nullif(u, 1) from t1; -- NULLIF",
    "target_query": "EXPLAIN SELECT NULLIF(u, 1) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NULLIF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NULLIF(a, b)",
        "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
        "examples": [
          "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
          "SELECT NULLIF(YEAR('2021-01-01'), 2021) AS year_check;",
          "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "NULLIF(a, b)",
        "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
        "examples": [
          "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
          "SELECT NULLIF(EXTRACT(YEAR FROM DATE '2021-01-01'), 2021) AS year_check;",
          "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_9_12",
    "database_name": "monetdb_9_12",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select sum(if(num is null,0.00,num)) from t1; -- IF",
    "target_query": "SELECT SUM(CASE WHEN num IS NULL THEN 0.00 ELSE num END) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (num  double(12,2));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (num decimal(12,2));"
    ]
  },
  {
    "sql_id": "monetdb_9_16",
    "database_name": "monetdb_9_16",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select min(if(y -x > 5,y,NULL)), max(if(y - x > 5,y,NULL)) from t1; -- IF",
    "target_query": "SELECT MIN(CASE WHEN y - x > 5 THEN y ELSE NULL END), MAX(CASE WHEN y - x > 5 THEN y ELSE NULL END) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (x int, y int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (x int, y int);"
    ]
  },
  {
    "sql_id": "monetdb_9_18",
    "database_name": "monetdb_9_18",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT NULLIF(5,5) IS NULL, NULLIF(5,5) IS NOT NULL; -- NULLIF",
    "target_query": "SELECT NULLIF(5,5) IS NULL, NULLIF(5,5) IS NOT NULL;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NULLIF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NULLIF(a, b)",
        "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
        "examples": [
          "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
          "SELECT NULLIF(YEAR('2021-01-01'), 2021) AS year_check;",
          "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "NULLIF(a, b)",
        "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
        "examples": [
          "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
          "SELECT NULLIF(EXTRACT(YEAR FROM DATE '2021-01-01'), 2021) AS year_check;",
          "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_9_21",
    "database_name": "monetdb_9_21",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT id, IF(date IS NULL, '-', FROM_UNIXTIME(date, '%d-%m-%Y')) AS date_ord, text FROM t1 ORDER BY date_ord ASC; -- IF, FROM_UNIXTIME",
    "target_query": "SELECT id, CASE WHEN date IS NULL THEN '-' ELSE CAST(TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1110000000' SECOND AS STRING) END AS date_ord, text FROM t1 ORDER BY date_ord ASC;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF",
      "FROM_UNIXTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      },
      {
        "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
        "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
          "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      },
      {
        "expression": "TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '<seconds>' SECOND",
        "description": "Adds seconds to the UNIX epoch by using an INTERVAL expression with a string constant representing the number of seconds.",
        "examples": [
          "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000' SECOND;",
          "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000.987' SECOND;",
          "SELECT CAST(TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000' SECOND AS STRING);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE `t1` (`id` int(11) NOT NULL ,`date` int(10) default NULL,`text` varchar(32) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id int NOT NULL, date int DEFAULT NULL, text varchar(32) NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_9_22",
    "database_name": "monetdb_9_22",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT id, IF(date IS NULL, '-', FROM_UNIXTIME(date, '%d-%m-%Y')) AS date_ord, text FROM t1 ORDER BY date_ord DESC; -- IF, FROM_UNIXTIME",
    "target_query": "SELECT id, CASE WHEN date IS NULL THEN '-' ELSE CAST(TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1110000000' SECOND AS STRING) END AS date_ord, text FROM t1 ORDER BY date_ord DESC;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF",
      "FROM_UNIXTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      },
      {
        "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
        "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
          "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      },
      {
        "expression": "TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '<seconds>' SECOND",
        "description": "Adds seconds to the UNIX epoch by using an INTERVAL expression with a string constant representing the number of seconds.",
        "examples": [
          "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000' SECOND;",
          "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000.987' SECOND;",
          "SELECT CAST(TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000' SECOND AS STRING);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE `t1` (`id` int(11) NOT NULL ,`date` int(10) default NULL,`text` varchar(32) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id int NOT NULL, date int DEFAULT NULL, text varchar(32) NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_9_26",
    "database_name": "monetdb_9_26",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT * FROM (SELECT MAX(IF(1, CAST(c AS UNSIGNED), 0)) FROM t1) AS te; -- IF",
    "target_query": "SELECT * FROM (SELECT MAX(CASE WHEN 1 THEN CAST(c AS BIGINT) ELSE 0 END) FROM t1) AS te;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (c LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c clob);  -- MonetDB 不支持 LONGTEXT，用 clob 表示"
    ]
  },
  {
    "sql_id": "monetdb_9_27",
    "database_name": "monetdb_9_27",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT * FROM (SELECT MAX(IFNULL(CAST(c AS UNSIGNED), 0)) FROM t1) AS te; -- IFNULL",
    "target_query": "SELECT * FROM (SELECT MAX(COALESCE(CAST(c AS BIGINT), 0)) FROM t1) AS te;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2)",
        "description": "MonetDB also uses COALESCE to return the first non-NULL value. This works the same way as IFNULL in MySQL.",
        "examples": [
          "SELECT COALESCE(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (c LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c clob);  -- MonetDB 不支持 LONGTEXT，用 clob 表示"
    ]
  },
  {
    "sql_id": "monetdb_9_29",
    "database_name": "monetdb_9_29",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT AVG(NULLIF(YEAR('2001-01-01'),10)); -- NULLIF, YEAR",
    "target_query": "SELECT AVG(NULLIF(EXTRACT(YEAR FROM DATE '2001-01-01'), 10));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NULLIF",
      "YEAR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NULLIF(a, b)",
        "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
        "examples": [
          "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
          "SELECT NULLIF(YEAR('2021-01-01'), 2021) AS year_check;",
          "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
        ]
      },
      {
        "expression": "YEAR(date)",
        "description": "Extracts the year from a date or datetime and returns it as an integer.",
        "examples": [
          "SELECT YEAR('2023-04-10');",
          "SELECT YEAR(NOW());",
          "SELECT YEAR('2022-03-15');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "NULLIF(a, b)",
        "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
        "examples": [
          "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
          "SELECT NULLIF(EXTRACT(YEAR FROM DATE '2021-01-01'), 2021) AS year_check;",
          "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
        ]
      },
      {
        "expression": "EXTRACT(YEAR FROM date)",
        "description": "Extracts the year from a date or datetime and returns it as an integer.",
        "examples": [
          "SELECT EXTRACT(YEAR FROM DATE '2023-04-10');",
          "SELECT EXTRACT(YEAR FROM CURRENT_DATE);",
          "SELECT EXTRACT(YEAR FROM DATE '2022-03-15');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_90_0",
    "database_name": "monetdb_90_0",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT FROM_DAYS(3652499), FROM_DAYS(3652500), FROM_DAYS(3652501); -- FROM_DAYS",
    "target_query": "SELECT sql_add(DATE '0000-01-01', INTERVAL '3652499' DAY), sql_add(DATE '0000-01-01', INTERVAL '3652500' DAY), sql_add(DATE '0000-01-01', INTERVAL '3652501' DAY); -- FROM_DAYS",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FROM_DAYS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FROM_DAYS(n)",
        "description": "Returns a date corresponding to the number of days since year 0.",
        "examples": [
          "SELECT FROM_DAYS(1);",
          "SELECT FROM_DAYS(730000);",
          "SELECT CONCAT('Date is: ', FROM_DAYS(738000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": " INTERVAL 'n' DAY)",
        "description": "Adds n days to the base date '0000-01-01' using sql_add to simulate FROM_DAYS.",
        "examples": [
          "SELECT sql_add(DATE '0000-01-01', INTERVAL '1' DAY);",
          "SELECT sql_add(DATE '0000-01-01', INTERVAL '730000' DAY);",
          "SELECT 'Date is: ' || sql_add(DATE '0000-01-01', INTERVAL '738000' DAY);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_90_1",
    "database_name": "monetdb_90_1",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT FROM_DAYS(42949670), FROM_DAYS(42949671), FROM_DAYS(42949673); -- FROM_DAYS",
    "target_query": "SELECT sql_add(DATE '0000-01-01', INTERVAL '42949670' DAY), sql_add(DATE '0000-01-01', INTERVAL '42949671' DAY), sql_add(DATE '0000-01-01', INTERVAL '42949673' DAY); -- FROM_DAYS",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FROM_DAYS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FROM_DAYS(n)",
        "description": "Returns a date corresponding to the number of days since year 0.",
        "examples": [
          "SELECT FROM_DAYS(1);",
          "SELECT FROM_DAYS(730000);",
          "SELECT CONCAT('Date is: ', FROM_DAYS(738000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": " INTERVAL 'n' DAY)",
        "description": "Adds n days to the base date '0000-01-01' using sql_add to simulate FROM_DAYS.",
        "examples": [
          "SELECT sql_add(DATE '0000-01-01', INTERVAL '1' DAY);",
          "SELECT sql_add(DATE '0000-01-01', INTERVAL '730000' DAY);",
          "SELECT 'Date is: ' || sql_add(DATE '0000-01-01', INTERVAL '738000' DAY);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_91_2",
    "database_name": "monetdb_91_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t VALUES (0, REPEAT('x', 120000)), (1, REPEAT('z', 12000)); -- REPEAT",
    "target_query": "INSERT INTO t VALUES (0, REPEAT('x', 120000)), (1, REPEAT('z', 12000));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t(i int, b LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t(i int, b TEXT);"
    ]
  },
  {
    "sql_id": "monetdb_91_4",
    "database_name": "monetdb_91_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT LENGTH(b) FROM (SELECT * FROM t INTERSECT SELECT * FROM t) derived; -- LENGTH",
    "target_query": "SELECT octet_length(b) FROM (SELECT * FROM t INTERSECT SELECT * FROM t) derived;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t(i int, b LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t(i int, b TEXT);"
    ]
  },
  {
    "sql_id": "monetdb_92_2",
    "database_name": "monetdb_92_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT argument FROM test_log WHERE argument LIKE CONCAT('%azun','dris%'); -- CONCAT",
    "target_query": "SELECT argument FROM test_log WHERE argument LIKE '%azun' || 'dris%';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE test_log (argument TEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE test_log (argument TEXT);"
    ]
  },
  {
    "sql_id": "monetdb_96_0",
    "database_name": "monetdb_96_0",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT RPAD(NULL, 5, 'x') AS result; -- RPAD",
    "target_query": "SELECT RPAD(NULL, 5, 'x') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "MonetDB can simulate RPAD by concatenating strings.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_96_1",
    "database_name": "monetdb_96_1",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT RPAD(NULL, NULL, 'x') AS result; -- RPAD",
    "target_query": "SELECT RPAD(NULL, NULL, 'x') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "MonetDB can simulate RPAD by concatenating strings.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_96_2",
    "database_name": "monetdb_96_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT RPAD(NULL, NULL, NULL) AS result; -- RPAD",
    "target_query": "SELECT RPAD(NULL, NULL, NULL) AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "MonetDB can simulate RPAD by concatenating strings.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_96_3",
    "database_name": "monetdb_96_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT RPAD('a', NULL, 'x') AS result; -- RPAD",
    "target_query": "SELECT RPAD('a', NULL, 'x') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "MonetDB can simulate RPAD by concatenating strings.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_96_4",
    "database_name": "monetdb_96_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT RPAD('a', NULL, NULL) AS result; -- RPAD",
    "target_query": "SELECT RPAD('a', NULL, NULL) AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "MonetDB can simulate RPAD by concatenating strings.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_96_5",
    "database_name": "monetdb_96_5",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT RPAD('a', 5, NULL) AS result; -- RPAD",
    "target_query": "SELECT RPAD('a', 5, NULL) AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "MonetDB can simulate RPAD by concatenating strings.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_96_6",
    "database_name": "monetdb_96_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT RPAD(NULL, 5, NULL) AS result; -- RPAD",
    "target_query": "SELECT RPAD(NULL, 5, NULL) AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "MonetDB can simulate RPAD by concatenating strings.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_96_7",
    "database_name": "monetdb_96_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT RPAD('a', 0, 'x') AS result; -- RPAD",
    "target_query": "SELECT RPAD('a', 0, 'x') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "MonetDB can simulate RPAD by concatenating strings.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_96_8",
    "database_name": "monetdb_96_8",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT RPAD('a', 0, '') AS result; -- RPAD",
    "target_query": "SELECT RPAD('a', 0, '') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "MonetDB can simulate RPAD by concatenating strings.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_96_9",
    "database_name": "monetdb_96_9",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT RPAD('', 0, 'x') AS result; -- RPAD",
    "target_query": "SELECT RPAD('', 0, 'x') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "MonetDB can simulate RPAD by concatenating strings.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_96_10",
    "database_name": "monetdb_96_10",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT RPAD('', 0, '') AS result; -- RPAD",
    "target_query": "SELECT RPAD('', 0, '') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "MonetDB can simulate RPAD by concatenating strings.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_96_11",
    "database_name": "monetdb_96_11",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT RPAD('a', -1, 'x'); -- RPAD",
    "target_query": "SELECT RPAD('a', -1, 'x');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "MonetDB can simulate RPAD by concatenating strings.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_96_12",
    "database_name": "monetdb_96_12",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT RPAD('123456787890', 1, 'x'); -- RPAD",
    "target_query": "SELECT RPAD('123456787890', 1, 'x');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "MonetDB can simulate RPAD by concatenating strings.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_96_13",
    "database_name": "monetdb_96_13",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT RPAD('a', 5, 'xy'); -- RPAD",
    "target_query": "SELECT RPAD('a', 5, 'xy');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "MonetDB can simulate RPAD by concatenating strings.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_96_14",
    "database_name": "monetdb_96_14",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT RPAD(\"I LOVE SQL\", 20, \" \"); -- RPAD",
    "target_query": "SELECT RPAD('I LOVE SQL', 20, ' ');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "MonetDB can simulate RPAD by concatenating strings.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_96_15",
    "database_name": "monetdb_96_15",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT RPAD(\"I LOVE SQL in the morning\", 20, \" \"); -- RPAD",
    "target_query": "SELECT RPAD('I LOVE SQL in the morning', 20, ' ');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "MonetDB can simulate RPAD by concatenating strings.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_97_6",
    "database_name": "monetdb_97_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "EXPLAIN SELECT * FROM t1 WHERE ISNULL(t1.a IN (SELECT t3.a FROM t1 t3)); -- ISNULL",
    "target_query": "EXPLAIN SELECT * FROM t1 WHERE (t1.a IN (SELECT t3.a FROM t1 t3)) IS NULL;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ISNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ISNULL(expr)",
        "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
        "examples": [
          "SELECT ISNULL(NULL);",
          "SELECT ISNULL(5 + NULL);",
          "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "expr IS NULL",
        "description": "Standard SQL construct for detecting NULL values.",
        "examples": [
          "SELECT NULL IS NULL;",
          "SELECT (5 * NULL) IS NULL;",
          "SELECT CASE WHEN balance IS NULL THEN 0 ELSE balance END FROM accounts;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(a INT, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(a INT, b INT);"
    ]
  },
  {
    "sql_id": "monetdb_97_7",
    "database_name": "monetdb_97_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT * FROM t1 WHERE ISNULL(t1.a IN (SELECT t3.a FROM t1 t3)); -- ISNULL",
    "target_query": "SELECT * FROM t1 WHERE (t1.a IN (SELECT t3.a FROM t1 t3)) IS NULL;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ISNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ISNULL(expr)",
        "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
        "examples": [
          "SELECT ISNULL(NULL);",
          "SELECT ISNULL(5 + NULL);",
          "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "expr IS NULL",
        "description": "Standard SQL construct for detecting NULL values.",
        "examples": [
          "SELECT NULL IS NULL;",
          "SELECT (5 * NULL) IS NULL;",
          "SELECT CASE WHEN balance IS NULL THEN 0 ELSE balance END FROM accounts;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(a INT, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(a INT, b INT);"
    ]
  },
  {
    "sql_id": "monetdb_98_4",
    "database_name": "monetdb_98_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "EXPLAIN SELECT * FROM t1 WHERE (SELECT b FROM t2 WHERE CAST(UUID() AS CHAR) = CAST(t2.a AS CHAR)) > 0; -- UUID",
    "target_query": "EXPLAIN SELECT * FROM t1 WHERE (SELECT b FROM t2 WHERE CAST(UUID() AS TEXT) = CAST(t2.a AS TEXT) ) > 0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UUID"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UUID()",
        "description": "In MySQL, the UUID() function generates a unique 128-bit identifier, typically represented as a string containing numbers and letters, in the standard UUID format.",
        "examples": [
          "SELECT UUID();",
          "SELECT CONCAT(UUID(), 'some_random_string');",
          "SELECT UPPER(UUID());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "UUID()",
        "description": "MonetDB supports the UUID() function, which generates a UUID in the standard format.",
        "examples": [
          "SELECT UUID();",
          "SELECT CONCAT(UUID(), 'some_random_string');",
          "SELECT UPPER(UUID());"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2(a INT, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2(a INT, b INT);"
    ]
  },
  {
    "sql_id": "monetdb_98_14",
    "database_name": "monetdb_98_14",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ; -- COALESCE",
    "target_query": "SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...)",
        "description": "Standard SQL COALESCE function is supported.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t3(a INT, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t3(a INT, b INT);"
    ]
  },
  {
    "sql_id": "monetdb_98_15",
    "database_name": "monetdb_98_15",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "EXPLAIN SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ; -- COALESCE",
    "target_query": "EXPLAIN SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...)",
        "description": "Standard SQL COALESCE function is supported.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t3(a INT, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t3(a INT, b INT);"
    ]
  },
  {
    "sql_id": "monetdb_98_16",
    "database_name": "monetdb_98_16",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT (SELECT IFNULL(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ; -- IFNULL",
    "target_query": "SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2)",
        "description": "MonetDB also uses COALESCE to return the first non-NULL value. This works the same way as IFNULL in MySQL.",
        "examples": [
          "SELECT COALESCE(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t3(a INT, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t3(a INT, b INT);"
    ]
  },
  {
    "sql_id": "monetdb_98_17",
    "database_name": "monetdb_98_17",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "EXPLAIN SELECT (SELECT IFNULL(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ; -- IFNULL",
    "target_query": "EXPLAIN SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2)",
        "description": "MonetDB also uses COALESCE to return the first non-NULL value. This works the same way as IFNULL in MySQL.",
        "examples": [
          "SELECT COALESCE(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t3(a INT, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t3(a INT, b INT);"
    ]
  },
  {
    "sql_id": "monetdb_99_6",
    "database_name": "monetdb_99_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT TRIM(f1), COUNT(*) FROM table_varchar_pad_space GROUP BY f1; -- TRIM, COUNT",
    "target_query": "SELECT TRIM(f1), COUNT(*) FROM table_varchar_pad_space GROUP BY f1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TRIM",
      "COUNT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      },
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN FORMAT=TREE SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "MonetDB's TRIM function operates the same way as in MySQL and other databases. It removes unwanted characters from the start and/or end of a string.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      },
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE table_varchar_pad_space (f1 VARCHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE table_varchar_pad_space (f1 VARCHAR(20));"
    ]
  },
  {
    "sql_id": "monetdb_10_3",
    "database_name": "monetdb_10_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select a1,a2,b,min(c) from t1 where (ord(a1) > 97) and (ord(a2) + ord(a1) > 194) and (b = 'a') group by a1,a2,b; -- ORD",
    "target_query": "select a1,a2,b,min(c) from t1 where (ASCII(a1) > 97) and (ASCII(a2) + ASCII(a1) > 194) and (b = 'a') group by a1,a2,b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ORD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ORD(string)",
        "description": "The ORD() function returns the Unicode code point of the first character of a string.",
        "examples": [
          "SELECT ORD('A');",
          "SELECT ORD('B');",
          "SELECT ORD('C') > 60;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "ASCII(string)",
        "description": "MonetDB uses ASCII() to return the ASCII value of the first character in the string. It does not have a direct equivalent to ORD() for Unicode code points, but ASCII() can work for characters in the basic ASCII range.",
        "examples": [
          "SELECT ASCII('A');",
          "SELECT ASCII('B');",
          "SELECT ASCII('C') > 60;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');"
    ],
    "target_related_schemas": [
      "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');"
    ]
  },
  {
    "sql_id": "monetdb_10_4",
    "database_name": "monetdb_10_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select concat(a1,min(c)),b from t1 where a1 < 'd' group by a1,a2,b; -- CONCAT",
    "target_query": "select a1 || min(c), b from t1 where a1 < 'd' group by a1,a2,b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');"
    ],
    "target_related_schemas": [
      "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');"
    ]
  },
  {
    "sql_id": "monetdb_10_5",
    "database_name": "monetdb_10_5",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select concat(a1,min(c)),b,max(c) from t1 where a1 < 'd' group by a1,a2,b; -- CONCAT",
    "target_query": "select a1 || min(c), b, max(c) from t1 where a1 < 'd' group by a1,a2,b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');"
    ],
    "target_related_schemas": [
      "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');"
    ]
  },
  {
    "sql_id": "monetdb_10_6",
    "database_name": "monetdb_10_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select concat(a1,a2),b,min(c),max(c) from t1 where a1 < 'd' group by a1,a2,b; -- CONCAT",
    "target_query": "select a1 || a2, b, min(c), max(c) from t1 where a1 < 'd' group by a1,a2,b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');"
    ],
    "target_related_schemas": [
      "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');"
    ]
  },
  {
    "sql_id": "monetdb_10_7",
    "database_name": "monetdb_10_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select concat(ord(min(b)),ord(max(b))),min(b),max(b) from t1 group by a1,a2; -- CONCAT, ORD",
    "target_query": "select ASCII(min(b)) || ASCII(max(b)), min(b), max(b) from t1 group by a1,a2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT",
      "ORD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      },
      {
        "expression": "ORD(string)",
        "description": "The ORD() function returns the Unicode code point of the first character of a string.",
        "examples": [
          "SELECT ORD('A');",
          "SELECT ORD('B');",
          "SELECT ORD('C') > 60;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      },
      {
        "expression": "ASCII(string)",
        "description": "MonetDB uses ASCII() to return the ASCII value of the first character in the string. It does not have a direct equivalent to ORD() for Unicode code points, but ASCII() can work for characters in the basic ASCII range.",
        "examples": [
          "SELECT ASCII('A');",
          "SELECT ASCII('B');",
          "SELECT ASCII('C') > 60;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');"
    ],
    "target_related_schemas": [
      "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');"
    ]
  },
  {
    "sql_id": "monetdb_11_3",
    "database_name": "monetdb_11_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select Fld1, max(Fld2) from t1 group by Fld1 having std(Fld2) is not null; -- STD",
    "target_query": "select Fld1, max(Fld2) from t1 group by Fld1 having stddev_samp(Fld2) is not null;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STD(expression)",
        "description": "Calculates the standard deviation for the sample of a given expression.",
        "examples": [
          "SELECT some_dimension, COUNT(*), MIN(some_expression), MAX(some_expression), SUM(some_expression), AVG(some_expression), STD(some_expression) FROM some_data GROUP BY some_dimension LIMIT 5;",
          "SELECT another_dimension, COUNT(*), STD(expression1 / expression2) FROM another_data GROUP BY another_dimension ORDER BY another_dimension;",
          "SELECT ROUND(STD(expression1 / expression2), 5) FROM more_data;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "stddev_samp(expression)",
        "description": "Calculates the standard deviation for the sample of a given expression.",
        "examples": [
          "SELECT some_dimension, COUNT(*), MIN(some_expression), MAX(some_expression), SUM(some_expression), AVG(some_expression), stddev_samp(some_expression) FROM some_data GROUP BY some_dimension LIMIT 5;",
          "SELECT another_dimension, COUNT(*), stddev_samp(expression1 / expression2) FROM another_data GROUP BY another_dimension ORDER BY another_dimension;",
          "SELECT ROUND(stddev_samp(expression1 / expression2), 5) FROM more_data;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (Fld1 int(11) default NULL,Fld2 int(11) default NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (Fld1 int default NULL,Fld2 int default NULL);"
    ]
  },
  {
    "sql_id": "monetdb_12_8",
    "database_name": "monetdb_12_8",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "insert into t3 select concat('c-', 1000+A.a, '=w'), concat('c-', 2000+A.a, '=w'),'filler-1' from t2 A; -- CONCAT",
    "target_query": "INSERT INTO t3 SELECT 'c-' || CAST(1000+A.a AS STRING) || '=w', 'c-' || CAST(2000+A.a AS STRING) || '=w', 'filler-1' FROM t2 A;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t3 (a char(8) not null, b char(8) not null, filler char(200));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t3 (a CHAR(8) NOT NULL, b CHAR(8) NOT NULL, filler CHAR(200));"
    ]
  },
  {
    "sql_id": "monetdb_12_9",
    "database_name": "monetdb_12_9",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "insert into t3 select concat('c-', 1000+A.a, '=w'), concat('c-', 3000+A.a, '=w'),'filler-2' from t2 A; -- CONCAT",
    "target_query": "INSERT INTO t3 SELECT 'c-' || CAST(1000+A.a AS STRING) || '=w', 'c-' || CAST(3000+A.a AS STRING) || '=w', 'filler-2' FROM t2 A;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t3 (a char(8) not null, b char(8) not null, filler char(200));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t3 (a CHAR(8) NOT NULL, b CHAR(8) NOT NULL, filler CHAR(200));"
    ]
  },
  {
    "sql_id": "monetdb_12_23",
    "database_name": "monetdb_12_23",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "update t1 set b=repeat(char(65+a), 20) where a < 25; -- REPEAT",
    "target_query": "UPDATE t1 SET b=REPEAT(CAST(65+a AS CHAR), 20) WHERE a < 25;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t0 (a int);",
      "create table t1 (a int, b char(20), filler char(200));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0 (a INT);",
      "CREATE TABLE t1 (a INT, b char(20), filler CHAR(200));"
    ]
  },
  {
    "sql_id": "monetdb_12_24",
    "database_name": "monetdb_12_24",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "explain select * from t1 where a < 10 and b = repeat(char(65+a), 20); -- REPEAT",
    "target_query": "EXPLAIN SELECT * FROM t1 WHERE a < 10 AND b = REPEAT(CAST(65+a AS CHAR), 20);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t0 (a int);",
      "create table t1 (a int, b char(20), filler char(200));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0 (a INT);",
      "CREATE TABLE t1 (a INT, b char(20), filler CHAR(200));"
    ]
  },
  {
    "sql_id": "monetdb_12_25",
    "database_name": "monetdb_12_25",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select * from t1 where a < 10 and b = repeat(char(65+a), 20); -- REPEAT",
    "target_query": "SELECT * FROM t1 WHERE a < 10 AND b = REPEAT(CAST(65+a AS CHAR), 20);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t0 (a int);",
      "create table t1 (a int, b char(20), filler char(200));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0 (a INT);",
      "CREATE TABLE t1 (a INT, b char(20), filler CHAR(200));"
    ]
  },
  {
    "sql_id": "monetdb_14_3",
    "database_name": "monetdb_14_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "UPDATE t1 set data=repeat('a',18*1024); -- REPEAT",
    "target_query": "UPDATE t1 set data=repeat('a',18*1024);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (data LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (data BLOB);"
    ]
  },
  {
    "sql_id": "monetdb_14_4",
    "database_name": "monetdb_14_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select length(data) from t1; -- LENGTH",
    "target_query": "select octet_length(data) from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (data LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (data BLOB);"
    ]
  },
  {
    "sql_id": "monetdb_14_7",
    "database_name": "monetdb_14_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 (data) VALUES (repeat('a',1*1024)); -- REPEAT",
    "target_query": "INSERT INTO t1 (data) VALUES (repeat('a',1*1024));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (data LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (data BLOB);"
    ]
  },
  {
    "sql_id": "monetdb_14_8",
    "database_name": "monetdb_14_8",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 (data) VALUES (repeat('b',16*1024-1024)); -- REPEAT",
    "target_query": "INSERT INTO t1 (data) VALUES (repeat('b',16*1024-1024));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (data LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (data BLOB);"
    ]
  },
  {
    "sql_id": "monetdb_14_10",
    "database_name": "monetdb_14_10",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "UPDATE t1 set data=repeat('c',17*1024); -- REPEAT",
    "target_query": "UPDATE t1 set data=repeat('c',17*1024);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (data LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (data BLOB);"
    ]
  },
  {
    "sql_id": "monetdb_14_13",
    "database_name": "monetdb_14_13",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 set data=repeat('a',18*1024); -- REPEAT",
    "target_query": "INSERT INTO t1 (data) VALUES (repeat('a', 18*1024));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (data LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (data BLOB);"
    ]
  },
  {
    "sql_id": "monetdb_14_14",
    "database_name": "monetdb_14_14",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select length(data) from t1; -- LENGTH",
    "target_query": "select octet_length(data) from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (data LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (data BLOB);"
    ]
  },
  {
    "sql_id": "monetdb_15_0",
    "database_name": "monetdb_15_0",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT UNIX_TIMESTAMP('2011-01-01 00:00:00') as time_t,UNIX_TIMESTAMP('2011-01-01 00:00:00') % 3 as part,1234567890 % 3 as part2; -- UNIX_TIMESTAMP",
    "target_query": "SELECT '2011-01-01 00:00:00' AS time_t, EXTRACT(EPOCH FROM TIMESTAMP '2011-01-01 00:00:00') % 3 AS part, 1234567890 % 3 AS part2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_15_3",
    "database_name": "monetdb_15_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t3 (a) VALUES (NOW()); -- NOW",
    "target_query": "INSERT INTO t3 (a) VALUES (CURRENT_TIMESTAMP);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t3(a timestamp,b char(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t3(a TIMESTAMP, b CHAR(10));"
    ]
  },
  {
    "sql_id": "monetdb_15_13",
    "database_name": "monetdb_15_13",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t2 VALUES (1 + (SELECT a FROM t1),CONCAT(\"subq: \", (SELECT b FROM t1))); -- CONCAT",
    "target_query": "INSERT INTO t2 SELECT 1 + a, 'subq: ' || b FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 (a INT, b VARCHAR(64));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (a INT, b VARCHAR(64));"
    ]
  },
  {
    "sql_id": "monetdb_17_2",
    "database_name": "monetdb_17_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a' IN 'abc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_17_3",
    "database_name": "monetdb_17_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('b' IN 'abc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_17_4",
    "database_name": "monetdb_17_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('c' IN 'abc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_17_5",
    "database_name": "monetdb_17_5",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('d' IN 'abc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_17_6",
    "database_name": "monetdb_17_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a' IN NULL);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_17_7",
    "database_name": "monetdb_17_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION(NULL IN 'a');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_17_8",
    "database_name": "monetdb_17_8",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( NULL, NULL ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION(NULL IN NULL);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_17_9",
    "database_name": "monetdb_17_9",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT hex( concat(regexp_instr( 'a', 'a' )) ); -- HEX, CONCAT, REGEXP_INSTR",
    "target_query": "SELECT 'a' || POSITION('a' IN 'a');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "CONCAT",
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      },
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "",
        "description": "",
        "examples": []
      },
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      },
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_17_10",
    "database_name": "monetdb_17_10",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( 1, 'a' ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a' IN CAST(1 AS STRING));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_17_11",
    "database_name": "monetdb_17_11",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( 1.1, 'a' ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a' IN CAST(1.1 AS STRING));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_17_12",
    "database_name": "monetdb_17_12",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( 'a', 1 ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION(CAST(1 AS STRING) IN 'a');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_17_13",
    "database_name": "monetdb_17_13",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( 'a', 1.1 ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION(CAST(1.1 AS STRING) IN 'a');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_17_14",
    "database_name": "monetdb_17_14",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( subject, pattern ) FROM t1; -- REGEXP_INSTR",
    "target_query": "SELECT POSITION(pattern IN subject) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (subject char(10),pattern char(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (subject char(10),pattern char(10));"
    ]
  },
  {
    "sql_id": "monetdb_17_15",
    "database_name": "monetdb_17_15",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1 ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a+' IN 'abcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_17_16",
    "database_name": "monetdb_17_16",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 2 ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a+' IN 'bcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_17_17",
    "database_name": "monetdb_17_17",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'b+', 1 ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('b+' IN 'abcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_17_18",
    "database_name": "monetdb_17_18",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'b+', 2 ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('b+' IN 'cabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_17_19",
    "database_name": "monetdb_17_19",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'b+', 3 ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('b+' IN 'abcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_17_20",
    "database_name": "monetdb_17_20",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 2 ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a+' IN 'abcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_17_21",
    "database_name": "monetdb_17_21",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 3 ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a+' IN 'bcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_17_22",
    "database_name": "monetdb_17_22",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 4 ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a+' IN 'cabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_17_23",
    "database_name": "monetdb_17_23",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 4, 2 ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a+' IN 'abcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_17_24",
    "database_name": "monetdb_17_24",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( 'a', 'a+', 1, 1, NULL ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a+' IN 'a');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_17_25",
    "database_name": "monetdb_17_25",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 0 ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a+' IN 'abcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_17_26",
    "database_name": "monetdb_17_26",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 1 ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a+' IN 'abcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_17_27",
    "database_name": "monetdb_17_27",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( 'aaabcabcabc', 'a+', 1, 1, 1 ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a+' IN 'aaabcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_17_28",
    "database_name": "monetdb_17_28",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'c' ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('A+' IN 'aaabcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_17_29",
    "database_name": "monetdb_17_29",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'i' ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('A+' IN 'aaabcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_17_30",
    "database_name": "monetdb_17_30",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'ci' ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('A+' IN 'aaabcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_17_31",
    "database_name": "monetdb_17_31",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'cic' ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('A+' IN 'aaabcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_17_32",
    "database_name": "monetdb_17_32",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_instr( 'a', 'a+', 1, 1, 1, NULL ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a+' IN 'a');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_18_0",
    "database_name": "monetdb_18_0",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_replace( 'aaa', 'a', 'X' ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace( 'aaa', 'a', 'X' );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_18_1",
    "database_name": "monetdb_18_1",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace( 'abc', 'b', 'X' );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_18_2",
    "database_name": "monetdb_18_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_replace( NULL, 'a', 'X' ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace( NULL, 'a', 'X' );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_18_3",
    "database_name": "monetdb_18_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_replace( 'aaa', NULL, 'X' ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace( 'aaa', NULL, 'X' );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_18_4",
    "database_name": "monetdb_18_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_replace( 'aaa', 'a', NULL ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace( 'aaa', 'a', NULL );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_18_5",
    "database_name": "monetdb_18_5",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT concat( regexp_replace( 'aaa', 'a', 'X' ), 'x' ); -- CONCAT, REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace( 'aaa', 'a', 'X' ) || 'x';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT",
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      },
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      },
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_18_6",
    "database_name": "monetdb_18_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_replace( 'aaa', 'a', 'X', 1 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace( 'aaa', 'a', 'X' );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_18_7",
    "database_name": "monetdb_18_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 1 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_18_8",
    "database_name": "monetdb_18_8",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 2 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_18_9",
    "database_name": "monetdb_18_9",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>', 1, 2 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>' );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_18_10",
    "database_name": "monetdb_18_10",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x', 1, 0 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x' );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_18_11",
    "database_name": "monetdb_18_11",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x', 1, 0 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x' );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_18_12",
    "database_name": "monetdb_18_12",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_replace( 'aaab', 'b', 'x', 1, 2 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace( 'aaab', 'b', 'x' );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_18_13",
    "database_name": "monetdb_18_13",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_replace( 'aaabccc', 'b', 'x', 1, 2 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace( 'aaabccc', 'b', 'x' );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_18_14",
    "database_name": "monetdb_18_14",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace( 'abc', 'b', 'X' );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_18_15",
    "database_name": "monetdb_18_15",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_replace( 'abcbdb', 'b', 'X' ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace( 'abcbdb', 'b', 'X' );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_18_16",
    "database_name": "monetdb_18_16",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_replace( 'abcbdb', 'b', 'X', 3 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace( 'abcbdb', 'b', 'X' );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_18_17",
    "database_name": "monetdb_18_17",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 1 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace( 'aaabcbdb', 'b', 'X' );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_18_18",
    "database_name": "monetdb_18_18",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 2 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace( 'aaabcbdb', 'b', 'X' );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_18_19",
    "database_name": "monetdb_18_19",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 3 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace( 'aaabcbdb', 'b', 'X' );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_18_20",
    "database_name": "monetdb_18_20",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_replace( 'aaa', 'a', 'X', 2 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace( 'aaa', 'a', 'X' );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_18_21",
    "database_name": "monetdb_18_21",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_replace( 'aaa', 'a', 'XX', 2 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace( 'aaa', 'a', 'XX' );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_19_2",
    "database_name": "monetdb_19_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 VALUES ( regexp_instr('a', 'a'),regexp_instr('a', 'a'),regexp_instr('a', 'a'),regexp_instr('a', 'a') ); -- REGEXP_INSTR",
    "target_query": "INSERT INTO t1 VALUES (CAST(POSITION('a' IN 'a') AS REAL), CAST(POSITION('a' IN 'a') AS INT), CAST(POSITION('a' IN 'a') AS CHAR(100)), CAST(POSITION('a' IN 'a') AS DECIMAL));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(a REAL,b INT,c CHAR(100),d DECIMAL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(a REAL, b INT, c CHAR(100), d DECIMAL);"
    ]
  },
  {
    "sql_id": "monetdb_19_6",
    "database_name": "monetdb_19_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 ( c ) VALUES ( regexp_replace('a', 'a', 'a') ); -- REGEXP_REPLACE",
    "target_query": "INSERT INTO t1 ( c ) VALUES ( regexp_replace('a', 'a', 'a') );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(a REAL,b INT,c CHAR(100),d DECIMAL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(a REAL, b INT, c CHAR(100), d DECIMAL);"
    ]
  },
  {
    "sql_id": "monetdb_19_10",
    "database_name": "monetdb_19_10",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT length(regexp_replace( repeat('a', 'b'), 'a', 'b' )); -- LENGTH, REGEXP_REPLACE, REPEAT",
    "target_query": "SELECT octet_length(regexp_replace( repeat('a', 1), 'a', 'b' ));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH",
      "REGEXP_REPLACE",
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      },
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      },
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      },
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
        ]
      },
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_19_12",
    "database_name": "monetdb_19_12",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 VALUES ( repeat( 'a', 16384 ) ); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES ( repeat( 'a', 16384 ) );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a TEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a TEXT);"
    ]
  },
  {
    "sql_id": "monetdb_19_13",
    "database_name": "monetdb_19_13",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT char_length ( regexp_replace( a, 'a', 'b' ) ) FROM t1; -- CHAR_LENGTH, REGEXP_REPLACE",
    "target_query": "SELECT char_length ( regexp_replace( a, 'a', 'b' ) ) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CHAR_LENGTH",
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CHAR_LENGTH(expr)",
        "description": "Returns the number of characters in the string, not bytes.",
        "examples": [
          "SELECT CHAR_LENGTH('abc');",
          "SELECT CHAR_LENGTH('你好');",
          "SELECT CHAR_LENGTH('a你b好c');"
        ]
      },
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "char_length(expr)",
        "description": "Returns the number of characters in a string (char_length and length are equivalent).",
        "examples": [
          "SELECT char_length('abc');",
          "SELECT char_length('你好');",
          "SELECT char_length('a你b好c');"
        ]
      },
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a TEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a TEXT);"
    ]
  },
  {
    "sql_id": "monetdb_19_17",
    "database_name": "monetdb_19_17",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT regexp_replace(a, '^([[:alpha:]]+)[[:space:]].*$', '$1') FROM t1; -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace(a, '^([[:alpha:]]+)[[:space:]].*$', '$1') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a VARCHAR(10) );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a VARCHAR(10) );"
    ]
  },
  {
    "sql_id": "monetdb_19_21",
    "database_name": "monetdb_19_21",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "UPDATE t1 SET a = regexp_replace ( 'b', 'b', 'y' ); -- REGEXP_REPLACE",
    "target_query": "UPDATE t1 SET a = regexp_replace ( 'b', 'b', 'y' );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a CHAR(3) );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a CHAR(3) );"
    ]
  },
  {
    "sql_id": "monetdb_20_2",
    "database_name": "monetdb_20_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT SUM(DISTINCT LENGTH(name)) s1 FROM t1; -- LENGTH",
    "target_query": "SELECT SUM(DISTINCT octet_length(name)) s1 FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (id INTEGER NOT NULL PRIMARY KEY,gender CHAR(1),name VARCHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id INTEGER NOT NULL PRIMARY KEY,gender CHAR(1),name VARCHAR(20));"
    ]
  },
  {
    "sql_id": "monetdb_20_6",
    "database_name": "monetdb_20_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT SUM(DISTINCT LENGTH(name)) s1 FROM t1; -- LENGTH",
    "target_query": "SELECT SUM(DISTINCT octet_length(name)) s1 FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (id INTEGER NOT NULL PRIMARY KEY,gender CHAR(1),name VARCHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id INTEGER NOT NULL PRIMARY KEY,gender CHAR(1),name VARCHAR(20));"
    ]
  },
  {
    "sql_id": "monetdb_20_10",
    "database_name": "monetdb_20_10",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT (SELECT SUM(DISTINCT LENGTH(name)) FROM t1) FROM t2; -- LENGTH",
    "target_query": "SELECT (SELECT SUM(DISTINCT octet_length(name)) FROM t1) FROM t2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 SELECT name FROM t1;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 AS SELECT name FROM t1;"
    ]
  },
  {
    "sql_id": "monetdb_20_13",
    "database_name": "monetdb_20_13",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t2 VALUES (1,'18:19:29',NOW()); -- NOW",
    "target_query": "INSERT INTO t2 VALUES (1,'18:19:29',CURRENT_TIMESTAMP);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 (pk int(11) NOT NULL PRIMARY KEY,time_nokey time DEFAULT NULL,datetime_key time DEFAULT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (pk int NOT NULL PRIMARY KEY,time_nokey time DEFAULT NULL,datetime_key time DEFAULT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_22_0",
    "database_name": "monetdb_22_0",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT LEAST(CAST('01-01-01' AS DATETIME), '01-01:02'); -- LEAST",
    "target_query": "SELECT CASE WHEN CAST('2001-01-01 00:00:01' AS TIMESTAMP) <= CAST('2001-01-01 00:00:02' AS TIMESTAMP) THEN CAST('2001-01-01 00:00:01' AS TIMESTAMP) ELSE CAST('2001-01-01 00:00:02' AS TIMESTAMP) END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN ... THEN ... END",
        "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
        "examples": [
          "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
          "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
          "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_22_1",
    "database_name": "monetdb_22_1",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT LEAST(CAST('2001-12-10' AS DATE), '2001-12/11'); -- LEAST",
    "target_query": "SELECT CASE WHEN CAST('2001-12-10' AS DATE) <= CAST('2001-12-11' AS DATE) THEN CAST('2001-12-10' AS DATE) ELSE CAST('2001-12-11' AS DATE) END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN ... THEN ... END",
        "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
        "examples": [
          "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
          "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
          "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_22_2",
    "database_name": "monetdb_22_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT LEAST(CAST('10:11:12' AS TIME), '10:11:13 '); -- LEAST",
    "target_query": "SELECT CASE WHEN CAST('10:11:12' AS TIME) <= CAST('10:11:13' AS TIME) THEN CAST('10:11:12' AS TIME) ELSE CAST('10:11:13' AS TIME) END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN ... THEN ... END",
        "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
        "examples": [
          "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
          "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
          "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_23_3",
    "database_name": "monetdb_23_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "insert into t1 (i, ts) values(unix_timestamp('2003-03-01 00:00:00'),'2003-03-01 00:00:00'); -- UNIX_TIMESTAMP",
    "target_query": "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-01 00:00:00') AS BIGINT), '2003-03-01 00:00:00');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (i int, ts timestamp);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (i BIGINT, ts TIMESTAMP);"
    ]
  },
  {
    "sql_id": "monetdb_23_4",
    "database_name": "monetdb_23_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "insert into t1 (i, ts) values(unix_timestamp('2003-03-30 01:59:59'),'2003-03-30 01:59:59'),(unix_timestamp('2003-03-30 02:30:00'),'2003-03-30 02:30:00'),(unix_timestamp('2003-03-30 03:00:00'),'2003-03-30 03:00:00'); -- UNIX_TIMESTAMP",
    "target_query": "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59') AS BIGINT), '2003-03-30 01:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00') AS BIGINT), '2003-03-30 02:30:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00') AS BIGINT), '2003-03-30 03:00:00');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (i int, ts timestamp);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (i BIGINT, ts TIMESTAMP);"
    ]
  },
  {
    "sql_id": "monetdb_23_6",
    "database_name": "monetdb_23_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "insert into t1 (i, ts) values(unix_timestamp('2003-05-01 00:00:00'),'2003-05-01 00:00:00'); -- UNIX_TIMESTAMP",
    "target_query": "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-05-01 00:00:00') AS BIGINT), '2003-05-01 00:00:00');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (i int, ts timestamp);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (i BIGINT, ts TIMESTAMP);"
    ]
  },
  {
    "sql_id": "monetdb_23_7",
    "database_name": "monetdb_23_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "insert into t1 (i, ts) values(unix_timestamp('2003-10-26 01:00:00'),'2003-10-26 01:00:00'),(unix_timestamp('2003-10-26 02:00:00'),'2003-10-26 02:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'),(unix_timestamp('2003-10-26 04:00:00'),'2003-10-26 04:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'); -- UNIX_TIMESTAMP",
    "target_query": "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 01:00:00') AS BIGINT), '2003-10-26 01:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:00:00') AS BIGINT), '2003-10-26 02:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59') AS BIGINT), '2003-10-26 02:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 04:00:00') AS BIGINT), '2003-10-26 04:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59') AS BIGINT), '2003-10-26 02:59:59');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (i int, ts timestamp);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (i BIGINT, ts TIMESTAMP);"
    ]
  },
  {
    "sql_id": "monetdb_23_10",
    "database_name": "monetdb_23_10",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select from_unixtime(362793609); -- FROM_UNIXTIME",
    "target_query": "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '362793609' SECOND;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FROM_UNIXTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
        "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
          "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '<seconds>' SECOND",
        "description": "Adds seconds to the UNIX epoch by using an INTERVAL expression with a string constant representing the number of seconds.",
        "examples": [
          "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000' SECOND;",
          "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000.987' SECOND;",
          "SELECT CAST(TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000' SECOND AS STRING);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_23_12",
    "database_name": "monetdb_23_12",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "insert into t1 (ts) values (now()); -- NOW",
    "target_query": "INSERT INTO t1 (ts) VALUES (CURRENT_TIMESTAMP);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (ts timestamp);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (ts TIMESTAMP);"
    ]
  },
  {
    "sql_id": "monetdb_23_15",
    "database_name": "monetdb_23_15",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 VALUES('2003-03-30 01:59:59', 'Before the gap'),('2003-03-30 02:30:00', 'Inside the gap'),('2003-03-30 03:00:00',  'After the gap'); -- UNIX_TIMESTAMP",
    "target_query": "INSERT INTO t1 VALUES ('2003-03-30 01:59:59', 'Before the gap'), ('2003-03-30 02:30:00', 'Inside the gap'), ('2003-03-30 03:00:00', 'After the gap');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a TIMESTAMP, b VARCHAR(30));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a TIMESTAMP, b VARCHAR(30));"
    ]
  },
  {
    "sql_id": "monetdb_23_18",
    "database_name": "monetdb_23_18",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT UNIX_TIMESTAMP('2003-03-30 01:59:59'), 'Before the gap' AS b; -- UNIX_TIMESTAMP",
    "target_query": "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59') AS BIGINT), 'Before the gap' AS b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_23_19",
    "database_name": "monetdb_23_19",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT UNIX_TIMESTAMP('2003-03-30 02:30:00'), 'Inside the gap' AS b; -- UNIX_TIMESTAMP",
    "target_query": "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00') AS BIGINT), 'Inside the gap' AS b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_23_20",
    "database_name": "monetdb_23_20",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT UNIX_TIMESTAMP('2003-03-30 03:00:00'), 'After the gap' AS b; -- UNIX_TIMESTAMP",
    "target_query": "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00') AS BIGINT), 'After the gap' AS b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_23_21",
    "database_name": "monetdb_23_21",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT FROM_UNIXTIME(0); -- FROM_UNIXTIME",
    "target_query": "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '0' SECOND;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FROM_UNIXTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
        "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
          "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '<seconds>' SECOND",
        "description": "Adds seconds to the UNIX epoch by using an INTERVAL expression with a string constant representing the number of seconds.",
        "examples": [
          "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000' SECOND;",
          "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000.987' SECOND;",
          "SELECT CAST(TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000' SECOND AS STRING);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_23_22",
    "database_name": "monetdb_23_22",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT UNIX_TIMESTAMP(\"1969-12-31 15:59:59\"); -- UNIX_TIMESTAMP",
    "target_query": "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '1969-12-31 15:59:59') AS BIGINT);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_23_23",
    "database_name": "monetdb_23_23",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT UNIX_TIMESTAMP(\"1969-12-31 16:00:00\"); -- UNIX_TIMESTAMP",
    "target_query": "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '1969-12-31 16:00:00') AS BIGINT);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_23_24",
    "database_name": "monetdb_23_24",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT UNIX_TIMESTAMP(\"1969-12-31 16:00:01\"); -- UNIX_TIMESTAMP",
    "target_query": "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '1969-12-31 16:00:01') AS BIGINT);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_23_25",
    "database_name": "monetdb_23_25",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT UNIX_TIMESTAMP(\"1970-01-01 00:00:01\"); -- UNIX_TIMESTAMP",
    "target_query": "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '1970-01-01 00:00:01') AS BIGINT);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_23_26",
    "database_name": "monetdb_23_26",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT UNIX_TIMESTAMP(\"2022-01-01 16:00:01\"); -- UNIX_TIMESTAMP",
    "target_query": "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '2022-01-01 16:00:01') AS BIGINT);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_24_3",
    "database_name": "monetdb_24_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select hex(a) from t1; -- HEX",
    "target_query": "SELECT a FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "",
        "description": "",
        "examples": []
      }
    ],
    "source_related_schemas": [
      "create table t1 (a bit(64));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a blob);"
    ]
  },
  {
    "sql_id": "monetdb_24_7",
    "database_name": "monetdb_24_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select hex(a) from t1; -- HEX",
    "target_query": "SELECT a FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "",
        "description": "",
        "examples": []
      }
    ],
    "source_related_schemas": [
      "create table t1 (a bit);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a blob);"
    ]
  },
  {
    "sql_id": "monetdb_24_11",
    "database_name": "monetdb_24_11",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select hex(min(a)) from t1; -- HEX, MIN",
    "target_query": "SELECT MIN(a) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "MIN"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "",
        "description": "",
        "examples": []
      },
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a bit(7), b bit(9));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a blob, b blob);"
    ]
  },
  {
    "sql_id": "monetdb_24_12",
    "database_name": "monetdb_24_12",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select hex(min(b)) from t1; -- HEX, MIN",
    "target_query": "SELECT MIN(b) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "MIN"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "",
        "description": "",
        "examples": []
      },
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a bit(7), b bit(9));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a blob, b blob);"
    ]
  },
  {
    "sql_id": "monetdb_24_13",
    "database_name": "monetdb_24_13",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select hex(min(a)), hex(max(a)), hex(min(b)), hex(max(b)) from t1; -- HEX, MIN, MAX",
    "target_query": "SELECT MIN(a), MAX(a), MIN(b), MAX(b) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "MIN",
      "MAX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      },
      {
        "expression": "MAX(expr)",
        "description": "Returns the maximum value of the expression in an aggregation context.",
        "examples": [
          "SELECT MAX(10), MAX(5), MAX(20);",
          "SELECT MAX('apple'), MAX('banana'), MAX('pear');",
          "SELECT MAX(ABS(-5)), MAX(ABS(3));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "",
        "description": "",
        "examples": []
      },
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      },
      {
        "expression": "MAX(expr)",
        "description": "Aggregates the maximum value of the input expression.",
        "examples": [
          "SELECT MAX(2), MAX(4), MAX(8);",
          "SELECT MAX('lion'), MAX('tiger'), MAX('bear');",
          "SELECT MAX(sqrt(16)), MAX(sqrt(25));"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a bit(7), b bit(9));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a blob, b blob);"
    ]
  },
  {
    "sql_id": "monetdb_24_17",
    "database_name": "monetdb_24_17",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select hex(min(b)) from t1 where a = 4; -- HEX, MIN",
    "target_query": "SELECT MIN(b) FROM t1 WHERE a = 4;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "MIN"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "",
        "description": "",
        "examples": []
      },
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a int not null, b bit, c bit(9));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT NOT NULL, b blob, c blob);"
    ]
  },
  {
    "sql_id": "monetdb_24_19",
    "database_name": "monetdb_24_19",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select hex(max(b)) from t1; -- HEX",
    "target_query": "SELECT MAX(b) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "",
        "description": "",
        "examples": []
      }
    ],
    "source_related_schemas": [
      "create table t1 (a int not null, b bit, c bit(9));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT NOT NULL, b blob, c blob);"
    ]
  },
  {
    "sql_id": "monetdb_25_3",
    "database_name": "monetdb_25_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT HEX(b), i2 FROM t1 WHERE (i2>=100 AND i2<201) AND b=TRUE; -- HEX",
    "target_query": "SELECT b, i2 FROM t1 WHERE (i2 >= 100 AND i2 < 201) AND b = TRUE;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "",
        "description": "",
        "examples": []
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (b BIT NOT NULL, i2 INTEGER NOT NULL, s VARCHAR(255) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (b BOOLEAN NOT NULL, i2 INTEGER NOT NULL, s VARCHAR(255) NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_25_7",
    "database_name": "monetdb_25_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT HEX(b1), i2 FROM t2 WHERE (i2>=100 AND i2<201) AND b1=TRUE; -- HEX",
    "target_query": "SELECT b1, i2 FROM t2 WHERE (i2 >= 100 AND i2 < 201) AND b1 = TRUE;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "",
        "description": "",
        "examples": []
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 (b1 BIT NOT NULL, b2 BIT NOT NULL, i2 INTEGER NOT NULL,s VARCHAR(255) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (b1 BOOLEAN NOT NULL, b2 BOOLEAN NOT NULL, i2 INTEGER NOT NULL, s VARCHAR(255) NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_25_8",
    "database_name": "monetdb_25_8",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT HEX(b2), i2 FROM t2 WHERE (i2>=100 AND i2<201) AND b2=FALSE; -- HEX",
    "target_query": "SELECT b2, i2 FROM t2 WHERE (i2 >= 100 AND i2 < 201) AND b2 = FALSE;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "",
        "description": "",
        "examples": []
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 (b1 BIT NOT NULL, b2 BIT NOT NULL, i2 INTEGER NOT NULL,s VARCHAR(255) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (b1 BOOLEAN NOT NULL, b2 BOOLEAN NOT NULL, i2 INTEGER NOT NULL, s VARCHAR(255) NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_25_13",
    "database_name": "monetdb_25_13",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT HEX(GROUP_CONCAT(DISTINCT b)) FROM t1 GROUP BY a; -- HEX, GROUP_CONCAT",
    "target_query": "SELECT group_concat(DISTINCT b) FROM t1 GROUP BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "GROUP_CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
        "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "",
        "description": "",
        "examples": []
      },
      {
        "expression": "group_concat(X) group_concat(X,Y)",
        "description": "The group_concat(X,Y) function returns a string which is the concatenation of all non-NULL values of X. If parameter Y is present, it is used as the separator between values. A comma (\",\") is used as the default separator if Y is omitted.\n\nThe order of concatenated elements is arbitrary unless an ORDER BY clause is explicitly used.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns names separated by commas",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by ' | '",
          "SELECT department, group_concat(name, '; ') FROM employees GROUP BY department; -- Groups names by department"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a INT, b BIT(2));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT, b SMALLINT);"
    ]
  },
  {
    "sql_id": "monetdb_25_15",
    "database_name": "monetdb_25_15",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT HEX(t2.b) FROM t2; -- HEX",
    "target_query": "SELECT t2.b FROM t2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "",
        "description": "",
        "examples": []
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a INT, b BIT(2));",
      "CREATE TABLE t2 AS SELECT DISTINCT b FROM t1;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT, b SMALLINT);",
      "CREATE TABLE t2 AS SELECT DISTINCT b FROM t1;"
    ]
  },
  {
    "sql_id": "monetdb_25_16",
    "database_name": "monetdb_25_16",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT a, HEX(b) FROM t1 ORDER BY b; -- HEX",
    "target_query": "SELECT a, b FROM t1 ORDER BY b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "",
        "description": "",
        "examples": []
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a INT, b BIT(2));",
      "CREATE TABLE t2 AS SELECT DISTINCT b FROM t1;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT, b SMALLINT);",
      "CREATE TABLE t2 AS SELECT DISTINCT b FROM t1;"
    ]
  },
  {
    "sql_id": "monetdb_26_3",
    "database_name": "monetdb_26_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select hex(a) from t1 order by a; -- HEX",
    "target_query": "select a from t1 order by a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "",
        "description": "",
        "examples": []
      }
    ],
    "source_related_schemas": [
      "CREATE table t1 (a blob);"
    ],
    "target_related_schemas": [
      "CREATE table t1 (a blob);"
    ]
  },
  {
    "sql_id": "monetdb_26_4",
    "database_name": "monetdb_26_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select hex(concat(a,'\\\\0')) as b from t1 order by concat(a,'\\\\0'); -- HEX, CONCAT",
    "target_query": "select (a || '\\\\0') as b from t1 order by (a || '\\\\0');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "",
        "description": "",
        "examples": []
      },
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE table t1 (a blob);"
    ],
    "target_related_schemas": [
      "CREATE table t1 (a blob);"
    ]
  },
  {
    "sql_id": "monetdb_26_6",
    "database_name": "monetdb_26_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select hex(a) from t1 order by a; -- HEX",
    "target_query": "select a from t1 order by a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "",
        "description": "",
        "examples": []
      }
    ],
    "source_related_schemas": [
      "CREATE table t1 (a blob);"
    ],
    "target_related_schemas": [
      "CREATE table t1 (a blob);"
    ]
  },
  {
    "sql_id": "monetdb_26_10",
    "database_name": "monetdb_26_10",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t (c) VALUES (REPEAT('3',65535)); -- REPEAT",
    "target_query": "INSERT INTO t (c) VALUES (REPEAT('3',65535));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t (c TEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t (c TEXT);"
    ]
  },
  {
    "sql_id": "monetdb_26_11",
    "database_name": "monetdb_26_11",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT LENGTH(c), CHAR_LENGTH(c) FROM t; -- LENGTH, CHAR_LENGTH",
    "target_query": "SELECT octet_length(c), char_length(c) FROM t;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH",
      "CHAR_LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      },
      {
        "expression": "CHAR_LENGTH(expr)",
        "description": "Returns the number of characters in the string, not bytes.",
        "examples": [
          "SELECT CHAR_LENGTH('abc');",
          "SELECT CHAR_LENGTH('你好');",
          "SELECT CHAR_LENGTH('a你b好c');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      },
      {
        "expression": "char_length(expr)",
        "description": "Returns the number of characters in a string (char_length and length are equivalent).",
        "examples": [
          "SELECT char_length('abc');",
          "SELECT char_length('你好');",
          "SELECT char_length('a你b好c');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t (c TEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t (c TEXT);"
    ]
  },
  {
    "sql_id": "monetdb_26_16",
    "database_name": "monetdb_26_16",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT LENGTH(c) FROM t2; -- LENGTH",
    "target_query": "SELECT octet_length(c) FROM t2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2(id INT NOT NULL, c TEXT NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2(id INT NOT NULL, c TEXT NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_27_0",
    "database_name": "monetdb_27_0",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select least(-1.1111111111111111111111111,- group_concat(1.7976931348623157E+308)) as foo; -- LEAST, GROUP_CONCAT",
    "target_query": "SELECT CASE WHEN -1.1111111111111111111111111 <= -GROUP_CONCAT(1.7976931348623157E+308) THEN -1.1111111111111111111111111 ELSE -GROUP_CONCAT(1.7976931348623157E+308) END AS foo;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST",
      "GROUP_CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      },
      {
        "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
        "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN ... THEN ... END",
        "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
        "examples": [
          "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
          "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
          "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
        ]
      },
      {
        "expression": "group_concat(X) group_concat(X,Y)",
        "description": "The group_concat(X,Y) function returns a string which is the concatenation of all non-NULL values of X. If parameter Y is present, it is used as the separator between values. A comma (\",\") is used as the default separator if Y is omitted.\n\nThe order of concatenated elements is arbitrary unless an ORDER BY clause is explicitly used.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns names separated by commas",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by ' | '",
          "SELECT department, group_concat(name, '; ') FROM employees GROUP BY department; -- Groups names by department"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_28_7",
    "database_name": "monetdb_28_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "insert into t1 values (now()); -- NOW",
    "target_query": "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a timestamp NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a timestamp NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_28_8",
    "database_name": "monetdb_28_8",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select date_format(a,\"%Y %y\"),year(a),year(now()) from t1; -- DATE_FORMAT, YEAR, NOW",
    "target_query": "SELECT sys.timestamp_to_str(a, 'YYYY YY'), EXTRACT(YEAR FROM a), EXTRACT(YEAR FROM CURRENT_TIMESTAMP) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT",
      "YEAR",
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      },
      {
        "expression": "YEAR(date)",
        "description": "Extracts the year from a date or datetime and returns it as an integer.",
        "examples": [
          "SELECT YEAR('2023-04-10');",
          "SELECT YEAR(NOW());",
          "SELECT YEAR('2022-03-15');"
        ]
      },
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
        "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
        "examples": [
          "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
        ]
      },
      {
        "expression": "EXTRACT(YEAR FROM date)",
        "description": "Extracts the year from a date or datetime and returns it as an integer.",
        "examples": [
          "SELECT EXTRACT(YEAR FROM DATE '2023-04-10');",
          "SELECT EXTRACT(YEAR FROM CURRENT_DATE);",
          "SELECT EXTRACT(YEAR FROM DATE '2022-03-15');"
        ]
      },
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a timestamp NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a timestamp NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_28_10",
    "database_name": "monetdb_28_10",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT TIMESTAMP('2000-01-27','23:13:41') - TIMESTAMP('2003-05-16','23:53:29'); -- TIMESTAMP",
    "target_query": "SELECT CAST('2000-01-27 23:13:41' AS TIMESTAMP) - CAST('2003-05-16 23:53:29' AS TIMESTAMP);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
        "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
        "examples": [
          "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CAST('2023-06-15 10:30:45' AS TIMESTAMP)",
        "description": "MonetDB uses CAST to convert a date-time string to a TIMESTAMP value.",
        "examples": [
          "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP);",
          "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP);",
          "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP) > CAST('2023-06-14 10:30:45' AS TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_30_5",
    "database_name": "monetdb_30_5",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select length(v),length(c),length(e),length(t) from t1; -- LENGTH",
    "target_query": "select octet_length(v),octet_length(c),octet_length(e),octet_length(t) from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (v varchar(30), c char(3), e char(3), t text);"
    ],
    "target_related_schemas": [
      "create table t1 (v varchar(30), c char(3), e char(3), t text);"
    ]
  },
  {
    "sql_id": "monetdb_30_8",
    "database_name": "monetdb_30_8",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 VALUES(SUBSTR(f1, 1, 3)); -- SUBSTR",
    "target_query": "INSERT INTO t1 VALUES(substring('test' from 1 for 3));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "SUBSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
        "description": "The substr(str,pos[,len]) function returns a substring from string str starting at position pos.\nIf len is specified, returns a substring len characters long starting at position pos.\nIf pos is positive, the position is counted from the start of the string.\nIf pos is negative, the position is counted from the end of the string.\nlen must be positive. If len is omitted, returns all characters to the end of the string.\nReturns NULL if any argument is NULL.",
        "examples": [
          "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
          "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "substring(X from Y for Z)",
        "description": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
        "examples": [
          "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
          "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
          "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(f1 VARCHAR(100) DEFAULT 'test');"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(f1 VARCHAR(100) DEFAULT 'test');"
    ]
  },
  {
    "sql_id": "monetdb_30_12",
    "database_name": "monetdb_30_12",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT a,(a DIV 2) FROM t1 ORDER BY a; -- DIV",
    "target_query": "SELECT a,(FLOOR(CAST(a AS DOUBLE) / 2)) FROM t1 ORDER BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DIV"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "a DIV b",
        "description": "Performs integer division between two numbers and returns the floor of the quotient.",
        "examples": [
          "SELECT 10 DIV 3;",
          "SELECT 5.8 DIV 2;",
          "SELECT 9 DIV 4 + 1;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "FLOOR(a / b)",
        "description": "Evaluates division and applies FLOOR to get integer result.",
        "examples": [
          "SELECT FLOOR(10 / 3);",
          "SELECT FLOOR(5.8 / 2);",
          "SELECT FLOOR(9 / 4) + 1;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a CHAR(2));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a CHAR(2));"
    ]
  },
  {
    "sql_id": "monetdb_31_2",
    "database_name": "monetdb_31_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "insert into t1 values (now()); -- NOW",
    "target_query": "insert into t1 values (CURRENT_TIMESTAMP);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (y year);"
    ],
    "target_related_schemas": [
      "create table t1 (y date);"
    ]
  },
  {
    "sql_id": "monetdb_31_3",
    "database_name": "monetdb_31_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select if(y = now(), 1, 0) from t1; -- IF, NOW",
    "target_query": "select CASE WHEN y = CURRENT_TIMESTAMP THEN 1 ELSE 0 END from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF",
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      },
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      },
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (y year);"
    ],
    "target_related_schemas": [
      "create table t1 (y date);"
    ]
  },
  {
    "sql_id": "monetdb_31_9",
    "database_name": "monetdb_31_9",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT * FROM t4 WHERE yyyy = NOW(); -- NOW",
    "target_query": "SELECT * FROM t4 WHERE yyyy = EXTRACT(YEAR FROM CURRENT_TIMESTAMP);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t4(yyyy YEAR, c4 CHAR(4));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t4(yyyy int, c4 CHAR(4));"
    ]
  },
  {
    "sql_id": "monetdb_31_13",
    "database_name": "monetdb_31_13",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT LEAST(d, y) FROM t1; -- LEAST",
    "target_query": "SELECT CASE WHEN d <= y THEN d ELSE y END FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN ... THEN ... END",
        "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
        "examples": [
          "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
          "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
          "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(y YEAR,d DATE,i INTEGER,v VARCHAR(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(y date,d DATE,i INTEGER,v VARCHAR(10));"
    ]
  },
  {
    "sql_id": "monetdb_31_14",
    "database_name": "monetdb_31_14",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT LEAST(y, d) FROM t1; -- LEAST",
    "target_query": "SELECT CASE WHEN y <= d THEN y ELSE d END FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN ... THEN ... END",
        "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
        "examples": [
          "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
          "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
          "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(y YEAR,d DATE,i INTEGER,v VARCHAR(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(y date,d DATE,i INTEGER,v VARCHAR(10));"
    ]
  },
  {
    "sql_id": "monetdb_31_19",
    "database_name": "monetdb_31_19",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT TIMESTAMPDIFF(QUARTER, LEAST(y1, y2), dbl)FROM t1; -- TIMESTAMPDIFF, LEAST",
    "target_query": "SELECT CAST(CASE WHEN y1 <= y2 THEN y1 ELSE y2 END AS INT) - CAST(dbl AS INT) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMPDIFF",
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMPDIFF(unit, datetime1, datetime2)",
        "description": "Returns the difference between two datetime values in the specified unit.",
        "examples": [
          "SELECT TIMESTAMPDIFF(YEAR, '2001-01-01', '2005-01-01');  -- 4",
          "SELECT TIMESTAMPDIFF(MONTH, '2020-01-01', '2020-03-01');  -- 2",
          "SELECT TIMESTAMPDIFF(DAY, '2020-01-01', '2020-01-31');    -- 30"
        ]
      },
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CAST(end_date AS DATE) - CAST(start_date AS DATE)",
        "description": "MonetDB calculates the difference between two dates using UNIX timestamps (seconds since '1970-01-01 00:00:00'). The result is returned in seconds. For example, the difference between '2005-01-01' and '2001-01-01' in MonetDB is calculated in seconds, and this must be converted manually into days, months, or years by further calculations.",
        "examples": [
          "SELECT CAST(DATE '2005-01-01' AS DATE) - CAST(DATE '2001-01-01' AS DATE);  -- 126230400 seconds"
        ]
      },
      {
        "expression": "CASE WHEN ... THEN ... END",
        "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
        "examples": [
          "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
          "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
          "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (d DATE DEFAULT NULL,y1 YEAR DEFAULT NULL,y2 YEAR DEFAULT NULL,dbl DOUBLE DEFAULT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (d DATE DEFAULT NULL,y1 int DEFAULT NULL,y2 int DEFAULT NULL,dbl DOUBLE DEFAULT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_32_12",
    "database_name": "monetdb_32_12",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT y, CONCAT('\"', c, '\"') FROM t1; -- CONCAT",
    "target_query": "SELECT y, '\"' || c || '\"' FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (y YEAR NOT NULL DEFAULT 0,i INT NOT NULL DEFAULT 0,c VARCHAR(20) NOT NULL DEFAULT '');"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (y INT NOT NULL DEFAULT 0,i INT NOT NULL DEFAULT 0,c VARCHAR(20) NOT NULL DEFAULT '');"
    ]
  },
  {
    "sql_id": "monetdb_34_8",
    "database_name": "monetdb_34_8",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select concat(\"*\",name, \"*\") from t1 order by 1; -- CONCAT",
    "target_query": "SELECT '*' || name || '*' FROM t1 ORDER BY 1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t2 (name char(20) not null, primary key (name));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (name CHAR(20) NOT NULL, PRIMARY KEY (name));"
    ]
  },
  {
    "sql_id": "monetdb_34_9",
    "database_name": "monetdb_34_9",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select min(name),min(concat(\"*\",name,\"*\")),max(name),max(concat(\"*\",name,\"*\")) from t1; -- CONCAT",
    "target_query": "SELECT MIN(name), MIN('*' || name || '*'), MAX(name), MAX('*' || name || '*') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t2 (name char(20) not null, primary key (name));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (name CHAR(20) NOT NULL, PRIMARY KEY (name));"
    ]
  },
  {
    "sql_id": "monetdb_34_14",
    "database_name": "monetdb_34_14",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select concat(\"-\",a,\"-\",b,\"-\") from t1 where a=\"hello\"; -- CONCAT",
    "target_query": "SELECT '-' || a || '-' || b || '-' FROM t1 WHERE a = 'hello';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a char(10) not null, b char(10) not null);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a CHAR(10) NOT NULL, b CHAR(10) NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_34_16",
    "database_name": "monetdb_34_16",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select concat(\"-\",a,\"-\",b,\"-\") from t1 where a=\"hello\"; -- CONCAT",
    "target_query": "SELECT '-' || a || '-' || b || '-' FROM t1 WHERE a = 'hello';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a char(10) not null, b char(10) not null);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a CHAR(10) NOT NULL, b CHAR(10) NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_35_2",
    "database_name": "monetdb_35_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029087575'); -- UNHEX",
    "target_query": "INSERT INTO t1 (a) VALUES (X'1F9480179366F2BF567E1C4B964C1EF029087575');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNHEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNHEX(str)",
        "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT HEX(UNHEX('4D7953514C'));",
          "SELECT UNHEX('48656C6C6F');",
          "SELECT UNHEX(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "",
        "description": "",
        "examples": []
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a binary(20) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a blob NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_35_3",
    "database_name": "monetdb_35_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029082020'); -- UNHEX",
    "target_query": "INSERT INTO t1 (a) VALUES (X'1F9480179366F2BF567E1C4B964C1EF029082020');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNHEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNHEX(str)",
        "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT HEX(UNHEX('4D7953514C'));",
          "SELECT UNHEX('48656C6C6F');",
          "SELECT UNHEX(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "",
        "description": "",
        "examples": []
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a binary(20) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a blob NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_35_4",
    "database_name": "monetdb_35_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029080707'); -- UNHEX",
    "target_query": "INSERT INTO t1 (a) VALUES (X'1F9480179366F2BF567E1C4B964C1EF029080707');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNHEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNHEX(str)",
        "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT HEX(UNHEX('4D7953514C'));",
          "SELECT UNHEX('48656C6C6F');",
          "SELECT UNHEX(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "",
        "description": "",
        "examples": []
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a binary(20) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a blob NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_35_5",
    "database_name": "monetdb_35_5",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT hex(a) FROM t1 order by a; -- HEX",
    "target_query": "SELECT a FROM t1 ORDER BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "",
        "description": "",
        "examples": []
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a binary(20) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a blob NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_35_6",
    "database_name": "monetdb_35_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "EXPLAIN SELECT hex(a) FROM t1 order by a; -- HEX",
    "target_query": "EXPLAIN SELECT a FROM t1 ORDER BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "",
        "description": "",
        "examples": []
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a binary(20) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a blob NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_35_7",
    "database_name": "monetdb_35_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT hex(a) from t1 WHERE a=unhex('1F9480179366F2BF567E1C4B964C1EF029082020'); -- HEX, UNHEX",
    "target_query": "SELECT a FROM t1 WHERE a=CAST('1F9480179366F2BF567E1C4B964C1EF029082020' AS BLOB);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "UNHEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "UNHEX(str)",
        "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT HEX(UNHEX('4D7953514C'));",
          "SELECT UNHEX('48656C6C6F');",
          "SELECT UNHEX(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "",
        "description": "",
        "examples": []
      },
      {
        "expression": "",
        "description": "",
        "examples": []
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a binary(20) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a blob NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_35_8",
    "database_name": "monetdb_35_8",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT hex(a) from t1 WHERE a=unhex('1F9480179366F2BF567E1C4B964C1EF02908'); -- HEX, UNHEX",
    "target_query": "SELECT a FROM t1 WHERE a=CAST('1F9480179366F2BF567E1C4B964C1EF02908' AS BLOB);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "UNHEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "UNHEX(str)",
        "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT HEX(UNHEX('4D7953514C'));",
          "SELECT UNHEX('48656C6C6F');",
          "SELECT UNHEX(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "",
        "description": "",
        "examples": []
      },
      {
        "expression": "",
        "description": "",
        "examples": []
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a binary(20) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a blob NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_36_0",
    "database_name": "monetdb_36_0",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT IF(NULL AND 1, 1, 2), IF(1 AND NULL, 1, 2); -- IF",
    "target_query": "SELECT CASE WHEN NULL AND 1 THEN 1 ELSE 2 END, CASE WHEN 1 AND NULL THEN 1 ELSE 2 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_36_4",
    "database_name": "monetdb_36_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT * FROM t1 WHERE IF(a AND 1, 0, 1); -- IF",
    "target_query": "SELECT * FROM t1 WHERE CASE WHEN a AND 1 THEN 0 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT);"
    ]
  },
  {
    "sql_id": "monetdb_36_5",
    "database_name": "monetdb_36_5",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT * FROM t1 WHERE IF(1 AND a, 0, 1); -- IF",
    "target_query": "SELECT * FROM t1 WHERE CASE WHEN 1 AND a THEN 0 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT);"
    ]
  },
  {
    "sql_id": "monetdb_36_9",
    "database_name": "monetdb_36_9",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select ifnull(A, 'N') as A, ifnull(B, 'N') as B, ifnull(not A, 'N') as nA, ifnull(not B, 'N') as nB, ifnull(A and B, 'N') as AB, ifnull(not (A and B), 'N') as `n(AB)`, ifnull((not A or not B), 'N') as nAonB, ifnull(A or B, 'N') as AoB, ifnull(not(A or B), 'N') as `n(AoB)`, ifnull(not A and not B, 'N') as nAnB from t1; -- IFNULL",
    "target_query": "SELECT COALESCE(A, 'N') AS A, COALESCE(B, 'N') AS B, COALESCE(NOT A, 'N') AS nA, COALESCE(NOT B, 'N') AS nB, COALESCE(A AND B, 'N') AS AB, COALESCE(NOT (A AND B), 'N') AS nAB, COALESCE((NOT A OR NOT B), 'N') AS nAonB, COALESCE(A OR B, 'N') AS AoB, COALESCE(NOT(A OR B), 'N') AS nAoB, COALESCE(NOT A AND NOT B, 'N') AS nAnB FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2)",
        "description": "MonetDB also uses COALESCE to return the first non-NULL value. This works the same way as IFNULL in MySQL.",
        "examples": [
          "SELECT COALESCE(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a int, b int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT, b INT);"
    ]
  },
  {
    "sql_id": "monetdb_36_10",
    "database_name": "monetdb_36_10",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select ifnull(A=1, 'N') as A, ifnull(B=1, 'N') as B, ifnull(not (A=1), 'N') as nA, ifnull(not (B=1), 'N') as nB, ifnull((A=1) and (B=1), 'N') as AB, ifnull(not ((A=1) and (B=1)), 'N') as `n(AB)`, ifnull((not (A=1) or not (B=1)), 'N') as nAonB, ifnull((A=1) or (B=1), 'N') as AoB, ifnull(not((A=1) or (B=1)), 'N') as `n(AoB)`, ifnull(not (A=1) and not (B=1), 'N') as nAnB from t1; -- IFNULL",
    "target_query": "SELECT COALESCE(A=1, 'N') AS A, COALESCE(B=1, 'N') AS B, COALESCE(NOT (A=1), 'N') AS nA, COALESCE(NOT (B=1), 'N') AS nB, COALESCE((A=1) AND (B=1), 'N') AS AB, COALESCE(NOT ((A=1) AND (B=1)), 'N') AS nAB, COALESCE((NOT (A=1) OR NOT (B=1)), 'N') AS nAonB, COALESCE((A=1) OR (B=1), 'N') AS AoB, COALESCE(NOT((A=1) OR (B=1)), 'N') AS nAoB, COALESCE(NOT (A=1) AND NOT (B=1), 'N') AS nAnB FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2)",
        "description": "MonetDB also uses COALESCE to return the first non-NULL value. This works the same way as IFNULL in MySQL.",
        "examples": [
          "SELECT COALESCE(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a int, b int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT, b INT);"
    ]
  },
  {
    "sql_id": "monetdb_37_0",
    "database_name": "monetdb_37_0",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select CONVERT(\"2004-01-22 21:45:33\",DATE); -- CONVERT",
    "target_query": "SELECT CAST('2004-01-22 21:45:33' AS DATE);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONVERT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONVERT(expression USING charset)",
        "description": "Converts data types or changes the character set.",
        "examples": [
          "SELECT CONVERT('Hello World' USING utf8);",
          "SELECT CONVERT(1234, CHAR);",
          "SELECT CONVERT(column_name USING latin1) FROM my_table;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CAST(expression AS target_type)",
        "description": "MonetDB uses CAST for type conversion. No direct equivalent for CONVERT TO CHARACTER SET.",
        "examples": [
          "SELECT CAST('Hello World' AS TEXT);",
          "SELECT CAST(1234 AS VARCHAR);",
          "SELECT CAST(column_name AS TEXT) FROM my_table;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_37_1",
    "database_name": "monetdb_37_1",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select timediff(cast('2004-12-30 12:00:00' as time), '12:00:00'); -- TIMEDIFF",
    "target_query": "SELECT EXTRACT(EPOCH FROM CAST('2004-12-30 12:00:00' AS TIMESTAMP) - TIMESTAMP '2004-12-30 12:00:00');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')",
        "description": "MonetDB does not have a TIMEDIFF function but supports using EXTRACT to calculate the time difference in seconds.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');",
          "SELECT EXTRACT(EPOCH FROM NOW() - timestamp '2023-06-15 10:00:00');",
          "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_37_2",
    "database_name": "monetdb_37_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select timediff(cast('1 12:00:00' as time), '12:00:00'); -- TIMEDIFF",
    "target_query": "SELECT EXTRACT(EPOCH FROM CAST('12:00:00' AS TIME) - TIME '12:00:00');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')",
        "description": "MonetDB does not have a TIMEDIFF function but supports using EXTRACT to calculate the time difference in seconds.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');",
          "SELECT EXTRACT(EPOCH FROM NOW() - timestamp '2023-06-15 10:00:00');",
          "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_37_3",
    "database_name": "monetdb_37_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select cast(concat('12345','6789') as unsigned); -- CONCAT",
    "target_query": "SELECT CAST('12345' || '6789' AS INTEGER);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_37_4",
    "database_name": "monetdb_37_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select cast(concat('12345','6789') as signed); -- CONCAT",
    "target_query": "SELECT CAST('12345' || '6789' AS INTEGER);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_37_5",
    "database_name": "monetdb_37_5",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select cast(repeat('1',9) as unsigned); -- REPEAT",
    "target_query": "SELECT CAST(REPEAT('1', 9) AS INTEGER);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_37_6",
    "database_name": "monetdb_37_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select cast(repeat('1',9) as signed); -- REPEAT",
    "target_query": "SELECT CAST(REPEAT('1', 9) AS INTEGER);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_37_7",
    "database_name": "monetdb_37_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select isnull(date(NULL)), isnull(cast(NULL as DATE)); -- ISNULL, DATE",
    "target_query": "SELECT NULL IS NULL, CAST(NULL AS DATE) IS NULL;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ISNULL",
      "DATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ISNULL(expr)",
        "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
        "examples": [
          "SELECT ISNULL(NULL);",
          "SELECT ISNULL(5 + NULL);",
          "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
        ]
      },
      {
        "expression": "DATE()",
        "description": "In MySQL, the DATE function extracts the date part from a DATETIME or TIMESTAMP value.",
        "examples": [
          "SELECT DATE('2023-05-01 12:34:56') AS result;",
          "SELECT DATE(NOW()) AS current_date_result;",
          "SELECT DATE(CAST('2023-05-01' AS DATETIME)) AS date_from_datetime;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "expr IS NULL",
        "description": "Standard SQL construct for detecting NULL values.",
        "examples": [
          "SELECT NULL IS NULL;",
          "SELECT (5 * NULL) IS NULL;",
          "SELECT CASE WHEN balance IS NULL THEN 0 ELSE balance END FROM accounts;"
        ]
      },
      {
        "expression": "CAST()",
        "description": "MonetDB uses the CAST function to extract a DATE from a DATETIME or TIMESTAMP.",
        "examples": [
          "SELECT CAST('2023-05-01 12:34:56' AS DATE) AS result;",
          "SELECT CAST(NOW() AS DATE) AS current_date_result;",
          "SELECT CAST('2023-05-01' AS DATE) AS date_from_datetime;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_37_12",
    "database_name": "monetdb_37_12",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT cast(date(d1) as signed) FROM t1; -- DATE",
    "target_query": "SELECT CAST(d1 AS TIMESTAMP) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE()",
        "description": "In MySQL, the DATE function extracts the date part from a DATETIME or TIMESTAMP value.",
        "examples": [
          "SELECT DATE('2023-05-01 12:34:56') AS result;",
          "SELECT DATE(NOW()) AS current_date_result;",
          "SELECT DATE(CAST('2023-05-01' AS DATETIME)) AS date_from_datetime;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CAST()",
        "description": "MonetDB uses the CAST function to extract a DATE from a DATETIME or TIMESTAMP.",
        "examples": [
          "SELECT CAST('2023-05-01 12:34:56' AS DATE) AS result;",
          "SELECT CAST(NOW() AS DATE) AS current_date_result;",
          "SELECT CAST('2023-05-01' AS DATE) AS date_from_datetime;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (d1 datetime);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (d1 TIMESTAMP);"
    ]
  },
  {
    "sql_id": "monetdb_37_16",
    "database_name": "monetdb_37_16",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT HOUR(f1),MINUTE(f1),SECOND(f1) FROM t1; -- HOUR, MINUTE, SECOND",
    "target_query": "SELECT EXTRACT(HOUR FROM f1), \"minute\"(f1), EXTRACT(SECOND FROM f1) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HOUR",
      "MINUTE",
      "SECOND"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HOUR(expr)",
        "description": "Extracts the hour (0–23) from a time or datetime expression.",
        "examples": [
          "SELECT HOUR('18:45:30');",
          "SELECT HOUR('2023-10-01 08:15:00');",
          "SELECT HOUR(CURRENT_TIMESTAMP);"
        ]
      },
      {
        "expression": "MINUTE()",
        "description": "Extracts the minute part from a time or datetime value.",
        "examples": [
          "SELECT MINUTE('12:34:56');",
          "SELECT MINUTE('2025-01-01 10:30:00');",
          "SELECT MINUTE(NULL);"
        ]
      },
      {
        "expression": "SECOND(time)",
        "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
        "examples": [
          "SELECT SECOND('10:11:12');",
          "SELECT SECOND(4.99999999991e0);",
          "SELECT SECOND(CAST('2007-07-19' AS DATE));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(HOUR FROM expr)",
        "description": "Returns the hour component of a time or timestamp expression.",
        "examples": [
          "SELECT EXTRACT(HOUR FROM TIME '18:45:30');",
          "SELECT EXTRACT(HOUR FROM TIMESTAMP '2023-10-01 08:15:00');",
          "SELECT EXTRACT(HOUR FROM CURRENT_TIMESTAMP);"
        ]
      },
      {
        "expression": "\"minute\"()",
        "description": "Extracts the minute part from a time or timestamp value. In MonetDB, the function is used with the input explicitly cast to either `time` or `timestamp`.",
        "examples": [
          "SELECT \"minute\"(time '12:34:56');",
          "SELECT \"minute\"(timestamp '2025-01-01 10:30:00');",
          "SELECT \"minute\"(NULL);"
        ]
      },
      {
        "expression": "EXTRACT(SECOND FROM time)",
        "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
        "examples": [
          "SELECT EXTRACT(SECOND FROM TIME '10:11:12');",
          "SELECT EXTRACT(SECOND FROM CAST('2007-07-19' AS DATE));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (f1 DATE);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (f1 DATE);"
    ]
  },
  {
    "sql_id": "monetdb_37_18",
    "database_name": "monetdb_37_18",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT HOUR(CAST('2007-07-19' AS DATE)),MINUTE(CAST('2007-07-19' AS DATE)),SECOND(CAST('2007-07-19' AS DATE)); -- HOUR, MINUTE, SECOND",
    "target_query": "SELECT EXTRACT(HOUR FROM CAST('2007-07-19' AS DATE)), \"minute\"(CAST('2007-07-19' AS DATE)), EXTRACT(SECOND FROM CAST('2007-07-19' AS DATE));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HOUR",
      "MINUTE",
      "SECOND"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HOUR(expr)",
        "description": "Extracts the hour (0–23) from a time or datetime expression.",
        "examples": [
          "SELECT HOUR('18:45:30');",
          "SELECT HOUR('2023-10-01 08:15:00');",
          "SELECT HOUR(CURRENT_TIMESTAMP);"
        ]
      },
      {
        "expression": "MINUTE()",
        "description": "Extracts the minute part from a time or datetime value.",
        "examples": [
          "SELECT MINUTE('12:34:56');",
          "SELECT MINUTE('2025-01-01 10:30:00');",
          "SELECT MINUTE(NULL);"
        ]
      },
      {
        "expression": "SECOND(time)",
        "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
        "examples": [
          "SELECT SECOND('10:11:12');",
          "SELECT SECOND(4.99999999991e0);",
          "SELECT SECOND(CAST('2007-07-19' AS DATE));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(HOUR FROM expr)",
        "description": "Returns the hour component of a time or timestamp expression.",
        "examples": [
          "SELECT EXTRACT(HOUR FROM TIME '18:45:30');",
          "SELECT EXTRACT(HOUR FROM TIMESTAMP '2023-10-01 08:15:00');",
          "SELECT EXTRACT(HOUR FROM CURRENT_TIMESTAMP);"
        ]
      },
      {
        "expression": "\"minute\"()",
        "description": "Extracts the minute part from a time or timestamp value. In MonetDB, the function is used with the input explicitly cast to either `time` or `timestamp`.",
        "examples": [
          "SELECT \"minute\"(time '12:34:56');",
          "SELECT \"minute\"(timestamp '2025-01-01 10:30:00');",
          "SELECT \"minute\"(NULL);"
        ]
      },
      {
        "expression": "EXTRACT(SECOND FROM time)",
        "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
        "examples": [
          "SELECT EXTRACT(SECOND FROM TIME '10:11:12');",
          "SELECT EXTRACT(SECOND FROM CAST('2007-07-19' AS DATE));"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_37_19",
    "database_name": "monetdb_37_19",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT HOUR(CAST(NULL AS DATE)),MINUTE(CAST(NULL AS DATE)),SECOND(CAST(NULL AS DATE)); -- HOUR, MINUTE, SECOND",
    "target_query": "SELECT EXTRACT(HOUR FROM CAST(NULL AS DATE)), \"minute\"(CAST(NULL AS DATE)), EXTRACT(SECOND FROM CAST(NULL AS DATE));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HOUR",
      "MINUTE",
      "SECOND"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HOUR(expr)",
        "description": "Extracts the hour (0–23) from a time or datetime expression.",
        "examples": [
          "SELECT HOUR('18:45:30');",
          "SELECT HOUR('2023-10-01 08:15:00');",
          "SELECT HOUR(CURRENT_TIMESTAMP);"
        ]
      },
      {
        "expression": "MINUTE()",
        "description": "Extracts the minute part from a time or datetime value.",
        "examples": [
          "SELECT MINUTE('12:34:56');",
          "SELECT MINUTE('2025-01-01 10:30:00');",
          "SELECT MINUTE(NULL);"
        ]
      },
      {
        "expression": "SECOND(time)",
        "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
        "examples": [
          "SELECT SECOND('10:11:12');",
          "SELECT SECOND(4.99999999991e0);",
          "SELECT SECOND(CAST('2007-07-19' AS DATE));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(HOUR FROM expr)",
        "description": "Returns the hour component of a time or timestamp expression.",
        "examples": [
          "SELECT EXTRACT(HOUR FROM TIME '18:45:30');",
          "SELECT EXTRACT(HOUR FROM TIMESTAMP '2023-10-01 08:15:00');",
          "SELECT EXTRACT(HOUR FROM CURRENT_TIMESTAMP);"
        ]
      },
      {
        "expression": "\"minute\"()",
        "description": "Extracts the minute part from a time or timestamp value. In MonetDB, the function is used with the input explicitly cast to either `time` or `timestamp`.",
        "examples": [
          "SELECT \"minute\"(time '12:34:56');",
          "SELECT \"minute\"(timestamp '2025-01-01 10:30:00');",
          "SELECT \"minute\"(NULL);"
        ]
      },
      {
        "expression": "EXTRACT(SECOND FROM time)",
        "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
        "examples": [
          "SELECT EXTRACT(SECOND FROM TIME '10:11:12');",
          "SELECT EXTRACT(SECOND FROM CAST('2007-07-19' AS DATE));"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_37_20",
    "database_name": "monetdb_37_20",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT HOUR(NULL),MINUTE(NULL),SECOND(NULL); -- HOUR, MINUTE, SECOND",
    "target_query": "SELECT EXTRACT(HOUR FROM NULL), \"minute\"(NULL), EXTRACT(SECOND FROM NULL);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HOUR",
      "MINUTE",
      "SECOND"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HOUR(expr)",
        "description": "Extracts the hour (0–23) from a time or datetime expression.",
        "examples": [
          "SELECT HOUR('18:45:30');",
          "SELECT HOUR('2023-10-01 08:15:00');",
          "SELECT HOUR(CURRENT_TIMESTAMP);"
        ]
      },
      {
        "expression": "MINUTE()",
        "description": "Extracts the minute part from a time or datetime value.",
        "examples": [
          "SELECT MINUTE('12:34:56');",
          "SELECT MINUTE('2025-01-01 10:30:00');",
          "SELECT MINUTE(NULL);"
        ]
      },
      {
        "expression": "SECOND(time)",
        "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
        "examples": [
          "SELECT SECOND('10:11:12');",
          "SELECT SECOND(4.99999999991e0);",
          "SELECT SECOND(CAST('2007-07-19' AS DATE));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(HOUR FROM expr)",
        "description": "Returns the hour component of a time or timestamp expression.",
        "examples": [
          "SELECT EXTRACT(HOUR FROM TIME '18:45:30');",
          "SELECT EXTRACT(HOUR FROM TIMESTAMP '2023-10-01 08:15:00');",
          "SELECT EXTRACT(HOUR FROM CURRENT_TIMESTAMP);"
        ]
      },
      {
        "expression": "\"minute\"()",
        "description": "Extracts the minute part from a time or timestamp value. In MonetDB, the function is used with the input explicitly cast to either `time` or `timestamp`.",
        "examples": [
          "SELECT \"minute\"(time '12:34:56');",
          "SELECT \"minute\"(timestamp '2025-01-01 10:30:00');",
          "SELECT \"minute\"(NULL);"
        ]
      },
      {
        "expression": "EXTRACT(SECOND FROM time)",
        "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
        "examples": [
          "SELECT EXTRACT(SECOND FROM TIME '10:11:12');",
          "SELECT EXTRACT(SECOND FROM CAST('2007-07-19' AS DATE));"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_37_21",
    "database_name": "monetdb_37_21",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT CONVERT('a', CHAR(2049)); -- CONVERT",
    "target_query": "SELECT CAST('a' AS VARCHAR(2049));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONVERT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONVERT(expression USING charset)",
        "description": "Converts data types or changes the character set.",
        "examples": [
          "SELECT CONVERT('Hello World' USING utf8);",
          "SELECT CONVERT(1234, CHAR);",
          "SELECT CONVERT(column_name USING latin1) FROM my_table;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CAST(expression AS target_type)",
        "description": "MonetDB uses CAST for type conversion. No direct equivalent for CONVERT TO CHARACTER SET.",
        "examples": [
          "SELECT CAST('Hello World' AS TEXT);",
          "SELECT CAST(1234 AS VARCHAR);",
          "SELECT CAST(column_name AS TEXT) FROM my_table;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_37_22",
    "database_name": "monetdb_37_22",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT CONCAT(\"value=\", CAST(\"3.4e5\" AS FLOAT)); -- CONCAT",
    "target_query": "SELECT 'value=' || CAST('3.4e5' AS FLOAT);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_37_23",
    "database_name": "monetdb_37_23",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT MAKETIME(1, 2, CAST(\"1.6\" AS FLOAT)); -- MAKETIME",
    "target_query": "SELECT TIME '01:02:01';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKETIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKETIME(hours, minutes, seconds)",
        "description": "Creates a time value from the provided hours, minutes, and seconds.",
        "examples": [
          "SELECT MAKETIME(1, 30, 45);",
          "SELECT MAKETIME(12, 0, 0);",
          "SELECT MAKETIME(23, 59, 59);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TIME 'HH:MI:SS'",
        "description": "MonetDB supports creating time values by directly using the TIME keyword with the format 'HH:MI:SS'.",
        "examples": [
          "SELECT TIME '01:30:45';",
          "SELECT TIME '12:00:00';",
          "SELECT TIME '23:59:59';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_38_3",
    "database_name": "monetdb_38_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT STRCMP(a, b) FROM t1; -- STRCMP",
    "target_query": "SELECT CASE WHEN CAST(a AS String) = CAST(b AS string) THEN 0 WHEN a < b THEN -1 ELSE 1 END FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "MonetDB does not have a direct STRCMP function. This behavior can be simulated using a CASE statement to compare two strings lexicographically.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(a YEAR, b VARCHAR(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(a int, b VARCHAR(10));"
    ]
  },
  {
    "sql_id": "monetdb_38_6",
    "database_name": "monetdb_38_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT CAST(1988 AS YEAR), REPEAT(CAST(1988 AS YEAR), 3) AS c2; -- REPEAT",
    "target_query": "SELECT CAST(1988 AS int), REPEAT(CAST(1988 AS int), 3) AS c2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_38_7",
    "database_name": "monetdb_38_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT CONCAT('x', CAST(1988 AS YEAR)); -- CONCAT",
    "target_query": "SELECT 'x' || CAST(1988 AS STRING);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_38_8",
    "database_name": "monetdb_38_8",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT TIME_TO_SEC(CAST('2030' AS YEAR)); -- TIME_TO_SEC",
    "target_query": "SELECT EXTRACT(EPOCH FROM date '2030-01-01');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME_TO_SEC"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME_TO_SEC(time)",
        "description": "Converts a time value (HH:MM:SS) to the total number of seconds.",
        "examples": [
          "SELECT TIME_TO_SEC('15:12:22');",
          "SELECT TIME_TO_SEC('00:01:00');",
          "SELECT SEC_TO_TIME(TIME_TO_SEC('15:12:22') - TIME_TO_SEC('14:12:22'));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM time)",
        "description": "Converts a time value (HH:MM:SS) to the total number of seconds.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM TIME '15:12:22');",
          "SELECT EXTRACT(EPOCH FROM TIME '00:01:00');",
          "SELECT EXTRACT(EPOCH FROM TIME '15:12:22') - EXTRACT(EPOCH FROM TIME '14:12:22');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_38_9",
    "database_name": "monetdb_38_9",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT TIMESTAMPADD(MINUTE, 1, CAST(1988 AS YEAR)); -- TIMESTAMPADD",
    "target_query": "SELECT DATE '1988-01-01' + INTERVAL '1' MINUTE;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMPADD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMPADD(unit, interval, datetime_expr)",
        "description": "Adds a time interval to a date or timestamp expression using the specified unit.",
        "examples": [
          "SELECT TIMESTAMPADD(DAY, 2, '2023-01-01');",
          "SELECT TIMESTAMPADD(MINUTE, -5, '2023-05-10 12:00:00');",
          "SELECT TIMESTAMPADD(YEAR, 1, '2020-06-15');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "datetime_expr + INTERVAL 'n' unit",
        "description": "Adds a time interval to a timestamp or date using SQL standard INTERVAL syntax with integer value and time unit.",
        "examples": [
          "SELECT DATE '2023-01-01' + INTERVAL '2' DAY;",
          "SELECT TIMESTAMP '2023-05-10 12:00:00' + INTERVAL '-5' MINUTE;",
          "SELECT DATE '2020-06-15' + INTERVAL '1' YEAR;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_38_10",
    "database_name": "monetdb_38_10",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT CAST(STR_TO_DATE('nope','%d-%m-%Y') AS YEAR); -- STR_TO_DATE",
    "target_query": "SELECT CAST(str_to_date('01-05-1997','%d-%m-%Y') AS date);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STR_TO_DATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STR_TO_DATE('09:22', '%H:%i')",
        "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
        "examples": [
          "SELECT STR_TO_DATE('12:45', '%H:%i');",
          "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
          "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str_to_date('2000-01-01', '%Y-%m-%d')",
        "description": "Converts a string to a date using the specified format, where '%Y-%m-%d' corresponds to the 'Year-Month-Day' format.",
        "examples": [
          "SELECT str_to_date('2000-01-01', '%Y-%m-%d');",
          "SELECT str_to_date('2023-05-06', '%Y-%m-%d');",
          "SELECT str_to_date('1999-12-31', '%Y-%m-%d');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_38_13",
    "database_name": "monetdb_38_13",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT 1 FROM t WHERE CAST(a AS UNSIGNED INTEGER) = 1 AND a = IF(TRUE, NULL, 1); -- IF",
    "target_query": "SELECT 1 FROM t WHERE CAST(a AS INTEGER) = 1 AND a = CASE WHEN TRUE THEN NULL ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t (a INT NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t (a INT NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_40_3",
    "database_name": "monetdb_40_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT hex(a),STRCMP(a,'a'), STRCMP(a,'a ') FROM t1; -- HEX, STRCMP",
    "target_query": "SELECT NULL AS hex_a, CASE WHEN a = 'a' THEN 0 WHEN a < 'a' THEN -1 ELSE 1 END AS strcmp_a_a, CASE WHEN a = 'a ' THEN 0 WHEN a < 'a ' THEN -1 ELSE 1 END AS strcmp_a_a_space FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "",
        "description": "",
        "examples": []
      },
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "MonetDB does not have a direct STRCMP function. This behavior can be simulated using a CASE statement to compare two strings lexicographically.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a char(10) not null);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a char(10) not null);"
    ]
  },
  {
    "sql_id": "monetdb_40_7",
    "database_name": "monetdb_40_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT CONCAT(b,c), CONCAT(b,c) = '0101' FROM t1; -- CONCAT",
    "target_query": "SELECT b || c AS concat_bc, b || c = '0101' AS concat_bc_equals_0101 FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE  t1 (b int(2) zerofill, c int(2) zerofill);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (b int, c int);"
    ]
  },
  {
    "sql_id": "monetdb_40_8",
    "database_name": "monetdb_40_8",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "EXPLAIN SELECT b,c FROM t1 WHERE b = 1 AND CONCAT(b,c) = '0101'; -- CONCAT",
    "target_query": "EXPLAIN SELECT b, c FROM t1 WHERE b = 1 AND b || c = '0101';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE  t1 (b int(2) zerofill, c int(2) zerofill);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (b int, c int);"
    ]
  },
  {
    "sql_id": "monetdb_40_9",
    "database_name": "monetdb_40_9",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT b,c FROM t1 WHERE b = 1 AND CONCAT(b,c) = '0101'; -- CONCAT",
    "target_query": "SELECT b, c FROM t1 WHERE b = 1 AND b || c = '0101';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE  t1 (b int(2) zerofill, c int(2) zerofill);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (b int, c int);"
    ]
  },
  {
    "sql_id": "monetdb_40_12",
    "database_name": "monetdb_40_12",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 VALUES (NOW()),(NOW()),(NOW()); -- NOW",
    "target_query": "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP),(CURRENT_TIMESTAMP),(CURRENT_TIMESTAMP);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a TIMESTAMP);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a TIMESTAMP);"
    ]
  },
  {
    "sql_id": "monetdb_41_3",
    "database_name": "monetdb_41_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select count(distinct if(f1,3,f2)) from t1; -- COUNT, IF",
    "target_query": "select count(distinct case when f1 then 3 else f2 end) from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COUNT",
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN FORMAT=TREE SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      },
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      },
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (f1 int, f2 int);"
    ],
    "target_related_schemas": [
      "create table t1 (f1 int, f2 int);"
    ]
  },
  {
    "sql_id": "monetdb_43_3",
    "database_name": "monetdb_43_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select concat(name,space(level)), concat(name, repeat(' ',level)) from t1; -- CONCAT, SPACE, REPEAT",
    "target_query": "SELECT name || REPEAT(' ', level), name || REPEAT(' ', level) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT",
      "SPACE",
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      },
      {
        "expression": "SPACE(n)",
        "description": "Returns a string consisting of n space characters.",
        "examples": [
          "SELECT LENGTH(SPACE(5));",
          "SELECT CONCAT('A', SPACE(3), 'B');",
          "SELECT CONCAT(REPEAT('-', 2), SPACE(4), '!');"
        ]
      },
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      },
      {
        "expression": "REPEAT(' ', n)",
        "description": "Returns a string consisting of n space characters by repeating a space character. String concatenation is performed using the '||' operator.",
        "examples": [
          "SELECT LENGTH(REPEAT(' ', 5));",
          "SELECT 'A' || REPEAT(' ', 3) || 'B';",
          "SELECT REPEAT('-', 2) || REPEAT(' ', 4) || '!';"
        ]
      },
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (name varchar(10),level smallint);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (name VARCHAR(10), level SMALLINT);"
    ]
  },
  {
    "sql_id": "monetdb_43_5",
    "database_name": "monetdb_43_5",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "create table t1 select repeat('a',4000) a; -- REPEAT",
    "target_query": "CREATE TABLE t1 AS SELECT REPEAT('a', 4000) AS a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 select repeat('a',4000) a; -- REPEAT"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 AS SELECT REPEAT('a', 4000) AS a;"
    ]
  },
  {
    "sql_id": "monetdb_43_14",
    "database_name": "monetdb_43_14",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT",
    "target_query": "CREATE TABLE head AS SELECT b1.b || b2.b AS head FROM t1 b1, t1 b2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT"
    ],
    "target_related_schemas": [
      "CREATE TABLE head AS SELECT b1.b || b2.b AS head FROM t1 b1, t1 b2;"
    ]
  },
  {
    "sql_id": "monetdb_43_15",
    "database_name": "monetdb_43_15",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "CREATE TABLE tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2; -- CONCAT",
    "target_query": "CREATE TABLE tail AS SELECT b1.b || b2.b AS tail FROM t1 b1, t1 b2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT",
      "CREATE TABLE tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2; -- CONCAT"
    ],
    "target_related_schemas": [
      "CREATE TABLE head AS SELECT b1.b || b2.b AS head FROM t1 b1, t1 b2;",
      "CREATE TABLE tail AS SELECT b1.b || b2.b AS tail FROM t1 b1, t1 b2;"
    ]
  },
  {
    "sql_id": "monetdb_44_3",
    "database_name": "monetdb_44_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT GROUP_CONCAT(IFNULL(a,'')) FROM t1; -- GROUP_CONCAT, IFNULL",
    "target_query": "SELECT GROUP_CONCAT(COALESCE(a,'')) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GROUP_CONCAT",
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
        "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
        ]
      },
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "group_concat(X) group_concat(X,Y)",
        "description": "The group_concat(X,Y) function returns a string which is the concatenation of all non-NULL values of X. If parameter Y is present, it is used as the separator between values. A comma (\",\") is used as the default separator if Y is omitted.\n\nThe order of concatenated elements is arbitrary unless an ORDER BY clause is explicitly used.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns names separated by commas",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by ' | '",
          "SELECT department, group_concat(name, '; ') FROM employees GROUP BY department; -- Groups names by department"
        ]
      },
      {
        "expression": "COALESCE(expr1, expr2)",
        "description": "MonetDB also uses COALESCE to return the first non-NULL value. This works the same way as IFNULL in MySQL.",
        "examples": [
          "SELECT COALESCE(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a MEDIUMINT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INTEGER NULL);"
    ]
  },
  {
    "sql_id": "monetdb_44_4",
    "database_name": "monetdb_44_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT GROUP_CONCAT(IF(a,a,'')) FROM t1; -- GROUP_CONCAT, IF",
    "target_query": "SELECT GROUP_CONCAT(CASE WHEN a IS NOT NULL THEN a ELSE '' END) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GROUP_CONCAT",
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
        "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
        ]
      },
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "group_concat(X) group_concat(X,Y)",
        "description": "The group_concat(X,Y) function returns a string which is the concatenation of all non-NULL values of X. If parameter Y is present, it is used as the separator between values. A comma (\",\") is used as the default separator if Y is omitted.\n\nThe order of concatenated elements is arbitrary unless an ORDER BY clause is explicitly used.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns names separated by commas",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by ' | '",
          "SELECT department, group_concat(name, '; ') FROM employees GROUP BY department; -- Groups names by department"
        ]
      },
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a MEDIUMINT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INTEGER NULL);"
    ]
  },
  {
    "sql_id": "monetdb_44_5",
    "database_name": "monetdb_44_5",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT GROUP_CONCAT(CASE WHEN a THEN a ELSE '' END) FROM t1; -- GROUP_CONCAT",
    "target_query": "SELECT GROUP_CONCAT(CASE WHEN a THEN a ELSE '' END) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GROUP_CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
        "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "group_concat(X) group_concat(X,Y)",
        "description": "The group_concat(X,Y) function returns a string which is the concatenation of all non-NULL values of X. If parameter Y is present, it is used as the separator between values. A comma (\",\") is used as the default separator if Y is omitted.\n\nThe order of concatenated elements is arbitrary unless an ORDER BY clause is explicitly used.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns names separated by commas",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by ' | '",
          "SELECT department, group_concat(name, '; ') FROM employees GROUP BY department; -- Groups names by department"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a MEDIUMINT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INTEGER NULL);"
    ]
  },
  {
    "sql_id": "monetdb_44_6",
    "database_name": "monetdb_44_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT COALESCE(a,'') FROM t1 GROUP BY 1; -- COALESCE",
    "target_query": "SELECT COALESCE(a,'') FROM t1 GROUP BY 1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...)",
        "description": "Standard SQL COALESCE function is supported.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a MEDIUMINT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INTEGER NULL);"
    ]
  },
  {
    "sql_id": "monetdb_44_10",
    "database_name": "monetdb_44_10",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "CREATE TABLE t2 AS SELECT LCASE(a) FROM t1; -- LCASE",
    "target_query": "CREATE TABLE t2 AS SELECT lower(a) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LCASE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LCASE(str)",
        "description": "Converts all characters in a string to lowercase. Equivalent to LOWER(str).",
        "examples": [
          "SELECT LCASE('TeSt');",
          "SELECT LCASE(CONCAT('A', 'B', 'C'));",
          "SELECT LCASE(456);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "lower(str)",
        "description": "Converts a string to lowercase letters.",
        "examples": [
          "SELECT lower('TeSt');",
          "SELECT lower('ABC');",
          "SELECT lower(CAST(456 AS VARCHAR));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 AS SELECT LCASE(a) FROM t1; -- LCASE"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 AS SELECT lower(a) FROM t1;"
    ]
  },
  {
    "sql_id": "monetdb_44_12",
    "database_name": "monetdb_44_12",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "CREATE TABLE t2 AS SELECT UCASE(a) FROM t1; -- UCASE",
    "target_query": "CREATE TABLE t2 AS SELECT UPPER(a) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UCASE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UCASE(str)",
        "description": "Returns the string `str` with all characters converted to uppercase. UCASE is a synonym for UPPER.",
        "examples": [
          "SELECT UCASE('hello world');",
          "SELECT UCASE(CONCAT('abc', '123'));",
          "SELECT UCASE(REPLACE('test case', 'case', 'CASE'));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "UPPER(str)",
        "description": "Returns the given string with all alphabetic characters converted to uppercase.",
        "examples": [
          "SELECT UPPER('hello world');",
          "SELECT UPPER(CONCAT('abc', '123'));",
          "SELECT UPPER(REPLACE('test case', 'case', 'CASE'));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 AS SELECT UCASE(a) FROM t1; -- UCASE"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 AS SELECT UPPER(a) FROM t1;"
    ]
  },
  {
    "sql_id": "monetdb_44_14",
    "database_name": "monetdb_44_14",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "CREATE TABLE t2 AS SELECT REPEAT(1,2) FROM t1; -- REPEAT",
    "target_query": "CREATE TABLE t2 AS SELECT REPEAT(1,2) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 AS SELECT REPEAT(1,2) FROM t1; -- REPEAT"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 AS SELECT REPEAT(1,2) FROM t1;"
    ]
  },
  {
    "sql_id": "monetdb_45_11",
    "database_name": "monetdb_45_11",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select * from t1 where a=lpad('xxx',10,' '); -- LPAD",
    "target_query": "SELECT * FROM t1 WHERE a=CONCAT(REPEAT(' ', GREATEST(0, 10 - LENGTH('xxx'))), 'xxx');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
        "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
        "examples": [
          "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
          "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
          "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a char(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a CHAR(20));"
    ]
  },
  {
    "sql_id": "monetdb_45_15",
    "database_name": "monetdb_45_15",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select ifnull(c1,''), ifnull(null,c1) from t1; -- IFNULL",
    "target_query": "select ifnull(c1,''), ifnull(null,c1) from t1; -- IFNULL",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2)",
        "description": "MonetDB also uses COALESCE to return the first non-NULL value. This works the same way as IFNULL in MySQL.",
        "examples": [
          "SELECT COALESCE(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 char(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 CHAR(10));"
    ]
  },
  {
    "sql_id": "monetdb_45_16",
    "database_name": "monetdb_45_16",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select if(1,c1,''), if(0,c1,'') from t1; -- IF",
    "target_query": "SELECT CASE WHEN 1 THEN c1 ELSE '' END, CASE WHEN 0 THEN c1 ELSE '' END FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 char(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 CHAR(10));"
    ]
  },
  {
    "sql_id": "monetdb_45_17",
    "database_name": "monetdb_45_17",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select coalesce('',c1), coalesce(null,c1) from t1; -- COALESCE",
    "target_query": "SELECT COALESCE(c1,''), COALESCE(NULL,c1) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...)",
        "description": "Standard SQL COALESCE function is supported.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 char(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 CHAR(10));"
    ]
  },
  {
    "sql_id": "monetdb_45_18",
    "database_name": "monetdb_45_18",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select least(c1,''), greatest(c1,'') from t1; -- LEAST, GREATEST",
    "target_query": "SELECT CASE WHEN c1 IS NULL THEN '' WHEN '' IS NULL THEN c1 WHEN c1 <= '' THEN c1 ELSE '' END, GREATEST(c1,'') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST",
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      },
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN ... THEN ... END",
        "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
        "examples": [
          "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
          "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
          "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
        ]
      },
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 char(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 CHAR(10));"
    ]
  },
  {
    "sql_id": "monetdb_45_19",
    "database_name": "monetdb_45_19",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select locate(c1,''), locate('',c1) from t1; -- LOCATE",
    "target_query": "SELECT POSITION(c1 IN ''), POSITION('' IN c1) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LOCATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LOCATE(substr, str[, start_position])",
        "description": "Returns the position of the first occurrence of substring 'substr' in string 'str'. If 'start_position' is provided, the search starts from that position.",
        "examples": [
          "select locate('a', 'banana', 2);",
          "select locate('foo', 'foobar', 2);",
          "select locate('ab', 'abcab', 3);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION(substr IN str)",
        "description": "Same as PostgreSQL. Returns the position of the first occurrence of substring 'substr' in string 'str'. MonetDB does not support 'start_position'.",
        "examples": [
          "select position('a' IN 'banana');",
          "select position('foo' IN 'foobar');",
          "select position('ab' IN 'abcab');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 char(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 CHAR(10));"
    ]
  },
  {
    "sql_id": "monetdb_45_21",
    "database_name": "monetdb_45_21",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select concat(c1,''), concat('',c1) from t1; -- CONCAT",
    "target_query": "SELECT c1 || '', '' || c1 FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 char(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 CHAR(10));"
    ]
  },
  {
    "sql_id": "monetdb_45_24",
    "database_name": "monetdb_45_24",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select lpad(c1,3,'x'), lpad('x',3,c1) from t1; -- LPAD",
    "target_query": "select lpad(c1,3,''), lpad('',3,c1) from t1; -- LPAD",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
        "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
        "examples": [
          "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
          "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
          "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 char(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 CHAR(10));"
    ]
  },
  {
    "sql_id": "monetdb_45_25",
    "database_name": "monetdb_45_25",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select rpad(c1,3,'x'), rpad('x',3,c1) from t1; -- RPAD",
    "target_query": "SELECT RPAD(c1,3,''), RPAD('',3,c1) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "MonetDB can simulate RPAD by concatenating strings.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 char(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 CHAR(10));"
    ]
  },
  {
    "sql_id": "monetdb_46_5",
    "database_name": "monetdb_46_5",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select date1,format1,str_to_date(date1, format1) as str_to_date from t1; -- STR_TO_DATE",
    "target_query": "SELECT date1, format1, str_to_date(date1, format1) AS str_to_date FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STR_TO_DATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STR_TO_DATE('09:22', '%H:%i')",
        "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
        "examples": [
          "SELECT STR_TO_DATE('12:45', '%H:%i');",
          "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
          "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str_to_date('2000-01-01', '%Y-%m-%d')",
        "description": "Converts a string to a date using the specified format, where '%Y-%m-%d' corresponds to the 'Year-Month-Day' format.",
        "examples": [
          "SELECT str_to_date('2000-01-01', '%Y-%m-%d');",
          "SELECT str_to_date('2023-05-06', '%Y-%m-%d');",
          "SELECT str_to_date('1999-12-31', '%Y-%m-%d');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (date1 char(30), format1 char(30) not null);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (date1 CHAR(30), format1 CHAR(30) NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_46_6",
    "database_name": "monetdb_46_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select date1,format1,concat('',str_to_date(date1, format1)) as con from t1; -- CONCAT, STR_TO_DATE",
    "target_query": "SELECT date1, format1, '' || str_to_date(date1, format1) AS con FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT",
      "STR_TO_DATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      },
      {
        "expression": "STR_TO_DATE('09:22', '%H:%i')",
        "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
        "examples": [
          "SELECT STR_TO_DATE('12:45', '%H:%i');",
          "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
          "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      },
      {
        "expression": "str_to_date('2000-01-01', '%Y-%m-%d')",
        "description": "Converts a string to a date using the specified format, where '%Y-%m-%d' corresponds to the 'Year-Month-Day' format.",
        "examples": [
          "SELECT str_to_date('2000-01-01', '%Y-%m-%d');",
          "SELECT str_to_date('2023-05-06', '%Y-%m-%d');",
          "SELECT str_to_date('1999-12-31', '%Y-%m-%d');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (date1 char(30), format1 char(30) not null);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (date1 CHAR(30), format1 CHAR(30) NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_46_8",
    "database_name": "monetdb_46_8",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select date1,format1,DATE(str_to_date(date1, format1)) as date2 from t1; -- DATE, STR_TO_DATE",
    "target_query": "SELECT date1, format1, CAST(str_to_date(date1, format1) AS DATE) AS date2 FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE",
      "STR_TO_DATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE()",
        "description": "In MySQL, the DATE function extracts the date part from a DATETIME or TIMESTAMP value.",
        "examples": [
          "SELECT DATE('2023-05-01 12:34:56') AS result;",
          "SELECT DATE(NOW()) AS current_date_result;",
          "SELECT DATE(CAST('2023-05-01' AS DATETIME)) AS date_from_datetime;"
        ]
      },
      {
        "expression": "STR_TO_DATE('09:22', '%H:%i')",
        "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
        "examples": [
          "SELECT STR_TO_DATE('12:45', '%H:%i');",
          "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
          "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CAST()",
        "description": "MonetDB uses the CAST function to extract a DATE from a DATETIME or TIMESTAMP.",
        "examples": [
          "SELECT CAST('2023-05-01 12:34:56' AS DATE) AS result;",
          "SELECT CAST(NOW() AS DATE) AS current_date_result;",
          "SELECT CAST('2023-05-01' AS DATE) AS date_from_datetime;"
        ]
      },
      {
        "expression": "str_to_date('2000-01-01', '%Y-%m-%d')",
        "description": "Converts a string to a date using the specified format, where '%Y-%m-%d' corresponds to the 'Year-Month-Day' format.",
        "examples": [
          "SELECT str_to_date('2000-01-01', '%Y-%m-%d');",
          "SELECT str_to_date('2023-05-06', '%Y-%m-%d');",
          "SELECT str_to_date('1999-12-31', '%Y-%m-%d');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (date1 char(30), format1 char(30) not null);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (date1 CHAR(30), format1 CHAR(30) NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_46_15",
    "database_name": "monetdb_46_15",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select date_format(d,\"%d\") from t1 order by 1; -- DATE_FORMAT",
    "target_query": "SELECT sys.timestamp_to_str(d, 'DD') FROM t1 ORDER BY 1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
        "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
        "examples": [
          "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (d date);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (d DATE);"
    ]
  },
  {
    "sql_id": "monetdb_46_17",
    "database_name": "monetdb_46_17",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select date_format('2004-01-01','%W (%a), %e %M (%b) %Y'); -- DATE_FORMAT",
    "target_query": "SELECT sys.timestamp_to_str(TIMESTAMP '2004-01-01', 'Day (DY), DD Month (MON) YYYY');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
        "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
        "examples": [
          "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_47_13",
    "database_name": "monetdb_47_13",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select str_to_date('04 /30/2004', '%m /%d/%Y'); -- STR_TO_DATE",
    "target_query": "SELECT str_to_date('04 /30/2004', '%m /%d/%Y');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STR_TO_DATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STR_TO_DATE('09:22', '%H:%i')",
        "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
        "examples": [
          "SELECT STR_TO_DATE('12:45', '%H:%i');",
          "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
          "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str_to_date('2000-01-01', '%Y-%m-%d')",
        "description": "Converts a string to a date using the specified format, where '%Y-%m-%d' corresponds to the 'Year-Month-Day' format.",
        "examples": [
          "SELECT str_to_date('2000-01-01', '%Y-%m-%d');",
          "SELECT str_to_date('2023-05-06', '%Y-%m-%d');",
          "SELECT str_to_date('1999-12-31', '%Y-%m-%d');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_47_14",
    "database_name": "monetdb_47_14",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select str_to_date('04/30 /2004', '%m /%d /%Y'); -- STR_TO_DATE",
    "target_query": "SELECT str_to_date('04/30 /2004', '%m /%d /%Y');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STR_TO_DATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STR_TO_DATE('09:22', '%H:%i')",
        "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
        "examples": [
          "SELECT STR_TO_DATE('12:45', '%H:%i');",
          "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
          "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str_to_date('2000-01-01', '%Y-%m-%d')",
        "description": "Converts a string to a date using the specified format, where '%Y-%m-%d' corresponds to the 'Year-Month-Day' format.",
        "examples": [
          "SELECT str_to_date('2000-01-01', '%Y-%m-%d');",
          "SELECT str_to_date('2023-05-06', '%Y-%m-%d');",
          "SELECT str_to_date('1999-12-31', '%Y-%m-%d');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_47_15",
    "database_name": "monetdb_47_15",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select str_to_date('04/30/2004 ', '%m/%d/%Y '); -- STR_TO_DATE",
    "target_query": "SELECT str_to_date('04/30/2004 ', '%m/%d/%Y ');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STR_TO_DATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STR_TO_DATE('09:22', '%H:%i')",
        "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
        "examples": [
          "SELECT STR_TO_DATE('12:45', '%H:%i');",
          "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
          "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str_to_date('2000-01-01', '%Y-%m-%d')",
        "description": "Converts a string to a date using the specified format, where '%Y-%m-%d' corresponds to the 'Year-Month-Day' format.",
        "examples": [
          "SELECT str_to_date('2000-01-01', '%Y-%m-%d');",
          "SELECT str_to_date('2023-05-06', '%Y-%m-%d');",
          "SELECT str_to_date('1999-12-31', '%Y-%m-%d');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_47_16",
    "database_name": "monetdb_47_16",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT DATE_FORMAT(\"0000-01-01\",'%W %d %M %Y') as valid_date; -- DATE_FORMAT",
    "target_query": "SELECT sys.timestamp_to_str(TIMESTAMP '0000-01-01', 'Day DD Month YYYY') as valid_date;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
        "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
        "examples": [
          "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_47_17",
    "database_name": "monetdb_47_17",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT DATE_FORMAT(\"0000-02-28\",'%W %d %M %Y') as valid_date; -- DATE_FORMAT",
    "target_query": "SELECT sys.timestamp_to_str(TIMESTAMP '0000-02-28', 'Day DD Month YYYY') as valid_date;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
        "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
        "examples": [
          "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_47_18",
    "database_name": "monetdb_47_18",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT DATE_FORMAT(\"2009-01-01\",'%W %d %M %Y') as valid_date; -- DATE_FORMAT",
    "target_query": "SELECT sys.timestamp_to_str(TIMESTAMP '2009-01-01', 'Day DD Month YYYY') as valid_date;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
        "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
        "examples": [
          "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_49_5",
    "database_name": "monetdb_49_5",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select concat('|', text1, '|') as c from t1 where text1='teststring' or text1 like 'teststring_%' order by c; -- CONCAT",
    "target_query": "select '|' || text1 || '|' as c from t1 where text1='teststring' or text1 like 'teststring_%' order by c;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);"
    ],
    "target_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);"
    ]
  },
  {
    "sql_id": "monetdb_49_6",
    "database_name": "monetdb_49_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select concat('|', text1, '|') from t1 where text1='teststring' or text1 > 'teststring\\\\t'; -- CONCAT",
    "target_query": "select '|' || text1 || '|' from t1 where text1='teststring' or text1 > 'teststring\\\\t';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);"
    ],
    "target_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);"
    ]
  },
  {
    "sql_id": "monetdb_49_7",
    "database_name": "monetdb_49_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select text1, length(text1) from t1 order by text1; -- LENGTH",
    "target_query": "select text1, octet_length(text1) from t1 order by text1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);"
    ],
    "target_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);"
    ]
  },
  {
    "sql_id": "monetdb_49_9",
    "database_name": "monetdb_49_9",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select concat('|', text1, '|') from t1 order by text1; -- CONCAT",
    "target_query": "select '|' || text1 || '|' from t1 order by text1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);"
    ],
    "target_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);"
    ]
  },
  {
    "sql_id": "monetdb_49_10",
    "database_name": "monetdb_49_10",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select concat('|', text1, '|') from t1 where text1='teststring' or text1 > 'teststring\\\\t'; -- CONCAT",
    "target_query": "select '|' || text1 || '|' from t1 where text1='teststring' or text1 > 'teststring\\\\t';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);"
    ],
    "target_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);"
    ]
  },
  {
    "sql_id": "monetdb_49_11",
    "database_name": "monetdb_49_11",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select concat('|', text1, '|') from t1 where text1='teststring'; -- CONCAT",
    "target_query": "select '|' || text1 || '|' from t1 where text1='teststring';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);"
    ],
    "target_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);"
    ]
  },
  {
    "sql_id": "monetdb_49_12",
    "database_name": "monetdb_49_12",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select concat('|', text1, '|') from t1 where text1='teststring '; -- CONCAT",
    "target_query": "select '|' || text1 || '|' from t1 where text1='teststring ';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);"
    ],
    "target_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);"
    ]
  },
  {
    "sql_id": "monetdb_50_3",
    "database_name": "monetdb_50_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT CONCAT(\"Let's create some new events from the name of \", USER()); -- CONCAT, USER",
    "target_query": "SELECT 'Let''s create some new events from the name of ' || '';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT",
      "USER"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      },
      {
        "expression": "USER()",
        "description": "Returns the current MySQL user and host in the format 'username@hostname'.",
        "examples": [
          "SELECT USER();"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      },
      {
        "expression": "",
        "description": "",
        "examples": []
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_51_2",
    "database_name": "monetdb_51_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 VALUES ( 2, REPEAT('-', 104) ); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES ( 2, REPEAT('-', 104) );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (f1 INTEGER,f2 LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (f1 INTEGER,f2 String);"
    ]
  },
  {
    "sql_id": "monetdb_51_3",
    "database_name": "monetdb_51_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 VALUES ( 1, REPEAT('x', 104) ); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES ( 1, REPEAT('x', 104) );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (f1 INTEGER,f2 LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (f1 INTEGER,f2 String);"
    ]
  },
  {
    "sql_id": "monetdb_51_7",
    "database_name": "monetdb_51_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT CONCAT(f1, '') AS dummy FROM t1 ORDER BY dummy; -- CONCAT",
    "target_query": "SELECT f1 || '' AS dummy FROM t1 ORDER BY dummy;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( f1 VARCHAR(100) );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( f1 VARCHAR(100) );"
    ]
  },
  {
    "sql_id": "monetdb_51_18",
    "database_name": "monetdb_51_18",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 VALUES (1, REPEAT('x', 40001)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (1, REPEAT('x', 40001));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ]
  },
  {
    "sql_id": "monetdb_51_19",
    "database_name": "monetdb_51_19",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 VALUES (2, REPEAT('x', 40002)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (2, REPEAT('x', 40002));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ]
  },
  {
    "sql_id": "monetdb_51_20",
    "database_name": "monetdb_51_20",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 VALUES (3, REPEAT('x', 40003)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (3, REPEAT('x', 40003));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ]
  },
  {
    "sql_id": "monetdb_51_21",
    "database_name": "monetdb_51_21",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 VALUES (4, REPEAT('x', 40005)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (4, REPEAT('x', 40005));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ]
  },
  {
    "sql_id": "monetdb_51_22",
    "database_name": "monetdb_51_22",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 VALUES (5, REPEAT('x', 40008)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (5, REPEAT('x', 40008));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ]
  },
  {
    "sql_id": "monetdb_51_23",
    "database_name": "monetdb_51_23",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 VALUES (6, REPEAT('x', 40013)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (6, REPEAT('x', 40013));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ]
  },
  {
    "sql_id": "monetdb_51_24",
    "database_name": "monetdb_51_24",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT a, LENGTH(b) FROM t1 ORDER BY a DESC; -- LENGTH",
    "target_query": "SELECT a, octet_length(b) FROM t1 ORDER BY a DESC;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ]
  },
  {
    "sql_id": "monetdb_52_13",
    "database_name": "monetdb_52_13",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) > 3; -- LENGTH",
    "target_query": "EXPLAIN SELECT * FROM t1 WHERE octet_length(t1.vc) > 3;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(col1_idx INT DEFAULT NULL,col2_idx INT DEFAULT NULL,col3 INT DEFAULT NULL,col4 INT NOT NULL,vc VARCHAR(30),vc_ft VARCHAR(30));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(col1_idx INT DEFAULT NULL,col2_idx INT DEFAULT NULL,col3 INT DEFAULT NULL,col4 INT NOT NULL,vc VARCHAR(30),vc_ft VARCHAR(30));"
    ]
  },
  {
    "sql_id": "monetdb_52_14",
    "database_name": "monetdb_52_14",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) = 3; -- LENGTH",
    "target_query": "EXPLAIN SELECT * FROM t1 WHERE octet_length(t1.vc) = 3;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(col1_idx INT DEFAULT NULL,col2_idx INT DEFAULT NULL,col3 INT DEFAULT NULL,col4 INT NOT NULL,vc VARCHAR(30),vc_ft VARCHAR(30));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(col1_idx INT DEFAULT NULL,col2_idx INT DEFAULT NULL,col3 INT DEFAULT NULL,col4 INT NOT NULL,vc VARCHAR(30),vc_ft VARCHAR(30));"
    ]
  },
  {
    "sql_id": "monetdb_52_15",
    "database_name": "monetdb_52_15",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) IS NULL; -- LENGTH",
    "target_query": "EXPLAIN SELECT * FROM t1 WHERE octet_length(t1.vc) IS NULL;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(col1_idx INT DEFAULT NULL,col2_idx INT DEFAULT NULL,col3 INT DEFAULT NULL,col4 INT NOT NULL,vc VARCHAR(30),vc_ft VARCHAR(30));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(col1_idx INT DEFAULT NULL,col2_idx INT DEFAULT NULL,col3 INT DEFAULT NULL,col4 INT NOT NULL,vc VARCHAR(30),vc_ft VARCHAR(30));"
    ]
  },
  {
    "sql_id": "monetdb_52_16",
    "database_name": "monetdb_52_16",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) IS NOT NULL; -- LENGTH",
    "target_query": "EXPLAIN SELECT * FROM t1 WHERE octet_length(t1.vc) IS NOT NULL;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(col1_idx INT DEFAULT NULL,col2_idx INT DEFAULT NULL,col3 INT DEFAULT NULL,col4 INT NOT NULL,vc VARCHAR(30),vc_ft VARCHAR(30));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(col1_idx INT DEFAULT NULL,col2_idx INT DEFAULT NULL,col3 INT DEFAULT NULL,col4 INT NOT NULL,vc VARCHAR(30),vc_ft VARCHAR(30));"
    ]
  },
  {
    "sql_id": "monetdb_53_12",
    "database_name": "monetdb_53_12",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t VALUES(REPEAT(x'0a',1000)); -- REPEAT",
    "target_query": "INSERT INTO t VALUES(REPEAT(x'0a',1000));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t(b BLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t(b BLOB);"
    ]
  },
  {
    "sql_id": "monetdb_53_21",
    "database_name": "monetdb_53_21",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t VALUES(1, REPEAT('2', 32750), REPEAT('1', 32750)); -- REPEAT",
    "target_query": "INSERT INTO t VALUES(1,REPEAT('2',32750),REPEAT('1',32750));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t (gid int, a varbinary(65500), b blob);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t (gid int,a blob,b blob);"
    ]
  },
  {
    "sql_id": "monetdb_54_2",
    "database_name": "monetdb_54_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "insert t1 values (NULL), ('A\\0\\0\\0BBBBBBBB'), (SPACE(50000)), (SPACE(50000)); -- SPACE",
    "target_query": "insert into t1 values (NULL), (X'410000004242424242424242'), (CAST(REPEAT(' ', 50000) AS BLOB)), (CAST(REPEAT(' ', 50000) AS BLOB));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "SPACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SPACE(n)",
        "description": "Returns a string consisting of n space characters.",
        "examples": [
          "SELECT LENGTH(SPACE(5));",
          "SELECT CONCAT('A', SPACE(3), 'B');",
          "SELECT CONCAT(REPEAT('-', 2), SPACE(4), '!');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(' ', n)",
        "description": "Returns a string consisting of n space characters by repeating a space character. String concatenation is performed using the '||' operator.",
        "examples": [
          "SELECT LENGTH(REPEAT(' ', 5));",
          "SELECT 'A' || REPEAT(' ', 3) || 'B';",
          "SELECT REPEAT('-', 2) || REPEAT(' ', 4) || '!';"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a BLOB);"
    ],
    "target_related_schemas": [
      "create table t1 (a BLOB);"
    ]
  },
  {
    "sql_id": "monetdb_54_3",
    "database_name": "monetdb_54_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select length(a) from t1; -- LENGTH",
    "target_query": "select octet_length(a) from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a BLOB);"
    ],
    "target_related_schemas": [
      "create table t1 (a BLOB);"
    ]
  },
  {
    "sql_id": "monetdb_55_3",
    "database_name": "monetdb_55_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select * from t1 where concat(A,C,B,D) = 'AAAA2003-03-011051'; -- CONCAT",
    "target_query": "SELECT * FROM t1 WHERE a || c || CAST(b AS STRING) || CAST(d AS STRING) = 'AAAA2003-03-011051';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a char(4), b double, c date, d tinyint(4));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a CHAR(4), b DOUBLE, c DATE, d TINYINT);"
    ]
  },
  {
    "sql_id": "monetdb_55_5",
    "database_name": "monetdb_55_5",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select 'a' union select concat('a', -4); -- CONCAT",
    "target_query": "SELECT 'a' UNION SELECT 'a' || CAST(-4 AS STRING);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_55_6",
    "database_name": "monetdb_55_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select 'a' union select concat('a', -4.5); -- CONCAT",
    "target_query": "SELECT 'a' UNION SELECT 'a' || CAST(-4.5 AS STRING);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_55_7",
    "database_name": "monetdb_55_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select 'a' union select concat('a', -(4 + 1)); -- CONCAT",
    "target_query": "SELECT 'a' UNION SELECT 'a' || CAST(-(4 + 1) AS STRING);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_55_8",
    "database_name": "monetdb_55_8",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select 'a' union select concat('a', 4 - 5); -- CONCAT",
    "target_query": "SELECT 'a' UNION SELECT 'a' || CAST(4 - 5 AS STRING);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_55_9",
    "database_name": "monetdb_55_9",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select 'a' union select concat('a', -'3'); -- CONCAT",
    "target_query": "SELECT 'a' UNION SELECT 'a' || CAST(-3 AS STRING);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_55_10",
    "database_name": "monetdb_55_10",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select 'a' union select concat('a', -concat('3',4)); -- CONCAT",
    "target_query": "SELECT 'a' UNION SELECT 'a' || CAST(-('3' || CAST(4 AS STRING)) AS STRING);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_55_11",
    "database_name": "monetdb_55_11",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select 'a' union select concat('a', -0); -- CONCAT",
    "target_query": "SELECT 'a' UNION SELECT 'a' || CAST(-0 AS STRING);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_55_12",
    "database_name": "monetdb_55_12",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select 'a' union select concat('a', -0.0); -- CONCAT",
    "target_query": "SELECT 'a' UNION SELECT 'a' || CAST(-0.0 AS STRING);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_55_13",
    "database_name": "monetdb_55_13",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select 'a' union select concat('a', -0.0000); -- CONCAT",
    "target_query": "SELECT 'a' UNION SELECT 'a' || CAST(-0.0000 AS STRING);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_55_14",
    "database_name": "monetdb_55_14",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select concat((select x from (select 'a' as x) as t1 ),(select y from (select 'b' as y) as t2 )) from (select 1 union select 2 )as t3; -- CONCAT",
    "target_query": "SELECT (SELECT x FROM (SELECT 'a' AS x) AS t1) || (SELECT y FROM (SELECT 'b' AS y) AS t2) FROM (SELECT 1 UNION SELECT 2) AS t3;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_55_17",
    "database_name": "monetdb_55_17",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select concat(f1, 2) a from t1 union select 'x' a from t1; -- CONCAT",
    "target_query": "SELECT f1 || CAST(2 AS STRING) AS a FROM t1 UNION SELECT 'x' AS a FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1(f1 varchar(6));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(f1 VARCHAR(6));"
    ]
  },
  {
    "sql_id": "monetdb_56_2",
    "database_name": "monetdb_56_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "insert into t1 values (date_add(NULL, INTERVAL 1 DAY)); -- DATE_ADD",
    "target_query": "insert into t1 values (CAST(NULL AS DATE) + INTERVAL '1' DAY);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_ADD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_ADD(datetime_expr, INTERVAL expr unit)",
        "description": "Adds a time interval to a date or datetime value.",
        "examples": [
          "SELECT DATE_ADD('2020-01-01', INTERVAL 10 DAY);",
          "SELECT DATE_ADD('2020-01-01 12:00:00', INTERVAL 3 HOUR);",
          "SELECT DATE_ADD('2020-12-31', INTERVAL 1 MONTH);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "datetime + INTERVAL 'expr' unit",
        "description": "Adds an interval to a datetime using standard SQL interval syntax.",
        "examples": [
          "SELECT TIMESTAMP '2020-01-01' + INTERVAL '10' DAY;",
          "SELECT TIMESTAMP '2020-01-01 12:00:00' + INTERVAL '3' HOUR;",
          "SELECT TIMESTAMP '2020-12-31' + INTERVAL '1' MONTH;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (d date);"
    ],
    "target_related_schemas": [
      "create table t1 (d date);"
    ]
  },
  {
    "sql_id": "monetdb_56_3",
    "database_name": "monetdb_56_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "insert into t1 values (date_add('2000-01-04', INTERVAL NULL DAY)); -- DATE_ADD",
    "target_query": "insert into t1 values (TIMESTAMP '2000-01-04' + INTERVAL '1' DAY);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_ADD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_ADD(datetime_expr, INTERVAL expr unit)",
        "description": "Adds a time interval to a date or datetime value.",
        "examples": [
          "SELECT DATE_ADD('2020-01-01', INTERVAL 10 DAY);",
          "SELECT DATE_ADD('2020-01-01 12:00:00', INTERVAL 3 HOUR);",
          "SELECT DATE_ADD('2020-12-31', INTERVAL 1 MONTH);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "datetime + INTERVAL 'expr' unit",
        "description": "Adds an interval to a datetime using standard SQL interval syntax.",
        "examples": [
          "SELECT TIMESTAMP '2020-01-01' + INTERVAL '10' DAY;",
          "SELECT TIMESTAMP '2020-01-01 12:00:00' + INTERVAL '3' HOUR;",
          "SELECT TIMESTAMP '2020-12-31' + INTERVAL '1' MONTH;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (d date);"
    ],
    "target_related_schemas": [
      "create table t1 (d date);"
    ]
  },
  {
    "sql_id": "monetdb_56_4",
    "database_name": "monetdb_56_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "insert into t1 values (date_add(NULL, INTERVAL 1 DAY)); -- DATE_ADD",
    "target_query": "insert into t1 values (CAST(NULL AS DATE) + INTERVAL '1' DAY);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_ADD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_ADD(datetime_expr, INTERVAL expr unit)",
        "description": "Adds a time interval to a date or datetime value.",
        "examples": [
          "SELECT DATE_ADD('2020-01-01', INTERVAL 10 DAY);",
          "SELECT DATE_ADD('2020-01-01 12:00:00', INTERVAL 3 HOUR);",
          "SELECT DATE_ADD('2020-12-31', INTERVAL 1 MONTH);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "datetime + INTERVAL 'expr' unit",
        "description": "Adds an interval to a datetime using standard SQL interval syntax.",
        "examples": [
          "SELECT TIMESTAMP '2020-01-01' + INTERVAL '10' DAY;",
          "SELECT TIMESTAMP '2020-01-01 12:00:00' + INTERVAL '3' HOUR;",
          "SELECT TIMESTAMP '2020-12-31' + INTERVAL '1' MONTH;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (d date);"
    ],
    "target_related_schemas": [
      "create table t1 (d date);"
    ]
  },
  {
    "sql_id": "monetdb_56_5",
    "database_name": "monetdb_56_5",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "insert into t1 values (date_add('2000-01-04', INTERVAL 1 DAY)); -- DATE_ADD",
    "target_query": "insert into t1 values (TIMESTAMP '2000-01-04' + INTERVAL '1' DAY);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_ADD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_ADD(datetime_expr, INTERVAL expr unit)",
        "description": "Adds a time interval to a date or datetime value.",
        "examples": [
          "SELECT DATE_ADD('2020-01-01', INTERVAL 10 DAY);",
          "SELECT DATE_ADD('2020-01-01 12:00:00', INTERVAL 3 HOUR);",
          "SELECT DATE_ADD('2020-12-31', INTERVAL 1 MONTH);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "datetime + INTERVAL 'expr' unit",
        "description": "Adds an interval to a datetime using standard SQL interval syntax.",
        "examples": [
          "SELECT TIMESTAMP '2020-01-01' + INTERVAL '10' DAY;",
          "SELECT TIMESTAMP '2020-01-01 12:00:00' + INTERVAL '3' HOUR;",
          "SELECT TIMESTAMP '2020-12-31' + INTERVAL '1' MONTH;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (d date);"
    ],
    "target_related_schemas": [
      "create table t1 (d date);"
    ]
  },
  {
    "sql_id": "monetdb_56_7",
    "database_name": "monetdb_56_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT DATE(ts) = CURRENT_DATE + INTERVAL '1' DAY AS is_tomorrow, TIME(ts)FROM (SELECT ADDDATE(TIME'00:00:00', INTERVAL 1 DAY) AS ts) AS dt; -- DATE",
    "target_query": "SELECT CAST(ts AS DATE) = CURRENT_DATE + INTERVAL '1' DAY AS is_tomorrow,CAST(ts AS TIME) AS time_component FROM(SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1' DAY AS ts) AS dt;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE()",
        "description": "In MySQL, the DATE function extracts the date part from a DATETIME or TIMESTAMP value.",
        "examples": [
          "SELECT DATE('2023-05-01 12:34:56') AS result;",
          "SELECT DATE(NOW()) AS current_date_result;",
          "SELECT DATE(CAST('2023-05-01' AS DATETIME)) AS date_from_datetime;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CAST()",
        "description": "MonetDB uses the CAST function to extract a DATE from a DATETIME or TIMESTAMP.",
        "examples": [
          "SELECT CAST('2023-05-01 12:34:56' AS DATE) AS result;",
          "SELECT CAST(NOW() AS DATE) AS current_date_result;",
          "SELECT CAST('2023-05-01' AS DATE) AS date_from_datetime;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_57_3",
    "database_name": "monetdb_57_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select * from t1 where isnull(to_days(mydate)); -- ISNULL, TO_DAYS",
    "target_query": "SELECT * FROM t1 WHERE mydate IS NULL;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ISNULL",
      "TO_DAYS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ISNULL(expr)",
        "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
        "examples": [
          "SELECT ISNULL(NULL);",
          "SELECT ISNULL(5 + NULL);",
          "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
        ]
      },
      {
        "expression": "TO_DAYS(date)",
        "description": "Returns the number of days since 0000-01-01 for a given date.",
        "examples": [
          "SELECT TO_DAYS('2024-05-07');",
          "SELECT TO_DAYS(CURDATE());",
          "SELECT TO_DAYS('1999-12-31 23:59:59');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "expr IS NULL",
        "description": "Standard SQL construct for detecting NULL values.",
        "examples": [
          "SELECT NULL IS NULL;",
          "SELECT (5 * NULL) IS NULL;",
          "SELECT CASE WHEN balance IS NULL THEN 0 ELSE balance END FROM accounts;"
        ]
      },
      {
        "expression": "",
        "description": "",
        "examples": []
      }
    ],
    "source_related_schemas": [
      "create table t1 (id int primary key not null, mydate date not null);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id INT PRIMARY KEY NOT NULL GENERATED ALWAYS AS IDENTITY, mydate DATE NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_57_13",
    "database_name": "monetdb_57_13",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select * from t3 left join(t2 outr2 join t2 outr join t1)on (outr.pk = t3.pk) and (t1.col_int_key = t3.pk) and isnull(t1.col_date_key)and (outr2.pk <> t3.pk); -- ISNULL",
    "target_query": "SELECT * FROM t3 LEFT JOIN (t2 outr2 JOIN t2 outr JOIN t1) ON (outr.pk = t3.pk) AND (t1.col_int_key = t3.pk) AND t1.col_date_key IS NULL AND (outr2.pk <> t3.pk);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ISNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ISNULL(expr)",
        "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
        "examples": [
          "SELECT ISNULL(NULL);",
          "SELECT ISNULL(5 + NULL);",
          "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "expr IS NULL",
        "description": "Standard SQL construct for detecting NULL values.",
        "examples": [
          "SELECT NULL IS NULL;",
          "SELECT (5 * NULL) IS NULL;",
          "SELECT CASE WHEN balance IS NULL THEN 0 ELSE balance END FROM accounts;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t3(pk INT NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t3 (pk INT NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_57_14",
    "database_name": "monetdb_57_14",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select * from t3 join(t2 outr2 join t2 outr join t1)on (outr.pk = t3.pk) and (t1.col_int_key = t3.pk) and isnull(t1.col_date_key)and (outr2.pk <> t3.pk) ; -- ISNULL",
    "target_query": "SELECT * FROM t3 JOIN (t2 outr2 JOIN t2 outr JOIN t1) ON (outr.pk = t3.pk) AND (t1.col_int_key = t3.pk) AND t1.col_date_key IS NULL AND (outr2.pk <> t3.pk);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ISNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ISNULL(expr)",
        "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
        "examples": [
          "SELECT ISNULL(NULL);",
          "SELECT ISNULL(5 + NULL);",
          "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "expr IS NULL",
        "description": "Standard SQL construct for detecting NULL values.",
        "examples": [
          "SELECT NULL IS NULL;",
          "SELECT (5 * NULL) IS NULL;",
          "SELECT CASE WHEN balance IS NULL THEN 0 ELSE balance END FROM accounts;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t3(pk INT NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t3 (pk INT NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_58_4",
    "database_name": "monetdb_58_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "explain select * from t1 where a like concat('abc','%'); -- CONCAT",
    "target_query": "explain select * from t1 where a like 'abc' || '%';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a varchar(10));"
    ],
    "target_related_schemas": [
      "create table t1 (a varchar(10));"
    ]
  },
  {
    "sql_id": "monetdb_58_5",
    "database_name": "monetdb_58_5",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select * from t1 where a like concat(\"abc\",\"%\"); -- CONCAT",
    "target_query": "select * from t1 where a like 'abc' || '%';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str1 || str2 || ...",
        "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
        "examples": [
          "SELECT 'Hello' || ' ' || 'World';",
          "SELECT 'Year: ' || CAST(2025 AS STRING);",
          "SELECT name || '_' || CAST(id AS STRING) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a varchar(10));"
    ],
    "target_related_schemas": [
      "create table t1 (a varchar(10));"
    ]
  },
  {
    "sql_id": "monetdb_59_0",
    "database_name": "monetdb_59_0",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL); -- LN",
    "target_query": "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LN"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LN(x)",
        "description": "The LN() function returns the natural logarithm of x. If x is less than or equal to 0, it returns NULL.",
        "examples": [
          "select ln(exp(10));",
          "select exp(ln(sqrt(10)) * 2);",
          "select ln(-1);",
          "select ln(0);",
          "select ln(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LN(x)",
        "description": "MonetDB's LN() function returns the natural logarithm of x. It returns NaN for negative or zero values, similar to ClickHouse.",
        "examples": [
          "select ln(exp(10));",
          "select exp(ln(sqrt(10)) * 2);",
          "select ln(NULL);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_59_1",
    "database_name": "monetdb_59_1",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select log2(8),log2(15),log2(NULL); -- LOG2",
    "target_query": "select log(8) / log(2),log(15) / log(2),log(NULL) / log(2);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LOG2"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LOG2(number)",
        "description": "Returns the logarithm of a number with base 2. Returns NULL for zero or negative numbers.",
        "examples": [
          "SELECT LOG2(8);",
          "SELECT LOG2(15);",
          "SELECT LOG2(-2);",
          "SELECT LOG2(0);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "log(number) / log(2)",
        "description": "Computes the logarithm of a number with base 2 using the formula log(number) / log(2). Returns NULL for zero or negative numbers.",
        "examples": [
          "SELECT log(8) / log(2);",
          "SELECT log(15) / log(2);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_59_2",
    "database_name": "monetdb_59_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select pow(10,log10(10)),power(2,4); -- POW, POWER",
    "target_query": "select POWER(10,log10(10)),POWER(2,4);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "POW",
      "POWER"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "POW(3, 3)",
        "description": "POW(x, y) in MySQL is used to calculate x raised to the power of y. It returns the result of x^y.",
        "examples": [
          "SELECT POW(3, 3);",
          "SELECT POW(5, 4);",
          "SELECT POW(x, 2) FROM some_table;"
        ]
      },
      {
        "expression": "SELECT POW(10, 2), POWER(2, 3), POWER(3, 3);",
        "description": "Calculates the power of a number: POW(10, 2) returns 100, POWER(2, 3) returns 8, POWER(3, 3) returns 27.",
        "examples": [
          "SELECT POW(5, 2);",
          "SELECT POWER(3, 4);",
          "SELECT POWER(10, 0);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POWER(3, 3)",
        "description": "MonetDB supports the POWER() function to calculate x raised to the power of y, where x and y are typically INTEGER or FLOAT types.",
        "examples": [
          "SELECT POWER(3, 3);",
          "SELECT POWER(5, 4);",
          "SELECT POWER(x, 2) FROM some_table;"
        ]
      },
      {
        "expression": "SELECT POWER(10, 2), POWER(2, 3), POWER(3, 3);",
        "description": "Calculates the power of a number: POWER(10, 2) returns 100, POWER(2, 3) returns 8, POWER(3, 3) returns 27.",
        "examples": [
          "SELECT POWER(5, 2);",
          "SELECT POWER(3, 4);",
          "SELECT POWER(10, 0);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_59_3",
    "database_name": "monetdb_59_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select ceil(0.09); -- CEIL",
    "target_query": "select ceil(0.09);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CEIL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CEIL(x)",
        "description": "Returns the smallest integer value not less than x (rounds up).",
        "examples": [
          "SELECT CEIL(1.3);",
          "SELECT CEIL(-2.8);",
          "SELECT CEIL(RAND() * 100);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CEIL(x)",
        "description": "Returns the least integer greater than or equal to x.",
        "examples": [
          "SELECT CEIL(1.3);",
          "SELECT CEIL(-2.8);",
          "SELECT CEIL(RAND() * 100);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_59_4",
    "database_name": "monetdb_59_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select ceil(0.000000000000000009); -- CEIL",
    "target_query": "select ceil(0.000000000000000009);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CEIL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CEIL(x)",
        "description": "Returns the smallest integer value not less than x (rounds up).",
        "examples": [
          "SELECT CEIL(1.3);",
          "SELECT CEIL(-2.8);",
          "SELECT CEIL(RAND() * 100);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CEIL(x)",
        "description": "Returns the least integer greater than or equal to x.",
        "examples": [
          "SELECT CEIL(1.3);",
          "SELECT CEIL(-2.8);",
          "SELECT CEIL(RAND() * 100);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_59_7",
    "database_name": "monetdb_59_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "insert into t1 values ('http://www.foo.com/', now()); -- NOW",
    "target_query": "insert into t1 values ('http://www.foo.com/', CURRENT_TIMESTAMP);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a varchar(90), ts datetime not null);"
    ],
    "target_related_schemas": [
      "create table t1 (a varchar(90), ts timestamp not null);"
    ]
  },
  {
    "sql_id": "monetdb_59_8",
    "database_name": "monetdb_59_8",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select a from t1 where a='http://www.foo.com/' order by abs(timediff(ts, 0)); -- TIMEDIFF",
    "target_query": "select a from t1 where a='http://www.foo.com/' order by abs(EXTRACT(EPOCH FROM ts - timestamp '1970-01-01 00:00:00'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')",
        "description": "MonetDB does not have a TIMEDIFF function but supports using EXTRACT to calculate the time difference in seconds.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');",
          "SELECT EXTRACT(EPOCH FROM NOW() - timestamp '2023-06-15 10:00:00');",
          "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a varchar(90), ts datetime not null);"
    ],
    "target_related_schemas": [
      "create table t1 (a varchar(90), ts timestamp not null);"
    ]
  },
  {
    "sql_id": "monetdb_59_10",
    "database_name": "monetdb_59_10",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select mod(cast(-2 as unsigned), 3), mod(18446744073709551614, 3), mod(-2, 3); -- MOD",
    "target_query": "select mod(-2, 3), mod(18446744073709551614, 3), mod(-2, 3);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MOD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Returns the remainder of N divided by M. Returns NULL if M = 0.",
        "examples": [
          "SELECT MOD(10, 3);",
          "SELECT 10 % 3;",
          "SELECT MOD(5, 0);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Returns the remainder after integer division.",
        "examples": [
          "SELECT MOD(7, 2);",
          "SELECT 7 % 2;",
          "SELECT MOD(3, 0);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_59_11",
    "database_name": "monetdb_59_11",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select mod(5, cast(-2 as unsigned)), mod(5, 18446744073709551614), mod(5, -2); -- MOD",
    "target_query": "SELECT mod(5, -2), mod(5, 18446744073709551614), mod(5, -2);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MOD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Returns the remainder of N divided by M. Returns NULL if M = 0.",
        "examples": [
          "SELECT MOD(10, 3);",
          "SELECT 10 % 3;",
          "SELECT MOD(5, 0);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Returns the remainder after integer division.",
        "examples": [
          "SELECT MOD(7, 2);",
          "SELECT 7 % 2;",
          "SELECT MOD(3, 0);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_59_12",
    "database_name": "monetdb_59_12",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select pow(cast(-2 as unsigned), 5), pow(18446744073709551614, 5), pow(-2, 5); -- POW",
    "target_query": "select POWER(-2, 5), POWER(18446744073709551614, 5), POWER(-2, 5);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "POW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "POW(3, 3)",
        "description": "POW(x, y) in MySQL is used to calculate x raised to the power of y. It returns the result of x^y.",
        "examples": [
          "SELECT POW(3, 3);",
          "SELECT POW(5, 4);",
          "SELECT POW(x, 2) FROM some_table;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POWER(3, 3)",
        "description": "MonetDB supports the POWER() function to calculate x raised to the power of y, where x and y are typically INTEGER or FLOAT types.",
        "examples": [
          "SELECT POWER(3, 3);",
          "SELECT POWER(5, 4);",
          "SELECT POWER(x, 2) FROM some_table;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_59_17",
    "database_name": "monetdb_59_17",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT CASE(('')) WHEN (CONVERT(1, CHAR(1))) THEN (('' / 1)) END; -- CONVERT",
    "target_query": "SELECT CASE(('')) WHEN (CAST(1 AS CHAR(1))) THEN (('' / 1)) END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONVERT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONVERT(expression USING charset)",
        "description": "Converts data types or changes the character set.",
        "examples": [
          "SELECT CONVERT('Hello World' USING utf8);",
          "SELECT CONVERT(1234, CHAR);",
          "SELECT CONVERT(column_name USING latin1) FROM my_table;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CAST(expression AS target_type)",
        "description": "MonetDB uses CAST for type conversion. No direct equivalent for CONVERT TO CHARACTER SET.",
        "examples": [
          "SELECT CAST('Hello World' AS TEXT);",
          "SELECT CAST(1234 AS VARCHAR);",
          "SELECT CAST(column_name AS TEXT) FROM my_table;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_60_1",
    "database_name": "monetdb_60_1",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select (1.175494351E-37 div 1.7976931348623157E+308); -- DIV",
    "target_query": "SELECT FLOOR(1.175494351E-37 / 1.7976931348623157E+308);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DIV"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "a DIV b",
        "description": "Performs integer division between two numbers and returns the floor of the quotient.",
        "examples": [
          "SELECT 10 DIV 3;",
          "SELECT 5.8 DIV 2;",
          "SELECT 9 DIV 4 + 1;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "FLOOR(a / b)",
        "description": "Evaluates division and applies FLOOR to get integer result.",
        "examples": [
          "SELECT FLOOR(10 / 3);",
          "SELECT FLOOR(5.8 / 2);",
          "SELECT FLOOR(9 / 4) + 1;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_60_4",
    "database_name": "monetdb_60_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO t1 VALUES (ln(1)); -- LN",
    "target_query": "INSERT INTO t1 VALUES (ln(1));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LN"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LN(x)",
        "description": "The LN() function returns the natural logarithm of x. If x is less than or equal to 0, it returns NULL.",
        "examples": [
          "select ln(exp(10));",
          "select exp(ln(sqrt(10)) * 2);",
          "select ln(-1);",
          "select ln(0);",
          "select ln(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LN(x)",
        "description": "MonetDB's LN() function returns the natural logarithm of x. It returns NaN for negative or zero values, similar to ClickHouse.",
        "examples": [
          "select ln(exp(10));",
          "select exp(ln(sqrt(10)) * 2);",
          "select ln(NULL);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(a DOUBLE);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(a DOUBLE);"
    ]
  },
  {
    "sql_id": "monetdb_60_6",
    "database_name": "monetdb_60_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT floor(ceil(123456789)); -- CEIL",
    "target_query": "SELECT floor(ceil(123456789));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CEIL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CEIL(x)",
        "description": "Returns the smallest integer value not less than x (rounds up).",
        "examples": [
          "SELECT CEIL(1.3);",
          "SELECT CEIL(-2.8);",
          "SELECT CEIL(RAND() * 100);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CEIL(x)",
        "description": "Returns the least integer greater than or equal to x.",
        "examples": [
          "SELECT CEIL(1.3);",
          "SELECT CEIL(-2.8);",
          "SELECT CEIL(RAND() * 100);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_60_7",
    "database_name": "monetdb_60_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select cast(pow(2,63)-1024 as signed) as pp; -- POW",
    "target_query": "SELECT cast(POWER(2,63)-1024 as bigint) as pp;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "POW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "POW(3, 3)",
        "description": "POW(x, y) in MySQL is used to calculate x raised to the power of y. It returns the result of x^y.",
        "examples": [
          "SELECT POW(3, 3);",
          "SELECT POW(5, 4);",
          "SELECT POW(x, 2) FROM some_table;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POWER(3, 3)",
        "description": "MonetDB supports the POWER() function to calculate x raised to the power of y, where x and y are typically INTEGER or FLOAT types.",
        "examples": [
          "SELECT POWER(3, 3);",
          "SELECT POWER(5, 4);",
          "SELECT POWER(x, 2) FROM some_table;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_60_12",
    "database_name": "monetdb_60_12",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT * FROM t0 WHERE CAST(COALESCE(t0.c0, -1) AS UNSIGNED); -- COALESCE",
    "target_query": "SELECT * FROM t0 WHERE CAST(COALESCE(t0.c0, -1) AS bigint);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...)",
        "description": "Standard SQL COALESCE function is supported.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t0(c0 BIGINT UNSIGNED);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0(c0 BIGINT);"
    ]
  },
  {
    "sql_id": "monetdb_60_13",
    "database_name": "monetdb_60_13",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT * FROM t0 WHERE CAST(IFNULL(t0.c0, -1) AS UNSIGNED); -- IFNULL",
    "target_query": "SELECT * FROM t0 WHERE CAST(COALESCE(t0.c0, -1) AS bigint);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2)",
        "description": "MonetDB also uses COALESCE to return the first non-NULL value. This works the same way as IFNULL in MySQL.",
        "examples": [
          "SELECT COALESCE(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t0(c0 BIGINT UNSIGNED);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0(c0 BIGINT);"
    ]
  },
  {
    "sql_id": "monetdb_60_14",
    "database_name": "monetdb_60_14",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT CAST(COALESCE(t0.c0, -1) AS UNSIGNED) IS TRUE FROM t0; -- COALESCE",
    "target_query": "SELECT CAST(COALESCE(t0.c0, -1) AS bigint) !=0 FROM t0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...)",
        "description": "Standard SQL COALESCE function is supported.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t0(c0 BIGINT UNSIGNED);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0(c0 BIGINT);"
    ]
  },
  {
    "sql_id": "monetdb_60_15",
    "database_name": "monetdb_60_15",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT CAST(COALESCE(t0.c0, -1) AS UNSIGNED) FROM t0; -- COALESCE",
    "target_query": "SELECT CAST(COALESCE(t0.c0, -1) AS bigint) FROM t0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...)",
        "description": "Standard SQL COALESCE function is supported.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t0(c0 BIGINT UNSIGNED);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0(c0 BIGINT);"
    ]
  },
  {
    "sql_id": "monetdb_61_0",
    "database_name": "monetdb_61_0",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select md5('a'), hex(md5('a')); -- MD5, HEX",
    "target_query": "SELECT MD5('a');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MD5",
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      },
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      },
      {
        "expression": "",
        "description": "",
        "examples": []
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_61_2",
    "database_name": "monetdb_61_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "create table t1 as select md5('a') as c1; -- MD5",
    "target_query": "CREATE TABLE t1 AS SELECT MD5('a') AS c1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MD5"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 as select md5('a') as c1; -- MD5"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 AS SELECT MD5('a') AS c1;"
    ]
  },
  {
    "sql_id": "monetdb_61_4",
    "database_name": "monetdb_61_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select md5('hello'); -- MD5",
    "target_query": "SELECT MD5('hello');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MD5"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_61_5",
    "database_name": "monetdb_61_5",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "explain select md5('hello'); -- MD5",
    "target_query": "EXPLAIN SELECT MD5('hello');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MD5"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_61_6",
    "database_name": "monetdb_61_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select length(unhex(md5(\"abrakadabra\"))); -- LENGTH, UNHEX, MD5",
    "target_query": "SELECT octet_length(MD5('abrakadabra'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH",
      "UNHEX",
      "MD5"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      },
      {
        "expression": "UNHEX(str)",
        "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT HEX(UNHEX('4D7953514C'));",
          "SELECT UNHEX('48656C6C6F');",
          "SELECT UNHEX(NULL);"
        ]
      },
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "octet_length(str)",
        "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
        "examples": [
          "SELECT octet_length('abc');",
          "SELECT octet_length('你好');",
          "SELECT octet_length(repeat('a', 1000));"
        ]
      },
      {
        "expression": "",
        "description": "",
        "examples": []
      },
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_61_8",
    "database_name": "monetdb_61_8",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "insert into t1 values ( 'test',md5('test')), ('test', md5('test')); -- MD5",
    "target_query": "INSERT INTO t1 VALUES ('test', MD5('test')), ('test', MD5('test'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MD5"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (f1 varchar(4), f2 varchar(64));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (f1 VARCHAR(4), f2 VARCHAR(64));"
    ]
  },
  {
    "sql_id": "monetdb_61_9",
    "database_name": "monetdb_61_9",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select * from t1 where f1='test' and (f2= md5(\"test\") or f2= md5(\"Test\")); -- MD5",
    "target_query": "SELECT * FROM t1 WHERE f1 = 'test' AND (f2 = MD5('test') OR f2 = MD5('TEST'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MD5"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (f1 varchar(4), f2 varchar(64));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (f1 VARCHAR(4), f2 VARCHAR(64));"
    ]
  },
  {
    "sql_id": "monetdb_61_10",
    "database_name": "monetdb_61_10",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select * from t1 where f1='test' and (f2= md5(\"TEST\") or f2= md5(\"test\")); -- MD5",
    "target_query": "SELECT * FROM t1 WHERE f1 = 'test' AND (f2 = MD5('TEST') OR f2 = MD5('test'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MD5"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (f1 varchar(4), f2 varchar(64));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (f1 VARCHAR(4), f2 VARCHAR(64));"
    ]
  },
  {
    "sql_id": "monetdb_62_4",
    "database_name": "monetdb_62_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select a from t1 where mid(a+0,6,3) in ( mid(20040106123400,6,3) ); -- MID",
    "target_query": "SELECT a FROM t1 WHERE substring(sys.timestamp_to_str(a, '%Y%m%d%H%i%s'), 6, 3) IN ( substring('20040106123400', 6, 3));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MID"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MID(str, pos, len)",
        "description": "Extracts a substring from the string `str`, starting at position `pos`, with length `len`.",
        "examples": [
          "SELECT MID('ABCDEFGHIJKL', 5, 3);",
          "SELECT CONCAT(MID('hello_world', 1, 5), MID('hello_world', 7, 5));",
          "SELECT MID('  padded_text  ', 3, 6);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "substring(str, pos, len)",
        "description": "Standard SQL function to extract a substring starting at character `pos` for length `len`.",
        "examples": [
          "SELECT substring('ABCDEFGHIJKL', 5, 3);",
          "SELECT substring('hello_world', 1, 5) || substring('hello_world', 7, 5);",
          "SELECT substring('  padded_text  ', 3, 6);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 ( a timestamp );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a timestamp );"
    ]
  },
  {
    "sql_id": "monetdb_62_5",
    "database_name": "monetdb_62_5",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select a from t1 where mid(a+0,6,3) = ( mid(20040106123400,6,3) ); -- MID",
    "target_query": "SELECT a FROM t1 WHERE substring(sys.timestamp_to_str(a, '%Y%m%d%H%i%s'), 6, 3) = substring('20040106123400', 6, 3);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MID"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MID(str, pos, len)",
        "description": "Extracts a substring from the string `str`, starting at position `pos`, with length `len`.",
        "examples": [
          "SELECT MID('ABCDEFGHIJKL', 5, 3);",
          "SELECT CONCAT(MID('hello_world', 1, 5), MID('hello_world', 7, 5));",
          "SELECT MID('  padded_text  ', 3, 6);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "substring(str, pos, len)",
        "description": "Standard SQL function to extract a substring starting at character `pos` for length `len`.",
        "examples": [
          "SELECT substring('ABCDEFGHIJKL', 5, 3);",
          "SELECT substring('hello_world', 1, 5) || substring('hello_world', 7, 5);",
          "SELECT substring('  padded_text  ', 3, 6);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 ( a timestamp );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a timestamp );"
    ]
  },
  {
    "sql_id": "monetdb_62_15",
    "database_name": "monetdb_62_15",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT DISTINCT LEAST(a, (SELECT b FROM t1 LIMIT 1)) FROM t1 UNION SELECT 1; -- LEAST",
    "target_query": "SELECT DISTINCT CASE WHEN a <= (SELECT b FROM t1 LIMIT 1) THEN a ELSE (SELECT b FROM t1 LIMIT 1) END FROM t1 UNION SELECT 1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN ... THEN ... END",
        "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
        "examples": [
          "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
          "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
          "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a INT, b LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT, b VARCHAR);"
    ]
  },
  {
    "sql_id": "monetdb_62_16",
    "database_name": "monetdb_62_16",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT DISTINCT GREATEST(a, (SELECT b FROM t1 LIMIT 1)) FROM t1 UNION SELECT 1; -- GREATEST",
    "target_query": "SELECT DISTINCT GREATEST(a, (SELECT b FROM t1 LIMIT 1)) FROM t1 UNION SELECT 1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a INT, b LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT, b VARCHAR);"
    ]
  },
  {
    "sql_id": "monetdb_63_0",
    "database_name": "monetdb_63_0",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select 1+1,1-1,1+1*2,8/5,8%5,mod(8,5),-(1+1)*-2; -- MOD",
    "target_query": "select 1+1,1-1,1+1*2,8/5,8%5,mod(8,5),-(1+1)*-2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MOD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Returns the remainder of N divided by M. Returns NULL if M = 0.",
        "examples": [
          "SELECT MOD(10, 3);",
          "SELECT 10 % 3;",
          "SELECT MOD(5, 0);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Returns the remainder after integer division.",
        "examples": [
          "SELECT MOD(7, 2);",
          "SELECT 7 % 2;",
          "SELECT MOD(3, 0);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_64_0",
    "database_name": "monetdb_64_0",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select date_format(\"1997-12-31 23:59:59.000002\", \"%f\"); -- DATE_FORMAT",
    "target_query": "SELECT sys.timestamp_to_str(TIMESTAMP '1997-12-31 23:59:59.000002', 'FF6');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
        "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
        "examples": [
          "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
          "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_64_1",
    "database_name": "monetdb_64_1",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select datediff(\"1997-12-31 23:59:59.000001\",\"1997-12-30\"); -- DATEDIFF",
    "target_query": "SELECT DATE '1997-12-31' - DATE '1997-12-30';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATEDIFF(date1, date2)",
        "description": "Returns the number of days between two date or datetime expressions (date1 - date2), ignoring time part.",
        "examples": [
          "SELECT DATEDIFF('2025-12-31', '2025-12-01');",
          "SELECT DATEDIFF('2025-01-01', '2024-12-31');",
          "SELECT DATEDIFF(NULL, '2025-01-01');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "date1 - date2",
        "description": "Subtracting one DATE from another returns the day difference as an integer.",
        "examples": [
          "SELECT DATE '2025-12-31' - DATE '2025-12-01';",
          "SELECT DATE '2025-01-01' - DATE '2024-12-31';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_64_2",
    "database_name": "monetdb_64_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select datediff(\"1997-11-30 23:59:59.000001\",null); --  DATEDIFF",
    "target_query": "SELECT DATE '1997-11-30' - NULL;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATEDIFF(date1, date2)",
        "description": "Returns the number of days between two date or datetime expressions (date1 - date2), ignoring time part.",
        "examples": [
          "SELECT DATEDIFF('2025-12-31', '2025-12-01');",
          "SELECT DATEDIFF('2025-01-01', '2024-12-31');",
          "SELECT DATEDIFF(NULL, '2025-01-01');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "date1 - date2",
        "description": "Subtracting one DATE from another returns the day difference as an integer.",
        "examples": [
          "SELECT DATE '2025-12-31' - DATE '2025-12-01';",
          "SELECT DATE '2025-01-01' - DATE '2024-12-31';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_64_3",
    "database_name": "monetdb_64_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select makedate(03,1); -- MAKEDATE",
    "target_query": "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKEDATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKEDATE(year, day_of_year)",
        "description": "Returns a date from the given year and day of the year.",
        "examples": [
          "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
          "SELECT MAKEDATE(2025, 100) AS specific_date;",
          "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "DATE 'year-01-01' + INTERVAL 'day_of_year - 1' DAY",
        "description": "Returns a date from the given year and day of the year by adding interval days to January 1st.",
        "examples": [
          "SELECT DATE '2009-01-01' AS first_day_of_year;",
          "SELECT DATE '2025-01-01' + INTERVAL '99' DAY AS specific_date;",
          "SELECT DATE '2020-01-01' + INTERVAL '365' DAY AS last_day_of_year;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_64_5",
    "database_name": "monetdb_64_5",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select makedate(1997,1); -- MAKEDATE",
    "target_query": "SELECT DATE '1997-01-01' + INTERVAL '0' DAY;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKEDATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKEDATE(year, day_of_year)",
        "description": "Returns a date from the given year and day of the year.",
        "examples": [
          "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
          "SELECT MAKEDATE(2025, 100) AS specific_date;",
          "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "DATE 'year-01-01' + INTERVAL 'day_of_year - 1' DAY",
        "description": "Returns a date from the given year and day of the year by adding interval days to January 1st.",
        "examples": [
          "SELECT DATE '2009-01-01' AS first_day_of_year;",
          "SELECT DATE '2025-01-01' + INTERVAL '99' DAY AS specific_date;",
          "SELECT DATE '2020-01-01' + INTERVAL '365' DAY AS last_day_of_year;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_64_6",
    "database_name": "monetdb_64_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select makedate(1997,0); -- MAKEDATE",
    "target_query": "SELECT DATE '1997-01-01' + INTERVAL '-1' DAY;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKEDATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKEDATE(year, day_of_year)",
        "description": "Returns a date from the given year and day of the year.",
        "examples": [
          "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
          "SELECT MAKEDATE(2025, 100) AS specific_date;",
          "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "DATE 'year-01-01' + INTERVAL 'day_of_year - 1' DAY",
        "description": "Returns a date from the given year and day of the year by adding interval days to January 1st.",
        "examples": [
          "SELECT DATE '2009-01-01' AS first_day_of_year;",
          "SELECT DATE '2025-01-01' + INTERVAL '99' DAY AS specific_date;",
          "SELECT DATE '2020-01-01' + INTERVAL '365' DAY AS last_day_of_year;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_64_7",
    "database_name": "monetdb_64_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select makedate(9999,365); -- MAKEDATE",
    "target_query": "SELECT DATE '9999-01-01' + INTERVAL '364' DAY;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKEDATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKEDATE(year, day_of_year)",
        "description": "Returns a date from the given year and day of the year.",
        "examples": [
          "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
          "SELECT MAKEDATE(2025, 100) AS specific_date;",
          "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "DATE 'year-01-01' + INTERVAL 'day_of_year - 1' DAY",
        "description": "Returns a date from the given year and day of the year by adding interval days to January 1st.",
        "examples": [
          "SELECT DATE '2009-01-01' AS first_day_of_year;",
          "SELECT DATE '2025-01-01' + INTERVAL '99' DAY AS specific_date;",
          "SELECT DATE '2020-01-01' + INTERVAL '365' DAY AS last_day_of_year;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_64_8",
    "database_name": "monetdb_64_8",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select makedate(9999,366); -- MAKEDATE",
    "target_query": "SELECT DATE '9999-01-01' + INTERVAL '365' DAY;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKEDATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKEDATE(year, day_of_year)",
        "description": "Returns a date from the given year and day of the year.",
        "examples": [
          "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
          "SELECT MAKEDATE(2025, 100) AS specific_date;",
          "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "DATE 'year-01-01' + INTERVAL 'day_of_year - 1' DAY",
        "description": "Returns a date from the given year and day of the year by adding interval days to January 1st.",
        "examples": [
          "SELECT DATE '2009-01-01' AS first_day_of_year;",
          "SELECT DATE '2025-01-01' + INTERVAL '99' DAY AS specific_date;",
          "SELECT DATE '2020-01-01' + INTERVAL '365' DAY AS last_day_of_year;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_64_9",
    "database_name": "monetdb_64_9",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select makedate(100,1); -- MAKEDATE",
    "target_query": "SELECT DATE '0100-01-01' + INTERVAL '0' DAY;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKEDATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKEDATE(year, day_of_year)",
        "description": "Returns a date from the given year and day of the year.",
        "examples": [
          "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
          "SELECT MAKEDATE(2025, 100) AS specific_date;",
          "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "DATE 'year-01-01' + INTERVAL 'day_of_year - 1' DAY",
        "description": "Returns a date from the given year and day of the year by adding interval days to January 1st.",
        "examples": [
          "SELECT DATE '2009-01-01' AS first_day_of_year;",
          "SELECT DATE '2025-01-01' + INTERVAL '99' DAY AS specific_date;",
          "SELECT DATE '2020-01-01' + INTERVAL '365' DAY AS last_day_of_year;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_64_10",
    "database_name": "monetdb_64_10",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select subtime(\"1997-12-31 23:59:59.000001\", \"1 1:1:1.000002\"); -- SUBTIME",
    "target_query": "SELECT TIMESTAMP '1997-12-31 23:59:59.000001' - INTERVAL '1 01:01:01.000002' DAY TO SECOND;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "SUBTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SUBTIME(expr1, expr2)",
        "description": "Subtracts a time/datetime interval from the given time or datetime.",
        "examples": [
          "SELECT SUBTIME('12:00:00', '01:30:00');",
          "SELECT SUBTIME('2025-01-01 10:00:00', '00:00:01');",
          "SELECT SUBTIME('05:00:00', '05:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "expr - INTERVAL",
        "description": "Subtracts interval using ANSI SQL syntax with HOUR TO MINUTE/SECOND.",
        "examples": [
          "SELECT TIME '12:00:00' - INTERVAL '01:30' HOUR TO MINUTE;",
          "SELECT TIMESTAMP '2025-01-01 10:00:00' - INTERVAL '00:00:01' HOUR TO SECOND;",
          "SELECT TIME '05:00:00' - INTERVAL '05:00' HOUR TO MINUTE;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_64_11",
    "database_name": "monetdb_64_11",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select subtime(\"1997-12-31 23:59:59.999999\", \"1998-01-01 01:01:01.999999\"); -- SUBTIME",
    "target_query": "SELECT TIMESTAMP '1997-12-31 23:59:59.999999' - TIMESTAMP '1998-01-01 01:01:01.999999';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "SUBTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SUBTIME(expr1, expr2)",
        "description": "Subtracts a time/datetime interval from the given time or datetime.",
        "examples": [
          "SELECT SUBTIME('12:00:00', '01:30:00');",
          "SELECT SUBTIME('2025-01-01 10:00:00', '00:00:01');",
          "SELECT SUBTIME('05:00:00', '05:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "expr - INTERVAL",
        "description": "Subtracts interval using ANSI SQL syntax with HOUR TO MINUTE/SECOND.",
        "examples": [
          "SELECT TIME '12:00:00' - INTERVAL '01:30' HOUR TO MINUTE;",
          "SELECT TIMESTAMP '2025-01-01 10:00:00' - INTERVAL '00:00:01' HOUR TO SECOND;",
          "SELECT TIME '05:00:00' - INTERVAL '05:00' HOUR TO MINUTE;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_64_12",
    "database_name": "monetdb_64_12",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select subtime(\"01:00:00.999999\", \"02:00:00.999998\"); -- SUBTIME",
    "target_query": "SELECT TIME '01:00:00.999999' - TIME '02:00:00.999998';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "SUBTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SUBTIME(expr1, expr2)",
        "description": "Subtracts a time/datetime interval from the given time or datetime.",
        "examples": [
          "SELECT SUBTIME('12:00:00', '01:30:00');",
          "SELECT SUBTIME('2025-01-01 10:00:00', '00:00:01');",
          "SELECT SUBTIME('05:00:00', '05:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "expr - INTERVAL",
        "description": "Subtracts interval using ANSI SQL syntax with HOUR TO MINUTE/SECOND.",
        "examples": [
          "SELECT TIME '12:00:00' - INTERVAL '01:30' HOUR TO MINUTE;",
          "SELECT TIMESTAMP '2025-01-01 10:00:00' - INTERVAL '00:00:01' HOUR TO SECOND;",
          "SELECT TIME '05:00:00' - INTERVAL '05:00' HOUR TO MINUTE;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_64_13",
    "database_name": "monetdb_64_13",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select subtime(\"02:01:01.999999\", \"01:01:01.999999\"); -- SUBTIME",
    "target_query": "SELECT TIME '02:01:01.999999' - TIME '01:01:01.999999';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "SUBTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SUBTIME(expr1, expr2)",
        "description": "Subtracts a time/datetime interval from the given time or datetime.",
        "examples": [
          "SELECT SUBTIME('12:00:00', '01:30:00');",
          "SELECT SUBTIME('2025-01-01 10:00:00', '00:00:01');",
          "SELECT SUBTIME('05:00:00', '05:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "expr - INTERVAL",
        "description": "Subtracts interval using ANSI SQL syntax with HOUR TO MINUTE/SECOND.",
        "examples": [
          "SELECT TIME '12:00:00' - INTERVAL '01:30' HOUR TO MINUTE;",
          "SELECT TIMESTAMP '2025-01-01 10:00:00' - INTERVAL '00:00:01' HOUR TO SECOND;",
          "SELECT TIME '05:00:00' - INTERVAL '05:00' HOUR TO MINUTE;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_64_14",
    "database_name": "monetdb_64_14",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select timediff(\"1997-01-01 23:59:59.000001\",\"1995-12-31 23:59:59.000002\"); -- TIMEDIFF",
    "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1997-01-01 23:59:59.000001' - TIMESTAMP '1995-12-31 23:59:59.000002');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')",
        "description": "MonetDB does not have a TIMEDIFF function but supports using EXTRACT to calculate the time difference in seconds.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');",
          "SELECT EXTRACT(EPOCH FROM NOW() - timestamp '2023-06-15 10:00:00');",
          "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_64_15",
    "database_name": "monetdb_64_15",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select timediff(\"1997-12-31 23:59:59.000001\",\"1997-12-30 01:01:01.000002\"); -- TIMEDIFF",
    "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1997-12-31 23:59:59.000001' - TIMESTAMP '1997-12-30 01:01:01.000002');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')",
        "description": "MonetDB does not have a TIMEDIFF function but supports using EXTRACT to calculate the time difference in seconds.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');",
          "SELECT EXTRACT(EPOCH FROM NOW() - timestamp '2023-06-15 10:00:00');",
          "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_64_16",
    "database_name": "monetdb_64_16",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select timediff(\"1997-12-31 23:59:59.000001\",\"23:59:59.000001\"); -- TIMEDIFF",
    "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1997-12-31 23:59:59.000001' - TIME '23:59:59.000001');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')",
        "description": "MonetDB does not have a TIMEDIFF function but supports using EXTRACT to calculate the time difference in seconds.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');",
          "SELECT EXTRACT(EPOCH FROM NOW() - timestamp '2023-06-15 10:00:00');",
          "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_64_17",
    "database_name": "monetdb_64_17",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select timediff(\"2000:01:01 00:00:00\", \"2000:01:01 00:00:00.000001\"); -- TIMEDIFF",
    "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2000-01-01 00:00:00' - TIMESTAMP '2000-01-01 00:00:00.000001');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')",
        "description": "MonetDB does not have a TIMEDIFF function but supports using EXTRACT to calculate the time difference in seconds.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');",
          "SELECT EXTRACT(EPOCH FROM NOW() - timestamp '2023-06-15 10:00:00');",
          "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_64_18",
    "database_name": "monetdb_64_18",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select timediff(\"2005-01-11 15:48:49.999999\", \"2005-01-11 15:48:50\"); --  TIMEDIFF",
    "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2005-01-11 15:48:49.999999' - TIMESTAMP '2005-01-11 15:48:50');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')",
        "description": "MonetDB does not have a TIMEDIFF function but supports using EXTRACT to calculate the time difference in seconds.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');",
          "SELECT EXTRACT(EPOCH FROM NOW() - timestamp '2023-06-15 10:00:00');",
          "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_65_0",
    "database_name": "monetdb_65_0",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select maketime(10,11,12); -- MAKETIME",
    "target_query": "SELECT TIME '10:11:12';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKETIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKETIME(hours, minutes, seconds)",
        "description": "Creates a time value from the provided hours, minutes, and seconds.",
        "examples": [
          "SELECT MAKETIME(1, 30, 45);",
          "SELECT MAKETIME(12, 0, 0);",
          "SELECT MAKETIME(23, 59, 59);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TIME 'HH:MI:SS'",
        "description": "MonetDB supports creating time values by directly using the TIME keyword with the format 'HH:MI:SS'.",
        "examples": [
          "SELECT TIME '01:30:45';",
          "SELECT TIME '12:00:00';",
          "SELECT TIME '23:59:59';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_65_1",
    "database_name": "monetdb_65_1",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select maketime(20,11,12); -- MAKETIME",
    "target_query": "SELECT TIME '20:11:12';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKETIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKETIME(hours, minutes, seconds)",
        "description": "Creates a time value from the provided hours, minutes, and seconds.",
        "examples": [
          "SELECT MAKETIME(1, 30, 45);",
          "SELECT MAKETIME(12, 0, 0);",
          "SELECT MAKETIME(23, 59, 59);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TIME 'HH:MI:SS'",
        "description": "MonetDB supports creating time values by directly using the TIME keyword with the format 'HH:MI:SS'.",
        "examples": [
          "SELECT TIME '01:30:45';",
          "SELECT TIME '12:00:00';",
          "SELECT TIME '23:59:59';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_65_3",
    "database_name": "monetdb_65_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select timestamp(\"2001-12-01\", \"01:01:01.999999\"); -- TIMESTAMP",
    "target_query": "SELECT CAST('2001-12-01 01:01:01.999999' AS TIMESTAMP);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
        "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
        "examples": [
          "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CAST('2023-06-15 10:30:45' AS TIMESTAMP)",
        "description": "MonetDB uses CAST to convert a date-time string to a TIMESTAMP value.",
        "examples": [
          "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP);",
          "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP);",
          "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP) > CAST('2023-06-14 10:30:45' AS TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_65_4",
    "database_name": "monetdb_65_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select timestamp(\"2001-10-01\", \"01:01:01.000001\"); -- TIMESTAMP",
    "target_query": "SELECT CAST('2001-10-01 01:01:01.000001' AS TIMESTAMP);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
        "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
        "examples": [
          "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CAST('2023-06-15 10:30:45' AS TIMESTAMP)",
        "description": "MonetDB uses CAST to convert a date-time string to a TIMESTAMP value.",
        "examples": [
          "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP);",
          "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP);",
          "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP) > CAST('2023-06-14 10:30:45' AS TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_65_5",
    "database_name": "monetdb_65_5",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select timestamp(\"2001-12-01\", \"20:01:01\"); -- TIMESTAMP",
    "target_query": "SELECT CAST('2001-12-01 20:01:01' AS TIMESTAMP);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
        "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
        "examples": [
          "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CAST('2023-06-15 10:30:45' AS TIMESTAMP)",
        "description": "MonetDB uses CAST to convert a date-time string to a TIMESTAMP value.",
        "examples": [
          "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP);",
          "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP);",
          "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP) > CAST('2023-06-14 10:30:45' AS TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_65_6",
    "database_name": "monetdb_65_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select timestamp(\"2001-12-01\"); -- TIMESTAMP",
    "target_query": "SELECT CAST('2001-12-01' AS TIMESTAMP);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
        "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
        "examples": [
          "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CAST('2023-06-15 10:30:45' AS TIMESTAMP)",
        "description": "MonetDB uses CAST to convert a date-time string to a TIMESTAMP value.",
        "examples": [
          "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP);",
          "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP);",
          "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP) > CAST('2023-06-14 10:30:45' AS TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_65_7",
    "database_name": "monetdb_65_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select day(\"1997-12-31 23:59:59.000001\"); -- DAY",
    "target_query": "SELECT dayofmonth('1997-12-31 23:59:59.000001');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DAY"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DAY(date_expr)",
        "description": "Returns the day of the month (1-31) from a date or datetime expression.",
        "examples": [
          "SELECT DAY('2023-10-15');",
          "SELECT DAY(NOW());",
          "SELECT DAY(CAST('2024-02-29 12:34:56' AS DATE));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "dayofmonth(date_expr)",
        "description": "Returns the day part of a DATE or TIMESTAMP value (1–31).",
        "examples": [
          "SELECT dayofmonth(DATE '2023-10-15');",
          "SELECT dayofmonth(CURRENT_DATE);",
          "SELECT dayofmonth(TIMESTAMP '2024-02-29 00:00:00');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_65_8",
    "database_name": "monetdb_65_8",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select time(\"1997-12-31 23:59:59.000001\"); -- TIME",
    "target_query": "SELECT sys.timestamp_to_str(CAST('1997-12-31 23:59:59' AS TIMESTAMP), '%H:%M:%S');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
        "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
        "examples": [
          "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
          "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "sys.time_to_str(time-value, format)",
        "description": "In MonetDB, the TIME function from SQLite can be emulated using sys.time_to_str to format TIME values as strings in the format 'HH:MM:SS' or 'HH:MM:SS.SSS'. Time arithmetic can be performed using sql_add with INTERVAL expressions.",
        "examples": [
          "SELECT sys.time_to_str(CURRENT_TIME, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
          "SELECT sys.time_to_str(sql_add(CURRENT_TIME, interval '1' hour), '%H:%M:%S'); -- Returns the time one hour after the current time.",
          "SELECT sys.time_to_str(time '14:16:00', '%H:%M:%S.000'); -- Returns '14:16:00.000' with milliseconds."
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_65_12",
    "database_name": "monetdb_65_12",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT TIMEDIFF(t1, t4) As ttt, TIMEDIFF(t2, t3) As qqq,TIMEDIFF(t3, t2) As eee, TIMEDIFF(t2, t4) As rrr from test; -- TIMEDIFF",
    "target_query": "SELECT EXTRACT(EPOCH FROM t1 - t4) AS ttt, EXTRACT(EPOCH FROM t2 - t3) AS qqq, EXTRACT(EPOCH FROM t3 - t2) AS eee, EXTRACT(EPOCH FROM t2 - t4) AS rrr FROM test;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')",
        "description": "MonetDB does not have a TIMEDIFF function but supports using EXTRACT to calculate the time difference in seconds.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');",
          "SELECT EXTRACT(EPOCH FROM NOW() - timestamp '2023-06-15 10:00:00');",
          "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table test(t1 datetime, t2 time, t3 time, t4 datetime);"
    ],
    "target_related_schemas": [
      "CREATE TABLE test(t1 TIMESTAMP, t2 TIME, t3 TIME, t4 TIMESTAMP);"
    ]
  },
  {
    "sql_id": "monetdb_65_13",
    "database_name": "monetdb_65_13",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select str_to_date(\"2003-01-02 10:11:12.0012\", \"%Y-%m-%d %H:%i:%S.%f\"); -- STR_TO_DATE",
    "target_query": "SELECT str_to_date('2003-01-02 10:11:12', '%Y-%m-%d %H:%M:%S');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STR_TO_DATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STR_TO_DATE('09:22', '%H:%i')",
        "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
        "examples": [
          "SELECT STR_TO_DATE('12:45', '%H:%i');",
          "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
          "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "str_to_date('2000-01-01', '%Y-%m-%d')",
        "description": "Converts a string to a date using the specified format, where '%Y-%m-%d' corresponds to the 'Year-Month-Day' format.",
        "examples": [
          "SELECT str_to_date('2000-01-01', '%Y-%m-%d');",
          "SELECT str_to_date('2023-05-06', '%Y-%m-%d');",
          "SELECT str_to_date('1999-12-31', '%Y-%m-%d');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_65_14",
    "database_name": "monetdb_65_14",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select timediff('2008-09-29 20:10:10','2008-09-30 20:10:10'),time('00:00:00'); -- TIMEDIFF, TIME",
    "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2008-09-29 20:10:10' - TIMESTAMP '2008-09-30 20:10:10'), sys.time_to_str('00:00:00', '%H:%M:%S');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF",
      "TIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      },
      {
        "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
        "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
        "examples": [
          "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
          "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')",
        "description": "MonetDB does not have a TIMEDIFF function but supports using EXTRACT to calculate the time difference in seconds.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');",
          "SELECT EXTRACT(EPOCH FROM NOW() - timestamp '2023-06-15 10:00:00');",
          "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');"
        ]
      },
      {
        "expression": "sys.time_to_str(time-value, format)",
        "description": "In MonetDB, the TIME function from SQLite can be emulated using sys.time_to_str to format TIME values as strings in the format 'HH:MM:SS' or 'HH:MM:SS.SSS'. Time arithmetic can be performed using sql_add with INTERVAL expressions.",
        "examples": [
          "SELECT sys.time_to_str(CURRENT_TIME, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
          "SELECT sys.time_to_str(sql_add(CURRENT_TIME, interval '1' hour), '%H:%M:%S'); -- Returns the time one hour after the current time.",
          "SELECT sys.time_to_str(time '14:16:00', '%H:%M:%S.000'); -- Returns '14:16:00.000' with milliseconds."
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_65_15",
    "database_name": "monetdb_65_15",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select timediff('2008-09-29 20:10:10','2008-09-30 20:10:10')>time('00:00:00'); -- TIMEDIFF, TIME",
    "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2008-09-29 20:10:10' - TIMESTAMP '2008-09-30 20:10:10') > 0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF",
      "TIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      },
      {
        "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
        "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
        "examples": [
          "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
          "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')",
        "description": "MonetDB does not have a TIMEDIFF function but supports using EXTRACT to calculate the time difference in seconds.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');",
          "SELECT EXTRACT(EPOCH FROM NOW() - timestamp '2023-06-15 10:00:00');",
          "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');"
        ]
      },
      {
        "expression": "sys.time_to_str(time-value, format)",
        "description": "In MonetDB, the TIME function from SQLite can be emulated using sys.time_to_str to format TIME values as strings in the format 'HH:MM:SS' or 'HH:MM:SS.SSS'. Time arithmetic can be performed using sql_add with INTERVAL expressions.",
        "examples": [
          "SELECT sys.time_to_str(CURRENT_TIME, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
          "SELECT sys.time_to_str(sql_add(CURRENT_TIME, interval '1' hour), '%H:%M:%S'); -- Returns the time one hour after the current time.",
          "SELECT sys.time_to_str(time '14:16:00', '%H:%M:%S.000'); -- Returns '14:16:00.000' with milliseconds."
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_65_16",
    "database_name": "monetdb_65_16",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select timediff('2008-09-29 20:10:10','2008-09-30 20:10:10')<time('00:00:00'); -- TIMEDIFF, TIME",
    "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2008-09-29 20:10:10' - TIMESTAMP '2008-09-30 20:10:10') < 0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF",
      "TIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      },
      {
        "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
        "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
        "examples": [
          "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
          "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')",
        "description": "MonetDB does not have a TIMEDIFF function but supports using EXTRACT to calculate the time difference in seconds.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');",
          "SELECT EXTRACT(EPOCH FROM NOW() - timestamp '2023-06-15 10:00:00');",
          "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');"
        ]
      },
      {
        "expression": "sys.time_to_str(time-value, format)",
        "description": "In MonetDB, the TIME function from SQLite can be emulated using sys.time_to_str to format TIME values as strings in the format 'HH:MM:SS' or 'HH:MM:SS.SSS'. Time arithmetic can be performed using sql_add with INTERVAL expressions.",
        "examples": [
          "SELECT sys.time_to_str(CURRENT_TIME, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
          "SELECT sys.time_to_str(sql_add(CURRENT_TIME, interval '1' hour), '%H:%M:%S'); -- Returns the time one hour after the current time.",
          "SELECT sys.time_to_str(time '14:16:00', '%H:%M:%S.000'); -- Returns '14:16:00.000' with milliseconds."
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_66_1",
    "database_name": "monetdb_66_1",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT sec_to_time(86399)=TIME('23:59:59'); -- SEC_TO_TIME, TIME",
    "target_query": "SELECT LPAD(CAST(CASE WHEN 86399 / 3600 = 24 THEN 0 ELSE 86399 / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((86399 % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(86399 % 60 AS STRING), 2, '0') = sys.time_to_str(TIME '23:59:59', '%H:%M:%S');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "SEC_TO_TIME",
      "TIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SEC_TO_TIME(seconds)",
        "description": "Converts the given number of seconds into a time value in the format HH:MM:SS. Wraps around if seconds exceed 86400.",
        "examples": [
          "SELECT SEC_TO_TIME(3661); -- Returns '01:01:01'",
          "SELECT SEC_TO_TIME(3600); -- Returns '01:00:00'",
          "SELECT SEC_TO_TIME(86400); -- Returns '00:00:00'"
        ]
      },
      {
        "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
        "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
        "examples": [
          "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
          "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT LPAD(CAST(CASE WHEN seconds / 3600 = 24 THEN 0 ELSE seconds / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((seconds % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(seconds % 60 AS STRING), 2, '0') FROM (SELECT 86400 AS seconds) AS t;",
        "description": "In MonetDB, SEC_TO_TIME is not natively supported, but we can simulate it by converting seconds into hours, minutes, and seconds. We use LPAD to ensure the time components are always two digits. Additionally, we use a CASE expression to handle the special case when 24 hours are calculated, resetting it to '00' to correctly represent the time at midnight.",
        "examples": [
          "SELECT LPAD(CAST(CASE WHEN seconds / 3600 = 24 THEN 0 ELSE seconds / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((seconds % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(seconds % 60 AS STRING), 2, '0') FROM (SELECT 3661 AS seconds) AS t,; -- Returns '01:01:01'",
          "SELECT LPAD(CAST(CASE WHEN seconds / 3600 = 24 THEN 0 ELSE seconds / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((seconds % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(seconds % 60 AS STRING), 2, '0') FROM (SELECT 3600 AS seconds) AS t; -- Returns '01:00:00'",
          "SELECT LPAD(CAST(CASE WHEN seconds / 3600 = 24 THEN 0 ELSE seconds / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((seconds % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(seconds % 60 AS STRING), 2, '0') FROM (SELECT 86400 AS seconds) AS t; -- Returns '00:00:00'"
        ]
      },
      {
        "expression": "sys.time_to_str(time-value, format)",
        "description": "In MonetDB, the TIME function from SQLite can be emulated using sys.time_to_str to format TIME values as strings in the format 'HH:MM:SS' or 'HH:MM:SS.SSS'. Time arithmetic can be performed using sql_add with INTERVAL expressions.",
        "examples": [
          "SELECT sys.time_to_str(CURRENT_TIME, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
          "SELECT sys.time_to_str(sql_add(CURRENT_TIME, interval '1' hour), '%H:%M:%S'); -- Returns the time one hour after the current time.",
          "SELECT sys.time_to_str(time '14:16:00', '%H:%M:%S.000'); -- Returns '14:16:00.000' with milliseconds."
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_66_2",
    "database_name": "monetdb_66_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT sec_to_time(86399)='23:59:59'; -- SEC_TO_TIME",
    "target_query": "SELECT LPAD(CAST(CASE WHEN 86399/ 3600 = 24 THEN 0 ELSE 86399 / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((86399 % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(86399 % 60 AS STRING), 2, '0') = '23:59:59';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "SEC_TO_TIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SEC_TO_TIME(seconds)",
        "description": "Converts the given number of seconds into a time value in the format HH:MM:SS. Wraps around if seconds exceed 86400.",
        "examples": [
          "SELECT SEC_TO_TIME(3661); -- Returns '01:01:01'",
          "SELECT SEC_TO_TIME(3600); -- Returns '01:00:00'",
          "SELECT SEC_TO_TIME(86400); -- Returns '00:00:00'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT LPAD(CAST(CASE WHEN seconds / 3600 = 24 THEN 0 ELSE seconds / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((seconds % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(seconds % 60 AS STRING), 2, '0') FROM (SELECT 86400 AS seconds) AS t;",
        "description": "In MonetDB, SEC_TO_TIME is not natively supported, but we can simulate it by converting seconds into hours, minutes, and seconds. We use LPAD to ensure the time components are always two digits. Additionally, we use a CASE expression to handle the special case when 24 hours are calculated, resetting it to '00' to correctly represent the time at midnight.",
        "examples": [
          "SELECT LPAD(CAST(CASE WHEN seconds / 3600 = 24 THEN 0 ELSE seconds / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((seconds % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(seconds % 60 AS STRING), 2, '0') FROM (SELECT 3661 AS seconds) AS t,; -- Returns '01:01:01'",
          "SELECT LPAD(CAST(CASE WHEN seconds / 3600 = 24 THEN 0 ELSE seconds / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((seconds % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(seconds % 60 AS STRING), 2, '0') FROM (SELECT 3600 AS seconds) AS t; -- Returns '01:00:00'",
          "SELECT LPAD(CAST(CASE WHEN seconds / 3600 = 24 THEN 0 ELSE seconds / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((seconds % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(seconds % 60 AS STRING), 2, '0') FROM (SELECT 86400 AS seconds) AS t; -- Returns '00:00:00'"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_66_3",
    "database_name": "monetdb_66_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT time(sec_to_time(86399))=TIME('23:59:59'); -- TIME, SEC_TO_TIME",
    "target_query": "SELECT sys.time_to_str(CAST(LPAD(CAST(86399/3600 AS STRING),2,'0')||':'||LPAD(CAST((86399%3600)/60 AS STRING),2,'0')||':'||LPAD(CAST(86399%60 AS STRING),2,'0') AS TIME),'%H:%M:%S')=sys.time_to_str(TIME'23:59:59','%H:%M:%S');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME",
      "SEC_TO_TIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
        "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
        "examples": [
          "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
          "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
        ]
      },
      {
        "expression": "SEC_TO_TIME(seconds)",
        "description": "Converts the given number of seconds into a time value in the format HH:MM:SS. Wraps around if seconds exceed 86400.",
        "examples": [
          "SELECT SEC_TO_TIME(3661); -- Returns '01:01:01'",
          "SELECT SEC_TO_TIME(3600); -- Returns '01:00:00'",
          "SELECT SEC_TO_TIME(86400); -- Returns '00:00:00'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "sys.time_to_str(time-value, format)",
        "description": "In MonetDB, the TIME function from SQLite can be emulated using sys.time_to_str to format TIME values as strings in the format 'HH:MM:SS' or 'HH:MM:SS.SSS'. Time arithmetic can be performed using sql_add with INTERVAL expressions.",
        "examples": [
          "SELECT sys.time_to_str(CURRENT_TIME, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
          "SELECT sys.time_to_str(sql_add(CURRENT_TIME, interval '1' hour), '%H:%M:%S'); -- Returns the time one hour after the current time.",
          "SELECT sys.time_to_str(time '14:16:00', '%H:%M:%S.000'); -- Returns '14:16:00.000' with milliseconds."
        ]
      },
      {
        "expression": "SELECT LPAD(CAST(CASE WHEN seconds / 3600 = 24 THEN 0 ELSE seconds / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((seconds % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(seconds % 60 AS STRING), 2, '0') FROM (SELECT 86400 AS seconds) AS t;",
        "description": "In MonetDB, SEC_TO_TIME is not natively supported, but we can simulate it by converting seconds into hours, minutes, and seconds. We use LPAD to ensure the time components are always two digits. Additionally, we use a CASE expression to handle the special case when 24 hours are calculated, resetting it to '00' to correctly represent the time at midnight.",
        "examples": [
          "SELECT LPAD(CAST(CASE WHEN seconds / 3600 = 24 THEN 0 ELSE seconds / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((seconds % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(seconds % 60 AS STRING), 2, '0') FROM (SELECT 3661 AS seconds) AS t,; -- Returns '01:01:01'",
          "SELECT LPAD(CAST(CASE WHEN seconds / 3600 = 24 THEN 0 ELSE seconds / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((seconds % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(seconds % 60 AS STRING), 2, '0') FROM (SELECT 3600 AS seconds) AS t; -- Returns '01:00:00'",
          "SELECT LPAD(CAST(CASE WHEN seconds / 3600 = 24 THEN 0 ELSE seconds / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((seconds % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(seconds % 60 AS STRING), 2, '0') FROM (SELECT 86400 AS seconds) AS t; -- Returns '00:00:00'"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_66_4",
    "database_name": "monetdb_66_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT maketime(1,0,1)='01:00:01'; -- MAKETIME",
    "target_query": "SELECT TIME '01:00:01' = '01:00:01';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKETIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKETIME(hours, minutes, seconds)",
        "description": "Creates a time value from the provided hours, minutes, and seconds.",
        "examples": [
          "SELECT MAKETIME(1, 30, 45);",
          "SELECT MAKETIME(12, 0, 0);",
          "SELECT MAKETIME(23, 59, 59);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TIME 'HH:MI:SS'",
        "description": "MonetDB supports creating time values by directly using the TIME keyword with the format 'HH:MI:SS'.",
        "examples": [
          "SELECT TIME '01:30:45';",
          "SELECT TIME '12:00:00';",
          "SELECT TIME '23:59:59';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_66_5",
    "database_name": "monetdb_66_5",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT TIME(maketime(1,0,1))=CAST('01:00:01' AS TIME); -- TIME, MAKETIME",
    "target_query": "SELECT sys.time_to_str(TIME '01:00:01', '%H:%M:%S') = CAST('01:00:01' AS TIME);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME",
      "MAKETIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
        "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
        "examples": [
          "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
          "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
        ]
      },
      {
        "expression": "MAKETIME(hours, minutes, seconds)",
        "description": "Creates a time value from the provided hours, minutes, and seconds.",
        "examples": [
          "SELECT MAKETIME(1, 30, 45);",
          "SELECT MAKETIME(12, 0, 0);",
          "SELECT MAKETIME(23, 59, 59);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "sys.time_to_str(time-value, format)",
        "description": "In MonetDB, the TIME function from SQLite can be emulated using sys.time_to_str to format TIME values as strings in the format 'HH:MM:SS' or 'HH:MM:SS.SSS'. Time arithmetic can be performed using sql_add with INTERVAL expressions.",
        "examples": [
          "SELECT sys.time_to_str(CURRENT_TIME, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
          "SELECT sys.time_to_str(sql_add(CURRENT_TIME, interval '1' hour), '%H:%M:%S'); -- Returns the time one hour after the current time.",
          "SELECT sys.time_to_str(time '14:16:00', '%H:%M:%S.000'); -- Returns '14:16:00.000' with milliseconds."
        ]
      },
      {
        "expression": "TIME 'HH:MI:SS'",
        "description": "MonetDB supports creating time values by directly using the TIME keyword with the format 'HH:MI:SS'.",
        "examples": [
          "SELECT TIME '01:30:45';",
          "SELECT TIME '12:00:00';",
          "SELECT TIME '23:59:59';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_66_6",
    "database_name": "monetdb_66_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT maketime(1,0,1)=CAST('01:00:01' AS TIME); -- MAKETIME",
    "target_query": "SELECT TIME '01:00:01' = CAST('01:00:01' AS TIME);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKETIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKETIME(hours, minutes, seconds)",
        "description": "Creates a time value from the provided hours, minutes, and seconds.",
        "examples": [
          "SELECT MAKETIME(1, 30, 45);",
          "SELECT MAKETIME(12, 0, 0);",
          "SELECT MAKETIME(23, 59, 59);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TIME 'HH:MI:SS'",
        "description": "MonetDB supports creating time values by directly using the TIME keyword with the format 'HH:MI:SS'.",
        "examples": [
          "SELECT TIME '01:30:45';",
          "SELECT TIME '12:00:00';",
          "SELECT TIME '23:59:59';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_69_0",
    "database_name": "monetdb_69_0",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "select 0=0,1>0,1>=1,1<0,1<=0,1!=0,strcmp(\"abc\",\"abcd\"),strcmp(\"b\",\"a\"),strcmp(\"a\",\"a\") ; -- STRCMP",
    "target_query": "SELECT 0=0, 1>0, 1>=1, 1<0, 1<=0, 1!=0, CASE WHEN 'abc' = 'abcd' THEN 0 WHEN 'abc' < 'abcd' THEN -1 ELSE 1 END, CASE WHEN 'b' = 'a' THEN 0 WHEN 'b' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'a' = 'a' THEN 0 WHEN 'a' < 'a' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "MonetDB does not have a direct STRCMP function. This behavior can be simulated using a CASE statement to compare two strings lexicographically.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_69_4",
    "database_name": "monetdb_69_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT GREATEST(d,d) FROM t1 WHERE k=2; -- GREATEST",
    "target_query": "SELECT GREATEST(d,d) FROM t1 WHERE k=2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (d varchar(6), k int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (d varchar(6), k int);"
    ]
  },
  {
    "sql_id": "monetdb_69_10",
    "database_name": "monetdb_69_10",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT greatest( 123456789 , 234567890 ) as g; -- GREATEST",
    "target_query": "SELECT GREATEST(123456789, 234567890) AS g;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_69_11",
    "database_name": "monetdb_69_11",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT least   ( 123456789 , 234567890 ) as l; -- LEAST",
    "target_query": "SELECT CASE WHEN 123456789 <= 234567890 THEN 123456789 ELSE 234567890 END AS l;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN ... THEN ... END",
        "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
        "examples": [
          "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
          "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
          "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_69_12",
    "database_name": "monetdb_69_12",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT greatest (123456789, -1, 234567890 ) as g; -- GREATEST",
    "target_query": "SELECT GREATEST(123456789, -1, 234567890) AS g;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_69_13",
    "database_name": "monetdb_69_13",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT least    (123456789, -1, 234567890 ) as l; -- LEAST",
    "target_query": "SELECT CASE WHEN 123456789 <= -1 AND 123456789 <= 234567890 THEN 123456789 WHEN -1 <= 234567890 THEN -1 ELSE 234567890 END AS l;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN ... THEN ... END",
        "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
        "examples": [
          "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
          "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
          "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_69_14",
    "database_name": "monetdb_69_14",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "CREATE TABLE t1 AS SELECT greatest(-1, 123456789); -- GREATEST",
    "target_query": "CREATE TABLE t1 AS SELECT GREATEST(-1, 123456789);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 AS SELECT greatest(-1, 123456789); -- GREATEST"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 AS SELECT GREATEST(-1, 123456789);"
    ]
  },
  {
    "sql_id": "monetdb_70_0",
    "database_name": "monetdb_70_0",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT GREATEST('11', '5', '2'); -- GREATEST",
    "target_query": "SELECT GREATEST('11', '5', '2');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_70_1",
    "database_name": "monetdb_70_1",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT GREATEST('11', 5, 2); -- GREATEST",
    "target_query": "SELECT GREATEST('11', 5, 2);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_70_2",
    "database_name": "monetdb_70_2",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT GREATEST(11, 5, 2); -- GREATEST",
    "target_query": "SELECT GREATEST(11, 5, 2);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_70_3",
    "database_name": "monetdb_70_3",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT LEAST('11', '5', '2'); -- LEAST",
    "target_query": "SELECT CASE WHEN '11' IS NULL THEN '5' WHEN '5' IS NULL THEN '11' WHEN '11' <= '5' AND '11' <= '2' THEN '11' WHEN '5' <= '2' THEN '5' ELSE '2' END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN ... THEN ... END",
        "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
        "examples": [
          "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
          "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
          "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_70_4",
    "database_name": "monetdb_70_4",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT LEAST('11', 5, 2); -- LEAST",
    "target_query": "SELECT CASE WHEN '11' IS NULL THEN 5 WHEN 5 IS NULL THEN '11' WHEN '11' <= 5 AND '11' <= 2 THEN '11' WHEN 5 <= 2 THEN 5 ELSE 2 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN ... THEN ... END",
        "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
        "examples": [
          "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
          "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
          "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_70_5",
    "database_name": "monetdb_70_5",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT LEAST(11, 5, 2); -- LEAST",
    "target_query": "SELECT CASE WHEN 11 IS NULL THEN 5 WHEN 5 IS NULL THEN 11 WHEN 11 <= 5 AND 11 <= 2 THEN 11 WHEN 5 <= 2 THEN 5 ELSE 2 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN ... THEN ... END",
        "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
        "examples": [
          "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
          "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
          "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_70_6",
    "database_name": "monetdb_70_6",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT GREATEST('11', '5', '2') + 0; -- GREATEST",
    "target_query": "SELECT GREATEST('11', '5', '2') + 0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_70_7",
    "database_name": "monetdb_70_7",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT GREATEST('11', 5, 2) + 0; -- GREATEST",
    "target_query": "SELECT GREATEST('11', 5, 2) + 0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_70_8",
    "database_name": "monetdb_70_8",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT GREATEST(11, 5, 2) + 0; -- GREATEST",
    "target_query": "SELECT GREATEST(11, 5, 2) + 0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_70_9",
    "database_name": "monetdb_70_9",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT GREATEST('11', '5', '2') + 0.00; -- GREATEST",
    "target_query": "SELECT GREATEST('11', '5', '2') + 0.00;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_70_10",
    "database_name": "monetdb_70_10",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT GREATEST('11', 5, 2) + 0.00; -- GREATEST",
    "target_query": "SELECT GREATEST('11', 5, 2) + 0.00;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_70_11",
    "database_name": "monetdb_70_11",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT GREATEST(11, 5, 2) + 0.00; -- GREATEST",
    "target_query": "SELECT GREATEST(11, 5, 2) + 0.00;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_70_15",
    "database_name": "monetdb_70_15",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT greatest(18446744073709551615, NULL)FROM t0017; -- GREATEST",
    "target_query": "SELECT GREATEST(18446744073709551615, NULL) FROM t0017;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t0017 (c0002 bigint(20) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0017 (c0002 BIGINT NOT NULL);"
    ]
  },
  {
    "sql_id": "monetdb_70_20",
    "database_name": "monetdb_70_20",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT * FROM t1 WHERE (GREATEST(c1, c2) = 42) AND (c2 = 1); -- GREATEST",
    "target_query": "SELECT * FROM t1 WHERE (GREATEST(c1, c2) = 42) AND (c2 = 1);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (c1 INT, c2 INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 INT, c2 INT);"
    ]
  },
  {
    "sql_id": "monetdb_70_27",
    "database_name": "monetdb_70_27",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT SUM(LEAST(a, b)) FROM t1; -- LEAST",
    "target_query": "SELECT SUM(CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN ... THEN ... END",
        "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
        "examples": [
          "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
          "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
          "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 (a INTEGER, b INTEGER);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (a INTEGER, b INTEGER);"
    ]
  },
  {
    "sql_id": "monetdb_70_28",
    "database_name": "monetdb_70_28",
    "source_dialect": "mysql",
    "target_dialect": "monetdb",
    "source_query": "SELECT SUM(LEAST(a, b)) FROM t2; -- LEAST",
    "target_query": "SELECT SUM(CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END) FROM t2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN ... THEN ... END",
        "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
        "examples": [
          "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
          "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
          "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 (a INTEGER, b INTEGER);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (a INTEGER, b INTEGER);"
    ]
  },
  {
    "sql_id": "monetdb_1_33",
    "database_name": "monetdb_1_33",
    "source_dialect": "postgresql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO clstr_tst (a, b, c, d) VALUES (32, 6, 'seis', repeat('xyzzy', 10000)); -- REPEAT",
    "target_query": "INSERT INTO clstr_tst (a, b, c, d) VALUES (32, 6, 'seis', REPEAT('xyzzy', 10000));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE clstr_tst (a SERIAL PRIMARY KEY,b INT,c TEXT,d TEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE clstr_tst (a INT PRIMARY KEY,b INT,c TEXT,d TEXT);"
    ]
  },
  {
    "sql_id": "monetdb_10_2",
    "database_name": "monetdb_10_2",
    "source_dialect": "postgresql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO tidrangescan SELECT i,repeat('x', 100) FROM generate_series(1,200) AS s(i); -- REPEAT, GENERATE_SERIES",
    "target_query": "INSERT INTO tidrangescan SELECT i,repeat('x', 100) FROM generate_series(1,200 + 1) AS s(i);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT",
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      },
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      },
      {
        "expression": "generate_series(start, stop [+/-] 1 [, step])",
        "description": "MonetDB's generate_series excludes the stop value by default. To emulate PostgreSQL behavior (which includes the stop value), add 1 to stop when step > 0, or subtract 1 from stop when step < 0.",
        "examples": [
          "SELECT * FROM generate_series(1, 5 + 1);           -- Generates 1 to 5",
          "SELECT * FROM generate_series(3, 9 + 2, 2);        -- Generates 3, 5, 7, 9",
          "SELECT * FROM generate_series(10, 6 - 2, -2);      -- Generates 10, 8, 6"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE tidrangescan(id integer, data text);"
    ],
    "target_related_schemas": [
      "CREATE TABLE tidrangescan(id integer, data text);"
    ]
  },
  {
    "sql_id": "monetdb_12_0",
    "database_name": "monetdb_12_0",
    "source_dialect": "postgresql",
    "target_dialect": "monetdb",
    "source_query": "SELECT generate_series(1, 3); -- GENERATE_SERIES",
    "target_query": "SELECT * FROM generate_series(1, 3 + 1);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [+/-] 1 [, step])",
        "description": "MonetDB's generate_series excludes the stop value by default. To emulate PostgreSQL behavior (which includes the stop value), add 1 to stop when step > 0, or subtract 1 from stop when step < 0.",
        "examples": [
          "SELECT * FROM generate_series(1, 5 + 1);           -- Generates 1 to 5",
          "SELECT * FROM generate_series(3, 9 + 2, 2);        -- Generates 3, 5, 7, 9",
          "SELECT * FROM generate_series(10, 6 - 2, -2);      -- Generates 10, 8, 6"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_12_1",
    "database_name": "monetdb_12_1",
    "source_dialect": "postgresql",
    "target_dialect": "monetdb",
    "source_query": "SELECT generate_series(1, 3) AS val1, generate_series(3,5) AS val2; -- GENERATE_SERIES",
    "target_query": "SELECT * FROM generate_series(1, 3 + 1) AS t1(val1), generate_series(3, 5 + 1) AS t2(val2);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [+/-] 1 [, step])",
        "description": "MonetDB's generate_series excludes the stop value by default. To emulate PostgreSQL behavior (which includes the stop value), add 1 to stop when step > 0, or subtract 1 from stop when step < 0.",
        "examples": [
          "SELECT * FROM generate_series(1, 5 + 1);           -- Generates 1 to 5",
          "SELECT * FROM generate_series(3, 9 + 2, 2);        -- Generates 3, 5, 7, 9",
          "SELECT * FROM generate_series(10, 6 - 2, -2);      -- Generates 10, 8, 6"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_12_2",
    "database_name": "monetdb_12_2",
    "source_dialect": "postgresql",
    "target_dialect": "monetdb",
    "source_query": "SELECT generate_series(1, 2) AS val1, generate_series(1,4) AS val2; -- GENERATE_SERIES",
    "target_query": "SELECT * FROM generate_series(1, 2 + 1) AS t1(val1), generate_series(1, 4 + 1) AS t2(val2);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [+/-] 1 [, step])",
        "description": "MonetDB's generate_series excludes the stop value by default. To emulate PostgreSQL behavior (which includes the stop value), add 1 to stop when step > 0, or subtract 1 from stop when step < 0.",
        "examples": [
          "SELECT * FROM generate_series(1, 5 + 1);           -- Generates 1 to 5",
          "SELECT * FROM generate_series(3, 9 + 2, 2);        -- Generates 3, 5, 7, 9",
          "SELECT * FROM generate_series(10, 6 - 2, -2);      -- Generates 10, 8, 6"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_2_2",
    "database_name": "monetdb_2_2",
    "source_dialect": "postgresql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO cmdata VALUES(repeat('1234567890', 1000)); -- REPEAT",
    "target_query": "INSERT INTO cmdata VALUES(repeat('1234567890', 1000));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE cmdata(f1 text);"
    ],
    "target_related_schemas": [
      "CREATE TABLE cmdata(f1 text);"
    ]
  },
  {
    "sql_id": "monetdb_2_6",
    "database_name": "monetdb_2_6",
    "source_dialect": "postgresql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO cmdata1 VALUES(repeat('1234567890', 1004)); -- REPEAT",
    "target_query": "INSERT INTO cmdata1 VALUES(repeat('1234567890', 1004));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE cmdata1(f1 TEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE cmdata1(f1 TEXT);"
    ]
  },
  {
    "sql_id": "monetdb_3_3",
    "database_name": "monetdb_3_3",
    "source_dialect": "postgresql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO delete_test (id, a, b) VALUES (2, 50, repeat('x', 10000)); -- REPEAT",
    "target_query": "INSERT INTO delete_test (id, a, b) VALUES (2, 50, repeat('x', 10000));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE delete_test (id SERIAL PRIMARY KEY,a INT,b text);"
    ],
    "target_related_schemas": [
      "CREATE TABLE delete_test (id INT PRIMARY KEY, a INT, b text);"
    ]
  },
  {
    "sql_id": "monetdb_4_0",
    "database_name": "monetdb_4_0",
    "source_dialect": "postgresql",
    "target_dialect": "monetdb",
    "source_query": "SELECT current_timestamp = NOW(); -- NOW",
    "target_query": "SELECT current_timestamp = CURRENT_TIMESTAMP;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "In PostgreSQL, CURRENT_TIMESTAMP is used to retrieve the current date and time, equivalent to NOW() in MySQL and MariaDB.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_5_0",
    "database_name": "monetdb_5_0",
    "source_dialect": "postgresql",
    "target_dialect": "monetdb",
    "source_query": "select current_schemas(false); -- CURRENT_SCHEMAS",
    "target_query": "SELECT current_schema;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CURRENT_SCHEMAS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "current_schemas(include_implicit boolean)",
        "description": "Returns a text array of schema names in the current search path. The boolean parameter controls whether implicit schemas such as pg_catalog are included.",
        "examples": [
          "SELECT current_schemas(false);",
          "SELECT current_schemas(true);",
          "SELECT unnest(current_schemas(false));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "current_schema",
        "description": "Returns the name of the current database for the session, used as equivalent to schema name in PostgreSQL.",
        "examples": [
          "SELECT current_schema;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "monetdb_6_2",
    "database_name": "monetdb_6_2",
    "source_dialect": "postgresql",
    "target_dialect": "monetdb",
    "source_query": "create table simple1 as select generate_series(1, 200) AS id; -- GENERATE_SERIES",
    "target_query": "CREATE TABLE simple1 AS SELECT * FROM generate_series(1, 200 + 1) AS id;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [+/-] 1 [, step])",
        "description": "MonetDB's generate_series excludes the stop value by default. To emulate PostgreSQL behavior (which includes the stop value), add 1 to stop when step > 0, or subtract 1 from stop when step < 0.",
        "examples": [
          "SELECT * FROM generate_series(1, 5 + 1);           -- Generates 1 to 5",
          "SELECT * FROM generate_series(3, 9 + 2, 2);        -- Generates 3, 5, 7, 9",
          "SELECT * FROM generate_series(10, 6 - 2, -2);      -- Generates 10, 8, 6"
        ]
      }
    ],
    "source_related_schemas": [
      "create table simple1 as select generate_series(1, 200) AS id; -- GENERATE_SERIES"
    ],
    "target_related_schemas": [
      "CREATE TABLE simple1 AS SELECT * FROM generate_series(1, 200 + 1) AS id;"
    ]
  },
  {
    "sql_id": "monetdb_6_5",
    "database_name": "monetdb_6_5",
    "source_dialect": "postgresql",
    "target_dialect": "monetdb",
    "source_query": "create table bigger_than_it_looks as select generate_series(1, 200) as id; -- GENERATE_SERIES",
    "target_query": "CREATE TABLE bigger_than_it_looks AS SELECT * FROM generate_series(1, 200 + 1) AS id;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [+/-] 1 [, step])",
        "description": "MonetDB's generate_series excludes the stop value by default. To emulate PostgreSQL behavior (which includes the stop value), add 1 to stop when step > 0, or subtract 1 from stop when step < 0.",
        "examples": [
          "SELECT * FROM generate_series(1, 5 + 1);           -- Generates 1 to 5",
          "SELECT * FROM generate_series(3, 9 + 2, 2);        -- Generates 3, 5, 7, 9",
          "SELECT * FROM generate_series(10, 6 - 2, -2);      -- Generates 10, 8, 6"
        ]
      }
    ],
    "source_related_schemas": [
      "create table bigger_than_it_looks as select generate_series(1, 200) as id; -- GENERATE_SERIES"
    ],
    "target_related_schemas": [
      "CREATE TABLE bigger_than_it_looks AS SELECT * FROM generate_series(1, 200 + 1) AS id;"
    ]
  },
  {
    "sql_id": "monetdb_6_10",
    "database_name": "monetdb_6_10",
    "source_dialect": "postgresql",
    "target_dialect": "monetdb",
    "source_query": "insert into extremely_skewed select 42 as id, 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'from generate_series(1, 200); -- GENERATE_SERIES",
    "target_query": "INSERT INTO extremely_skewed SELECT 42 AS id, 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' FROM generate_series(1, 200 + 1);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [+/-] 1 [, step])",
        "description": "MonetDB's generate_series excludes the stop value by default. To emulate PostgreSQL behavior (which includes the stop value), add 1 to stop when step > 0, or subtract 1 from stop when step < 0.",
        "examples": [
          "SELECT * FROM generate_series(1, 5 + 1);           -- Generates 1 to 5",
          "SELECT * FROM generate_series(3, 9 + 2, 2);        -- Generates 3, 5, 7, 9",
          "SELECT * FROM generate_series(10, 6 - 2, -2);      -- Generates 10, 8, 6"
        ]
      }
    ],
    "source_related_schemas": [
      "create table extremely_skewed (id int, t text);"
    ],
    "target_related_schemas": [
      "CREATE TABLE extremely_skewed (id INT, t TEXT);"
    ]
  },
  {
    "sql_id": "monetdb_7_2",
    "database_name": "monetdb_7_2",
    "source_dialect": "postgresql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO pagg_tab SELECT i % 20, i % 30, to_char(i % 12, 'FM0000'), i % 30 FROM generate_series(0, 2999) i; -- TO_CHAR, GENERATE_SERIES",
    "target_query": "INSERT INTO pagg_tab SELECT i % 20, i % 30, lpad(CAST(i % 12 AS STRING), 4, '0'), i % 30 FROM generate_series(0, 2999 + 1) AS g(i);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TO_CHAR",
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "to_char(numeric, 'FM0000')",
        "description": "Formats a number as a zero-padded 4-digit string without leading spaces.",
        "examples": [
          "SELECT to_char(5, 'FM0000');   -- 0005",
          "SELECT to_char(123, 'FM0000'); -- 0123",
          "SELECT to_char(0, 'FM0000');   -- 0000"
        ]
      },
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "lpad(CAST(value AS string), 4, '0')",
        "description": "Pads numeric value with zeros using lpad.",
        "examples": [
          "SELECT lpad(CAST(5 AS string), 4, '0');",
          "SELECT lpad(CAST(123 AS string), 4, '0');",
          "SELECT lpad(CAST(0 AS string), 4, '0');"
        ]
      },
      {
        "expression": "generate_series(start, stop [+/-] 1 [, step])",
        "description": "MonetDB's generate_series excludes the stop value by default. To emulate PostgreSQL behavior (which includes the stop value), add 1 to stop when step > 0, or subtract 1 from stop when step < 0.",
        "examples": [
          "SELECT * FROM generate_series(1, 5 + 1);           -- Generates 1 to 5",
          "SELECT * FROM generate_series(3, 9 + 2, 2);        -- Generates 3, 5, 7, 9",
          "SELECT * FROM generate_series(10, 6 - 2, -2);      -- Generates 10, 8, 6"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE pagg_tab (a int, b int, c text, d int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE pagg_tab (a int, b int, c text, d int);"
    ]
  },
  {
    "sql_id": "monetdb_7_7",
    "database_name": "monetdb_7_7",
    "source_dialect": "postgresql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO pagg_tab_ml SELECT i % 30, i % 10, to_char(i % 4, 'FM0000') FROM generate_series(0, 29999) i; -- TO_CHAR",
    "target_query": "INSERT INTO pagg_tab_ml SELECT i % 30, i % 10, lpad(CAST(i % 4 AS string), 4, '0') FROM generate_series(0, 29999 + 1) AS g(i);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TO_CHAR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "to_char(numeric, 'FM0000')",
        "description": "Formats a number as a zero-padded 4-digit string without leading spaces.",
        "examples": [
          "SELECT to_char(5, 'FM0000');   -- 0005",
          "SELECT to_char(123, 'FM0000'); -- 0123",
          "SELECT to_char(0, 'FM0000');   -- 0000"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "lpad(CAST(value AS string), 4, '0')",
        "description": "Pads numeric value with zeros using lpad.",
        "examples": [
          "SELECT lpad(CAST(5 AS string), 4, '0');",
          "SELECT lpad(CAST(123 AS string), 4, '0');",
          "SELECT lpad(CAST(0 AS string), 4, '0');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE pagg_tab_ml (a int, b int, c text);"
    ],
    "target_related_schemas": [
      "CREATE TABLE pagg_tab_ml (a int, b int, c text);"
    ]
  },
  {
    "sql_id": "monetdb_8_2",
    "database_name": "monetdb_8_2",
    "source_dialect": "postgresql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO prt1 SELECT i, i % 25, to_char(i, 'FM0000') FROM generate_series(0, 599) i WHERE i % 2 = 0; -- TO_CHAR, GENERATE_SERIES",
    "target_query": "INSERT INTO prt1 SELECT i, i % 25, lpad(CAST(i AS string), 4, '0') FROM generate_series(0, 599 + 1) AS g(i) WHERE i % 2 = 0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TO_CHAR",
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "to_char(numeric, 'FM0000')",
        "description": "Formats a number as a zero-padded 4-digit string without leading spaces.",
        "examples": [
          "SELECT to_char(5, 'FM0000');   -- 0005",
          "SELECT to_char(123, 'FM0000'); -- 0123",
          "SELECT to_char(0, 'FM0000');   -- 0000"
        ]
      },
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "lpad(CAST(value AS string), 4, '0')",
        "description": "Pads numeric value with zeros using lpad.",
        "examples": [
          "SELECT lpad(CAST(5 AS string), 4, '0');",
          "SELECT lpad(CAST(123 AS string), 4, '0');",
          "SELECT lpad(CAST(0 AS string), 4, '0');"
        ]
      },
      {
        "expression": "generate_series(start, stop [+/-] 1 [, step])",
        "description": "MonetDB's generate_series excludes the stop value by default. To emulate PostgreSQL behavior (which includes the stop value), add 1 to stop when step > 0, or subtract 1 from stop when step < 0.",
        "examples": [
          "SELECT * FROM generate_series(1, 5 + 1);           -- Generates 1 to 5",
          "SELECT * FROM generate_series(3, 9 + 2, 2);        -- Generates 3, 5, 7, 9",
          "SELECT * FROM generate_series(10, 6 - 2, -2);      -- Generates 10, 8, 6"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE prt1 (a int, b int, c varchar);"
    ],
    "target_related_schemas": [
      "CREATE TABLE prt1 (a int, b int, c varchar);"
    ]
  },
  {
    "sql_id": "monetdb_8_7",
    "database_name": "monetdb_8_7",
    "source_dialect": "postgresql",
    "target_dialect": "monetdb",
    "source_query": "INSERT INTO prt2 SELECT i % 25, i, to_char(i, 'FM0000') FROM generate_series(0, 599) i WHERE i % 3 = 0; -- TO_CHAR, GENERATE_SERIES",
    "target_query": "INSERT INTO prt2 SELECT i % 25, i, lpad(CAST(i AS string), 4, '0') FROM generate_series(0, 599 + 1) AS g(i) WHERE i % 3 = 0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TO_CHAR",
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "to_char(numeric, 'FM0000')",
        "description": "Formats a number as a zero-padded 4-digit string without leading spaces.",
        "examples": [
          "SELECT to_char(5, 'FM0000');   -- 0005",
          "SELECT to_char(123, 'FM0000'); -- 0123",
          "SELECT to_char(0, 'FM0000');   -- 0000"
        ]
      },
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "lpad(CAST(value AS string), 4, '0')",
        "description": "Pads numeric value with zeros using lpad.",
        "examples": [
          "SELECT lpad(CAST(5 AS string), 4, '0');",
          "SELECT lpad(CAST(123 AS string), 4, '0');",
          "SELECT lpad(CAST(0 AS string), 4, '0');"
        ]
      },
      {
        "expression": "generate_series(start, stop [+/-] 1 [, step])",
        "description": "MonetDB's generate_series excludes the stop value by default. To emulate PostgreSQL behavior (which includes the stop value), add 1 to stop when step > 0, or subtract 1 from stop when step < 0.",
        "examples": [
          "SELECT * FROM generate_series(1, 5 + 1);           -- Generates 1 to 5",
          "SELECT * FROM generate_series(3, 9 + 2, 2);        -- Generates 3, 5, 7, 9",
          "SELECT * FROM generate_series(10, 6 - 2, -2);      -- Generates 10, 8, 6"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE prt2 (a int, b int, c varchar);"
    ],
    "target_related_schemas": [
      "CREATE TABLE prt2 (a int, b int, c varchar);"
    ]
  },
  {
    "sql_id": "monetdb_9_2",
    "database_name": "monetdb_9_2",
    "source_dialect": "postgresql",
    "target_dialect": "monetdb",
    "source_query": "SELECT nextval('seq3'); -- NEXTVAL",
    "target_query": "SELECT NEXT VALUE FOR seq3;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NEXTVAL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "nextval('sequence_name')",
        "description": "Returns the next value from a named sequence and increments the counter atomically.",
        "examples": [
          "SELECT nextval('my_seq');",
          "SELECT nextval('my_seq') + 5;",
          "SELECT nextval('my_seq') * 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "NEXT VALUE FOR sequence_name",
        "description": "Returns the next value from a named sequence using standard SQL syntax.",
        "examples": [
          "SELECT NEXT VALUE FOR my_seq;",
          "SELECT NEXT VALUE FOR my_seq + 5;",
          "SELECT NEXT VALUE FOR my_seq * 2;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  }
]