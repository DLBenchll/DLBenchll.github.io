[
  {
    "sql_id": "duckdb_1_6",
    "database_name": "duckdb_1_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT * FROM t0 WHERE (a, b) IN (ROW(1, 10)); -- ROW",
    "target_query": "SELECT * FROM t0 WHERE (a, b) IN (ROW(1, 10));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t0(a INT, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0(a INT, b INT);"
    ]
  },
  {
    "sql_id": "duckdb_1_7",
    "database_name": "duckdb_1_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT * FROM t0 WHERE (a, b) IN (VALUES ROW(1, 10), ROW(2, 20)); -- ROW",
    "target_query": "SELECT * FROM t0 WHERE (a, b) IN (ROW(1, 10), ROW(2, 20));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t0(a INT, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0(a INT, b INT);"
    ]
  },
  {
    "sql_id": "duckdb_1_8",
    "database_name": "duckdb_1_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT * FROM t0 WHERE (a, b) NOT IN (VALUES ROW(1, 10)); -- ROW",
    "target_query": "SELECT * FROM t0 WHERE (a, b) NOT IN (ROW(1, 10));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t0(a INT, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0(a INT, b INT);"
    ]
  },
  {
    "sql_id": "duckdb_1_9",
    "database_name": "duckdb_1_9",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT * FROM t0 WHERE (a, b) NOT IN (VALUES ROW(1, 10), ROW(2, 20)); -- ROW",
    "target_query": "SELECT * FROM t0 WHERE (a, b) NOT IN (ROW(1, 10), ROW(2, 20));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t0(a INT, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0(a INT, b INT);"
    ]
  },
  {
    "sql_id": "duckdb_100_2",
    "database_name": "duckdb_100_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 (ts) VALUES (Unix_timestamp('2002-10-27 01:00')); -- UNIX_TIMESTAMP",
    "target_query": "INSERT INTO t1 (ts) VALUES (EXTRACT(EPOCH FROM TIMESTAMP '2002-10-27 01:00'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (ts int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (ts int);"
    ]
  },
  {
    "sql_id": "duckdb_100_3",
    "database_name": "duckdb_100_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 (ts) VALUES (Unix_timestamp('2002-10-27 02:00')); -- UNIX_TIMESTAMP",
    "target_query": "INSERT INTO t1 (ts) VALUES (EXTRACT(EPOCH FROM TIMESTAMP '2002-10-27 02:00'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (ts int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (ts int);"
    ]
  },
  {
    "sql_id": "duckdb_100_4",
    "database_name": "duckdb_100_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 (ts) VALUES (Unix_timestamp('2002-10-27 03:00')); -- UNIX_TIMESTAMP",
    "target_query": "INSERT INTO t1 (ts) VALUES (EXTRACT(EPOCH FROM TIMESTAMP '2002-10-27 03:00'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (ts int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (ts int);"
    ]
  },
  {
    "sql_id": "duckdb_100_5",
    "database_name": "duckdb_100_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT ts,from_unixtime(ts) FROM t1; -- FROM_UNIXTIME",
    "target_query": "SELECT ts, TO_TIMESTAMP(ts) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FROM_UNIXTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
        "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
          "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TO_TIMESTAMP(unix_timestamp)",
        "description": "Converts a Unix timestamp (seconds since epoch) to a TIMESTAMP value.",
        "examples": [
          "SELECT TO_TIMESTAMP(1672531200);",
          "SELECT TO_TIMESTAMP(1672531200.789);",
          "SELECT id, TO_TIMESTAMP(event_time) AS event_ts FROM events;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (ts int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (ts int);"
    ]
  },
  {
    "sql_id": "duckdb_100_7",
    "database_name": "duckdb_100_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT TIMESTAMP( '2001-01-01 00:00:00' ); -- TIMESTAMP",
    "target_query": "SELECT TIMESTAMP '2001-01-01 00:00:00';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
        "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
        "examples": [
          "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TIMESTAMP '2023-06-15 10:30:45'",
        "description": "DuckDB supports the TIMESTAMP function to handle date-time strings as TIMESTAMP values.",
        "examples": [
          "SELECT TIMESTAMP '2023-06-15 10:30:45';",
          "SELECT TIMESTAMP '2023-06-15 10:30:45+02:00';",
          "SELECT TIMESTAMP '2023-06-15 10:30:45' > TIMESTAMP '2023-06-14 10:30:45';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_100_8",
    "database_name": "duckdb_100_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT TO_DAYS( '2001-01-01 00:00:00' ); -- TO_DAYS",
    "target_query": "SELECT DATEDIFF('day', DATE '1970-01-01', DATE '2001-01-01 00:00:00') + 719528;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TO_DAYS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TO_DAYS(date)",
        "description": "Returns the number of days since 0000-01-01 for a given date.",
        "examples": [
          "SELECT TO_DAYS('2024-05-07');",
          "SELECT TO_DAYS(CURDATE());",
          "SELECT TO_DAYS('1999-12-31 23:59:59');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "DATEDIFF('day', DATE '1970-01-01', date) + 719528",
        "description": "Computes the number of days since 0000-01-01 by offsetting from 1970-01-01.",
        "examples": [
          "SELECT DATEDIFF('day', DATE '1970-01-01', DATE '2024-05-07') + 719528;",
          "SELECT DATEDIFF('day', DATE '1970-01-01', CURRENT_DATE) + 719528;",
          "SELECT DATEDIFF('day', DATE '1970-01-01', DATE '1999-12-31') + 719528;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_100_9",
    "database_name": "duckdb_100_9",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT TO_DAYS( '2001-01-01 00:00:00' ); -- TO_DAYS",
    "target_query": "SELECT DATEDIFF('day', DATE '1970-01-01', DATE '2001-01-01 00:00:00') + 719528;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TO_DAYS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TO_DAYS(date)",
        "description": "Returns the number of days since 0000-01-01 for a given date.",
        "examples": [
          "SELECT TO_DAYS('2024-05-07');",
          "SELECT TO_DAYS(CURDATE());",
          "SELECT TO_DAYS('1999-12-31 23:59:59');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "DATEDIFF('day', DATE '1970-01-01', date) + 719528",
        "description": "Computes the number of days since 0000-01-01 by offsetting from 1970-01-01.",
        "examples": [
          "SELECT DATEDIFF('day', DATE '1970-01-01', DATE '2024-05-07') + 719528;",
          "SELECT DATEDIFF('day', DATE '1970-01-01', CURRENT_DATE) + 719528;",
          "SELECT DATEDIFF('day', DATE '1970-01-01', DATE '1999-12-31') + 719528;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_100_10",
    "database_name": "duckdb_100_10",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT DATEDIFF( '2007-12-31 23:59:59', '2007-12-30  00:00:00' ); -- DATEDIFF",
    "target_query": "SELECT DATE_DIFF('day', DATE '2007-12-30 00:00:00', DATE '2007-12-31 23:59:59');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATEDIFF(date1, date2)",
        "description": "Returns the number of days between two date or datetime expressions (date1 - date2), ignoring time part.",
        "examples": [
          "SELECT DATEDIFF('2025-12-31', '2025-12-01');",
          "SELECT DATEDIFF('2025-01-01', '2024-12-31');",
          "SELECT DATEDIFF(NULL, '2025-01-01');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "DATE_DIFF('day', date2, date1)",
        "description": "Computes the number of days between two dates as an integer by specifying the 'day' unit.",
        "examples": [
          "SELECT DATE_DIFF('day', DATE '2025-12-01', DATE '2025-12-31');",
          "SELECT DATE_DIFF('day', DATE '2024-12-31', DATE '2025-01-01');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_100_11",
    "database_name": "duckdb_100_11",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT TIMEDIFF( '2000:01:01 00:00:00','2000:01:01 00:00:00' ); -- TIMEDIFF",
    "target_query": "SELECT TIMESTAMP '2000-01-01 00:00:00' - TIMESTAMP '2000-01-01 00:00:00';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00'",
        "description": "DuckDB supports direct subtraction between timestamps to calculate the difference, returning the result as an interval.",
        "examples": [
          "SELECT TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00';",
          "SELECT CURRENT_TIMESTAMP - TIMESTAMP '2023-06-15 10:00:00';",
          "SELECT TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_100_12",
    "database_name": "duckdb_100_12",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT DATE_FORMAT( '2009-10-10 23:59:59', '%W %M %Y' ); -- DATE_FORMAT",
    "target_query": "SELECT STRFTIME(TIMESTAMP '2009-10-10 23:59:59', '%W %M %Y');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "STRFTIME(date_expr, format_str)",
        "description": "Formats a date/time value using SQLite-compatible strftime format specifiers.",
        "examples": [
          "SELECT STRFTIME('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT STRFTIME(CURRENT_TIMESTAMP, '%Y-%m-%d %H:%M:%S');",
          "SELECT STRFTIME('2023-01-15 12:00:00', '%d-%m-%Y');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_100_13",
    "database_name": "duckdb_100_13",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT TIME( '2003-12-31 23:59:59' ); -- TIME",
    "target_query": "SELECT STRFTIME(TIMESTAMP '2003-12-31 23:59:59', '%H:%M:%S');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
        "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
        "examples": [
          "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
          "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "strftime(format, datetime_expr)",
        "description": "DuckDB does not have a native TIME type, so operations involving just hours, minutes, and seconds must be done on full DateTime values. The `strftime` function can be used to extract or format time from a complete `TIMESTAMP` value. If a time value does not include year information (e.g., '14:16:00'), a default year (e.g., '1970-01-01') must be added to ensure it forms a valid `TIMESTAMP`. This is necessary to perform the time-based operations correctly.",
        "examples": [
          "SELECT strftime('%H:%M:%S', CAST(CURRENT_TIMESTAMP AS TIMESTAMP)); -- Returns the current time formatted as 'HH:MM:SS'.",
          "SELECT strftime('%H:%M:%S', CAST(CURRENT_TIMESTAMP + INTERVAL '1 hour' AS TIMESTAMP)); -- Adds 1 hour to the time, returning 'HH:MM:SS'.",
          "SELECT strftime('%H:%M:%S.%f', CAST(CONCAT('1970-01-01 ', '14:16:00') AS TIMESTAMP)); -- Returns '14:16:00.000000' with fractional seconds by concatenating time with a default date."
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_100_14",
    "database_name": "duckdb_100_14",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT TIMESTAMP( '2003-12-31 23:59:59', '12:00:00' ); -- TIMESTAMP",
    "target_query": "SELECT TIMESTAMP '2003-12-31 23:59:59' + INTERVAL '12:00:00';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
        "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
        "examples": [
          "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TIMESTAMP '2023-06-15 10:30:45'",
        "description": "DuckDB supports the TIMESTAMP function to handle date-time strings as TIMESTAMP values.",
        "examples": [
          "SELECT TIMESTAMP '2023-06-15 10:30:45';",
          "SELECT TIMESTAMP '2023-06-15 10:30:45+02:00';",
          "SELECT TIMESTAMP '2023-06-15 10:30:45' > TIMESTAMP '2023-06-14 10:30:45';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_100_15",
    "database_name": "duckdb_100_15",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT TIMESTAMPADD(MINUTE, 1, '2003-01-02 23:59:59' ); -- TIMESTAMPADD",
    "target_query": "SELECT TIMESTAMP '2003-01-02 23:59:59' + INTERVAL '1 minute';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMPADD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMPADD(unit, interval, datetime_expr)",
        "description": "Adds a time interval to a date or timestamp expression using the specified unit.",
        "examples": [
          "SELECT TIMESTAMPADD(DAY, 2, '2023-01-01');",
          "SELECT TIMESTAMPADD(MINUTE, -5, '2023-05-10 12:00:00');",
          "SELECT TIMESTAMPADD(YEAR, 1, '2020-06-15');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "datetime_expr + INTERVAL 'n unit'",
        "description": "Performs datetime arithmetic by adding a specified time interval using INTERVAL syntax.",
        "examples": [
          "SELECT DATE '2023-01-01' + INTERVAL '2 day';",
          "SELECT TIMESTAMP '2023-05-10 12:00:00' + INTERVAL '-5 minute';",
          "SELECT DATE '2020-06-15' + INTERVAL '1 year';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_100_16",
    "database_name": "duckdb_100_16",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT TIMESTAMPDIFF(MONTH, '2003-02-01 23:59:59', '2003-05-01' ); -- TIMESTAMPDIFF",
    "target_query": "SELECT DATEDIFF('month', DATE '2003-02-01 23:59:59', DATE '2003-05-01');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMPDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMPDIFF(unit, datetime1, datetime2)",
        "description": "Returns the difference between two datetime values in the specified unit.",
        "examples": [
          "SELECT TIMESTAMPDIFF(YEAR, '2001-01-01', '2005-01-01');  -- 4",
          "SELECT TIMESTAMPDIFF(MONTH, '2020-01-01', '2020-03-01');  -- 2",
          "SELECT TIMESTAMPDIFF(DAY, '2020-01-01', '2020-01-31');    -- 30"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "DATEDIFF(unit, datetime1, datetime2)",
        "description": "Computes the difference between two dates in the specified unit. The result is positive if the first date is earlier than the second date.",
        "examples": [
          "SELECT DATEDIFF('year', DATE '2001-01-01', DATE '2005-01-01');  -- 4",
          "SELECT DATEDIFF('month', DATE '2020-01-01', DATE '2020-03-01');  -- 2",
          "SELECT DATEDIFF('day', DATE '2020-01-01', DATE '2020-01-31');    -- 30"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_100_17",
    "database_name": "duckdb_100_17",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT TO_SECONDS( '2009-11-29 23:59:59' ); -- TO_SECONDS",
    "target_query": "SELECT epoch(TIMESTAMP '2009-11-29 23:59:59') + 62167219200;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TO_SECONDS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TO_SECONDS(datetime_expr)",
        "description": "Returns the number of seconds since year 0 to the given datetime.",
        "examples": [
          "SELECT TO_SECONDS('2000-01-01 00:00:00');",
          "SELECT TO_SECONDS(NOW());",
          "SELECT TO_SECONDS(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "epoch(ts) + 62167219200",
        "description": "Converts timestamp to Unix epoch time and adds the number of seconds between year 0 and 1970.",
        "examples": [
          "SELECT epoch(TIMESTAMP '2020-12-31 12:00:00') + 62167219200;",
          "SELECT epoch(CURRENT_TIMESTAMP) + 62167219200;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_100_18",
    "database_name": "duckdb_100_18",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT UNIX_TIMESTAMP( '2015-11-13 23:59:59' ); -- UNIX_TIMESTAMP",
    "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_101_3",
    "database_name": "duckdb_101_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select hex(s1) from t1; -- HEX",
    "target_query": "select hex(s1) from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (s1 blob);"
    ],
    "target_related_schemas": [
      "create table t1 (s1 blob);"
    ]
  },
  {
    "sql_id": "duckdb_101_7",
    "database_name": "duckdb_101_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select length(concat('*',s1,'*',s2,'*')) from t1; -- LENGTH, CONCAT",
    "target_query": "select length(concat('*',s1,'*',s2,'*')) from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH",
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      },
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      },
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (s1 blob, s2 blob);"
    ],
    "target_related_schemas": [
      "create table t1 (s1 blob, s2 blob);"
    ]
  },
  {
    "sql_id": "duckdb_101_11",
    "database_name": "duckdb_101_11",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select hex(s1),s2 from t1 order by s1,s2; -- HEX",
    "target_query": "select hex(s1),s2 from t1 order by s1,s2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (s1 blob, s2 varchar(1));"
    ],
    "target_related_schemas": [
      "create table t1 (s1 blob, s2 varchar(1));"
    ]
  },
  {
    "sql_id": "duckdb_101_12",
    "database_name": "duckdb_101_12",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select convert(123456789,unsigned); -- CONVERT",
    "target_query": "select CAST(123456789 AS BIGINT);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONVERT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONVERT(expression USING charset)",
        "description": "Converts data types or changes the character set.",
        "examples": [
          "SELECT CONVERT('Hello World' USING utf8);",
          "SELECT CONVERT(1234, CHAR);",
          "SELECT CONVERT(column_name USING latin1) FROM my_table;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CAST(expression AS target_type)",
        "description": "DuckDB uses CAST for type conversion. No direct equivalent for CONVERT TO CHARACTER SET.",
        "examples": [
          "SELECT CAST('2021-12-31' AS DATE);",
          "SELECT CAST(1234 AS VARCHAR);",
          "SELECT CAST(column_name AS VARCHAR) FROM my_table;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_102_2",
    "database_name": "duckdb_102_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 VALUES (DATE(NOW()), 1); -- DATE, NOW",
    "target_query": "INSERT INTO t1 VALUES (CAST(CURRENT_TIMESTAMP AS DATE), 1);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE",
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE()",
        "description": "In MySQL, the DATE function extracts the date part from a DATETIME or TIMESTAMP value.",
        "examples": [
          "SELECT DATE('2023-05-01 12:34:56') AS result;",
          "SELECT DATE(NOW()) AS current_date_result;",
          "SELECT DATE(CAST('2023-05-01' AS DATETIME)) AS date_from_datetime;"
        ]
      },
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CAST()",
        "description": "DuckDB supports the CAST function to extract a DATE from a TIMESTAMP or DATETIME.",
        "examples": [
          "SELECT CAST('2023-05-01 12:34:56' AS DATE) AS result;",
          "SELECT CURRENT_DATE AS current_date_result;",
          "SELECT CAST('2023-05-01' AS DATE) AS date_from_datetime;"
        ]
      },
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "DuckDB also uses CURRENT_TIMESTAMP to get the current date and time, similar to PostgreSQL and MonetDB.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT);"
    ]
  },
  {
    "sql_id": "duckdb_102_3",
    "database_name": "duckdb_102_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT COUNT(*) FROM t1 WHERE a = NOW(); -- COUNT, NOW",
    "target_query": "SELECT COUNT(*) FROM t1 WHERE a = CURRENT_TIMESTAMP;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COUNT",
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN FORMAT=TREE SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      },
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      },
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "DuckDB also uses CURRENT_TIMESTAMP to get the current date and time, similar to PostgreSQL and MonetDB.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT);"
    ]
  },
  {
    "sql_id": "duckdb_102_4",
    "database_name": "duckdb_102_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 VALUES (DATE(NOW()), 2); -- DATE, NOW",
    "target_query": "INSERT INTO t1 VALUES (CAST(CURRENT_TIMESTAMP AS DATE), 2);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE",
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE()",
        "description": "In MySQL, the DATE function extracts the date part from a DATETIME or TIMESTAMP value.",
        "examples": [
          "SELECT DATE('2023-05-01 12:34:56') AS result;",
          "SELECT DATE(NOW()) AS current_date_result;",
          "SELECT DATE(CAST('2023-05-01' AS DATETIME)) AS date_from_datetime;"
        ]
      },
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CAST()",
        "description": "DuckDB supports the CAST function to extract a DATE from a TIMESTAMP or DATETIME.",
        "examples": [
          "SELECT CAST('2023-05-01 12:34:56' AS DATE) AS result;",
          "SELECT CURRENT_DATE AS current_date_result;",
          "SELECT CAST('2023-05-01' AS DATE) AS date_from_datetime;"
        ]
      },
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "DuckDB also uses CURRENT_TIMESTAMP to get the current date and time, similar to PostgreSQL and MonetDB.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT);"
    ]
  },
  {
    "sql_id": "duckdb_102_5",
    "database_name": "duckdb_102_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT COUNT(*) FROM t1 WHERE a = NOW(); -- COUNT, NOW",
    "target_query": "SELECT COUNT(*) FROM t1 WHERE a = CURRENT_TIMESTAMP;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COUNT",
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN FORMAT=TREE SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      },
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      },
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "DuckDB also uses CURRENT_TIMESTAMP to get the current date and time, similar to PostgreSQL and MonetDB.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT);"
    ]
  },
  {
    "sql_id": "duckdb_102_6",
    "database_name": "duckdb_102_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT COUNT(*) FROM t1 WHERE a = NOW() AND b = 1; -- COUNT, NOW",
    "target_query": "SELECT COUNT(*) FROM t1 WHERE a = CURRENT_TIMESTAMP AND b = 1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COUNT",
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN FORMAT=TREE SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      },
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      },
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "DuckDB also uses CURRENT_TIMESTAMP to get the current date and time, similar to PostgreSQL and MonetDB.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT);"
    ]
  },
  {
    "sql_id": "duckdb_102_8",
    "database_name": "duckdb_102_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "CREATE TABLE t1 SELECT curdate() AS f1; -- CURDATE",
    "target_query": "CREATE TABLE t1 AS SELECT CURRENT_DATE AS f1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CURDATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CURDATE()",
        "description": "Returns the current date without the time component.",
        "examples": [
          "SELECT CURDATE();",
          "SELECT CONCAT('Today\\'s date is: ', CURDATE());",
          "SELECT 1 WHERE CURDATE() = CURDATE();"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CURRENT_DATE",
        "description": "Returns the current date without the time component, equivalent to MySQL's CURDATE().",
        "examples": [
          "SELECT CURRENT_DATE;",
          "SELECT CONCAT('Today''s date is: ', CURRENT_DATE);",
          "SELECT 1 WHERE CURRENT_DATE = CURRENT_DATE;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 SELECT curdate() AS f1; -- CURDATE"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 AS SELECT CURRENT_DATE AS f1;"
    ]
  },
  {
    "sql_id": "duckdb_102_9",
    "database_name": "duckdb_102_9",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT hour(f1), minute(f1), second(f1) FROM t1; -- HOUR, MINUTE, SECOND",
    "target_query": "SELECT EXTRACT(HOUR FROM f1), MINUTE(f1), EXTRACT(SECOND FROM f1) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HOUR",
      "MINUTE",
      "SECOND"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HOUR(expr)",
        "description": "Extracts the hour (0–23) from a time or datetime expression.",
        "examples": [
          "SELECT HOUR('18:45:30');",
          "SELECT HOUR('2023-10-01 08:15:00');",
          "SELECT HOUR(CURRENT_TIMESTAMP);"
        ]
      },
      {
        "expression": "MINUTE()",
        "description": "Extracts the minute part from a time or datetime value.",
        "examples": [
          "SELECT MINUTE('12:34:56');",
          "SELECT MINUTE('2025-01-01 10:30:00');",
          "SELECT MINUTE(NULL);"
        ]
      },
      {
        "expression": "SECOND(time)",
        "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
        "examples": [
          "SELECT SECOND('10:11:12');",
          "SELECT SECOND(4.99999999991e0);",
          "SELECT SECOND(CAST('2007-07-19' AS DATE));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(HOUR FROM expr)",
        "description": "Extracts the hour from a timestamp or time value.",
        "examples": [
          "SELECT EXTRACT(HOUR FROM TIME '18:45:30');",
          "SELECT EXTRACT(HOUR FROM TIMESTAMP '2023-10-01 08:15:00');",
          "SELECT EXTRACT(HOUR FROM CURRENT_TIMESTAMP);"
        ]
      },
      {
        "expression": "MINUTE()",
        "description": "Extracts the minute part from a time or timestamp value.",
        "examples": [
          "SELECT MINUTE('2025-01-01 12:34:56'::TIMESTAMP);",
          "SELECT MINUTE('12:34:56'::TIME);",
          "SELECT MINUTE(NULL::TIMESTAMP);"
        ]
      },
      {
        "expression": "EXTRACT(SECOND FROM time)",
        "description": "Extracts the second part from a TIME, INTERVAL, or timestamp value.",
        "examples": [
          "SELECT EXTRACT(SECOND FROM TIME '10:11:12');",
          "SELECT EXTRACT(SECOND FROM INTERVAL '4.99999999991');",
          "SELECT EXTRACT(SECOND FROM CAST('2007-07-19' AS DATE));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 SELECT curdate() AS f1; -- CURDATE"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 AS SELECT CURRENT_DATE AS f1;"
    ]
  },
  {
    "sql_id": "duckdb_102_17",
    "database_name": "duckdb_102_17",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT 1 FROM (SELECT LAST_DAY('0')) a; -- LAST_DAY",
    "target_query": "SELECT 1 FROM (SELECT last_day(date '0')) a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LAST_DAY"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LAST_DAY()",
        "description": "Returns the last day of the month for a given date or datetime expression.",
        "examples": [
          "SELECT LAST_DAY('2000-02-05') AS last_day_1;",
          "SELECT LAST_DAY(CURRENT_DATE) AS last_day_2;",
          "SELECT LAST_DAY('2025-05-17 15:32:00') AS last_day_3;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "last_day(date)",
        "description": "Returns the last day of the month for a given date or timestamp expression, matching MySQL's LAST_DAY behavior.",
        "examples": [
          "SELECT last_day(date '2000-02-05');",
          "SELECT last_day(CURRENT_DATE);",
          "SELECT last_day(timestamp '2025-05-17 15:32:00');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_102_18",
    "database_name": "duckdb_102_18",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT 1 FROM (SELECT MAKEDATE(2011,0)) a; -- MAKEDATE",
    "target_query": "SELECT 1 FROM (SELECT date '2011-01-01' + (0 - 1) * INTERVAL '1 day') a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKEDATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKEDATE(year, day_of_year)",
        "description": "Returns a date from the given year and day of the year.",
        "examples": [
          "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
          "SELECT MAKEDATE(2025, 100) AS specific_date;",
          "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "date 'year-01-01' + (day_of_year - 1) * INTERVAL '1 day'",
        "description": "Returns a date from the given year and day of the year by adding intervals.",
        "examples": [
          "SELECT date '2009-01-01' + (1 - 1) * INTERVAL '1 day' AS first_day_of_year;",
          "SELECT date '2025-01-01' + (100 - 1) * INTERVAL '1 day' AS specific_date;",
          "SELECT date '2020-01-01' + (366 - 1) * INTERVAL '1 day' AS last_day_of_year;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_2_2",
    "database_name": "duckdb_2_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "WITH recursive qn as (select 1 as n, cast('x' as char(100)) as un union all select 1+n, concat(un,'x') from qn where n<10) select * from qn; -- CONCAT",
    "target_query": "WITH recursive qn as (select 1 as n, cast('x' as char(100)) as un union all select 1+n, un || 'x' from qn where n<10) select * from qn; -- CONCAT",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t(c char(3), vc varchar(3), b binary(3), vb varbinary(3));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t(c char(3), vc varchar(3), b BLOB, vb BLOB);"
    ]
  },
  {
    "sql_id": "duckdb_3_2",
    "database_name": "duckdb_3_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT IF (COUNT(*) > 0, \"YES\", \"NO\") AS \"IMPLICIT COMMIT\" FROM trans; -- IF",
    "target_query": "SELECT CASE WHEN COUNT(*) > 0 THEN 'YES' ELSE 'NO' END AS \"IMPLICIT COMMIT\" FROM trans; -- IF",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE trans (a INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE trans (a INT);"
    ]
  },
  {
    "sql_id": "duckdb_39_3",
    "database_name": "duckdb_39_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT IF( a = 1, a, a ) AS b FROM t1 ORDER BY field( b + 1, 1 ); -- IF, FIELD",
    "target_query": "SELECT CASE WHEN a = 1 THEN a ELSE a END AS b FROM t1 ORDER BY COALESCE(array_position(ARRAY[1], b + 1), 0);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF",
      "FIELD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      },
      {
        "expression": "FIELD(val, val1, val2, ..., valN)",
        "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
        "examples": [
          "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      },
      {
        "expression": "COALESCE(array_position(ARRAY[val1, val2, ..., valN], val), 0)",
        "description": "Returns the index (1-based) of 'val' in the array. Returns 0 if not found, emulating MySQL FIELD().",
        "examples": [
          "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'c'), 0) AS result;",
          "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'x'), 0) AS result;",
          "SELECT COALESCE(array_position(ARRAY['b', 'b', 'b'], 'b'), 0) AS result;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a INT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a INT );"
    ]
  },
  {
    "sql_id": "duckdb_39_4",
    "database_name": "duckdb_39_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT IF( a = 1, a, a ) AS b FROM t1 ORDER BY field( b, 1 ); -- IF, FIELD",
    "target_query": "SELECT CASE WHEN a = 1 THEN a ELSE a END AS b FROM t1 ORDER BY COALESCE(array_position(ARRAY[1], b), 0);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF",
      "FIELD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      },
      {
        "expression": "FIELD(val, val1, val2, ..., valN)",
        "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
        "examples": [
          "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      },
      {
        "expression": "COALESCE(array_position(ARRAY[val1, val2, ..., valN], val), 0)",
        "description": "Returns the index (1-based) of 'val' in the array. Returns 0 if not found, emulating MySQL FIELD().",
        "examples": [
          "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'c'), 0) AS result;",
          "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'x'), 0) AS result;",
          "SELECT COALESCE(array_position(ARRAY['b', 'b', 'b'], 'b'), 0) AS result;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a INT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a INT );"
    ]
  },
  {
    "sql_id": "duckdb_4_4",
    "database_name": "duckdb_4_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775807 AND TRIM(a) = b; -- TRIM",
    "target_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775807 AND TRIM(CAST(a AS VARCHAR)) = b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TRIM"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "DuckDB's TRIM function is identical to MySQL's, removing unwanted characters from the beginning or end of a string, or from both ends if specified.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (id INT AUTO_INCREMENT PRIMARY KEY,a BIGINT(20) UNSIGNED,b VARCHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id INTEGER PRIMARY KEY, a BIGINT, b VARCHAR(20));"
    ]
  },
  {
    "sql_id": "duckdb_4_5",
    "database_name": "duckdb_4_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775806 AND TRIM(a) = b; -- TRIM",
    "target_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775806 AND TRIM(CAST(a AS VARCHAR)) = b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TRIM"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "DuckDB's TRIM function is identical to MySQL's, removing unwanted characters from the beginning or end of a string, or from both ends if specified.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (id INT AUTO_INCREMENT PRIMARY KEY,a BIGINT(20) UNSIGNED,b VARCHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id INTEGER PRIMARY KEY, a BIGINT, b VARCHAR(20));"
    ]
  },
  {
    "sql_id": "duckdb_4_6",
    "database_name": "duckdb_4_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775805 AND TRIM(a) = b; -- TRIM",
    "target_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775805 AND TRIM(CAST(a AS VARCHAR)) = b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TRIM"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "DuckDB's TRIM function is identical to MySQL's, removing unwanted characters from the beginning or end of a string, or from both ends if specified.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (id INT AUTO_INCREMENT PRIMARY KEY,a BIGINT(20) UNSIGNED,b VARCHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id INTEGER PRIMARY KEY, a BIGINT, b VARCHAR(20));"
    ]
  },
  {
    "sql_id": "duckdb_4_7",
    "database_name": "duckdb_4_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 0 AND TRIM(a) = b; -- TRIM",
    "target_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 0 AND TRIM(CAST(a AS VARCHAR)) = b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TRIM"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "DuckDB's TRIM function is identical to MySQL's, removing unwanted characters from the beginning or end of a string, or from both ends if specified.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (id INT AUTO_INCREMENT PRIMARY KEY,a BIGINT(20) UNSIGNED,b VARCHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id INTEGER PRIMARY KEY, a BIGINT, b VARCHAR(20));"
    ]
  },
  {
    "sql_id": "duckdb_4_11",
    "database_name": "duckdb_4_11",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT * FROM t1 WHERE coalesce(a) BETWEEN 0 and 0.9; -- COALESCE",
    "target_query": "SELECT * FROM t1 WHERE COALESCE(CAST(a AS DOUBLE)) BETWEEN 0 AND 0.9;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...)",
        "description": "DuckDB supports COALESCE for NULL handling.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a BIGINT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a BIGINT);"
    ]
  },
  {
    "sql_id": "duckdb_4_12",
    "database_name": "duckdb_4_12",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT * FROM t1 WHERE coalesce(a)=0.9; -- COALESCE",
    "target_query": "SELECT * FROM t1 WHERE COALESCE(CAST(a AS DOUBLE)) = 0.9;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...)",
        "description": "DuckDB supports COALESCE for NULL handling.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a BIGINT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a BIGINT);"
    ]
  },
  {
    "sql_id": "duckdb_4_13",
    "database_name": "duckdb_4_13",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT * FROM t1 WHERE coalesce(a) in (0.8,0.9); -- COALESCE",
    "target_query": "SELECT * FROM t1 WHERE COALESCE(CAST(a AS DOUBLE)) IN (0.8, 0.9);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...)",
        "description": "DuckDB supports COALESCE for NULL handling.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a BIGINT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a BIGINT);"
    ]
  },
  {
    "sql_id": "duckdb_6_3",
    "database_name": "duckdb_6_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT HEX(c1) FROM t1; -- HEX",
    "target_query": "SELECT HEX(c1) FROM t1; -- HEX",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(c1 CHAR(4));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(c1 CHAR(4));"
    ]
  },
  {
    "sql_id": "duckdb_6_5",
    "database_name": "duckdb_6_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "CREATE TABLE t1 SELECT repeat('a',4000) a; -- REPEAT",
    "target_query": "CREATE TABLE t1 AS SELECT repeat('a', 4000) AS a; -- REPEAT",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 SELECT repeat('a',4000) a; -- REPEAT"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 AS SELECT repeat('a', 4000) AS a; -- REPEAT"
    ]
  },
  {
    "sql_id": "duckdb_6_12",
    "database_name": "duckdb_6_12",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT",
    "target_query": "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT"
    ],
    "target_related_schemas": [
      "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT"
    ]
  },
  {
    "sql_id": "duckdb_6_13",
    "database_name": "duckdb_6_13",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "CREATE TABLE tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2; -- CONCAT",
    "target_query": "CREATE TABLE tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2; -- CONCAT",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT",
      "CREATE TABLE tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2; -- CONCAT"
    ],
    "target_related_schemas": [
      "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT",
      "CREATE TABLE tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2; -- CONCAT"
    ]
  },
  {
    "sql_id": "duckdb_6_18",
    "database_name": "duckdb_6_18",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "UPDATE IGNORE t1 SET a=unhex(code); -- UNHEX",
    "target_query": "UPDATE t1 SET a=FROM_HEX(code); -- UNHEX",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNHEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNHEX(str)",
        "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT HEX(UNHEX('4D7953514C'));",
          "SELECT UNHEX('48656C6C6F');",
          "SELECT UNHEX(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "FROM_HEX(str)",
        "description": "Converts a hexadecimal string into a BLOB value. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT TO_HEX(FROM_HEX('4D7953514C'));",
          "SELECT FROM_HEX('48656C6C6F');",
          "SELECT FROM_HEX(NULL);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 AS SELECT '111111' AS code, ' ' AS a LIMIT 1;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 AS SELECT '111111' AS code, ' ' AS a LIMIT 1;"
    ]
  },
  {
    "sql_id": "duckdb_6_19",
    "database_name": "duckdb_6_19",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT COUNT(*) FROM t1 WHERE a<>'' AND OCTET_LENGTH(a)=2; -- OCTET_LENGTH",
    "target_query": "SELECT COUNT(*) FROM t1 WHERE a<>'' AND LENGTH(a)=2; -- OCTET_LENGTH",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "OCTET_LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "OCTET_LENGTH()",
        "description": "Returns the number of bytes in a string.",
        "examples": [
          "SELECT OCTET_LENGTH('Hello World');",
          "SELECT OCTET_LENGTH('Test String') = 11;",
          "SELECT CASE WHEN OCTET_LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LENGTH()",
        "description": "Returns the number of bytes in a string.",
        "examples": [
          "SELECT LENGTH('Hello World');",
          "SELECT LENGTH('Test String') = 11;",
          "SELECT CASE WHEN LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 AS SELECT '111111' AS code, ' ' AS a LIMIT 1;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 AS SELECT '111111' AS code, ' ' AS a LIMIT 1;"
    ]
  },
  {
    "sql_id": "duckdb_6_20",
    "database_name": "duckdb_6_20",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT * FROM t1 WHERE CHAR_LENGTH(a)=2; -- CHAR_LENGTH",
    "target_query": "SELECT * FROM t1 WHERE LENGTH(a)=2; -- CHAR_LENGTH",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CHAR_LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CHAR_LENGTH(expr)",
        "description": "Returns the number of characters in the string, not bytes.",
        "examples": [
          "SELECT CHAR_LENGTH('abc');",
          "SELECT CHAR_LENGTH('你好');",
          "SELECT CHAR_LENGTH('a你b好c');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(expr)",
        "description": "Returns the number of characters in a string.",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length('a你b好c');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 AS SELECT '111111' AS code, ' ' AS a LIMIT 1;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 AS SELECT '111111' AS code, ' ' AS a LIMIT 1;"
    ]
  },
  {
    "sql_id": "duckdb_6_21",
    "database_name": "duckdb_6_21",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT COUNT(*) FROM t1 WHERE a<>'' AND OCTET_LENGTH(a)=3; -- OCTET_LENGTH",
    "target_query": "SELECT COUNT(*) FROM t1 WHERE a<>'' AND LENGTH(a)=3; -- OCTET_LENGTH",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "OCTET_LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "OCTET_LENGTH()",
        "description": "Returns the number of bytes in a string.",
        "examples": [
          "SELECT OCTET_LENGTH('Hello World');",
          "SELECT OCTET_LENGTH('Test String') = 11;",
          "SELECT CASE WHEN OCTET_LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LENGTH()",
        "description": "Returns the number of bytes in a string.",
        "examples": [
          "SELECT LENGTH('Hello World');",
          "SELECT LENGTH('Test String') = 11;",
          "SELECT CASE WHEN LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 AS SELECT '111111' AS code, ' ' AS a LIMIT 1;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 AS SELECT '111111' AS code, ' ' AS a LIMIT 1;"
    ]
  },
  {
    "sql_id": "duckdb_7_4",
    "database_name": "duckdb_7_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT c1, LENGTH(c1) FROM h; -- LENGTH",
    "target_query": "SELECT c1, length(c1) FROM h; -- LENGTH",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ]
  },
  {
    "sql_id": "duckdb_7_5",
    "database_name": "duckdb_7_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT c1, LPAD(c1, 20, ' ') FROM h; -- LPAD",
    "target_query": "SELECT c1, LPAD(c1, 20, ' ') FROM h; -- LPAD",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ]
  },
  {
    "sql_id": "duckdb_7_6",
    "database_name": "duckdb_7_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT c1, RPAD(c1, 20, '52') FROM h; -- RPAD",
    "target_query": "SELECT c1, RPAD(c1, 20, '52') FROM h; -- RPAD",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "DuckDB supports RPAD for string padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123::TEXT, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ]
  },
  {
    "sql_id": "duckdb_7_9",
    "database_name": "duckdb_7_9",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT INSTR(c1, 'h') FROM h; -- INSTR",
    "target_query": "SELECT INSTR(c1, 'h') FROM h; -- INSTR",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "INSTR(str, substr)",
        "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
        "examples": [
          "SELECT INSTR('foobar', 'bar');  -- Returns 4",
          "SELECT INSTR('foobar', 'baz');  -- Returns 0",
          "SELECT INSTR('foobar', '');     -- Returns 1",
          "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "instr(str, substr)",
        "description": "Returns the position of substr in str (1-based). Returns 0 if not found.",
        "examples": [
          "SELECT instr('foobar', 'bar');    -- Returns 4",
          "SELECT instr('hello', 'x');       -- Returns 0"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ]
  },
  {
    "sql_id": "duckdb_7_10",
    "database_name": "duckdb_7_10",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT INSTR(c1, '') FROM h; -- INSTR",
    "target_query": "SELECT INSTR(c1, '') FROM h; -- INSTR",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "INSTR(str, substr)",
        "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
        "examples": [
          "SELECT INSTR('foobar', 'bar');  -- Returns 4",
          "SELECT INSTR('foobar', 'baz');  -- Returns 0",
          "SELECT INSTR('foobar', '');     -- Returns 1",
          "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "instr(str, substr)",
        "description": "Returns the position of substr in str (1-based). Returns 0 if not found.",
        "examples": [
          "SELECT instr('foobar', 'bar');    -- Returns 4",
          "SELECT instr('hello', 'x');       -- Returns 0"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ]
  },
  {
    "sql_id": "duckdb_7_11",
    "database_name": "duckdb_7_11",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT INSTR(c1, '52') FROM h; -- INSTR",
    "target_query": "SELECT INSTR(c1, '52') FROM h; -- INSTR",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "INSTR(str, substr)",
        "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
        "examples": [
          "SELECT INSTR('foobar', 'bar');  -- Returns 4",
          "SELECT INSTR('foobar', 'baz');  -- Returns 0",
          "SELECT INSTR('foobar', '');     -- Returns 1",
          "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "instr(str, substr)",
        "description": "Returns the position of substr in str (1-based). Returns 0 if not found.",
        "examples": [
          "SELECT instr('foobar', 'bar');    -- Returns 4",
          "SELECT instr('hello', 'x');       -- Returns 0"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ]
  },
  {
    "sql_id": "duckdb_7_12",
    "database_name": "duckdb_7_12",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT INSTR(c1, '54') FROM h; -- INSTR",
    "target_query": "SELECT INSTR(c1, '54') FROM h; -- INSTR",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "INSTR(str, substr)",
        "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
        "examples": [
          "SELECT INSTR('foobar', 'bar');  -- Returns 4",
          "SELECT INSTR('foobar', 'baz');  -- Returns 0",
          "SELECT INSTR('foobar', '');     -- Returns 1",
          "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "instr(str, substr)",
        "description": "Returns the position of substr in str (1-based). Returns 0 if not found.",
        "examples": [
          "SELECT instr('foobar', 'bar');    -- Returns 4",
          "SELECT instr('hello', 'x');       -- Returns 0"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ]
  },
  {
    "sql_id": "duckdb_7_13",
    "database_name": "duckdb_7_13",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT INSTR(c1, '31') FROM h; -- INSTR",
    "target_query": "SELECT INSTR(c1, '31') FROM h; -- INSTR",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "INSTR(str, substr)",
        "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
        "examples": [
          "SELECT INSTR('foobar', 'bar');  -- Returns 4",
          "SELECT INSTR('foobar', 'baz');  -- Returns 0",
          "SELECT INSTR('foobar', '');     -- Returns 1",
          "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "instr(str, substr)",
        "description": "Returns the position of substr in str (1-based). Returns 0 if not found.",
        "examples": [
          "SELECT instr('foobar', 'bar');    -- Returns 4",
          "SELECT instr('hello', 'x');       -- Returns 0"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ]
  },
  {
    "sql_id": "duckdb_7_23",
    "database_name": "duckdb_7_23",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT c1, TRIM(c1) FROM h; -- TRIM",
    "target_query": "SELECT c1, TRIM(c1) FROM h; -- TRIM",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TRIM"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "DuckDB's TRIM function is identical to MySQL's, removing unwanted characters from the beginning or end of a string, or from both ends if specified.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ]
  },
  {
    "sql_id": "duckdb_71_0",
    "database_name": "duckdb_71_0",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select from_unixtime(123456789); -- FROM_UNIXTIME",
    "target_query": "SELECT TO_TIMESTAMP(123456789);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FROM_UNIXTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
        "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
          "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TO_TIMESTAMP(unix_timestamp)",
        "description": "Converts a Unix timestamp (seconds since epoch) to a TIMESTAMP value.",
        "examples": [
          "SELECT TO_TIMESTAMP(1672531200);",
          "SELECT TO_TIMESTAMP(1672531200.789);",
          "SELECT id, TO_TIMESTAMP(event_time) AS event_ts FROM events;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_71_1",
    "database_name": "duckdb_71_1",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select from_unixtime(234567890); -- FROM_UNIXTIME",
    "target_query": "SELECT TO_TIMESTAMP(234567890);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FROM_UNIXTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
        "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
          "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TO_TIMESTAMP(unix_timestamp)",
        "description": "Converts a Unix timestamp (seconds since epoch) to a TIMESTAMP value.",
        "examples": [
          "SELECT TO_TIMESTAMP(1672531200);",
          "SELECT TO_TIMESTAMP(1672531200.789);",
          "SELECT id, TO_TIMESTAMP(event_time) AS event_ts FROM events;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_71_2",
    "database_name": "duckdb_71_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select from_unixtime(1); -- FROM_UNIXTIME",
    "target_query": "SELECT TO_TIMESTAMP(1);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FROM_UNIXTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
        "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
          "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TO_TIMESTAMP(unix_timestamp)",
        "description": "Converts a Unix timestamp (seconds since epoch) to a TIMESTAMP value.",
        "examples": [
          "SELECT TO_TIMESTAMP(1672531200);",
          "SELECT TO_TIMESTAMP(1672531200.789);",
          "SELECT id, TO_TIMESTAMP(event_time) AS event_ts FROM events;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_71_3",
    "database_name": "duckdb_71_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select unix_timestamp(from_unixtime(123456789)); -- UNIX_TIMESTAMP, FROM_UNIXTIME",
    "target_query": "SELECT EXTRACT(EPOCH FROM TO_TIMESTAMP(123456789));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP",
      "FROM_UNIXTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      },
      {
        "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
        "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
          "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      },
      {
        "expression": "TO_TIMESTAMP(unix_timestamp)",
        "description": "Converts a Unix timestamp (seconds since epoch) to a TIMESTAMP value.",
        "examples": [
          "SELECT TO_TIMESTAMP(1672531200);",
          "SELECT TO_TIMESTAMP(1672531200.789);",
          "SELECT id, TO_TIMESTAMP(event_time) AS event_ts FROM events;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_71_4",
    "database_name": "duckdb_71_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select unix_timestamp(from_unixtime(234567890)); -- UNIX_TIMESTAMP, FROM_UNIXTIME",
    "target_query": "SELECT EXTRACT(EPOCH FROM TO_TIMESTAMP(234567890));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP",
      "FROM_UNIXTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      },
      {
        "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
        "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
          "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      },
      {
        "expression": "TO_TIMESTAMP(unix_timestamp)",
        "description": "Converts a Unix timestamp (seconds since epoch) to a TIMESTAMP value.",
        "examples": [
          "SELECT TO_TIMESTAMP(1672531200);",
          "SELECT TO_TIMESTAMP(1672531200.789);",
          "SELECT id, TO_TIMESTAMP(event_time) AS event_ts FROM events;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_71_5",
    "database_name": "duckdb_71_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select unix_timestamp('2039-01-20 01:00:00'); -- UNIX_TIMESTAMP",
    "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2039-01-20 01:00:00');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_71_6",
    "database_name": "duckdb_71_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select unix_timestamp('2038-02-10 01:00:00'); -- UNIX_TIMESTAMP",
    "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-02-10 01:00:00');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_71_7",
    "database_name": "duckdb_71_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select unix_timestamp('1970-01-01 01:00:00'),unix_timestamp('1970-01-01 01:00:01'),unix_timestamp('2038-01-19 04:14:07'),unix_timestamp('2038-01-19 04:14:08'); -- UNIX_TIMESTAMP",
    "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1970-01-01 01:00:00'), EXTRACT(EPOCH FROM TIMESTAMP '1970-01-01 01:00:01'), EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07'), EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:08');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_71_11",
    "database_name": "duckdb_71_11",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT a, FROM_UNIXTIME(a) FROM t1; -- FROM_UNIXTIME",
    "target_query": "SELECT a, TO_TIMESTAMP(a) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FROM_UNIXTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
        "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
          "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TO_TIMESTAMP(unix_timestamp)",
        "description": "Converts a Unix timestamp (seconds since epoch) to a TIMESTAMP value.",
        "examples": [
          "SELECT TO_TIMESTAMP(1672531200);",
          "SELECT TO_TIMESTAMP(1672531200.789);",
          "SELECT id, TO_TIMESTAMP(event_time) AS event_ts FROM events;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a BIGINT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a BIGINT);"
    ]
  },
  {
    "sql_id": "duckdb_71_13",
    "database_name": "duckdb_71_13",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT UNIX_TIMESTAMP(\"3001-01-19 08:59:59\"); -- UNIX_TIMESTAMP",
    "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '3001-01-19 08:59:59');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_72_4",
    "database_name": "duckdb_72_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "EXPLAIN SELECT * FROM t WHERE CONCAT(x,x) = 'XX'; -- CONCAT",
    "target_query": "EXPLAIN SELECT * FROM t WHERE CONCAT(x, x) = 'XX';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t(x VARCHAR(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t(x VARCHAR(10));"
    ]
  },
  {
    "sql_id": "duckdb_74_2",
    "database_name": "duckdb_74_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "insert into t1(f1) select if(max(f1) is null, '2000',max(f1)) from t1; -- IF, MAX",
    "target_query": "INSERT INTO t1(f1) SELECT CASE WHEN MAX(f1) IS NULL THEN '2000' ELSE MAX(f1) END FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF",
      "MAX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      },
      {
        "expression": "MAX(expr)",
        "description": "Returns the maximum value of the expression in an aggregation context.",
        "examples": [
          "SELECT MAX(10), MAX(5), MAX(20);",
          "SELECT MAX('apple'), MAX('banana'), MAX('pear');",
          "SELECT MAX(ABS(-5)), MAX(ABS(3));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      },
      {
        "expression": "MAX(expr)",
        "description": "Returns the maximum value among all input values.",
        "examples": [
          "SELECT MAX(1), MAX(5), MAX(3);",
          "SELECT MAX('orange'), MAX('apple'), MAX('banana');",
          "SELECT MAX(length('abc')), MAX(length('defg'));"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1(f1 varchar(5));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(f1 VARCHAR(5));"
    ]
  },
  {
    "sql_id": "duckdb_74_6",
    "database_name": "duckdb_74_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT (SELECT SUM(LENGTH(c)) FROM t1 WHERE c='13_characters') FROM t1; -- LENGTH",
    "target_query": "SELECT (SELECT SUM(length(c)) FROM t1 WHERE c='13_characters') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (c VARCHAR(30));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c VARCHAR(30));"
    ]
  },
  {
    "sql_id": "duckdb_74_9",
    "database_name": "duckdb_74_9",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t2 (d)SELECT (SELECT SUM(LENGTH(c)) FROM t1 WHERE c='13_characters') FROM t1; -- LENGTH",
    "target_query": "INSERT INTO t2 (d)SELECT (SELECT SUM(length(c)) FROM t1 WHERE c='13_characters') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 (d VARCHAR(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (d VARCHAR(10));"
    ]
  },
  {
    "sql_id": "duckdb_74_10",
    "database_name": "duckdb_74_10",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t2 (d)SELECT (SELECT SUM(LENGTH(c)) FROM t1 WHERE c='7_chars') FROM t1; -- LENGTH",
    "target_query": "INSERT INTO t2 (d)SELECT (SELECT SUM(length(c)) FROM t1 WHERE c='7_chars') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 (d VARCHAR(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (d VARCHAR(10));"
    ]
  },
  {
    "sql_id": "duckdb_74_16",
    "database_name": "duckdb_74_16",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT *, HEX(a) FROM t1; -- HEX",
    "target_query": "SELECT *, HEX(a) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (id INT PRIMARY KEY,a VARCHAR(100));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id INT PRIMARY KEY, a VARCHAR(100));"
    ]
  },
  {
    "sql_id": "duckdb_74_17",
    "database_name": "duckdb_74_17",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT *, HEX(a) FROM t1 WHERE a = 'abc-def'; -- HEX",
    "target_query": "SELECT *, HEX(a) FROM t1 WHERE a = 'abc-def';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (id INT PRIMARY KEY,a VARCHAR(100));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id INT PRIMARY KEY, a VARCHAR(100));"
    ]
  },
  {
    "sql_id": "duckdb_75_2",
    "database_name": "duckdb_75_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 VALUES('valid-string',1),(UNHEX('11'),2); -- UNHEX",
    "target_query": "INSERT INTO t1 VALUES('valid-string', 1), (FROM_HEX('11'), 2);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNHEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNHEX(str)",
        "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT HEX(UNHEX('4D7953514C'));",
          "SELECT UNHEX('48656C6C6F');",
          "SELECT UNHEX(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "FROM_HEX(str)",
        "description": "Converts a hexadecimal string into a BLOB value. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT TO_HEX(FROM_HEX('4D7953514C'));",
          "SELECT FROM_HEX('48656C6C6F');",
          "SELECT FROM_HEX(NULL);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (tx TEXT NULL,pk INTEGER PRIMARY KEY);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (tx TEXT NULL, pk INTEGER PRIMARY KEY);"
    ]
  },
  {
    "sql_id": "duckdb_75_3",
    "database_name": "duckdb_75_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT pk,OCTET_LENGTH(tx),LENGTH(tx) FROM t1; -- OCTET_LENGTH, LENGTH",
    "target_query": "SELECT pk, LENGTH(tx), LENGTH(tx) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "OCTET_LENGTH",
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "OCTET_LENGTH()",
        "description": "Returns the number of bytes in a string.",
        "examples": [
          "SELECT OCTET_LENGTH('Hello World');",
          "SELECT OCTET_LENGTH('Test String') = 11;",
          "SELECT CASE WHEN OCTET_LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
        ]
      },
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LENGTH()",
        "description": "Returns the number of bytes in a string.",
        "examples": [
          "SELECT LENGTH('Hello World');",
          "SELECT LENGTH('Test String') = 11;",
          "SELECT CASE WHEN LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
        ]
      },
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (tx TEXT NULL,pk INTEGER PRIMARY KEY);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (tx TEXT NULL, pk INTEGER PRIMARY KEY);"
    ]
  },
  {
    "sql_id": "duckdb_76_2",
    "database_name": "duckdb_76_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "insert ignore t1 values (1, repeat('a',110), repeat('b', 210)); -- REPEAT",
    "target_query": "insert into t1 values (1, repeat('a',110), repeat('b', 210));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (i int, a char(200), b text, unique (a), unique (b(300)));"
    ],
    "target_related_schemas": [
      "create table t1 (i int, a char(200), b text, unique (a), unique (b));"
    ]
  },
  {
    "sql_id": "duckdb_76_3",
    "database_name": "duckdb_76_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select i, length(a), length(b), char_length(a), char_length(b) from t1; -- LENGTH, CHAR_LENGTH",
    "target_query": "select i, length(a), length(b), length(a), length(b) from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH",
      "CHAR_LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      },
      {
        "expression": "CHAR_LENGTH(expr)",
        "description": "Returns the number of characters in the string, not bytes.",
        "examples": [
          "SELECT CHAR_LENGTH('abc');",
          "SELECT CHAR_LENGTH('你好');",
          "SELECT CHAR_LENGTH('a你b好c');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      },
      {
        "expression": "length(expr)",
        "description": "Returns the number of characters in a string.",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length('a你b好c');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (i int, a char(200), b text, unique (a), unique (b(300)));"
    ],
    "target_related_schemas": [
      "create table t1 (i int, a char(200), b text, unique (a), unique (b));"
    ]
  },
  {
    "sql_id": "duckdb_76_6",
    "database_name": "duckdb_76_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "insert into t1 values(1, 'a', 'a', NOW()), (1, 'b', 'b', NOW()); -- NOW",
    "target_query": "insert into t1 values(1, 'a', 'a', CURRENT_TIMESTAMP), (1, 'b', 'b', CURRENT_TIMESTAMP);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "DuckDB also uses CURRENT_TIMESTAMP to get the current date and time, similar to PostgreSQL and MonetDB.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 int,c2 char(12),c3 varchar(123),c4 timestamp NOT NULL);"
    ],
    "target_related_schemas": [
      "create table t1 (c1 int,c2 char(12),c3 varchar(123),c4 timestamp NOT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_77_3",
    "database_name": "duckdb_77_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select t1.time,t1.date,t1.timestamp,concat(date,\" \",time),t1.quarter+t1.week, t1.year+timestampadd,  timestampdiff from t1; -- CONCAT",
    "target_query": "select t1.time,t1.date,t1.timestamp,CONCAT(date, ' ', time),t1.quarter+t1.week, t1.year+timestampadd, timestampdiff from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (time time, date date, timestamp timestamp,quarter int, week int, year int, timestampadd int, timestampdiff int);"
    ],
    "target_related_schemas": [
      "create table t1 (time time, date date, timestamp timestamp,quarter int, week int, year int, timestampadd int, timestampdiff int);"
    ]
  },
  {
    "sql_id": "duckdb_78_2",
    "database_name": "duckdb_78_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select concat('|',a,'|'), concat('|',b,'|') from t1; -- CONCAT",
    "target_query": "select CONCAT('|',a,'|'), CONCAT('|',b,'|') from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a text, b text);"
    ],
    "target_related_schemas": [
      "create table t1 (a text, b text);"
    ]
  },
  {
    "sql_id": "duckdb_78_5",
    "database_name": "duckdb_78_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT HEX(val) FROM t1; -- HEX",
    "target_query": "SELECT HEX(val) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (val TEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (val TEXT);"
    ]
  },
  {
    "sql_id": "duckdb_78_8",
    "database_name": "duckdb_78_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT HEX(a) FROM t1; -- HEX",
    "target_query": "SELECT HEX(a) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(a VARCHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(a VARCHAR(20));"
    ]
  },
  {
    "sql_id": "duckdb_79_3",
    "database_name": "duckdb_79_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT a, date_format(a,'%a') as abday, dayname(a) as day FROM t1 ORDER BY a; -- DATE_FORMAT, DAYNAME",
    "target_query": "SELECT a, STRFTIME(a,'%a') as abday, dayname(a) as day FROM t1 ORDER BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT",
      "DAYNAME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      },
      {
        "expression": "DAYNAME(date)",
        "description": "Returns the full name of the day for a given date.",
        "examples": [
          "SELECT DAYNAME('2023-11-25');",
          "SELECT DAYNAME('2022-01-01');",
          "SELECT DAYNAME('1999-03-14');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "STRFTIME(date_expr, format_str)",
        "description": "Formats a date/time value using SQLite-compatible strftime format specifiers.",
        "examples": [
          "SELECT STRFTIME('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT STRFTIME(CURRENT_TIMESTAMP, '%Y-%m-%d %H:%M:%S');",
          "SELECT STRFTIME('2023-01-15 12:00:00', '%d-%m-%Y');"
        ]
      },
      {
        "expression": "dayname(date)",
        "description": "Returns the full name of the day for a given date.",
        "examples": [
          "SELECT dayname(DATE '2023-11-25');",
          "SELECT dayname(DATE '2022-01-01');",
          "SELECT dayname(DATE '1999-03-14');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a DATE);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a DATE);"
    ]
  },
  {
    "sql_id": "duckdb_79_7",
    "database_name": "duckdb_79_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT a, date_format(a,'%b') as abmon, monthname(a) as mon FROM t1 ORDER BY a; -- DATE_FORMAT, MONTHNAME",
    "target_query": "SELECT a, STRFTIME(a,'%b') as abmon, monthname(a) as mon FROM t1 ORDER BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT",
      "MONTHNAME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      },
      {
        "expression": "MONTHNAME(date)",
        "description": "Returns the full English name of the month for a given date.",
        "examples": [
          "SELECT MONTHNAME(DATE '2023-05-01') AS mon1;",
          "SELECT MONTHNAME(STR_TO_DATE('2024-12-31', '%Y-%m-%d')) AS mon2;",
          "SELECT MONTHNAME(NOW()) AS current_month;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "STRFTIME(date_expr, format_str)",
        "description": "Formats a date/time value using SQLite-compatible strftime format specifiers.",
        "examples": [
          "SELECT STRFTIME('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT STRFTIME(CURRENT_TIMESTAMP, '%Y-%m-%d %H:%M:%S');",
          "SELECT STRFTIME('2023-01-15 12:00:00', '%d-%m-%Y');"
        ]
      },
      {
        "expression": "monthname(date)",
        "description": "Returns the full English name of the month for a given date.",
        "examples": [
          "SELECT monthname(DATE '2023-05-01');",
          "SELECT monthname(DATE '2024-12-31');",
          "SELECT monthname(CURRENT_DATE);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a DATE);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a DATE);"
    ]
  },
  {
    "sql_id": "duckdb_79_9",
    "database_name": "duckdb_79_9",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT DATE_FORMAT('2001-01-01', '%w %a %W'); -- DATE_FORMAT",
    "target_query": "SELECT STRFTIME(DATE '2001-01-01', '%w %a %W');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "STRFTIME(date_expr, format_str)",
        "description": "Formats a date/time value using SQLite-compatible strftime format specifiers.",
        "examples": [
          "SELECT STRFTIME('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT STRFTIME(CURRENT_TIMESTAMP, '%Y-%m-%d %H:%M:%S');",
          "SELECT STRFTIME('2023-01-15 12:00:00', '%d-%m-%Y');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_79_10",
    "database_name": "duckdb_79_10",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT DATE_FORMAT('2001-01-01', '%c %b %M'); -- DATE_FORMAT",
    "target_query": "SELECT STRFTIME(DATE '2001-01-01', '%c %b %M');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "STRFTIME(date_expr, format_str)",
        "description": "Formats a date/time value using SQLite-compatible strftime format specifiers.",
        "examples": [
          "SELECT STRFTIME('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT STRFTIME(CURRENT_TIMESTAMP, '%Y-%m-%d %H:%M:%S');",
          "SELECT STRFTIME('2023-01-15 12:00:00', '%d-%m-%Y');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_79_11",
    "database_name": "duckdb_79_11",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT DATE_FORMAT('2010-03-23 11:00:00','%h %p'); -- DATE_FORMAT",
    "target_query": "SELECT STRFTIME(DATE '2010-03-23 11:00:00','%h %p');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "STRFTIME(date_expr, format_str)",
        "description": "Formats a date/time value using SQLite-compatible strftime format specifiers.",
        "examples": [
          "SELECT STRFTIME('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT STRFTIME(CURRENT_TIMESTAMP, '%Y-%m-%d %H:%M:%S');",
          "SELECT STRFTIME('2023-01-15 12:00:00', '%d-%m-%Y');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_8_0",
    "database_name": "duckdb_8_0",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select strcmp('','ae'),strcmp('ae',''),strcmp('aeq','q'),strcmp('q','aeq'); -- STRCMP",
    "target_query": "SELECT CASE WHEN '' = 'ae' THEN 0 WHEN '' < 'ae' THEN -1 ELSE 1 END, CASE WHEN 'ae' = '' THEN 0 WHEN 'ae' < '' THEN -1 ELSE 1 END, CASE WHEN 'aeq' = 'q' THEN 0 WHEN 'aeq' < 'q' THEN -1 ELSE 1 END, CASE WHEN 'q' = 'aeq' THEN 0 WHEN 'q' < 'aeq' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "DuckDB does not have a STRCMP function, but the same functionality can be achieved using a CASE statement to compare strings lexicographically.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_8_1",
    "database_name": "duckdb_8_1",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select strcmp('ss',''),strcmp('','ss'),strcmp('s','sss'),strcmp('q','ssq'); -- STRCMP",
    "target_query": "SELECT CASE WHEN 'ss' = '' THEN 0 WHEN 'ss' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'ss' THEN 0 WHEN '' < 'ss' THEN -1 ELSE 1 END, CASE WHEN 's' = 'sss' THEN 0 WHEN 's' < 'sss' THEN -1 ELSE 1 END, CASE WHEN 'q' = 'ssq' THEN 0 WHEN 'q' < 'ssq' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "DuckDB does not have a STRCMP function, but the same functionality can be achieved using a CASE statement to compare strings lexicographically.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_8_2",
    "database_name": "duckdb_8_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select strcmp('','af'),strcmp('a',''),strcmp('','aeq'),strcmp('','aeaeq'); -- STRCMP",
    "target_query": "SELECT CASE WHEN '' = 'af' THEN 0 WHEN '' < 'af' THEN -1 ELSE 1 END, CASE WHEN 'a' = '' THEN 0 WHEN 'a' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'aeq' THEN 0 WHEN '' < 'aeq' THEN -1 ELSE 1 END, CASE WHEN '' = 'aeaeq' THEN 0 WHEN '' < 'aeaeq' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "DuckDB does not have a STRCMP function, but the same functionality can be achieved using a CASE statement to compare strings lexicographically.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_8_3",
    "database_name": "duckdb_8_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select strcmp('ss','a'),strcmp('','ssa'),strcmp('sa','sssb'),strcmp('s',''); -- STRCMP",
    "target_query": "SELECT CASE WHEN 'ss' = 'a' THEN 0 WHEN 'ss' < 'a' THEN -1 ELSE 1 END, CASE WHEN '' = 'ssa' THEN 0 WHEN '' < 'ssa' THEN -1 ELSE 1 END, CASE WHEN 'sa' = 'sssb' THEN 0 WHEN 'sa' < 'sssb' THEN -1 ELSE 1 END, CASE WHEN 's' = '' THEN 0 WHEN 's' < '' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "DuckDB does not have a STRCMP function, but the same functionality can be achieved using a CASE statement to compare strings lexicographically.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_8_4",
    "database_name": "duckdb_8_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select strcmp('','o'),strcmp('','u'),strcmp('','oeb'); -- STRCMP",
    "target_query": "SELECT CASE WHEN '' = 'o' THEN 0 WHEN '' < 'o' THEN -1 ELSE 1 END, CASE WHEN '' = 'u' THEN 0 WHEN '' < 'u' THEN -1 ELSE 1 END, CASE WHEN '' = 'oeb' THEN 0 WHEN '' < 'oeb' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "DuckDB does not have a STRCMP function, but the same functionality can be achieved using a CASE statement to compare strings lexicographically.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_8_5",
    "database_name": "duckdb_8_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select strcmp('af',''),strcmp('','a'),strcmp('aeq',''),strcmp('aeaeq',''); -- STRCMP",
    "target_query": "SELECT CASE WHEN 'af' = '' THEN 0 WHEN 'af' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'a' THEN 0 WHEN '' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'aeq' = '' THEN 0 WHEN 'aeq' < '' THEN -1 ELSE 1 END, CASE WHEN 'aeaeq' = '' THEN 0 WHEN 'aeaeq' < '' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "DuckDB does not have a STRCMP function, but the same functionality can be achieved using a CASE statement to compare strings lexicographically.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_8_6",
    "database_name": "duckdb_8_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select strcmp('a','ss'),strcmp('ssa',''),strcmp('sssb','sa'),strcmp('','s'); -- STRCMP",
    "target_query": "SELECT CASE WHEN 'a' = 'ss' THEN 0 WHEN 'a' < 'ss' THEN -1 ELSE 1 END, CASE WHEN 'ssa' = '' THEN 0 WHEN 'ssa' < '' THEN -1 ELSE 1 END, CASE WHEN 'sssb' = 'sa' THEN 0 WHEN 'sssb' < 'sa' THEN -1 ELSE 1 END, CASE WHEN '' = 's' THEN 0 WHEN '' < 's' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "DuckDB does not have a STRCMP function, but the same functionality can be achieved using a CASE statement to compare strings lexicographically.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_8_7",
    "database_name": "duckdb_8_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select strcmp('u','a'),strcmp('u',''); -- STRCMP",
    "target_query": "SELECT CASE WHEN 'u' = 'a' THEN 0 WHEN 'u' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'u' = '' THEN 0 WHEN 'u' < '' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "DuckDB does not have a STRCMP function, but the same functionality can be achieved using a CASE statement to compare strings lexicographically.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_8_8",
    "database_name": "duckdb_8_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select strcmp('s', 'a'), strcmp('a', 'x'); -- STRCMP",
    "target_query": "SELECT CASE WHEN 's' = 'a' THEN 0 WHEN 's' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'a' = 'x' THEN 0 WHEN 'a' < 'x' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "DuckDB does not have a STRCMP function, but the same functionality can be achieved using a CASE statement to compare strings lexicographically.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_8_13",
    "database_name": "duckdb_8_13",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT FIELD('ue',s1), FIELD('',s1), s1='ue', s1='' FROM t1; -- FIELD",
    "target_query": "SELECT COALESCE(array_position(ARRAY[s1], 'ue'), 0), COALESCE(array_position(ARRAY[s1], ''), 0), s1='ue', s1='' FROM t1; -- FIELD",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FIELD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FIELD(val, val1, val2, ..., valN)",
        "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
        "examples": [
          "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(array_position(ARRAY[val1, val2, ..., valN], val), 0)",
        "description": "Returns the index (1-based) of 'val' in the array. Returns 0 if not found, emulating MySQL FIELD().",
        "examples": [
          "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'c'), 0) AS result;",
          "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'x'), 0) AS result;",
          "SELECT COALESCE(array_position(ARRAY['b', 'b', 'b'], 'b'), 0) AS result;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (s1 CHAR(5));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (s1 CHAR(5));"
    ]
  },
  {
    "sql_id": "duckdb_8_17",
    "database_name": "duckdb_8_17",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select * from t1 where length(s1)=2 and s1='oe'; -- LENGTH",
    "target_query": "select * from t1 where length(s1)=2 and s1='oe'; -- LENGTH",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (s1 char(5));"
    ],
    "target_related_schemas": [
      "create table t1 (s1 char(5));"
    ]
  },
  {
    "sql_id": "duckdb_80_0",
    "database_name": "duckdb_80_0",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT LPAD(NULL, 5, 'x') AS result; -- LPAD",
    "target_query": "SELECT LPAD(NULL, 5, 'x') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_80_1",
    "database_name": "duckdb_80_1",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT LPAD(NULL, NULL, 'x') AS result; -- LPAD",
    "target_query": "SELECT LPAD(NULL, NULL, 'x') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_80_2",
    "database_name": "duckdb_80_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT LPAD(NULL, NULL, NULL) AS result; -- LPAD",
    "target_query": "SELECT LPAD(NULL, NULL, NULL) AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_80_3",
    "database_name": "duckdb_80_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT LPAD('a', NULL, 'x') AS result; -- LPAD",
    "target_query": "SELECT LPAD('a', NULL, 'x') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_80_4",
    "database_name": "duckdb_80_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT LPAD('a', NULL, NULL) AS result; -- LPAD",
    "target_query": "SELECT LPAD('a', NULL, NULL) AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_80_5",
    "database_name": "duckdb_80_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT LPAD('a', 5, NULL) AS result; -- LPAD",
    "target_query": "SELECT LPAD('a', 5, NULL) AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_80_6",
    "database_name": "duckdb_80_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT LPAD(NULL, 5, NULL) AS result; -- LPAD",
    "target_query": "SELECT LPAD(NULL, 5, NULL) AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_80_7",
    "database_name": "duckdb_80_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT LPAD('a', 0, 'x') AS result; -- LPAD",
    "target_query": "SELECT LPAD('a', 0, 'x') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_80_8",
    "database_name": "duckdb_80_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT LPAD('a', 0, '') AS result; -- LPAD",
    "target_query": "SELECT LPAD('a', 0, '') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_80_9",
    "database_name": "duckdb_80_9",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT LPAD('', 0, 'x') AS result; -- LPAD",
    "target_query": "SELECT LPAD('', 0, 'x') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_80_10",
    "database_name": "duckdb_80_10",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT LPAD('', 0, '') AS result; -- LPAD",
    "target_query": "SELECT LPAD('', 0, '') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_80_11",
    "database_name": "duckdb_80_11",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT LPAD('a', -1, 'x'); -- LPAD",
    "target_query": "SELECT LPAD('a', -1, 'x');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_80_12",
    "database_name": "duckdb_80_12",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT LPAD('123', 5, 'x'); -- LPAD",
    "target_query": "SELECT LPAD('123', 5, 'x');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_80_13",
    "database_name": "duckdb_80_13",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT LPAD('a', 5, 'xy'); -- LPAD",
    "target_query": "SELECT LPAD('a', 5, 'xy');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_80_14",
    "database_name": "duckdb_80_14",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT LPAD(\"I LOVE SQL\", 20, \" \"); -- LPAD",
    "target_query": "SELECT LPAD('I LOVE SQL', 20, ' ');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_80_15",
    "database_name": "duckdb_80_15",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT LPAD(\"I LOVE SQL in the morning\", 20, \" \"); -- LPAD",
    "target_query": "SELECT LPAD('I LOVE SQL in the morning', 20, ' ');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_81_2",
    "database_name": "duckdb_81_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 VALUES(REPEAT('a', 1024), 0), (REPEAT('b', 1024), 1),(REPEAT('c', 1024), 2), (REPEAT('d', 1024), 3),(REPEAT('e', 1024), 4), (REPEAT('f', 1024), 5); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES(REPEAT('a', 1024), 0), (REPEAT('b', 1024), 1),(REPEAT('c', 1024), 2), (REPEAT('d', 1024), 3),(REPEAT('e', 1024), 4), (REPEAT('f', 1024), 5);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (f1 LONGTEXT , f2  INTEGER);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (f1 TEXT , f2  INTEGER);"
    ]
  },
  {
    "sql_id": "duckdb_81_15",
    "database_name": "duckdb_81_15",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT SUM(LENGTH(f1)) FROM t1; -- LENGTH",
    "target_query": "SELECT SUM(length(f1)) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (f1 LONGTEXT , f2  INTEGER);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (f1 TEXT , f2  INTEGER);"
    ]
  },
  {
    "sql_id": "duckdb_82_3",
    "database_name": "duckdb_82_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT COALESCE(d, d), IFNULL(d, d), IF(i, d, d),CASE i WHEN i THEN d ELSE d END, GREATEST(d, d), LEAST(d, d)FROM t1 ORDER BY RAND(); -- COALESCE, IFNULL, IF, GREATEST, LEAST",
    "target_query": "SELECT COALESCE(d, d), COALESCE(d, d), CASE WHEN i THEN d ELSE d END, CASE i WHEN i THEN d ELSE d END, GREATEST(d, d), least(d, d) FROM t1 ORDER BY RANDOM();",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE",
      "IFNULL",
      "IF",
      "GREATEST",
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      },
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      },
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      },
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      },
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...)",
        "description": "DuckDB supports COALESCE for NULL handling.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;"
        ]
      },
      {
        "expression": "COALESCE(expr1, expr2)",
        "description": "DuckDB also uses COALESCE to return the first non-NULL argument, which is functionally the same as IFNULL in MySQL.",
        "examples": [
          "SELECT COALESCE(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      },
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      },
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      },
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the least non-null value among the provided expressions. NULLs are skipped unless all arguments are NULL. This differs from MySQL/MariaDB which return NULL if any argument is NULL.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(DATE '2024-01-01', DATE '2023-12-31');",
          "SELECT least(NULL, 2);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (i INT, d DATE);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (i INT, d DATE);"
    ]
  },
  {
    "sql_id": "duckdb_83_3",
    "database_name": "duckdb_83_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT HEX(c1) FROM AB; -- HEX",
    "target_query": "SELECT HEX(c1) FROM AB;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE AB (c1 CHAR(100));"
    ],
    "target_related_schemas": [
      "CREATE TABLE AB (c1 CHAR(100));"
    ]
  },
  {
    "sql_id": "duckdb_84_2",
    "database_name": "duckdb_84_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "insert into t5 values (1, date_format('2001-01-01','%W')); -- DATE_FORMAT",
    "target_query": "insert into t5 values (1, STRFTIME(DATE '2001-01-01','%W'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "STRFTIME(date_expr, format_str)",
        "description": "Formats a date/time value using SQLite-compatible strftime format specifiers.",
        "examples": [
          "SELECT STRFTIME('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT STRFTIME(CURRENT_TIMESTAMP, '%Y-%m-%d %H:%M:%S');",
          "SELECT STRFTIME('2023-01-15 12:00:00', '%d-%m-%Y');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t5 (c1 int, c2 varchar(128) not null);"
    ],
    "target_related_schemas": [
      "create table t5 (c1 int, c2 varchar(128) not null);"
    ]
  },
  {
    "sql_id": "duckdb_84_3",
    "database_name": "duckdb_84_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "insert into t5 values (2, date_format('2001-01-01','%W')); -- DATE_FORMAT",
    "target_query": "insert into t5 values (2, STRFTIME(DATE '2001-01-01','%W'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "STRFTIME(date_expr, format_str)",
        "description": "Formats a date/time value using SQLite-compatible strftime format specifiers.",
        "examples": [
          "SELECT STRFTIME('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT STRFTIME(CURRENT_TIMESTAMP, '%Y-%m-%d %H:%M:%S');",
          "SELECT STRFTIME('2023-01-15 12:00:00', '%d-%m-%Y');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t5 (c1 int, c2 varchar(128) not null);"
    ],
    "target_related_schemas": [
      "create table t5 (c1 int, c2 varchar(128) not null);"
    ]
  },
  {
    "sql_id": "duckdb_84_4",
    "database_name": "duckdb_84_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "insert into t5 values (3, date_format('2001-01-01','%W')); -- DATE_FORMAT",
    "target_query": "insert into t5 values (3, STRFTIME(DATE '2001-01-01','%W'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "STRFTIME(date_expr, format_str)",
        "description": "Formats a date/time value using SQLite-compatible strftime format specifiers.",
        "examples": [
          "SELECT STRFTIME('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT STRFTIME(CURRENT_TIMESTAMP, '%Y-%m-%d %H:%M:%S');",
          "SELECT STRFTIME('2023-01-15 12:00:00', '%d-%m-%Y');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t5 (c1 int, c2 varchar(128) not null);"
    ],
    "target_related_schemas": [
      "create table t5 (c1 int, c2 varchar(128) not null);"
    ]
  },
  {
    "sql_id": "duckdb_84_8",
    "database_name": "duckdb_84_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select hex(a) from t1; -- HEX",
    "target_query": "select hex(a) from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a varchar(64));"
    ],
    "target_related_schemas": [
      "create table t1 (a varchar(64));"
    ]
  },
  {
    "sql_id": "duckdb_85_2",
    "database_name": "duckdb_85_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 123)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 123));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (c1 LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 TEXT);"
    ]
  },
  {
    "sql_id": "duckdb_85_3",
    "database_name": "duckdb_85_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 234)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 234));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (c1 LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 TEXT);"
    ]
  },
  {
    "sql_id": "duckdb_85_4",
    "database_name": "duckdb_85_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 345)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 345));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (c1 LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 TEXT);"
    ]
  },
  {
    "sql_id": "duckdb_85_5",
    "database_name": "duckdb_85_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 456)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 456));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (c1 LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 TEXT);"
    ]
  },
  {
    "sql_id": "duckdb_85_6",
    "database_name": "duckdb_85_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT LENGTH(c1) FROM t1; -- LENGTH",
    "target_query": "SELECT length(c1) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (c1 LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 TEXT);"
    ]
  },
  {
    "sql_id": "duckdb_86_0",
    "database_name": "duckdb_86_0",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select null,isnull(null),isnull(1/0),isnull(1/0 = null),ifnull(null,1),ifnull(null,\"TRUE\"),ifnull(\"TRUE\",\"ERROR\"),1/0 is null,1 is not null; -- ISNULL, IFNULL",
    "target_query": "SELECT NULL, NULL IS NULL, (1/0) IS NULL, (1/0 = NULL) IS NULL, COALESCE(NULL, 1), COALESCE(NULL, 'TRUE'), COALESCE('TRUE', 'ERROR'), (1/0) IS NULL, 1 IS NOT NULL;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ISNULL",
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ISNULL(expr)",
        "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
        "examples": [
          "SELECT ISNULL(NULL);",
          "SELECT ISNULL(5 + NULL);",
          "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
        ]
      },
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "expr IS NULL",
        "description": "Tests whether the expression evaluates to NULL.",
        "examples": [
          "SELECT NULL IS NULL;",
          "SELECT ('abc' || NULL) IS NULL;",
          "SELECT CASE WHEN status IS NULL THEN 'unknown' ELSE status END FROM orders;"
        ]
      },
      {
        "expression": "COALESCE(expr1, expr2)",
        "description": "DuckDB also uses COALESCE to return the first non-NULL argument, which is functionally the same as IFNULL in MySQL.",
        "examples": [
          "SELECT COALESCE(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_86_1",
    "database_name": "duckdb_86_1",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select NULL=NULL,NULL<>NULL,IFNULL(NULL,1.1)+0,IFNULL(NULL,1) | 0; -- IFNULL",
    "target_query": "SELECT NULL = NULL, NULL <> NULL, COALESCE(NULL, 1.1) + 0, COALESCE(NULL, 1) | 0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2)",
        "description": "DuckDB also uses COALESCE to return the first non-NULL argument, which is functionally the same as IFNULL in MySQL.",
        "examples": [
          "SELECT COALESCE(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_86_3",
    "database_name": "duckdb_86_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select repeat(\"a\",0),repeat(\"ab\",5+5),repeat(\"ab\",-1),reverse(NULL); -- REPEAT",
    "target_query": "SELECT REPEAT('a', 0), REPEAT('ab', 5 + 5), REPEAT('ab', -1), REVERSE(NULL);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_86_4",
    "database_name": "duckdb_86_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select field(NULL,\"a\",\"b\",\"c\"); -- FIELD",
    "target_query": "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], NULL), 0);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FIELD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FIELD(val, val1, val2, ..., valN)",
        "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
        "examples": [
          "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(array_position(ARRAY[val1, val2, ..., valN], val), 0)",
        "description": "Returns the index (1-based) of 'val' in the array. Returns 0 if not found, emulating MySQL FIELD().",
        "examples": [
          "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'c'), 0) AS result;",
          "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'x'), 0) AS result;",
          "SELECT COALESCE(array_position(ARRAY['b', 'b', 'b'], 'b'), 0) AS result;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_86_9",
    "database_name": "duckdb_86_9",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "CREATE TABLE t2 SELECT IFNULL(a, b) FROM t1; -- IFNULL",
    "target_query": "CREATE TABLE t2 AS SELECT COALESCE(a, b) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2)",
        "description": "DuckDB also uses COALESCE to return the first non-NULL argument, which is functionally the same as IFNULL in MySQL.",
        "examples": [
          "SELECT COALESCE(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 SELECT IFNULL(a, b) FROM t1; -- IFNULL"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 AS SELECT COALESCE(a, b) FROM t1;"
    ]
  },
  {
    "sql_id": "duckdb_86_11",
    "database_name": "duckdb_86_11",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "CREATE TABLE t2 SELECT IFNULL(a, NULL) FROM t1; -- IFNULL",
    "target_query": "CREATE TABLE t2 AS SELECT COALESCE(a, NULL) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2)",
        "description": "DuckDB also uses COALESCE to return the first non-NULL argument, which is functionally the same as IFNULL in MySQL.",
        "examples": [
          "SELECT COALESCE(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 SELECT IFNULL(a, NULL) FROM t1; -- IFNULL"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 AS SELECT COALESCE(a, NULL) FROM t1;"
    ]
  },
  {
    "sql_id": "duckdb_86_13",
    "database_name": "duckdb_86_13",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "CREATE TABLE t2 SELECT IFNULL(NULL, b) FROM t1; -- IFNULL",
    "target_query": "CREATE TABLE t2 AS SELECT COALESCE(NULL, b) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2)",
        "description": "DuckDB also uses COALESCE to return the first non-NULL argument, which is functionally the same as IFNULL in MySQL.",
        "examples": [
          "SELECT COALESCE(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 SELECT IFNULL(NULL, b) FROM t1; -- IFNULL"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 AS SELECT COALESCE(NULL, b) FROM t1;"
    ]
  },
  {
    "sql_id": "duckdb_87_2",
    "database_name": "duckdb_87_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 VALUES ( repeat( 'a', 10 ), 1),( repeat( 'b', 10 ), 2); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES ( repeat( 'a', 10 ), 1),( repeat( 'b', 10 ), 2);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1( a VARCHAR( 10 ), b INT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1( a VARCHAR( 10 ), b INT );"
    ]
  },
  {
    "sql_id": "duckdb_87_3",
    "database_name": "duckdb_87_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT GROUP_CONCAT(a) FROM t1; -- GROUP_CONCAT",
    "target_query": "SELECT GROUP_CONCAT(a) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GROUP_CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
        "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
        "description": "The GROUP_CONCAT function in DuckDB concatenates values from multiple rows into a single string, separated by a specified delimiter.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1( a VARCHAR( 10 ), b INT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1( a VARCHAR( 10 ), b INT );"
    ]
  },
  {
    "sql_id": "duckdb_87_5",
    "database_name": "duckdb_87_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT UNIX_TIMESTAMP(); -- UNIX_TIMESTAMP",
    "target_query": "SELECT EXTRACT(EPOCH FROM current_timestamp);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_88_0",
    "database_name": "duckdb_88_0",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select repeat('a',2000); -- REPEAT",
    "target_query": "SELECT REPEAT('a',2000);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_88_1",
    "database_name": "duckdb_88_1",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT length(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\") as len; -- LENGTH",
    "target_query": "SELECT length('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa') AS len;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_88_2",
    "database_name": "duckdb_88_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select length(repeat('a',2000)); -- LENGTH, REPEAT",
    "target_query": "SELECT length(REPEAT('a',2000));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH",
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      },
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      },
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_88_9",
    "database_name": "duckdb_88_9",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT c11, LENGTH(c12) FROM t1; -- LENGTH",
    "target_query": "SELECT c11, length(c12) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 (c21 INT NOT NULL, c22 LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (c21 INT NOT NULL, c22 TEXT);"
    ]
  },
  {
    "sql_id": "duckdb_89_3",
    "database_name": "duckdb_89_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select hex(a) from t1 where a like 'A_'; -- HEX",
    "target_query": "select hex(a) from t1 where a like 'A_';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a varchar(50));"
    ],
    "target_related_schemas": [
      "create table t1 (a varchar(50));"
    ]
  },
  {
    "sql_id": "duckdb_89_5",
    "database_name": "duckdb_89_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "explain select hex(a) from t1 where a like 'A_'; -- HEX",
    "target_query": "explain select hex(a) from t1 where a like 'A_';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a varchar(50));"
    ],
    "target_related_schemas": [
      "create table t1 (a varchar(50));"
    ]
  },
  {
    "sql_id": "duckdb_89_6",
    "database_name": "duckdb_89_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select hex(a) from t1; -- HEX",
    "target_query": "select hex(a) from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a varchar(50));"
    ],
    "target_related_schemas": [
      "create table t1 (a varchar(50));"
    ]
  },
  {
    "sql_id": "duckdb_89_8",
    "database_name": "duckdb_89_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "create table t1 as select to_seconds(null) as to_seconds; -- TO_SECONDS",
    "target_query": "create table t1 as select epoch(NULL::TIMESTAMP) + 62167219200 as to_seconds;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TO_SECONDS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TO_SECONDS(datetime_expr)",
        "description": "Returns the number of seconds since year 0 to the given datetime.",
        "examples": [
          "SELECT TO_SECONDS('2000-01-01 00:00:00');",
          "SELECT TO_SECONDS(NOW());",
          "SELECT TO_SECONDS(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "epoch(ts) + 62167219200",
        "description": "Converts timestamp to Unix epoch time and adds the number of seconds between year 0 and 1970.",
        "examples": [
          "SELECT epoch(TIMESTAMP '2020-12-31 12:00:00') + 62167219200;",
          "SELECT epoch(CURRENT_TIMESTAMP) + 62167219200;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 as select to_seconds(null) as to_seconds; -- TO_SECONDS"
    ],
    "target_related_schemas": [
      "create table t1 as select epoch(NULL::TIMESTAMP) + 62167219200 as to_seconds;"
    ]
  },
  {
    "sql_id": "duckdb_9_0",
    "database_name": "duckdb_9_0",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT IF(0,\"ERROR\",\"this\"),IF(1,\"is\",\"ERROR\"),IF(NULL,\"ERROR\",\"a\"),IF(1,2,3),IF(1,2.0,3.0)+0; -- IF",
    "target_query": "SELECT CASE WHEN 0 THEN 'ERROR' ELSE 'this' END, CASE WHEN 1 THEN 'is' ELSE 'ERROR' END, CASE WHEN NULL THEN 'ERROR' ELSE 'a' END, CASE WHEN 1 THEN 2 ELSE 3 END, CASE WHEN 1 THEN 2.0 ELSE 3.0 END + 0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_9_4",
    "database_name": "duckdb_9_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT IF(1,st,st) s FROM t1 ORDER BY s; -- IF",
    "target_query": "SELECT CASE WHEN 1 THEN st ELSE st END s FROM t1 ORDER BY s;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_9_5",
    "database_name": "duckdb_9_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT IF(u=1,st,st) s FROM t1 ORDER BY s; -- IF",
    "target_query": "SELECT CASE WHEN u=1 THEN st ELSE st END s FROM t1 ORDER BY s;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_9_7",
    "database_name": "duckdb_9_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select nullif(u, 1) from t1; -- NULLIF",
    "target_query": "SELECT NULLIF(u, 1) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NULLIF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NULLIF(a, b)",
        "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
        "examples": [
          "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
          "SELECT NULLIF(YEAR('2021-01-01'), 2021) AS year_check;",
          "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "NULLIF(a, b)",
        "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
        "examples": [
          "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
          "SELECT NULLIF(EXTRACT(YEAR FROM DATE '2021-01-01'), 2021) AS year_check;",
          "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_9_8",
    "database_name": "duckdb_9_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "explain select nullif(u, 1) from t1; -- NULLIF",
    "target_query": "EXPLAIN SELECT NULLIF(u, 1) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NULLIF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NULLIF(a, b)",
        "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
        "examples": [
          "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
          "SELECT NULLIF(YEAR('2021-01-01'), 2021) AS year_check;",
          "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "NULLIF(a, b)",
        "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
        "examples": [
          "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
          "SELECT NULLIF(EXTRACT(YEAR FROM DATE '2021-01-01'), 2021) AS year_check;",
          "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_9_12",
    "database_name": "duckdb_9_12",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select sum(if(num is null,0.00,num)) from t1; -- IF",
    "target_query": "SELECT SUM(CASE WHEN num IS NULL THEN 0.00 ELSE num END) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (num  double(12,2));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (num  double);"
    ]
  },
  {
    "sql_id": "duckdb_9_16",
    "database_name": "duckdb_9_16",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select min(if(y -x > 5,y,NULL)), max(if(y - x > 5,y,NULL)) from t1; -- IF",
    "target_query": "SELECT MIN(CASE WHEN y - x > 5 THEN y ELSE NULL END), MAX(CASE WHEN y - x > 5 THEN y ELSE NULL END) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (x int, y int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (x int, y int);"
    ]
  },
  {
    "sql_id": "duckdb_9_18",
    "database_name": "duckdb_9_18",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT NULLIF(5,5) IS NULL, NULLIF(5,5) IS NOT NULL; -- NULLIF",
    "target_query": "SELECT NULLIF(5,5) IS NULL, NULLIF(5,5) IS NOT NULL;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NULLIF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NULLIF(a, b)",
        "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
        "examples": [
          "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
          "SELECT NULLIF(YEAR('2021-01-01'), 2021) AS year_check;",
          "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "NULLIF(a, b)",
        "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
        "examples": [
          "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
          "SELECT NULLIF(EXTRACT(YEAR FROM DATE '2021-01-01'), 2021) AS year_check;",
          "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_9_21",
    "database_name": "duckdb_9_21",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT id, IF(date IS NULL, '-', FROM_UNIXTIME(date, '%d-%m-%Y')) AS date_ord, text FROM t1 ORDER BY date_ord ASC; -- IF, FROM_UNIXTIME",
    "target_query": "SELECT id, CASE WHEN date IS NULL THEN '-' ELSE STRFTIME(TO_TIMESTAMP(date), '%d-%m-%Y') END AS date_ord, text FROM t1 ORDER BY date_ord ASC;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF",
      "FROM_UNIXTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      },
      {
        "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
        "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
          "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      },
      {
        "expression": "TO_TIMESTAMP(unix_timestamp)",
        "description": "Converts a Unix timestamp (seconds since epoch) to a TIMESTAMP value.",
        "examples": [
          "SELECT TO_TIMESTAMP(1672531200);",
          "SELECT TO_TIMESTAMP(1672531200.789);",
          "SELECT id, TO_TIMESTAMP(event_time) AS event_ts FROM events;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE `t1` (`id` int(11) NOT NULL ,`date` int(10) default NULL,`text` varchar(32) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id int, date int DEFAULT NULL, text varchar(32) NOT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_9_22",
    "database_name": "duckdb_9_22",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT id, IF(date IS NULL, '-', FROM_UNIXTIME(date, '%d-%m-%Y')) AS date_ord, text FROM t1 ORDER BY date_ord DESC; -- IF, FROM_UNIXTIME",
    "target_query": "SELECT id, CASE WHEN date IS NULL THEN '-' ELSE STRFTIME(TO_TIMESTAMP(date), '%d-%m-%Y') END AS date_ord, text FROM t1 ORDER BY date_ord DESC;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF",
      "FROM_UNIXTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      },
      {
        "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
        "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
          "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      },
      {
        "expression": "TO_TIMESTAMP(unix_timestamp)",
        "description": "Converts a Unix timestamp (seconds since epoch) to a TIMESTAMP value.",
        "examples": [
          "SELECT TO_TIMESTAMP(1672531200);",
          "SELECT TO_TIMESTAMP(1672531200.789);",
          "SELECT id, TO_TIMESTAMP(event_time) AS event_ts FROM events;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE `t1` (`id` int(11) NOT NULL ,`date` int(10) default NULL,`text` varchar(32) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id int, date int DEFAULT NULL, text varchar(32) NOT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_9_26",
    "database_name": "duckdb_9_26",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT * FROM (SELECT MAX(IF(1, CAST(c AS UNSIGNED), 0)) FROM t1) AS te; -- IF",
    "target_query": "SELECT * FROM (SELECT MAX(CASE WHEN 1 THEN CAST(c AS INT64) ELSE 0 END) FROM t1) AS te;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (c LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c TEXT);"
    ]
  },
  {
    "sql_id": "duckdb_9_27",
    "database_name": "duckdb_9_27",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT * FROM (SELECT MAX(IFNULL(CAST(c AS UNSIGNED), 0)) FROM t1) AS te; -- IFNULL",
    "target_query": "SELECT * FROM (SELECT MAX(COALESCE(CAST(c AS INT64), 0)) FROM t1) AS te;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2)",
        "description": "DuckDB also uses COALESCE to return the first non-NULL argument, which is functionally the same as IFNULL in MySQL.",
        "examples": [
          "SELECT COALESCE(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (c LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c TEXT);"
    ]
  },
  {
    "sql_id": "duckdb_9_29",
    "database_name": "duckdb_9_29",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT AVG(NULLIF(YEAR('2001-01-01'),10)); -- NULLIF, YEAR",
    "target_query": "SELECT AVG(NULLIF(EXTRACT(YEAR FROM DATE '2001-01-01'),10));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NULLIF",
      "YEAR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NULLIF(a, b)",
        "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
        "examples": [
          "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
          "SELECT NULLIF(YEAR('2021-01-01'), 2021) AS year_check;",
          "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
        ]
      },
      {
        "expression": "YEAR(date)",
        "description": "Extracts the year from a date or datetime and returns it as an integer.",
        "examples": [
          "SELECT YEAR('2023-04-10');",
          "SELECT YEAR(NOW());",
          "SELECT YEAR('2022-03-15');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "NULLIF(a, b)",
        "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
        "examples": [
          "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
          "SELECT NULLIF(EXTRACT(YEAR FROM DATE '2021-01-01'), 2021) AS year_check;",
          "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
        ]
      },
      {
        "expression": "EXTRACT(YEAR FROM date)",
        "description": "Extracts the year from a date or datetime and returns it as an integer.",
        "examples": [
          "SELECT EXTRACT(YEAR FROM DATE '2023-04-10');",
          "SELECT EXTRACT(YEAR FROM CURRENT_DATE);",
          "SELECT EXTRACT(YEAR FROM DATE '2022-03-15');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_90_0",
    "database_name": "duckdb_90_0",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT FROM_DAYS(3652499), FROM_DAYS(3652500), FROM_DAYS(3652501); -- FROM_DAYS",
    "target_query": "SELECT DATE '0000-01-01' + INTERVAL 3652499 DAY, DATE '0000-01-01' + INTERVAL 3652500 DAY, DATE '0000-01-01' + INTERVAL 3652501 DAY;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FROM_DAYS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FROM_DAYS(n)",
        "description": "Returns a date corresponding to the number of days since year 0.",
        "examples": [
          "SELECT FROM_DAYS(1);",
          "SELECT FROM_DAYS(730000);",
          "SELECT CONCAT('Date is: ', FROM_DAYS(738000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "DATE '0000-01-01' + INTERVAL n DAY",
        "description": "Returns a date by adding n days as an interval to '0000-01-01'.",
        "examples": [
          "SELECT DATE '0000-01-01' + INTERVAL 1 DAY;",
          "SELECT DATE '0000-01-01' + INTERVAL 730000 DAY;",
          "SELECT 'Date is: ' || (DATE '0000-01-01' + INTERVAL 738000 DAY);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_90_1",
    "database_name": "duckdb_90_1",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT FROM_DAYS(42949670), FROM_DAYS(42949671), FROM_DAYS(42949673); -- FROM_DAYS",
    "target_query": "SELECT DATE '0000-01-01' + INTERVAL 42949670 DAY, DATE '0000-01-01' + INTERVAL 42949671 DAY, DATE '0000-01-01' + INTERVAL 42949673 DAY;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FROM_DAYS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FROM_DAYS(n)",
        "description": "Returns a date corresponding to the number of days since year 0.",
        "examples": [
          "SELECT FROM_DAYS(1);",
          "SELECT FROM_DAYS(730000);",
          "SELECT CONCAT('Date is: ', FROM_DAYS(738000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "DATE '0000-01-01' + INTERVAL n DAY",
        "description": "Returns a date by adding n days as an interval to '0000-01-01'.",
        "examples": [
          "SELECT DATE '0000-01-01' + INTERVAL 1 DAY;",
          "SELECT DATE '0000-01-01' + INTERVAL 730000 DAY;",
          "SELECT 'Date is: ' || (DATE '0000-01-01' + INTERVAL 738000 DAY);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_91_2",
    "database_name": "duckdb_91_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t VALUES (0, REPEAT('x', 120000)), (1, REPEAT('z', 12000)); -- REPEAT",
    "target_query": "INSERT INTO t VALUES (0, REPEAT('x', 120000)), (1, REPEAT('z', 12000));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t(i int, b LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t(i int, b TEXT);"
    ]
  },
  {
    "sql_id": "duckdb_91_4",
    "database_name": "duckdb_91_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT LENGTH(b) FROM (SELECT * FROM t INTERSECT SELECT * FROM t) derived; -- LENGTH",
    "target_query": "SELECT length(b) FROM (SELECT * FROM t INTERSECT SELECT * FROM t) derived;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t(i int, b LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t(i int, b TEXT);"
    ]
  },
  {
    "sql_id": "duckdb_92_2",
    "database_name": "duckdb_92_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT argument FROM test_log WHERE argument LIKE CONCAT('%azun','dris%'); -- CONCAT",
    "target_query": "SELECT argument FROM test_log WHERE argument LIKE CONCAT('%azun', 'dris%');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE test_log (argument TEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE test_log (argument TEXT);"
    ]
  },
  {
    "sql_id": "duckdb_93_0",
    "database_name": "duckdb_93_0",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select row(10,2,3) IN (row(3,2,3), row(1,2,3), row(1,3,3)); -- ROW",
    "target_query": "select row(10,2,3) IN (row(3,2,3), row(1,2,3), row(1,3,3));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_93_1",
    "database_name": "duckdb_93_1",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select row(1,2,3) IN (row(3,NULL,3), row(1,2,3), row(1,3,3)); -- ROW",
    "target_query": "select row(1,2,3) IN (row(3,NULL,3), row(1,2,3), row(1,3,3));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_93_2",
    "database_name": "duckdb_93_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select row(10,2,3) IN (row(3,NULL,3), row(1,2,3), row(1,3,3)); -- ROW",
    "target_query": "select row(10,2,3) IN (row(3,NULL,3), row(1,2,3), row(1,3,3));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_93_3",
    "database_name": "duckdb_93_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select row('a',1.5,3) IN (row(1,2,3), row('a',1.5,3), row('a','a','a')); -- ROW",
    "target_query": "select row('a',1.5,3) IN (row(1,2,3), row('a',1.5,3), row('a','a','a'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_93_4",
    "database_name": "duckdb_93_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select row('a',0,3) IN (row(3,2,3), row('a','a','3'), row(1,3,3)); -- ROW",
    "target_query": "select row('a',0,3) IN (row(3,2,3), row('a','a','3'), row(1,3,3));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_93_5",
    "database_name": "duckdb_93_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select row('a',0,3) IN (row(3,2,3), row('a','0','3'), row(1,3,3)); -- ROW",
    "target_query": "select row('a',0,3) IN (row(3,2,3), row('a','0','3'), row(1,3,3));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_93_6",
    "database_name": "duckdb_93_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select row('a',1.5,3) IN (row(3,NULL,3), row('a',1.5,3), row(1,3,3)); -- ROW",
    "target_query": "select row('a',1.5,3) IN (row(3,NULL,3), row('a',1.5,3), row(1,3,3));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_93_7",
    "database_name": "duckdb_93_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select row('b',1.5,3) IN (row(3,NULL,3), row('a',1.5,3), row(1,3,3)); -- ROW",
    "target_query": "select row('b',1.5,3) IN (row(3,NULL,3), row('a',1.5,3), row(1,3,3));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_93_8",
    "database_name": "duckdb_93_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select row('b',1.5,3) IN (row('b',NULL,3), row('a',1.5,3), row(1,3,3)); -- ROW",
    "target_query": "select row('b',1.5,3) IN (row('b',NULL,3), row('a',1.5,3), row(1,3,3));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_93_9",
    "database_name": "duckdb_93_9",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select row('b',1.5,3) IN (row('b',NULL,4), row('a',1.5,3), row(1,3,3)); -- ROW",
    "target_query": "select row('b',1.5,3) IN (row('b',NULL,4), row('a',1.5,3), row(1,3,3));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_93_10",
    "database_name": "duckdb_93_10",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select row(1,2,row(3,4)) IN (row(3,2,row(3,4)), row(1,2,row(3,NULL))); -- ROW",
    "target_query": "select row(1,2,row(3,4)) IN (row(3,2,row(3,4)), row(1,2,row(3,NULL)));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_93_11",
    "database_name": "duckdb_93_11",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "explain select row(1,2,row(3,4)) IN (row(3,2,row(3,4)), row(1,2,row(3,NULL))); -- ROW",
    "target_query": "explain select row(1,2,row(3,4)) IN (row(3,2,row(3,4)), row(1,2,row(3,NULL)));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_93_12",
    "database_name": "duckdb_93_12",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select row(1,2,row(3,null)) IN (row(3,2,row(3,4)), row(1,2,row(4,5))); -- ROW",
    "target_query": "select row(1,2,row(3,null)) IN (row(3,2,row(3,4)), row(1,2,row(4,5)));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_93_13",
    "database_name": "duckdb_93_13",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select row(1,2,row(3,null)) IN (row(3,2,row(3,4)), row(1,2,row(3,5))); -- ROW",
    "target_query": "select row(1,2,row(3,null)) IN (row(3,2,row(3,4)), row(1,2,row(3,5)));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_93_14",
    "database_name": "duckdb_93_14",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT ROW(1,2,3)=ROW(1,2,3); -- ROW",
    "target_query": "SELECT ROW(1,2,3)=ROW(1,2,3);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_93_15",
    "database_name": "duckdb_93_15",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT ROW(2,2,3)=ROW(1+1,2,3); -- ROW",
    "target_query": "SELECT ROW(2,2,3)=ROW(1+1,2,3);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_93_16",
    "database_name": "duckdb_93_16",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT ROW(1,2,3)=ROW(1+1,2,3); -- ROW",
    "target_query": "SELECT ROW(1,2,3)=ROW(1+1,2,3);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_93_17",
    "database_name": "duckdb_93_17",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT ROW(1,2,3)<ROW(1+1,2,3); -- ROW",
    "target_query": "SELECT ROW(1,2,3)<ROW(1+1,2,3);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_93_18",
    "database_name": "duckdb_93_18",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT ROW(1,2,3)>ROW(1+1,2,3); -- ROW",
    "target_query": "SELECT ROW(1,2,3)>ROW(1+1,2,3);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_93_19",
    "database_name": "duckdb_93_19",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT ROW(1,2,3)<=ROW(1+1,2,3); -- ROW",
    "target_query": "SELECT ROW(1,2,3)<=ROW(1+1,2,3);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_93_20",
    "database_name": "duckdb_93_20",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT ROW(1,2,3)>=ROW(1+1,2,3); -- ROW",
    "target_query": "SELECT ROW(1,2,3)>=ROW(1+1,2,3);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_93_21",
    "database_name": "duckdb_93_21",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT ROW(1,2,3)<>ROW(1+1,2,3); -- ROW",
    "target_query": "SELECT ROW(1,2,3)<>ROW(1+1,2,3);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_93_22",
    "database_name": "duckdb_93_22",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT ROW(NULL,2,3)=ROW(NULL,2,3); -- ROW",
    "target_query": "SELECT ROW(NULL,2,3)=ROW(NULL,2,3);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_93_23",
    "database_name": "duckdb_93_23",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT ROW(1,2,ROW(3,4,5))=ROW(1,2,ROW(3,4,5)); -- ROW",
    "target_query": "SELECT ROW(1,2,ROW(3,4,5))=ROW(1,2,ROW(3,4,5));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_93_24",
    "database_name": "duckdb_93_24",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT ROW('test',2,3.33)=ROW('test',2,3.33); -- ROW",
    "target_query": "SELECT ROW('test',2,3.33)=ROW('test',2,3.33);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_93_25",
    "database_name": "duckdb_93_25",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT ROW('test',2,ROW(3,33))=ROW('test',2,ROW(3,33)); -- ROW",
    "target_query": "SELECT ROW('test',2,ROW(3,33))=ROW('test',2,ROW(3,33));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_93_26",
    "database_name": "duckdb_93_26",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT ROW('test',2,ROW(3,33))=ROW('test',2,ROW(3,3)); -- ROW",
    "target_query": "SELECT ROW('test',2,ROW(3,33))=ROW('test',2,ROW(3,3));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_93_27",
    "database_name": "duckdb_93_27",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT ROW('test',2,ROW(3,33))=ROW('test',2,ROW(3,NULL)); -- ROW",
    "target_query": "SELECT ROW('test',2,ROW(3,33))=ROW('test',2,ROW(3,NULL));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_94_3",
    "database_name": "duckdb_94_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select * from t1 where ROW(1,2,3)=ROW(a,b,c); -- ROW",
    "target_query": "SELECT * FROM t1 WHERE ROW(1,2,3) = ROW(a,b,c);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 ( a int, b int, c int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a INT, b INT, c INT);"
    ]
  },
  {
    "sql_id": "duckdb_94_4",
    "database_name": "duckdb_94_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select * from t1 where ROW(0,2,3)=ROW(a,b,c); -- ROW",
    "target_query": "SELECT * FROM t1 WHERE ROW(0,2,3) = ROW(a,b,c);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 ( a int, b int, c int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a INT, b INT, c INT);"
    ]
  },
  {
    "sql_id": "duckdb_94_5",
    "database_name": "duckdb_94_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select * from t1 where ROW(1,2,3)<ROW(a,b,c); -- ROW",
    "target_query": "SELECT * FROM t1 WHERE ROW(1,2,3) < ROW(a,b,c);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 ( a int, b int, c int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a INT, b INT, c INT);"
    ]
  },
  {
    "sql_id": "duckdb_94_6",
    "database_name": "duckdb_94_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select ROW(a,2,3) IN(row(1,b,c), row(2,3,1)) from t1; -- ROW",
    "target_query": "SELECT ROW(a,2,3) IN (ROW(1,b,c), ROW(2,3,1)) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 ( a int, b int, c int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a INT, b INT, c INT);"
    ]
  },
  {
    "sql_id": "duckdb_94_7",
    "database_name": "duckdb_94_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select ROW(c,2,3) IN(row(1,b,a), row(2,3,1)) from t1; -- ROW",
    "target_query": "SELECT ROW(c,2,3) IN (ROW(1,b,a), ROW(2,3,1)) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 ( a int, b int, c int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a INT, b INT, c INT);"
    ]
  },
  {
    "sql_id": "duckdb_94_8",
    "database_name": "duckdb_94_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select ROW(a,b,c) IN(row(1,2,3), row(3,2,1)) from t1; -- ROW",
    "target_query": "SELECT ROW(a,b,c) IN (ROW(1,2,3), ROW(3,2,1)) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 ( a int, b int, c int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a INT, b INT, c INT);"
    ]
  },
  {
    "sql_id": "duckdb_94_9",
    "database_name": "duckdb_94_9",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select ROW(1,2,3) IN(row(a,b,c), row(1,2,3)) from t1; -- ROW",
    "target_query": "SELECT ROW(1,2,3) IN (ROW(a,b,c), ROW(1,2,3)) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 ( a int, b int, c int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a INT, b INT, c INT);"
    ]
  },
  {
    "sql_id": "duckdb_94_11",
    "database_name": "duckdb_94_11",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT ROW(1,1,1) = ROW(1,1,1), ROW(1,1,1) = ROW(1,2,1), ROW(1,NULL,1) = ROW(2,2,1), ROW(1,NULL,1) = ROW(1,2,2), ROW(1,NULL,1) = ROW(1,2,1) ; -- ROW",
    "target_query": "SELECT ROW(1,1,1) = ROW(1,1,1), ROW(1,1,1) = ROW(1,2,1), ROW(1,NULL,1) = ROW(2,2,1), ROW(1,NULL,1) = ROW(1,2,2), ROW(1,NULL,1) = ROW(1,2,1);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_95_3",
    "database_name": "duckdb_95_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT ROW(a, 1) IN (SELECT SUM(b), 1) FROM t1 GROUP BY a; -- ROW",
    "target_query": "SELECT ROW(a, 1) IN (SELECT ROW(SUM(b), 1)) FROM t1 GROUP BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a INT, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT, b INT);"
    ]
  },
  {
    "sql_id": "duckdb_95_4",
    "database_name": "duckdb_95_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT ROW(a, 1) IN (SELECT SUM(b), 3) FROM t1 GROUP BY a; -- ROW",
    "target_query": "SELECT ROW(a, 1) IN (SELECT ROW(SUM(b), 3)) FROM t1 GROUP BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a INT, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT, b INT);"
    ]
  },
  {
    "sql_id": "duckdb_95_12",
    "database_name": "duckdb_95_12",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT ROW(1,2) = (SELECT 1,2 FROM t1 WHERE 1 = 0); -- ROW",
    "target_query": "SELECT ROW(1,2) = ROW((SELECT 1), (SELECT 2)) FROM t1 WHERE 1 = 0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (i INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (i INT);"
    ]
  },
  {
    "sql_id": "duckdb_95_13",
    "database_name": "duckdb_95_13",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT ROW(1,2) = (SELECT 1,3 FROM t1 WHERE 1 = 0); -- ROW",
    "target_query": "SELECT ROW(1,2) = ROW((SELECT 1), (SELECT 3)) FROM t1 WHERE 1 = 0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (i INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (i INT);"
    ]
  },
  {
    "sql_id": "duckdb_95_18",
    "database_name": "duckdb_95_18",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "EXPLAIN SELECT row( min(a), 1 ) = row( a, 1 ) AS al FROM t1 GROUP BY a; -- ROW",
    "target_query": "EXPLAIN SELECT ROW(MIN(a), 1) = ROW(a, 1) AS al FROM t1 GROUP BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a INT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a INT );"
    ]
  },
  {
    "sql_id": "duckdb_95_19",
    "database_name": "duckdb_95_19",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT row( min(a), 1 ) = row( a, 1 ) AS al FROM t1 GROUP BY a; -- ROW",
    "target_query": "SELECT ROW(MIN(a), 1) = ROW(a, 1) AS al FROM t1 GROUP BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a INT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a INT );"
    ]
  },
  {
    "sql_id": "duckdb_96_0",
    "database_name": "duckdb_96_0",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT RPAD(NULL, 5, 'x') AS result; -- RPAD",
    "target_query": "SELECT RPAD(NULL, 5, 'x') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "DuckDB supports RPAD for string padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123::TEXT, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_96_1",
    "database_name": "duckdb_96_1",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT RPAD(NULL, NULL, 'x') AS result; -- RPAD",
    "target_query": "SELECT RPAD(NULL, NULL, 'x') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "DuckDB supports RPAD for string padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123::TEXT, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_96_2",
    "database_name": "duckdb_96_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT RPAD(NULL, NULL, NULL) AS result; -- RPAD",
    "target_query": "SELECT RPAD(NULL, NULL, NULL) AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "DuckDB supports RPAD for string padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123::TEXT, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_96_3",
    "database_name": "duckdb_96_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT RPAD('a', NULL, 'x') AS result; -- RPAD",
    "target_query": "SELECT RPAD('a', NULL, 'x') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "DuckDB supports RPAD for string padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123::TEXT, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_96_4",
    "database_name": "duckdb_96_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT RPAD('a', NULL, NULL) AS result; -- RPAD",
    "target_query": "SELECT RPAD('a', NULL, NULL) AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "DuckDB supports RPAD for string padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123::TEXT, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_96_5",
    "database_name": "duckdb_96_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT RPAD('a', 5, NULL) AS result; -- RPAD",
    "target_query": "SELECT RPAD('a', 5, NULL) AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "DuckDB supports RPAD for string padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123::TEXT, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_96_6",
    "database_name": "duckdb_96_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT RPAD(NULL, 5, NULL) AS result; -- RPAD",
    "target_query": "SELECT RPAD(NULL, 5, NULL) AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "DuckDB supports RPAD for string padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123::TEXT, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_96_7",
    "database_name": "duckdb_96_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT RPAD('a', 0, 'x') AS result; -- RPAD",
    "target_query": "SELECT RPAD('a', 0, 'x') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "DuckDB supports RPAD for string padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123::TEXT, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_96_8",
    "database_name": "duckdb_96_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT RPAD('a', 0, '') AS result; -- RPAD",
    "target_query": "SELECT RPAD('a', 0, '') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "DuckDB supports RPAD for string padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123::TEXT, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_96_9",
    "database_name": "duckdb_96_9",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT RPAD('', 0, 'x') AS result; -- RPAD",
    "target_query": "SELECT RPAD('', 0, 'x') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "DuckDB supports RPAD for string padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123::TEXT, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_96_10",
    "database_name": "duckdb_96_10",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT RPAD('', 0, '') AS result; -- RPAD",
    "target_query": "SELECT RPAD('', 0, '') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "DuckDB supports RPAD for string padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123::TEXT, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_96_11",
    "database_name": "duckdb_96_11",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT RPAD('a', -1, 'x'); -- RPAD",
    "target_query": "SELECT RPAD('a', -1, 'x');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "DuckDB supports RPAD for string padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123::TEXT, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_96_12",
    "database_name": "duckdb_96_12",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT RPAD('123456787890', 1, 'x'); -- RPAD",
    "target_query": "SELECT RPAD('123456787890', 1, 'x');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "DuckDB supports RPAD for string padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123::TEXT, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_96_13",
    "database_name": "duckdb_96_13",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT RPAD('a', 5, 'xy'); -- RPAD",
    "target_query": "SELECT RPAD('a', 5, 'xy');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "DuckDB supports RPAD for string padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123::TEXT, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_96_14",
    "database_name": "duckdb_96_14",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT RPAD(\"I LOVE SQL\", 20, \" \"); -- RPAD",
    "target_query": "SELECT RPAD('I LOVE SQL', 20, ' ');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "DuckDB supports RPAD for string padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123::TEXT, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_96_15",
    "database_name": "duckdb_96_15",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT RPAD(\"I LOVE SQL in the morning\", 20, \" \"); -- RPAD",
    "target_query": "SELECT RPAD('I LOVE SQL in the morning', 20, ' ');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "DuckDB supports RPAD for string padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123::TEXT, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_97_6",
    "database_name": "duckdb_97_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "EXPLAIN SELECT * FROM t1 WHERE ISNULL(t1.a IN (SELECT t3.a FROM t1 t3)); -- ISNULL",
    "target_query": "EXPLAIN SELECT * FROM t1 WHERE t1.a IN (SELECT t3.a FROM t1 t3) IS NULL;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ISNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ISNULL(expr)",
        "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
        "examples": [
          "SELECT ISNULL(NULL);",
          "SELECT ISNULL(5 + NULL);",
          "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "expr IS NULL",
        "description": "Tests whether the expression evaluates to NULL.",
        "examples": [
          "SELECT NULL IS NULL;",
          "SELECT ('abc' || NULL) IS NULL;",
          "SELECT CASE WHEN status IS NULL THEN 'unknown' ELSE status END FROM orders;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(a INT, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(a INT, b INT);"
    ]
  },
  {
    "sql_id": "duckdb_97_7",
    "database_name": "duckdb_97_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT * FROM t1 WHERE ISNULL(t1.a IN (SELECT t3.a FROM t1 t3)); -- ISNULL",
    "target_query": "SELECT * FROM t1 WHERE t1.a IN (SELECT t3.a FROM t1 t3) IS NULL;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ISNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ISNULL(expr)",
        "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
        "examples": [
          "SELECT ISNULL(NULL);",
          "SELECT ISNULL(5 + NULL);",
          "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "expr IS NULL",
        "description": "Tests whether the expression evaluates to NULL.",
        "examples": [
          "SELECT NULL IS NULL;",
          "SELECT ('abc' || NULL) IS NULL;",
          "SELECT CASE WHEN status IS NULL THEN 'unknown' ELSE status END FROM orders;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(a INT, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(a INT, b INT);"
    ]
  },
  {
    "sql_id": "duckdb_98_4",
    "database_name": "duckdb_98_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "EXPLAIN SELECT * FROM t1 WHERE (SELECT b FROM t2 WHERE CAST(UUID() AS CHAR) = CAST(t2.a AS CHAR)) > 0; -- UUID",
    "target_query": "EXPLAIN SELECT * FROM t1 WHERE (SELECT b FROM t2 WHERE CAST(uuid() AS TEXT) = CAST(t2.a AS TEXT) ) > 0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UUID"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UUID()",
        "description": "In MySQL, the UUID() function generates a unique 128-bit identifier, typically represented as a string containing numbers and letters, in the standard UUID format.",
        "examples": [
          "SELECT UUID();",
          "SELECT CONCAT(UUID(), 'some_random_string');",
          "SELECT UPPER(UUID());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "uuid()",
        "description": "DuckDB supports the uuid() function, which generates a unique 128-bit identifier in the same format as MySQL's UUID() function.",
        "examples": [
          "SELECT uuid();",
          "SELECT CONCAT(uuid(), 'some_random_string');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2(a INT, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2(a INT, b INT);"
    ]
  },
  {
    "sql_id": "duckdb_98_14",
    "database_name": "duckdb_98_14",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ; -- COALESCE",
    "target_query": "SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...)",
        "description": "DuckDB supports COALESCE for NULL handling.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t3(a INT, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t3(a INT, b INT);"
    ]
  },
  {
    "sql_id": "duckdb_98_15",
    "database_name": "duckdb_98_15",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "EXPLAIN SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ; -- COALESCE",
    "target_query": "EXPLAIN SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...)",
        "description": "DuckDB supports COALESCE for NULL handling.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t3(a INT, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t3(a INT, b INT);"
    ]
  },
  {
    "sql_id": "duckdb_98_16",
    "database_name": "duckdb_98_16",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT (SELECT IFNULL(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ; -- IFNULL",
    "target_query": "SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2)",
        "description": "DuckDB also uses COALESCE to return the first non-NULL argument, which is functionally the same as IFNULL in MySQL.",
        "examples": [
          "SELECT COALESCE(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t3(a INT, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t3(a INT, b INT);"
    ]
  },
  {
    "sql_id": "duckdb_98_17",
    "database_name": "duckdb_98_17",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "EXPLAIN SELECT (SELECT IFNULL(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ; -- IFNULL",
    "target_query": "EXPLAIN SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2)",
        "description": "DuckDB also uses COALESCE to return the first non-NULL argument, which is functionally the same as IFNULL in MySQL.",
        "examples": [
          "SELECT COALESCE(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t3(a INT, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t3(a INT, b INT);"
    ]
  },
  {
    "sql_id": "duckdb_99_6",
    "database_name": "duckdb_99_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT TRIM(f1), COUNT(*) FROM table_varchar_pad_space GROUP BY f1; -- TRIM, COUNT",
    "target_query": "SELECT TRIM(f1), COUNT(*) FROM table_varchar_pad_space GROUP BY f1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TRIM",
      "COUNT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      },
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN FORMAT=TREE SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "DuckDB's TRIM function is identical to MySQL's, removing unwanted characters from the beginning or end of a string, or from both ends if specified.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      },
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE table_varchar_pad_space (f1 VARCHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE table_varchar_pad_space (f1 VARCHAR(20));"
    ]
  },
  {
    "sql_id": "duckdb_10_3",
    "database_name": "duckdb_10_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select a1,a2,b,min(c) from t1 where (ord(a1) > 97) and (ord(a2) + ord(a1) > 194) and (b = 'a') group by a1,a2,b; -- ORD",
    "target_query": "select a1,a2,b,min(c) from t1 where (unicode(a1) > 97) and (unicode(a2) + unicode(a1) > 194) and (b = 'a') group by a1,a2,b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ORD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ORD(string)",
        "description": "The ORD() function returns the Unicode code point of the first character of a string.",
        "examples": [
          "SELECT ORD('A');",
          "SELECT ORD('B');",
          "SELECT ORD('C') > 60;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "unicode(string)",
        "description": "DuckDB uses the unicode() function to get the Unicode code point of a string's first character, similar to MySQL's ORD().",
        "examples": [
          "SELECT unicode('A');",
          "SELECT unicode('B');",
          "SELECT unicode('C') > 60;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');"
    ],
    "target_related_schemas": [
      "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');"
    ]
  },
  {
    "sql_id": "duckdb_10_4",
    "database_name": "duckdb_10_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select concat(a1,min(c)),b from t1 where a1 < 'd' group by a1,a2,b; -- CONCAT",
    "target_query": "select concat(a1,min(c)),b from t1 where a1 < 'd' group by a1,a2,b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');"
    ],
    "target_related_schemas": [
      "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');"
    ]
  },
  {
    "sql_id": "duckdb_10_5",
    "database_name": "duckdb_10_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select concat(a1,min(c)),b,max(c) from t1 where a1 < 'd' group by a1,a2,b; -- CONCAT",
    "target_query": "select concat(a1,min(c)),b,max(c) from t1 where a1 < 'd' group by a1,a2,b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');"
    ],
    "target_related_schemas": [
      "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');"
    ]
  },
  {
    "sql_id": "duckdb_10_6",
    "database_name": "duckdb_10_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select concat(a1,a2),b,min(c),max(c) from t1 where a1 < 'd' group by a1,a2,b; -- CONCAT",
    "target_query": "select concat(a1,a2),b,min(c),max(c) from t1 where a1 < 'd' group by a1,a2,b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');"
    ],
    "target_related_schemas": [
      "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');"
    ]
  },
  {
    "sql_id": "duckdb_10_7",
    "database_name": "duckdb_10_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select concat(ord(min(b)),ord(max(b))),min(b),max(b) from t1 group by a1,a2; -- CONCAT, ORD",
    "target_query": "select concat(unicode(min(b)),unicode(max(b))),min(b),max(b) from t1 group by a1,a2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT",
      "ORD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      },
      {
        "expression": "ORD(string)",
        "description": "The ORD() function returns the Unicode code point of the first character of a string.",
        "examples": [
          "SELECT ORD('A');",
          "SELECT ORD('B');",
          "SELECT ORD('C') > 60;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      },
      {
        "expression": "unicode(string)",
        "description": "DuckDB uses the unicode() function to get the Unicode code point of a string's first character, similar to MySQL's ORD().",
        "examples": [
          "SELECT unicode('A');",
          "SELECT unicode('B');",
          "SELECT unicode('C') > 60;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');"
    ],
    "target_related_schemas": [
      "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');"
    ]
  },
  {
    "sql_id": "duckdb_11_3",
    "database_name": "duckdb_11_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select Fld1, max(Fld2) from t1 group by Fld1 having std(Fld2) is not null; -- STD",
    "target_query": "select Fld1, max(Fld2) from t1 group by Fld1 having stddev(Fld2) is not null;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STD(expression)",
        "description": "Calculates the standard deviation for the sample of a given expression.",
        "examples": [
          "SELECT some_dimension, COUNT(*), MIN(some_expression), MAX(some_expression), SUM(some_expression), AVG(some_expression), STD(some_expression) FROM some_data GROUP BY some_dimension LIMIT 5;",
          "SELECT another_dimension, COUNT(*), STD(expression1 / expression2) FROM another_data GROUP BY another_dimension ORDER BY another_dimension;",
          "SELECT ROUND(STD(expression1 / expression2), 5) FROM more_data;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "stddev(expression)",
        "description": "Calculates the standard deviation for the sample of a given expression.",
        "examples": [
          "SELECT some_dimension, COUNT(*), MIN(some_expression), MAX(some_expression), SUM(some_expression), AVG(some_expression), stddev(some_expression) FROM some_data GROUP BY some_dimension LIMIT 5;",
          "SELECT another_dimension, COUNT(*), stddev(expression1 / expression2) FROM another_data GROUP BY another_dimension ORDER BY another_dimension;",
          "SELECT ROUND(stddev(expression1 / expression2), 5) FROM more_data;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (Fld1 int(11) default NULL,Fld2 int(11) default NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (Fld1 INT, Fld2 INT);"
    ]
  },
  {
    "sql_id": "duckdb_11_4",
    "database_name": "duckdb_11_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select Fld1, max(Fld2) from t1 group by Fld1 having variance(Fld2) is not null; -- VARIANCE",
    "target_query": "select Fld1, max(Fld2) from t1 group by Fld1 having variance(Fld2) is not null;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "VARIANCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "VARIANCE(column1)",
        "description": "In MySQL, the VARIANCE() function calculates the variance of a given column of numeric values. It is used to measure the spread or dispersion of the data in a column.",
        "examples": [
          "SELECT VARIANCE(column1) AS variance_value FROM some_table;",
          "SELECT department, VARIANCE(salary) AS department_salary_variance FROM employees GROUP BY department;",
          "SELECT VARIANCE(price) AS price_variance FROM items;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "VARIANCE(column1)",
        "description": "DuckDB supports the VARIANCE() function to compute the variance of a numeric column, which is used for measuring how spread out the data is.",
        "examples": [
          "SELECT VARIANCE(column1) AS variance_value FROM some_table;",
          "SELECT department, VARIANCE(salary) AS department_salary_variance FROM employees GROUP BY department;",
          "SELECT VARIANCE(price) AS price_variance FROM items;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (Fld1 int(11) default NULL,Fld2 int(11) default NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (Fld1 INT, Fld2 INT);"
    ]
  },
  {
    "sql_id": "duckdb_12_8",
    "database_name": "duckdb_12_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "insert into t3 select concat('c-', 1000+A.a, '=w'), concat('c-', 2000+A.a, '=w'),'filler-1' from t2 A; -- CONCAT",
    "target_query": "INSERT INTO t3 SELECT CONCAT('c-', 1000 + A.a, '=w'), CONCAT('c-', 2000 + A.a, '=w'), 'filler-1' FROM t2 A;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t3 (a char(8) not null, b char(8) not null, filler char(200));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t3 (a VARCHAR(8) NOT NULL, b VARCHAR(8) NOT NULL, filler VARCHAR(200));"
    ]
  },
  {
    "sql_id": "duckdb_12_9",
    "database_name": "duckdb_12_9",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "insert into t3 select concat('c-', 1000+A.a, '=w'), concat('c-', 3000+A.a, '=w'),'filler-2' from t2 A; -- CONCAT",
    "target_query": "INSERT INTO t3 SELECT CONCAT('c-', 1000 + A.a, '=w'), CONCAT('c-', 3000 + A.a, '=w'), 'filler-2' FROM t2 A;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t3 (a char(8) not null, b char(8) not null, filler char(200));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t3 (a VARCHAR(8) NOT NULL, b VARCHAR(8) NOT NULL, filler VARCHAR(200));"
    ]
  },
  {
    "sql_id": "duckdb_12_23",
    "database_name": "duckdb_12_23",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "update t1 set b=repeat(char(65+a), 20) where a < 25; -- REPEAT",
    "target_query": "UPDATE t1 SET b = REPEAT(CHR(65 + a), 20) WHERE a < 25;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t0 (a int);",
      "create table t1 (a int, b char(20), filler char(200));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0 (a INT);",
      "CREATE TABLE t1 (a INT, b VARCHAR(20), filler VARCHAR(200));"
    ]
  },
  {
    "sql_id": "duckdb_12_24",
    "database_name": "duckdb_12_24",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "explain select * from t1 where a < 10 and b = repeat(char(65+a), 20); -- REPEAT",
    "target_query": "EXPLAIN SELECT * FROM t1 WHERE a < 10 AND b = REPEAT(CHR(65 + a), 20);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t0 (a int);",
      "create table t1 (a int, b char(20), filler char(200));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0 (a INT);",
      "CREATE TABLE t1 (a INT, b VARCHAR(20), filler VARCHAR(200));"
    ]
  },
  {
    "sql_id": "duckdb_12_25",
    "database_name": "duckdb_12_25",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select * from t1 where a < 10 and b = repeat(char(65+a), 20); -- REPEAT",
    "target_query": "SELECT * FROM t1 WHERE a < 10 AND b = REPEAT(CHR(65 + a), 20);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t0 (a int);",
      "create table t1 (a int, b char(20), filler char(200));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0 (a INT);",
      "CREATE TABLE t1 (a INT, b VARCHAR(20), filler VARCHAR(200));"
    ]
  },
  {
    "sql_id": "duckdb_13_6",
    "database_name": "duckdb_13_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select a,hex(b),hex(c),filler from t1 order by filler; -- HEX",
    "target_query": "select a,hex(b),hex(c),filler from t1 order by filler;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a int, b char(10), c char(10), filler char(10));"
    ],
    "target_related_schemas": [
      "create table t1 (a int, b char(10), c char(10), filler char(10));"
    ]
  },
  {
    "sql_id": "duckdb_14_3",
    "database_name": "duckdb_14_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "UPDATE t1 set data=repeat('a',18*1024); -- REPEAT",
    "target_query": "UPDATE t1 SET data = REPEAT('a', 18 * 1024);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (data LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (data VARCHAR);"
    ]
  },
  {
    "sql_id": "duckdb_14_4",
    "database_name": "duckdb_14_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select length(data) from t1; -- LENGTH",
    "target_query": "SELECT LENGTH(data) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (data LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (data VARCHAR);"
    ]
  },
  {
    "sql_id": "duckdb_14_7",
    "database_name": "duckdb_14_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 (data) VALUES (repeat('a',1*1024)); -- REPEAT",
    "target_query": "INSERT INTO t1 (data) VALUES (REPEAT('a', 1 * 1024));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (data LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (data VARCHAR);"
    ]
  },
  {
    "sql_id": "duckdb_14_8",
    "database_name": "duckdb_14_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 (data) VALUES (repeat('b',16*1024-1024)); -- REPEAT",
    "target_query": "INSERT INTO t1 (data) VALUES (REPEAT('b', 16 * 1024 - 1024));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (data LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (data VARCHAR);"
    ]
  },
  {
    "sql_id": "duckdb_14_10",
    "database_name": "duckdb_14_10",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "UPDATE t1 set data=repeat('c',17*1024); -- REPEAT",
    "target_query": "UPDATE t1 SET data = REPEAT('c', 17 * 1024);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (data LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (data VARCHAR);"
    ]
  },
  {
    "sql_id": "duckdb_14_13",
    "database_name": "duckdb_14_13",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 set data=repeat('a',18*1024); -- REPEAT",
    "target_query": "INSERT INTO t1 (data) VALUES (REPEAT('a', 18 * 1024));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (data LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (data VARCHAR);"
    ]
  },
  {
    "sql_id": "duckdb_14_14",
    "database_name": "duckdb_14_14",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select length(data) from t1; -- LENGTH",
    "target_query": "SELECT LENGTH(data) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (data LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (data VARCHAR);"
    ]
  },
  {
    "sql_id": "duckdb_15_0",
    "database_name": "duckdb_15_0",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT UNIX_TIMESTAMP('2011-01-01 00:00:00') as time_t,UNIX_TIMESTAMP('2011-01-01 00:00:00') % 3 as part,1234567890 % 3 as part2; -- UNIX_TIMESTAMP",
    "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2011-01-01 00:00:00') as time_t, EXTRACT(EPOCH FROM TIMESTAMP '2011-01-01 00:00:00') % 3 as part, 1234567890 % 3 as part2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_15_3",
    "database_name": "duckdb_15_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t3 (a) VALUES (NOW()); -- NOW",
    "target_query": "INSERT INTO t3 (a) VALUES (CURRENT_TIMESTAMP);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "DuckDB also uses CURRENT_TIMESTAMP to get the current date and time, similar to PostgreSQL and MonetDB.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t3(a timestamp,b char(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t3(a TIMESTAMP, b CHAR(10));"
    ]
  },
  {
    "sql_id": "duckdb_15_13",
    "database_name": "duckdb_15_13",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t2 VALUES (1 + (SELECT a FROM t1),CONCAT(\"subq: \", (SELECT b FROM t1))); -- CONCAT",
    "target_query": "INSERT INTO t2 (a, b) SELECT 1 + a, 'subq: ' || b FROM t1; -- 直接计算避免子查询",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 (a INT, b VARCHAR(64));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (a INT, b VARCHAR(64));"
    ]
  },
  {
    "sql_id": "duckdb_17_2",
    "database_name": "duckdb_17_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a' IN 'abc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_17_3",
    "database_name": "duckdb_17_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('b' IN 'abc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_17_4",
    "database_name": "duckdb_17_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('c' IN 'abc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_17_5",
    "database_name": "duckdb_17_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('d' IN 'abc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_17_6",
    "database_name": "duckdb_17_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a' IN NULL);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_17_7",
    "database_name": "duckdb_17_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION(NULL IN 'a');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_17_8",
    "database_name": "duckdb_17_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( NULL, NULL ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION(NULL IN NULL);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_17_9",
    "database_name": "duckdb_17_9",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT hex( concat(regexp_instr( 'a', 'a' )) ); -- HEX, CONCAT, REGEXP_INSTR",
    "target_query": "SELECT HEX(CONCAT(POSITION('a' IN 'a')));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "CONCAT",
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      },
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      },
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_17_10",
    "database_name": "duckdb_17_10",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( 1, 'a' ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a' IN CAST(1 AS VARCHAR));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_17_11",
    "database_name": "duckdb_17_11",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( 1.1, 'a' ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a' IN CAST(1.1 AS VARCHAR));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_17_12",
    "database_name": "duckdb_17_12",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( 'a', 1 ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION(CAST(1 AS VARCHAR) IN 'a');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_17_13",
    "database_name": "duckdb_17_13",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( 'a', 1.1 ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION(CAST(1.1 AS VARCHAR) IN 'a');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_17_14",
    "database_name": "duckdb_17_14",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( subject, pattern ) FROM t1; -- REGEXP_INSTR",
    "target_query": "SELECT POSITION(pattern IN subject) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (subject char(10),pattern char(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (subject char(10),pattern char(10));"
    ]
  },
  {
    "sql_id": "duckdb_17_15",
    "database_name": "duckdb_17_15",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1 ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a+' IN 'abcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_17_16",
    "database_name": "duckdb_17_16",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 2 ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a+' IN 'abcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_17_17",
    "database_name": "duckdb_17_17",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'b+', 1 ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('b+' IN 'abcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_17_18",
    "database_name": "duckdb_17_18",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'b+', 2 ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('b+' IN 'abcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_17_19",
    "database_name": "duckdb_17_19",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'b+', 3 ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('b+' IN 'abcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_17_20",
    "database_name": "duckdb_17_20",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 2 ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a+' IN 'abcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_17_21",
    "database_name": "duckdb_17_21",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 3 ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a+' IN 'abcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_17_22",
    "database_name": "duckdb_17_22",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 4 ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a+' IN 'abcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_17_23",
    "database_name": "duckdb_17_23",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 4, 2 ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a+' IN 'abcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_17_24",
    "database_name": "duckdb_17_24",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( 'a', 'a+', 1, 1, NULL ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a+' IN 'a');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_17_25",
    "database_name": "duckdb_17_25",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 0 ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a+' IN 'abcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_17_26",
    "database_name": "duckdb_17_26",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 1 ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a+' IN 'abcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_17_27",
    "database_name": "duckdb_17_27",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( 'aaabcabcabc', 'a+', 1, 1, 1 ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a+' IN 'aaabcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_17_28",
    "database_name": "duckdb_17_28",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'c' ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('A+' IN 'aaabcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_17_29",
    "database_name": "duckdb_17_29",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'i' ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('A+' IN 'aaabcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_17_30",
    "database_name": "duckdb_17_30",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'ci' ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('A+' IN 'aaabcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_17_31",
    "database_name": "duckdb_17_31",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'cic' ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('A+' IN 'aaabcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_17_32",
    "database_name": "duckdb_17_32",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_instr( 'a', 'a+', 1, 1, 1, NULL ); -- REGEXP_INSTR",
    "target_query": "SELECT POSITION('a+' IN 'a');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_18_0",
    "database_name": "duckdb_18_0",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_replace( 'aaa', 'a', 'X' ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaa', 'a', 'X');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Returns a string where all occurrences of the regular expression pattern are replaced with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_18_1",
    "database_name": "duckdb_18_1",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('abc', 'b', 'X');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Returns a string where all occurrences of the regular expression pattern are replaced with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_18_2",
    "database_name": "duckdb_18_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_replace( NULL, 'a', 'X' ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace(NULL, 'a', 'X');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Returns a string where all occurrences of the regular expression pattern are replaced with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_18_3",
    "database_name": "duckdb_18_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_replace( 'aaa', NULL, 'X' ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaa', NULL, 'X');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Returns a string where all occurrences of the regular expression pattern are replaced with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_18_4",
    "database_name": "duckdb_18_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_replace( 'aaa', 'a', NULL ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaa', 'a', NULL);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Returns a string where all occurrences of the regular expression pattern are replaced with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_18_5",
    "database_name": "duckdb_18_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT concat( regexp_replace( 'aaa', 'a', 'X' ), 'x' ); -- CONCAT, REGEXP_REPLACE",
    "target_query": "SELECT CONCAT(regexp_replace('aaa', 'a', 'X'), 'x');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT",
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      },
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      },
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Returns a string where all occurrences of the regular expression pattern are replaced with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_18_6",
    "database_name": "duckdb_18_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_replace( 'aaa', 'a', 'X', 1 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaa', 'a', 'X');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Returns a string where all occurrences of the regular expression pattern are replaced with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_18_7",
    "database_name": "duckdb_18_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 1 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaabbccbbddaa', 'b+', 'X');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Returns a string where all occurrences of the regular expression pattern are replaced with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_18_8",
    "database_name": "duckdb_18_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 2 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaabbccbbddaa', 'b+', 'X');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Returns a string where all occurrences of the regular expression pattern are replaced with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_18_9",
    "database_name": "duckdb_18_9",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>', 1, 2 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaabbccbbddaa', '(b+)', '<$1>');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Returns a string where all occurrences of the regular expression pattern are replaced with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_18_10",
    "database_name": "duckdb_18_10",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x', 1, 0 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaabbccbbddaa', 'x+', 'x');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Returns a string where all occurrences of the regular expression pattern are replaced with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_18_11",
    "database_name": "duckdb_18_11",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x', 1, 0 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaabbccbbddaa', 'b+', 'x');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Returns a string where all occurrences of the regular expression pattern are replaced with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_18_12",
    "database_name": "duckdb_18_12",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_replace( 'aaab', 'b', 'x', 1, 2 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaab', 'b', 'x');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Returns a string where all occurrences of the regular expression pattern are replaced with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_18_13",
    "database_name": "duckdb_18_13",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_replace( 'aaabccc', 'b', 'x', 1, 2 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaabccc', 'b', 'x');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Returns a string where all occurrences of the regular expression pattern are replaced with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_18_14",
    "database_name": "duckdb_18_14",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('abc', 'b', 'X');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Returns a string where all occurrences of the regular expression pattern are replaced with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_18_15",
    "database_name": "duckdb_18_15",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_replace( 'abcbdb', 'b', 'X' ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('abcbdb', 'b', 'X');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Returns a string where all occurrences of the regular expression pattern are replaced with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_18_16",
    "database_name": "duckdb_18_16",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_replace( 'abcbdb', 'b', 'X', 3 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('abcbdb', 'b', 'X');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Returns a string where all occurrences of the regular expression pattern are replaced with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_18_17",
    "database_name": "duckdb_18_17",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 1 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaabcbdb', 'b', 'X');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Returns a string where all occurrences of the regular expression pattern are replaced with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_18_18",
    "database_name": "duckdb_18_18",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 2 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaabcbdb', 'b', 'X');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Returns a string where all occurrences of the regular expression pattern are replaced with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_18_19",
    "database_name": "duckdb_18_19",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 3 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaabcbdb', 'b', 'X');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Returns a string where all occurrences of the regular expression pattern are replaced with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_18_20",
    "database_name": "duckdb_18_20",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_replace( 'aaa', 'a', 'X', 2 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaa', 'a', 'X');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Returns a string where all occurrences of the regular expression pattern are replaced with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_18_21",
    "database_name": "duckdb_18_21",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_replace( 'aaa', 'a', 'XX', 2 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaa', 'a', 'XX');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Returns a string where all occurrences of the regular expression pattern are replaced with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_19_2",
    "database_name": "duckdb_19_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 VALUES ( regexp_instr('a', 'a'),regexp_instr('a', 'a'),regexp_instr('a', 'a'),regexp_instr('a', 'a') ); -- REGEXP_INSTR",
    "target_query": "INSERT INTO t1 VALUES ( POSITION('a' IN 'a'), POSITION('a' IN 'a'), POSITION('a' IN 'a'), POSITION('a' IN 'a') );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION('o' IN 'hello world')",
        "description": "DuckDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT POSITION('o' IN 'hello world');",
          "SELECT POSITION('x' IN 'hello world');",
          "SELECT POSITION('a' IN 'openai');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(a REAL,b INT,c CHAR(100),d DECIMAL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(a REAL,b INT,c CHAR(100),d DECIMAL);"
    ]
  },
  {
    "sql_id": "duckdb_19_6",
    "database_name": "duckdb_19_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 ( c ) VALUES ( regexp_replace('a', 'a', 'a') ); -- REGEXP_REPLACE",
    "target_query": "INSERT INTO t1 ( c ) VALUES ( regexp_replace('a', 'a', 'a') );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Returns a string where all occurrences of the regular expression pattern are replaced with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(a REAL,b INT,c CHAR(100),d DECIMAL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(a REAL,b INT,c CHAR(100),d DECIMAL);"
    ]
  },
  {
    "sql_id": "duckdb_19_10",
    "database_name": "duckdb_19_10",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT length(regexp_replace( repeat('a', 'b'), 'a', 'b' )); -- LENGTH, REGEXP_REPLACE, REPEAT",
    "target_query": "SELECT length(regexp_replace( repeat('a', 12), 'a', 'b' ));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH",
      "REGEXP_REPLACE",
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      },
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      },
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      },
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Returns a string where all occurrences of the regular expression pattern are replaced with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      },
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_19_12",
    "database_name": "duckdb_19_12",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 VALUES ( repeat( 'a', 16384 ) ); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES ( repeat( 'a', 16384 ) );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a TEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a TEXT);"
    ]
  },
  {
    "sql_id": "duckdb_19_13",
    "database_name": "duckdb_19_13",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT char_length ( regexp_replace( a, 'a', 'b' ) ) FROM t1; -- CHAR_LENGTH, REGEXP_REPLACE",
    "target_query": "SELECT length ( regexp_replace( a, 'a', 'b' ) ) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CHAR_LENGTH",
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CHAR_LENGTH(expr)",
        "description": "Returns the number of characters in the string, not bytes.",
        "examples": [
          "SELECT CHAR_LENGTH('abc');",
          "SELECT CHAR_LENGTH('你好');",
          "SELECT CHAR_LENGTH('a你b好c');"
        ]
      },
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(expr)",
        "description": "Returns the number of characters in a string.",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length('a你b好c');"
        ]
      },
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Returns a string where all occurrences of the regular expression pattern are replaced with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a TEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a TEXT);"
    ]
  },
  {
    "sql_id": "duckdb_19_17",
    "database_name": "duckdb_19_17",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT regexp_replace(a, '^([[:alpha:]]+)[[:space:]].*$', '$1') FROM t1; -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace(a, '^([[:alpha:]]+)[[:space:]].*$', '$1') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Returns a string where all occurrences of the regular expression pattern are replaced with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a VARCHAR(10) );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a VARCHAR(10) );"
    ]
  },
  {
    "sql_id": "duckdb_19_21",
    "database_name": "duckdb_19_21",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "UPDATE t1 SET a = regexp_replace ( 'b', 'b', 'y' ); -- REGEXP_REPLACE",
    "target_query": "UPDATE t1 SET a = regexp_replace ( 'b', 'b', 'y' );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Returns a string where all occurrences of the regular expression pattern are replaced with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a CHAR(3) );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a CHAR(3) );"
    ]
  },
  {
    "sql_id": "duckdb_20_2",
    "database_name": "duckdb_20_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT SUM(DISTINCT LENGTH(name)) s1 FROM t1; -- LENGTH",
    "target_query": "SELECT SUM(DISTINCT LENGTH(name)) AS s1 FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (id INTEGER NOT NULL PRIMARY KEY,gender CHAR(1),name VARCHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id INTEGER PRIMARY KEY, gender CHAR(1), name VARCHAR(20));"
    ]
  },
  {
    "sql_id": "duckdb_20_6",
    "database_name": "duckdb_20_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT SUM(DISTINCT LENGTH(name)) s1 FROM t1; -- LENGTH",
    "target_query": "SELECT SUM(DISTINCT LENGTH(name)) AS s1 FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (id INTEGER NOT NULL PRIMARY KEY,gender CHAR(1),name VARCHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id INTEGER PRIMARY KEY, gender CHAR(1), name VARCHAR(20));"
    ]
  },
  {
    "sql_id": "duckdb_20_10",
    "database_name": "duckdb_20_10",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT (SELECT SUM(DISTINCT LENGTH(name)) FROM t1) FROM t2; -- LENGTH",
    "target_query": "SELECT (SELECT SUM(DISTINCT LENGTH(name)) FROM t1) FROM t2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 SELECT name FROM t1;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 AS SELECT name FROM t1;"
    ]
  },
  {
    "sql_id": "duckdb_21_3",
    "database_name": "duckdb_21_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT CONCAT_WS(pkCrash, strCrash) FROM t1; -- CONCAT_WS",
    "target_query": "SELECT concat_ws('', pkCrash, strCrash) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT_WS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT_WS(separator, str1, str2, ...)",
        "description": "Concatenates multiple strings with the specified separator. If any argument is NULL, it is ignored.",
        "examples": [
          "SELECT CONCAT_WS(',', 'apple', 'banana', 'cherry');",
          "SELECT CONCAT_WS('-', 'hello', 'world');",
          "SELECT CONCAT_WS(' ', 'this', NULL, 'is', 'a', 'test');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat_ws(separator, str1, str2, ...)",
        "description": "Concatenates strings using a separator, and ignores NULL values.",
        "examples": [
          "SELECT concat_ws(',', 'apple', 'banana', 'cherry');",
          "SELECT concat_ws('-', 'hello', 'world');",
          "SELECT concat_ws(' ', 'this', NULL, 'is', 'a', 'test');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (pkCrash INTEGER PRIMARY KEY,strCrash VARCHAR(255));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (pkCrash INTEGER PRIMARY KEY,strCrash VARCHAR(255));"
    ]
  },
  {
    "sql_id": "duckdb_21_10",
    "database_name": "duckdb_21_10",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select one.id, two.val, elt(two.val,'one','two') from t1 one, t2 two where two.id=one.id order by one.id; -- ELT",
    "target_query": "select one.id, two.val, ['one', 'two'][two.val] from t1 one, t2 two where two.id=one.id order by one.id;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ELT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ELT(2, 'apple', 'banana', 'cherry')",
        "description": "Returns the N-th element from the list, where N is the first argument.",
        "examples": [
          "SELECT ELT(2, 'apple', 'banana', 'cherry');  -- Returns 'banana'",
          "SELECT ELT(1, 'red', 'green', 'blue');  -- Returns 'red'",
          "SELECT ELT(3, 'dog', 'cat', 'bird');  -- Returns 'bird'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "['str1', 'str2', 'str3'][N]",
        "description": "Simulates ELT by using array literal and 1-based indexing. Returns NULL if index is out of bounds.",
        "examples": [
          "SELECT ['apple', 'banana', 'cherry'][2];  -- Returns 'banana'",
          "SELECT ['red', 'green', 'blue'][1];  -- Returns 'red'",
          "SELECT ['dog', 'cat', 'bird'][3];  -- Returns 'bird'"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (id int(10) not null unique);",
      "create table t2 (id int(10) not null primary key,val int(10) not null);"
    ],
    "target_related_schemas": [
      "create table t1 (id int not null unique);",
      "create table t2 (id int not null primary key,val int not null);"
    ]
  },
  {
    "sql_id": "duckdb_22_0",
    "database_name": "duckdb_22_0",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT LEAST(CAST('01-01-01' AS DATETIME), '01-01:02'); -- LEAST",
    "target_query": "SELECT least(CAST('2001-01-01 00:00:00' AS TIMESTAMP), CAST('2001-01-01 00:01:02' AS TIMESTAMP));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the least non-null value among the provided expressions. NULLs are skipped unless all arguments are NULL. This differs from MySQL/MariaDB which return NULL if any argument is NULL.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(DATE '2024-01-01', DATE '2023-12-31');",
          "SELECT least(NULL, 2);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_22_1",
    "database_name": "duckdb_22_1",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT LEAST(CAST('2001-12-10' AS DATE), '2001-12/11'); -- LEAST",
    "target_query": "SELECT least(CAST('2001-12-10' AS DATE), CAST('2001-12-11' AS DATE));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the least non-null value among the provided expressions. NULLs are skipped unless all arguments are NULL. This differs from MySQL/MariaDB which return NULL if any argument is NULL.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(DATE '2024-01-01', DATE '2023-12-31');",
          "SELECT least(NULL, 2);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_22_2",
    "database_name": "duckdb_22_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT LEAST(CAST('10:11:12' AS TIME), '10:11:13 '); -- LEAST",
    "target_query": "SELECT least(CAST('10:11:12' AS TIME), CAST('10:11:13' AS TIME));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the least non-null value among the provided expressions. NULLs are skipped unless all arguments are NULL. This differs from MySQL/MariaDB which return NULL if any argument is NULL.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(DATE '2024-01-01', DATE '2023-12-31');",
          "SELECT least(NULL, 2);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_23_0",
    "database_name": "duckdb_23_0",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select unix_timestamp(utc_timestamp())-unix_timestamp(current_timestamp()); -- UNIX_TIMESTAMP, UTC_TIMESTAMP, CURRENT_TIMESTAMP",
    "target_query": "SELECT EXTRACT(EPOCH FROM CURRENT_TIMESTAMP AT TIME ZONE 'UTC') - EXTRACT(EPOCH FROM CURRENT_TIMESTAMP);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP",
      "UTC_TIMESTAMP",
      "CURRENT_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      },
      {
        "expression": "UTC_TIMESTAMP()",
        "description": "Returns the current UTC date and time as a DATETIME value.",
        "examples": [
          "SELECT UTC_TIMESTAMP();",
          "SELECT YEAR(UTC_TIMESTAMP());",
          "SELECT UNIX_TIMESTAMP(UTC_TIMESTAMP());"
        ]
      },
      {
        "expression": "CURRENT_TIMESTAMP(6)",
        "description": "Returns the current date and time, with precision up to microseconds.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP(6);",
          "SELECT CURRENT_TIMESTAMP(6) = LOCALTIMESTAMP(6);",
          "SELECT CURRENT_TIMESTAMP(6) > '2025-01-01 00:00:00.000000';"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      },
      {
        "expression": "CURRENT_TIMESTAMP AT TIME ZONE 'UTC'",
        "description": "Returns the current UTC timestamp by converting the current local time to UTC.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP AT TIME ZONE 'UTC';",
          "SELECT STRFTIME(CURRENT_TIMESTAMP AT TIME ZONE 'UTC', '%Y');",
          "SELECT EPOCH(CURRENT_TIMESTAMP AT TIME ZONE 'UTC');"
        ]
      },
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "Returns the current date and time, with precision up to seconds. No microsecond precision.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "SELECT CURRENT_TIMESTAMP = LOCALTIMESTAMP;",
          "SELECT CURRENT_TIMESTAMP > '2025-01-01 00:00:00';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_23_3",
    "database_name": "duckdb_23_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "insert into t1 (i, ts) values(unix_timestamp('2003-03-01 00:00:00'),'2003-03-01 00:00:00'); -- UNIX_TIMESTAMP",
    "target_query": "INSERT INTO t1 (i, ts) VALUES(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-01 00:00:00'), '2003-03-01 00:00:00');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (i int, ts timestamp);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (i INT, ts TIMESTAMP);"
    ]
  },
  {
    "sql_id": "duckdb_23_4",
    "database_name": "duckdb_23_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "insert into t1 (i, ts) values(unix_timestamp('2003-03-30 01:59:59'),'2003-03-30 01:59:59'),(unix_timestamp('2003-03-30 02:30:00'),'2003-03-30 02:30:00'),(unix_timestamp('2003-03-30 03:00:00'),'2003-03-30 03:00:00'); -- UNIX_TIMESTAMP",
    "target_query": "INSERT INTO t1 (i, ts) VALUES(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59'), '2003-03-30 01:59:59'), (EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00'), '2003-03-30 02:30:00'), (EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00'), '2003-03-30 03:00:00');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (i int, ts timestamp);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (i INT, ts TIMESTAMP);"
    ]
  },
  {
    "sql_id": "duckdb_23_5",
    "database_name": "duckdb_23_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "insert into t1 (i, ts) values(unix_timestamp(20030330015959),20030330015959),(unix_timestamp(20030330023000),20030330023000),(unix_timestamp(20030330030000),20030330030000); -- UNIX_TIMESTAMP",
    "target_query": "INSERT INTO t1 (i, ts) VALUES(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59'), '2003-03-30 01:59:59'), (EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00'), '2003-03-30 02:30:00'), (EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00'), '2003-03-30 03:00:00');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (i int, ts timestamp);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (i INT, ts TIMESTAMP);"
    ]
  },
  {
    "sql_id": "duckdb_23_6",
    "database_name": "duckdb_23_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "insert into t1 (i, ts) values(unix_timestamp('2003-05-01 00:00:00'),'2003-05-01 00:00:00'); -- UNIX_TIMESTAMP",
    "target_query": "INSERT INTO t1 (i, ts) VALUES(EXTRACT(EPOCH FROM TIMESTAMP '2003-05-01 00:00:00'), '2003-05-01 00:00:00');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (i int, ts timestamp);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (i INT, ts TIMESTAMP);"
    ]
  },
  {
    "sql_id": "duckdb_23_7",
    "database_name": "duckdb_23_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "insert into t1 (i, ts) values(unix_timestamp('2003-10-26 01:00:00'),'2003-10-26 01:00:00'),(unix_timestamp('2003-10-26 02:00:00'),'2003-10-26 02:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'),(unix_timestamp('2003-10-26 04:00:00'),'2003-10-26 04:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'); -- UNIX_TIMESTAMP",
    "target_query": "INSERT INTO t1 (i, ts) VALUES(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 01:00:00'), '2003-10-26 01:00:00'), (EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:00:00'), '2003-10-26 02:00:00'), (EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59'), '2003-10-26 02:59:59'), (EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 04:00:00'), '2003-10-26 04:00:00'), (EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59'), '2003-10-26 02:59:59');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (i int, ts timestamp);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (i INT, ts TIMESTAMP);"
    ]
  },
  {
    "sql_id": "duckdb_23_10",
    "database_name": "duckdb_23_10",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select from_unixtime(362793609); -- FROM_UNIXTIME",
    "target_query": "SELECT TO_TIMESTAMP(362793609);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FROM_UNIXTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
        "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
          "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TO_TIMESTAMP(unix_timestamp)",
        "description": "Converts a Unix timestamp (seconds since epoch) to a TIMESTAMP value.",
        "examples": [
          "SELECT TO_TIMESTAMP(1672531200);",
          "SELECT TO_TIMESTAMP(1672531200.789);",
          "SELECT id, TO_TIMESTAMP(event_time) AS event_ts FROM events;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_23_12",
    "database_name": "duckdb_23_12",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "insert into t1 (ts) values (now()); -- NOW",
    "target_query": "INSERT INTO t1 (ts) VALUES (CURRENT_TIMESTAMP);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "DuckDB also uses CURRENT_TIMESTAMP to get the current date and time, similar to PostgreSQL and MonetDB.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (ts timestamp);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (ts TIMESTAMP);"
    ]
  },
  {
    "sql_id": "duckdb_23_15",
    "database_name": "duckdb_23_15",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 VALUES('2003-03-30 01:59:59', 'Before the gap'),('2003-03-30 02:30:00', 'Inside the gap'),('2003-03-30 03:00:00',  'After the gap'); -- UNIX_TIMESTAMP",
    "target_query": "INSERT INTO t1 VALUES('2003-03-30 01:59:59', 'Before the gap'), ('2003-03-30 02:30:00', 'Inside the gap'), ('2003-03-30 03:00:00', 'After the gap');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a TIMESTAMP, b VARCHAR(30));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a TIMESTAMP, b VARCHAR(30));"
    ]
  },
  {
    "sql_id": "duckdb_23_18",
    "database_name": "duckdb_23_18",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT UNIX_TIMESTAMP('2003-03-30 01:59:59'), 'Before the gap' AS b; -- UNIX_TIMESTAMP",
    "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59'), 'Before the gap' AS b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_23_19",
    "database_name": "duckdb_23_19",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT UNIX_TIMESTAMP('2003-03-30 02:30:00'), 'Inside the gap' AS b; -- UNIX_TIMESTAMP",
    "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00'), 'Inside the gap' AS b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_23_20",
    "database_name": "duckdb_23_20",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT UNIX_TIMESTAMP('2003-03-30 03:00:00'), 'After the gap' AS b; -- UNIX_TIMESTAMP",
    "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00'), 'After the gap' AS b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_23_21",
    "database_name": "duckdb_23_21",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT FROM_UNIXTIME(0); -- FROM_UNIXTIME",
    "target_query": "SELECT TO_TIMESTAMP(0);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FROM_UNIXTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
        "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
          "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TO_TIMESTAMP(unix_timestamp)",
        "description": "Converts a Unix timestamp (seconds since epoch) to a TIMESTAMP value.",
        "examples": [
          "SELECT TO_TIMESTAMP(1672531200);",
          "SELECT TO_TIMESTAMP(1672531200.789);",
          "SELECT id, TO_TIMESTAMP(event_time) AS event_ts FROM events;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_23_22",
    "database_name": "duckdb_23_22",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT UNIX_TIMESTAMP(\"1969-12-31 15:59:59\"); -- UNIX_TIMESTAMP",
    "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1969-12-31 15:59:59');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_23_23",
    "database_name": "duckdb_23_23",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT UNIX_TIMESTAMP(\"1969-12-31 16:00:00\"); -- UNIX_TIMESTAMP",
    "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1969-12-31 16:00:00');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_23_24",
    "database_name": "duckdb_23_24",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT UNIX_TIMESTAMP(\"1969-12-31 16:00:01\"); -- UNIX_TIMESTAMP",
    "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1969-12-31 16:00:01');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_23_25",
    "database_name": "duckdb_23_25",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT UNIX_TIMESTAMP(\"1970-01-01 00:00:01\"); -- UNIX_TIMESTAMP",
    "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1970-01-01 00:00:01');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_23_26",
    "database_name": "duckdb_23_26",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT UNIX_TIMESTAMP(\"2022-01-01 16:00:01\"); -- UNIX_TIMESTAMP",
    "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2022-01-01 16:00:01');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_24_3",
    "database_name": "duckdb_24_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select hex(a) from t1; -- HEX",
    "target_query": "SELECT HEX(CAST(a AS VARCHAR)) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a bit(64));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a BIT);"
    ]
  },
  {
    "sql_id": "duckdb_24_7",
    "database_name": "duckdb_24_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select hex(a) from t1; -- HEX",
    "target_query": "SELECT HEX(CAST(a AS VARCHAR)) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a bit);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a BIT);"
    ]
  },
  {
    "sql_id": "duckdb_24_11",
    "database_name": "duckdb_24_11",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select hex(min(a)) from t1; -- HEX, MIN",
    "target_query": "SELECT HEX(CAST(min(a) AS VARCHAR)) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "MIN"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a bit(7), b bit(9));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a BIT, b BIT);"
    ]
  },
  {
    "sql_id": "duckdb_24_12",
    "database_name": "duckdb_24_12",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select hex(min(b)) from t1; -- HEX, MIN",
    "target_query": "SELECT HEX(CAST(min(b) AS VARCHAR)) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "MIN"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a bit(7), b bit(9));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a BIT, b BIT);"
    ]
  },
  {
    "sql_id": "duckdb_24_13",
    "database_name": "duckdb_24_13",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select hex(min(a)), hex(max(a)), hex(min(b)), hex(max(b)) from t1; -- HEX, MIN, MAX",
    "target_query": "SELECT HEX(CAST(min(a) AS VARCHAR)), HEX(CAST(max(a) AS VARCHAR)), HEX(CAST(min(b) AS VARCHAR)), HEX(CAST(max(b) AS VARCHAR)) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "MIN",
      "MAX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      },
      {
        "expression": "MAX(expr)",
        "description": "Returns the maximum value of the expression in an aggregation context.",
        "examples": [
          "SELECT MAX(10), MAX(5), MAX(20);",
          "SELECT MAX('apple'), MAX('banana'), MAX('pear');",
          "SELECT MAX(ABS(-5)), MAX(ABS(3));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      },
      {
        "expression": "MAX(expr)",
        "description": "Returns the maximum value among all input values.",
        "examples": [
          "SELECT MAX(1), MAX(5), MAX(3);",
          "SELECT MAX('orange'), MAX('apple'), MAX('banana');",
          "SELECT MAX(length('abc')), MAX(length('defg'));"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a bit(7), b bit(9));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a BIT, b BIT);"
    ]
  },
  {
    "sql_id": "duckdb_24_17",
    "database_name": "duckdb_24_17",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select hex(min(b)) from t1 where a = 4; -- HEX, MIN",
    "target_query": "SELECT HEX(CAST(min(b) AS VARCHAR)) FROM t1 WHERE a = 4;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "MIN"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a int not null, b bit, c bit(9));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT NOT NULL, b BIT, c BIT);"
    ]
  },
  {
    "sql_id": "duckdb_24_18",
    "database_name": "duckdb_24_18",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select hex(min(c)) from t1 where a = 4 and b = 0; -- HEX, MIN",
    "target_query": "SELECT HEX(CAST(min(c) AS VARCHAR)) FROM t1 WHERE a = 4 AND b = '0';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "MIN"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a int not null, b bit, c bit(9));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT NOT NULL, b BIT, c BIT);"
    ]
  },
  {
    "sql_id": "duckdb_24_19",
    "database_name": "duckdb_24_19",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select hex(max(b)) from t1; -- HEX",
    "target_query": "SELECT HEX(CAST(max(b) AS VARCHAR)) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a int not null, b bit, c bit(9));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT NOT NULL, b BIT, c BIT);"
    ]
  },
  {
    "sql_id": "duckdb_24_23",
    "database_name": "duckdb_24_23",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "update t1 set b= concat(a); -- CONCAT",
    "target_query": "UPDATE t1 SET b = a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1(a bit(2), b bit(2));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a BIT, b BIT);"
    ]
  },
  {
    "sql_id": "duckdb_24_27",
    "database_name": "duckdb_24_27",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT HEX(GROUP_CONCAT(DISTINCT b)) FROM t1 GROUP BY a; -- HEX, GROUP_CONCAT",
    "target_query": "SELECT HEX(string_agg(DISTINCT CAST(b AS VARCHAR), ',')) FROM t1 GROUP BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "GROUP_CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
        "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
        "description": "The GROUP_CONCAT function in DuckDB concatenates values from multiple rows into a single string, separated by a specified delimiter.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a INT, b BIT(2));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT, b BIT);"
    ]
  },
  {
    "sql_id": "duckdb_25_3",
    "database_name": "duckdb_25_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT HEX(b), i2 FROM t1 WHERE (i2>=100 AND i2<201) AND b=TRUE; -- HEX",
    "target_query": "SELECT HEX(CAST(b AS VARCHAR)), i2 FROM t1 WHERE (i2 >= 100 AND i2 < 201) AND b = '1';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (b BIT NOT NULL, i2 INTEGER NOT NULL, s VARCHAR(255) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (b BIT NOT NULL, i2 INTEGER NOT NULL, s VARCHAR(255) NOT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_25_7",
    "database_name": "duckdb_25_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT HEX(b1), i2 FROM t2 WHERE (i2>=100 AND i2<201) AND b1=TRUE; -- HEX",
    "target_query": "SELECT HEX(CAST(b1 AS VARCHAR)), i2 FROM t2 WHERE (i2 >= 100 AND i2 < 201) AND b1 = '1';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 (b1 BIT NOT NULL, b2 BIT NOT NULL, i2 INTEGER NOT NULL,s VARCHAR(255) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (b1 BIT NOT NULL, b2 BIT NOT NULL, i2 INTEGER NOT NULL, s VARCHAR(255) NOT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_25_8",
    "database_name": "duckdb_25_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT HEX(b2), i2 FROM t2 WHERE (i2>=100 AND i2<201) AND b2=FALSE; -- HEX",
    "target_query": "SELECT HEX(CAST(b2 AS VARCHAR)), i2 FROM t2 WHERE (i2 >= 100 AND i2 < 201) AND b2 = '0';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 (b1 BIT NOT NULL, b2 BIT NOT NULL, i2 INTEGER NOT NULL,s VARCHAR(255) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (b1 BIT NOT NULL, b2 BIT NOT NULL, i2 INTEGER NOT NULL, s VARCHAR(255) NOT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_25_13",
    "database_name": "duckdb_25_13",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT HEX(GROUP_CONCAT(DISTINCT b)) FROM t1 GROUP BY a; -- HEX, GROUP_CONCAT",
    "target_query": "SELECT HEX(string_agg(DISTINCT b, ',')) FROM t1 GROUP BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "GROUP_CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
        "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
        "description": "The GROUP_CONCAT function in DuckDB concatenates values from multiple rows into a single string, separated by a specified delimiter.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a INT, b BIT(2));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT, b VARCHAR(2));"
    ]
  },
  {
    "sql_id": "duckdb_25_15",
    "database_name": "duckdb_25_15",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT HEX(t2.b) FROM t2; -- HEX",
    "target_query": "SELECT HEX(b) FROM t2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a INT, b BIT(2));",
      "CREATE TABLE t2 AS SELECT DISTINCT b FROM t1;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT, b VARCHAR(2));",
      "CREATE TABLE t2 AS SELECT DISTINCT b FROM t1;"
    ]
  },
  {
    "sql_id": "duckdb_25_16",
    "database_name": "duckdb_25_16",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT a, HEX(b) FROM t1 ORDER BY b; -- HEX",
    "target_query": "SELECT a, HEX(b) FROM t1 ORDER BY b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a INT, b BIT(2));",
      "CREATE TABLE t2 AS SELECT DISTINCT b FROM t1;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT, b VARCHAR(2));",
      "CREATE TABLE t2 AS SELECT DISTINCT b FROM t1;"
    ]
  },
  {
    "sql_id": "duckdb_26_3",
    "database_name": "duckdb_26_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select hex(a) from t1 order by a; -- HEX",
    "target_query": "SELECT HEX(a) FROM t1 ORDER BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE table t1 (a blob);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a BLOB);"
    ]
  },
  {
    "sql_id": "duckdb_26_4",
    "database_name": "duckdb_26_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select hex(concat(a,'\\\\0')) as b from t1 order by concat(a,'\\\\0'); -- HEX, CONCAT",
    "target_query": "SELECT HEX(CONCAT(a, X'00')) AS b FROM t1 ORDER BY CONCAT(a, X'00');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE table t1 (a blob);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a BLOB);"
    ]
  },
  {
    "sql_id": "duckdb_26_6",
    "database_name": "duckdb_26_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select hex(a) from t1 order by a; -- HEX",
    "target_query": "SELECT HEX(a) FROM t1 ORDER BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE table t1 (a blob);",
      "alter table t1 modify a varbinary(5);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a BLOB);",
      "ALTER TABLE t1 ALTER COLUMN a SET DATA TYPE BLOB;"
    ]
  },
  {
    "sql_id": "duckdb_26_10",
    "database_name": "duckdb_26_10",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t (c) VALUES (REPEAT('3',65535)); -- REPEAT",
    "target_query": "INSERT INTO t (c) VALUES (REPEAT('3',65535));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t (c TEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t (c TEXT);"
    ]
  },
  {
    "sql_id": "duckdb_26_11",
    "database_name": "duckdb_26_11",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT LENGTH(c), CHAR_LENGTH(c) FROM t; -- LENGTH, CHAR_LENGTH",
    "target_query": "SELECT LENGTH(c), LENGTH(CAST(c AS VARCHAR)) AS lengthUTF8 FROM t;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH",
      "CHAR_LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      },
      {
        "expression": "CHAR_LENGTH(expr)",
        "description": "Returns the number of characters in the string, not bytes.",
        "examples": [
          "SELECT CHAR_LENGTH('abc');",
          "SELECT CHAR_LENGTH('你好');",
          "SELECT CHAR_LENGTH('a你b好c');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      },
      {
        "expression": "length(expr)",
        "description": "Returns the number of characters in a string.",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length('a你b好c');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t (c TEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t (c TEXT);"
    ]
  },
  {
    "sql_id": "duckdb_26_16",
    "database_name": "duckdb_26_16",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT LENGTH(c) FROM t2; -- LENGTH",
    "target_query": "SELECT LENGTH(c) FROM t2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2(id INT NOT NULL, c TEXT NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2(id INT NOT NULL, c TEXT NOT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_27_0",
    "database_name": "duckdb_27_0",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select least(-1.1111111111111111111111111,- group_concat(1.7976931348623157E+308)) as foo; -- LEAST, GROUP_CONCAT",
    "target_query": "SELECT LEAST(-1.1111111111111111111111111, -CAST((SELECT STRING_AGG(CAST(1.7976931348623157E+308 AS TEXT), ',') FROM (VALUES (1)) AS dummy) AS DOUBLE PRECISION)) AS foo;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST",
      "GROUP_CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      },
      {
        "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
        "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the least non-null value among the provided expressions. NULLs are skipped unless all arguments are NULL. This differs from MySQL/MariaDB which return NULL if any argument is NULL.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(DATE '2024-01-01', DATE '2023-12-31');",
          "SELECT least(NULL, 2);"
        ]
      },
      {
        "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
        "description": "The GROUP_CONCAT function in DuckDB concatenates values from multiple rows into a single string, separated by a specified delimiter.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_28_7",
    "database_name": "duckdb_28_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "insert into t1 values (now()); -- NOW",
    "target_query": "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "DuckDB also uses CURRENT_TIMESTAMP to get the current date and time, similar to PostgreSQL and MonetDB.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a timestamp NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a TIMESTAMP NOT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_28_8",
    "database_name": "duckdb_28_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select date_format(a,\"%Y %y\"),year(a),year(now()) from t1; -- DATE_FORMAT, YEAR, NOW",
    "target_query": "SELECT STRFTIME(a, '%Y %y'), EXTRACT(YEAR FROM a), EXTRACT(YEAR FROM CURRENT_TIMESTAMP) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT",
      "YEAR",
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      },
      {
        "expression": "YEAR(date)",
        "description": "Extracts the year from a date or datetime and returns it as an integer.",
        "examples": [
          "SELECT YEAR('2023-04-10');",
          "SELECT YEAR(NOW());",
          "SELECT YEAR('2022-03-15');"
        ]
      },
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "STRFTIME(date_expr, format_str)",
        "description": "Formats a date/time value using SQLite-compatible strftime format specifiers.",
        "examples": [
          "SELECT STRFTIME('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT STRFTIME(CURRENT_TIMESTAMP, '%Y-%m-%d %H:%M:%S');",
          "SELECT STRFTIME('2023-01-15 12:00:00', '%d-%m-%Y');"
        ]
      },
      {
        "expression": "EXTRACT(YEAR FROM date)",
        "description": "Extracts the year from a date or datetime and returns it as an integer.",
        "examples": [
          "SELECT EXTRACT(YEAR FROM DATE '2023-04-10');",
          "SELECT EXTRACT(YEAR FROM CURRENT_DATE);",
          "SELECT EXTRACT(YEAR FROM DATE '2022-03-15');"
        ]
      },
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "DuckDB also uses CURRENT_TIMESTAMP to get the current date and time, similar to PostgreSQL and MonetDB.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a timestamp NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a TIMESTAMP NOT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_28_10",
    "database_name": "duckdb_28_10",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT TIMESTAMP('2000-01-27','23:13:41') - TIMESTAMP('2003-05-16','23:53:29'); -- TIMESTAMP",
    "target_query": "SELECT TIMESTAMP '2000-01-27 23:13:41' - TIMESTAMP '2003-05-16 23:53:29';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
        "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
        "examples": [
          "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TIMESTAMP '2023-06-15 10:30:45'",
        "description": "DuckDB supports the TIMESTAMP function to handle date-time strings as TIMESTAMP values.",
        "examples": [
          "SELECT TIMESTAMP '2023-06-15 10:30:45';",
          "SELECT TIMESTAMP '2023-06-15 10:30:45+02:00';",
          "SELECT TIMESTAMP '2023-06-15 10:30:45' > TIMESTAMP '2023-06-14 10:30:45';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_30_5",
    "database_name": "duckdb_30_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select length(v),length(c),length(e),length(t) from t1; -- LENGTH",
    "target_query": "SELECT LENGTH(v), LENGTH(c), LENGTH(e), LENGTH(t) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (v varchar(30), c char(3), e char(3), t text);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (v VARCHAR(30), c CHAR(3), e CHAR(3), t TEXT);"
    ]
  },
  {
    "sql_id": "duckdb_30_8",
    "database_name": "duckdb_30_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 VALUES(SUBSTR(f1, 1, 3)); -- SUBSTR",
    "target_query": "INSERT INTO t1 VALUES ('tes');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "SUBSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
        "description": "The substr(str,pos[,len]) function returns a substring from string str starting at position pos.\nIf len is specified, returns a substring len characters long starting at position pos.\nIf pos is positive, the position is counted from the start of the string.\nIf pos is negative, the position is counted from the end of the string.\nlen must be positive. If len is omitted, returns all characters to the end of the string.\nReturns NULL if any argument is NULL.",
        "examples": [
          "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
          "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "substring(X,Y,Z)substring(X,Y)substring(X,Y,Z)substring(X,Y)",
        "description": "The SUBSTR function in DuckDB extracts a substring from a given string, starting from a specified position and optionally extending for a specified length.",
        "examples": [
          "SELECT substr('Hello World', 1, 5) AS substring; -- return Hello",
          "SELECT substr('Hello World', -5, 3) AS substring -- return Wor"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(f1 VARCHAR(100) DEFAULT 'test');"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(f1 VARCHAR(100) DEFAULT 'test');"
    ]
  },
  {
    "sql_id": "duckdb_30_12",
    "database_name": "duckdb_30_12",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT a,(a DIV 2) FROM t1 ORDER BY a; -- DIV",
    "target_query": "SELECT a, FLOOR(CAST(a AS INTEGER) / 2) FROM t1 ORDER BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DIV"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "a DIV b",
        "description": "Performs integer division between two numbers and returns the floor of the quotient.",
        "examples": [
          "SELECT 10 DIV 3;",
          "SELECT 5.8 DIV 2;",
          "SELECT 9 DIV 4 + 1;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "FLOOR(a / b)",
        "description": "Returns the floor of the result of dividing two numeric values.",
        "examples": [
          "SELECT FLOOR(10 / 3);",
          "SELECT FLOOR(5.8 / 2);",
          "SELECT FLOOR(9 / 4) + 1;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a CHAR(2));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a CHAR(2));"
    ]
  },
  {
    "sql_id": "duckdb_31_2",
    "database_name": "duckdb_31_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "insert into t1 values (now()); -- NOW",
    "target_query": "INSERT INTO t1 VALUES (EXTRACT(YEAR FROM CURRENT_TIMESTAMP));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "DuckDB also uses CURRENT_TIMESTAMP to get the current date and time, similar to PostgreSQL and MonetDB.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (y year);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (y INTEGER);"
    ]
  },
  {
    "sql_id": "duckdb_31_3",
    "database_name": "duckdb_31_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select if(y = now(), 1, 0) from t1; -- IF, NOW",
    "target_query": "SELECT CASE WHEN y = EXTRACT(YEAR FROM CURRENT_TIMESTAMP) THEN 1 ELSE 0 END FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF",
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      },
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      },
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "DuckDB also uses CURRENT_TIMESTAMP to get the current date and time, similar to PostgreSQL and MonetDB.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (y year);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (y INTEGER);"
    ]
  },
  {
    "sql_id": "duckdb_31_9",
    "database_name": "duckdb_31_9",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT * FROM t4 WHERE yyyy = NOW(); -- NOW",
    "target_query": "SELECT * FROM t4 WHERE yyyy = EXTRACT(YEAR FROM CURRENT_TIMESTAMP);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "DuckDB also uses CURRENT_TIMESTAMP to get the current date and time, similar to PostgreSQL and MonetDB.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t4(yyyy YEAR, c4 CHAR(4));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t4(yyyy INTEGER, c4 CHAR(4));"
    ]
  },
  {
    "sql_id": "duckdb_31_19",
    "database_name": "duckdb_31_19",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT TIMESTAMPDIFF(QUARTER, LEAST(y1, y2), dbl)FROM t1; -- TIMESTAMPDIFF, LEAST",
    "target_query": "SELECT EXTRACT(YEAR FROM d) * 4 + EXTRACT(QUARTER FROM d) - (LEAST(y1, y2) * 4) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMPDIFF",
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMPDIFF(unit, datetime1, datetime2)",
        "description": "Returns the difference between two datetime values in the specified unit.",
        "examples": [
          "SELECT TIMESTAMPDIFF(YEAR, '2001-01-01', '2005-01-01');  -- 4",
          "SELECT TIMESTAMPDIFF(MONTH, '2020-01-01', '2020-03-01');  -- 2",
          "SELECT TIMESTAMPDIFF(DAY, '2020-01-01', '2020-01-31');    -- 30"
        ]
      },
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "DATEDIFF(unit, datetime1, datetime2)",
        "description": "Computes the difference between two dates in the specified unit. The result is positive if the first date is earlier than the second date.",
        "examples": [
          "SELECT DATEDIFF('year', DATE '2001-01-01', DATE '2005-01-01');  -- 4",
          "SELECT DATEDIFF('month', DATE '2020-01-01', DATE '2020-03-01');  -- 2",
          "SELECT DATEDIFF('day', DATE '2020-01-01', DATE '2020-01-31');    -- 30"
        ]
      },
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the least non-null value among the provided expressions. NULLs are skipped unless all arguments are NULL. This differs from MySQL/MariaDB which return NULL if any argument is NULL.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(DATE '2024-01-01', DATE '2023-12-31');",
          "SELECT least(NULL, 2);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (d DATE DEFAULT NULL,y1 YEAR DEFAULT NULL,y2 YEAR DEFAULT NULL,dbl DOUBLE DEFAULT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (d DATE DEFAULT NULL, y1 INTEGER DEFAULT NULL, y2 INTEGER DEFAULT NULL, dbl DOUBLE PRECISION DEFAULT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_31_20",
    "database_name": "duckdb_31_20",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT HOUR(GREATEST(y1, y2))FROM t1; -- HOUR, GREATEST",
    "target_query": "SELECT GREATEST(y1, y2) AS max_year FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HOUR",
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HOUR(expr)",
        "description": "Extracts the hour (0–23) from a time or datetime expression.",
        "examples": [
          "SELECT HOUR('18:45:30');",
          "SELECT HOUR('2023-10-01 08:15:00');",
          "SELECT HOUR(CURRENT_TIMESTAMP);"
        ]
      },
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(HOUR FROM expr)",
        "description": "Extracts the hour from a timestamp or time value.",
        "examples": [
          "SELECT EXTRACT(HOUR FROM TIME '18:45:30');",
          "SELECT EXTRACT(HOUR FROM TIMESTAMP '2023-10-01 08:15:00');",
          "SELECT EXTRACT(HOUR FROM CURRENT_TIMESTAMP);"
        ]
      },
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (d DATE DEFAULT NULL,y1 YEAR DEFAULT NULL,y2 YEAR DEFAULT NULL,dbl DOUBLE DEFAULT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (d DATE DEFAULT NULL, y1 INTEGER DEFAULT NULL, y2 INTEGER DEFAULT NULL, dbl DOUBLE PRECISION DEFAULT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_32_12",
    "database_name": "duckdb_32_12",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT y, CONCAT('\"', c, '\"') FROM t1; -- CONCAT",
    "target_query": "SELECT y, CONCAT('\"', c, '\"') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (y YEAR NOT NULL DEFAULT 0,i INT NOT NULL DEFAULT 0,c VARCHAR(20) NOT NULL DEFAULT '');"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (y INT NOT NULL DEFAULT 0, i INT NOT NULL DEFAULT 0, c VARCHAR(20) NOT NULL DEFAULT '');"
    ]
  },
  {
    "sql_id": "duckdb_33_3",
    "database_name": "duckdb_33_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select hex(b) from t1 order by pk1; -- HEX",
    "target_query": "SELECT HEX(b) FROM t1 ORDER BY pk1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (pk1 int not null auto_increment primary key,b bit(64));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (pk1 INTEGER PRIMARY KEY, b BLOB);"
    ]
  },
  {
    "sql_id": "duckdb_33_7",
    "database_name": "duckdb_33_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select hex(b) from t1 order by pk1; -- HEX",
    "target_query": "SELECT HEX(b) FROM t1 ORDER BY pk1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (pk1 int not null auto_increment primary key,b bit(9));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (pk1 INTEGER PRIMARY KEY, b blob);"
    ]
  },
  {
    "sql_id": "duckdb_34_8",
    "database_name": "duckdb_34_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select concat(\"*\",name, \"*\") from t1 order by 1; -- CONCAT",
    "target_query": "SELECT CONCAT('*', name, '*') FROM t1 ORDER BY 1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t2 (name char(20) not null, primary key (name));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (name CHAR(20) NOT NULL, PRIMARY KEY (name));"
    ]
  },
  {
    "sql_id": "duckdb_34_9",
    "database_name": "duckdb_34_9",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select min(name),min(concat(\"*\",name,\"*\")),max(name),max(concat(\"*\",name,\"*\")) from t1; -- CONCAT",
    "target_query": "SELECT MIN(name), MIN(CONCAT('*', name, '*')), MAX(name), MAX(CONCAT('*', name, '*')) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t2 (name char(20) not null, primary key (name));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (name CHAR(20) NOT NULL, PRIMARY KEY (name));"
    ]
  },
  {
    "sql_id": "duckdb_34_14",
    "database_name": "duckdb_34_14",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select concat(\"-\",a,\"-\",b,\"-\") from t1 where a=\"hello\"; -- CONCAT",
    "target_query": "SELECT CONCAT('-', a, '-', b, '-') FROM t1 WHERE a = 'hello ';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a char(10) not null, b char(10) not null);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a CHAR(10) NOT NULL, b CHAR(10) NOT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_34_16",
    "database_name": "duckdb_34_16",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select concat(\"-\",a,\"-\",b,\"-\") from t1 where a=\"hello\"; -- CONCAT",
    "target_query": "SELECT CONCAT('-', a, '-', b, '-') FROM t1 WHERE a = 'hello ';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a char(10) not null, b char(10) not null);",
      "alter table t1 modify b tinytext;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a CHAR(10) NOT NULL, b CHAR(10) NOT NULL);",
      "ALTER TABLE t1 ALTER COLUMN b TYPE TEXT;"
    ]
  },
  {
    "sql_id": "duckdb_34_20",
    "database_name": "duckdb_34_20",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select hex(col1) from t1; -- HEX",
    "target_query": "SELECT HEX(col1) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (col1 binary(4));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (col1 BINARY);"
    ]
  },
  {
    "sql_id": "duckdb_34_22",
    "database_name": "duckdb_34_22",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select hex(col1) from t1; -- HEX",
    "target_query": "SELECT HEX(col1) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (col1 binary(4));",
      "alter table t1 modify col1 binary(10);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (col1 BINARY);",
      "ALTER TABLE t1 ALTER COLUMN col1 TYPE BINARY;"
    ]
  },
  {
    "sql_id": "duckdb_34_24",
    "database_name": "duckdb_34_24",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select hex(col1) from t1; -- HEX",
    "target_query": "SELECT HEX(col1) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (col1 binary(4));",
      "alter table t1 modify col1 binary(10);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (col1 BINARY);",
      "ALTER TABLE t1 ALTER COLUMN col1 TYPE BINARY;"
    ]
  },
  {
    "sql_id": "duckdb_35_2",
    "database_name": "duckdb_35_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029087575'); -- UNHEX",
    "target_query": "INSERT INTO t1 (a) VALUES (FROM_HEX('1F9480179366F2BF567E1C4B964C1EF029087575'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNHEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNHEX(str)",
        "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT HEX(UNHEX('4D7953514C'));",
          "SELECT UNHEX('48656C6C6F');",
          "SELECT UNHEX(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "FROM_HEX(str)",
        "description": "Converts a hexadecimal string into a BLOB value. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT TO_HEX(FROM_HEX('4D7953514C'));",
          "SELECT FROM_HEX('48656C6C6F');",
          "SELECT FROM_HEX(NULL);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a binary(20) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a BLOB NOT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_35_3",
    "database_name": "duckdb_35_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029082020'); -- UNHEX",
    "target_query": "INSERT INTO t1 (a) VALUES (FROM_HEX('1F9480179366F2BF567E1C4B964C1EF029082020'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNHEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNHEX(str)",
        "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT HEX(UNHEX('4D7953514C'));",
          "SELECT UNHEX('48656C6C6F');",
          "SELECT UNHEX(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "FROM_HEX(str)",
        "description": "Converts a hexadecimal string into a BLOB value. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT TO_HEX(FROM_HEX('4D7953514C'));",
          "SELECT FROM_HEX('48656C6C6F');",
          "SELECT FROM_HEX(NULL);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a binary(20) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a BLOB NOT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_35_4",
    "database_name": "duckdb_35_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029080707'); -- UNHEX",
    "target_query": "INSERT INTO t1 (a) VALUES (FROM_HEX('1F9480179366F2BF567E1C4B964C1EF029080707'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNHEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNHEX(str)",
        "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT HEX(UNHEX('4D7953514C'));",
          "SELECT UNHEX('48656C6C6F');",
          "SELECT UNHEX(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "FROM_HEX(str)",
        "description": "Converts a hexadecimal string into a BLOB value. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT TO_HEX(FROM_HEX('4D7953514C'));",
          "SELECT FROM_HEX('48656C6C6F');",
          "SELECT FROM_HEX(NULL);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a binary(20) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a BLOB NOT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_35_5",
    "database_name": "duckdb_35_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT hex(a) FROM t1 order by a; -- HEX",
    "target_query": "SELECT HEX(a) FROM t1 ORDER BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a binary(20) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a BLOB NOT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_35_6",
    "database_name": "duckdb_35_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "EXPLAIN SELECT hex(a) FROM t1 order by a; -- HEX",
    "target_query": "EXPLAIN SELECT hex(a) FROM t1 order by a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a binary(20) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a BLOB NOT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_35_7",
    "database_name": "duckdb_35_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT hex(a) from t1 WHERE a=unhex('1F9480179366F2BF567E1C4B964C1EF029082020'); -- HEX, UNHEX",
    "target_query": "SELECT HEX(a) FROM t1 WHERE a = FROM_HEX('1F9480179366F2BF567E1C4B964C1EF029082020');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "UNHEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "UNHEX(str)",
        "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT HEX(UNHEX('4D7953514C'));",
          "SELECT UNHEX('48656C6C6F');",
          "SELECT UNHEX(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "FROM_HEX(str)",
        "description": "Converts a hexadecimal string into a BLOB value. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT TO_HEX(FROM_HEX('4D7953514C'));",
          "SELECT FROM_HEX('48656C6C6F');",
          "SELECT FROM_HEX(NULL);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a binary(20) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a BLOB NOT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_35_8",
    "database_name": "duckdb_35_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT hex(a) from t1 WHERE a=unhex('1F9480179366F2BF567E1C4B964C1EF02908'); -- HEX, UNHEX",
    "target_query": "SELECT HEX(a) FROM t1 WHERE a = FROM_HEX('1F9480179366F2BF567E1C4B964C1EF02908');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "UNHEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "UNHEX(str)",
        "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT HEX(UNHEX('4D7953514C'));",
          "SELECT UNHEX('48656C6C6F');",
          "SELECT UNHEX(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "FROM_HEX(str)",
        "description": "Converts a hexadecimal string into a BLOB value. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT TO_HEX(FROM_HEX('4D7953514C'));",
          "SELECT FROM_HEX('48656C6C6F');",
          "SELECT FROM_HEX(NULL);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a binary(20) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a BLOB NOT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_36_0",
    "database_name": "duckdb_36_0",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT IF(NULL AND 1, 1, 2), IF(1 AND NULL, 1, 2); -- IF",
    "target_query": "SELECT CASE WHEN NULL AND 1 THEN 1 ELSE 2 END, CASE WHEN 1 AND NULL THEN 1 ELSE 2 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_36_4",
    "database_name": "duckdb_36_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT * FROM t1 WHERE IF(a AND 1, 0, 1); -- IF",
    "target_query": "SELECT * FROM t1 WHERE CASE WHEN a AND 1 THEN 0 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT);"
    ]
  },
  {
    "sql_id": "duckdb_36_5",
    "database_name": "duckdb_36_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT * FROM t1 WHERE IF(1 AND a, 0, 1); -- IF",
    "target_query": "SELECT * FROM t1 WHERE CASE WHEN 1 AND a THEN 0 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT);"
    ]
  },
  {
    "sql_id": "duckdb_36_9",
    "database_name": "duckdb_36_9",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select ifnull(A, 'N') as A, ifnull(B, 'N') as B, ifnull(not A, 'N') as nA, ifnull(not B, 'N') as nB, ifnull(A and B, 'N') as AB, ifnull(not (A and B), 'N') as `n(AB)`, ifnull((not A or not B), 'N') as nAonB, ifnull(A or B, 'N') as AoB, ifnull(not(A or B), 'N') as `n(AoB)`, ifnull(not A and not B, 'N') as nAnB from t1; -- IFNULL",
    "target_query": "SELECT COALESCE(A=1, 'N') AS A, COALESCE(B=1, 'N') AS B, COALESCE(CASE WHEN A IS NOT NULL THEN NOT (A::BOOLEAN) ELSE 'N' END, 'N') AS nA, COALESCE(CASE WHEN B IS NOT NULL THEN NOT (B::BOOLEAN) ELSE 'N' END, 'N') AS nB, COALESCE(CASE WHEN A AND B THEN 'Y' ELSE 'N' END, 'N') AS AB, COALESCE(CASE WHEN NOT (A AND B) THEN 'Y' ELSE 'N' END, 'N') AS \"n(AB)\", COALESCE(CASE WHEN (NOT A) OR (NOT B) THEN 'Y' ELSE 'N' END, 'N') AS nAonB, COALESCE(CASE WHEN A OR B THEN 'Y' ELSE 'N' END, 'N') AS ABor, COALESCE(CASE WHEN NOT (A OR B) THEN 'Y' ELSE 'N' END, 'N') AS \"n(ABor)\" FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2)",
        "description": "DuckDB also uses COALESCE to return the first non-NULL argument, which is functionally the same as IFNULL in MySQL.",
        "examples": [
          "SELECT COALESCE(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a int, b int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT, b INT);"
    ]
  },
  {
    "sql_id": "duckdb_36_10",
    "database_name": "duckdb_36_10",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select ifnull(A=1, 'N') as A, ifnull(B=1, 'N') as B, ifnull(not (A=1), 'N') as nA, ifnull(not (B=1), 'N') as nB, ifnull((A=1) and (B=1), 'N') as AB, ifnull(not ((A=1) and (B=1)), 'N') as `n(AB)`, ifnull((not (A=1) or not (B=1)), 'N') as nAonB, ifnull((A=1) or (B=1), 'N') as AoB, ifnull(not((A=1) or (B=1)), 'N') as `n(AoB)`, ifnull(not (A=1) and not (B=1), 'N') as nAnB from t1; -- IFNULL",
    "target_query": "SELECT COALESCE(A=1, 'N') AS A, COALESCE(B=1, 'N') AS B, COALESCE(NOT (A=1), 'N') AS nA, COALESCE(NOT (B=1), 'N') AS nB, COALESCE((A=1) AND (B=1), 'N') AS AB, COALESCE(NOT ((A=1) AND (B=1)), 'N') AS \"n(AB)\", COALESCE((NOT (A=1) OR NOT (B=1)), 'N') AS nAonB, COALESCE((A=1) OR (B=1), 'N') AS ABor, COALESCE(NOT ((A=1) OR (B=1)), 'N') AS \"n(ABor)\" FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2)",
        "description": "DuckDB also uses COALESCE to return the first non-NULL argument, which is functionally the same as IFNULL in MySQL.",
        "examples": [
          "SELECT COALESCE(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a int, b int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT, b INT);"
    ]
  },
  {
    "sql_id": "duckdb_37_0",
    "database_name": "duckdb_37_0",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select CONVERT(\"2004-01-22 21:45:33\",DATE); -- CONVERT",
    "target_query": "SELECT CAST('2004-01-22 21:45:33' AS DATE);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONVERT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONVERT(expression USING charset)",
        "description": "Converts data types or changes the character set.",
        "examples": [
          "SELECT CONVERT('Hello World' USING utf8);",
          "SELECT CONVERT(1234, CHAR);",
          "SELECT CONVERT(column_name USING latin1) FROM my_table;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CAST(expression AS target_type)",
        "description": "DuckDB uses CAST for type conversion. No direct equivalent for CONVERT TO CHARACTER SET.",
        "examples": [
          "SELECT CAST('2021-12-31' AS DATE);",
          "SELECT CAST(1234 AS VARCHAR);",
          "SELECT CAST(column_name AS VARCHAR) FROM my_table;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_37_1",
    "database_name": "duckdb_37_1",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select timediff(cast('2004-12-30 12:00:00' as time), '12:00:00'); -- TIMEDIFF",
    "target_query": "SELECT TIMESTAMP '2004-12-30 12:00:00' - TIMESTAMP '2004-12-30 12:00:00';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00'",
        "description": "DuckDB supports direct subtraction between timestamps to calculate the difference, returning the result as an interval.",
        "examples": [
          "SELECT TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00';",
          "SELECT CURRENT_TIMESTAMP - TIMESTAMP '2023-06-15 10:00:00';",
          "SELECT TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_37_2",
    "database_name": "duckdb_37_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select timediff(cast('1 12:00:00' as time), '12:00:00'); -- TIMEDIFF",
    "target_query": "SELECT TIMESTAMP '2025-01-01 12:00:00' - TIMESTAMP '2025-01-01 00:12:00';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00'",
        "description": "DuckDB supports direct subtraction between timestamps to calculate the difference, returning the result as an interval.",
        "examples": [
          "SELECT TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00';",
          "SELECT CURRENT_TIMESTAMP - TIMESTAMP '2023-06-15 10:00:00';",
          "SELECT TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_37_3",
    "database_name": "duckdb_37_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select cast(concat('12345','6789') as unsigned); -- CONCAT",
    "target_query": "SELECT CAST(CONCAT('12345', '6789') AS INTEGER);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_37_4",
    "database_name": "duckdb_37_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select cast(concat('12345','6789') as signed); -- CONCAT",
    "target_query": "SELECT CAST(CONCAT('12345', '6789') AS INTEGER);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_37_5",
    "database_name": "duckdb_37_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select cast(repeat('1',9) as unsigned); -- REPEAT",
    "target_query": "SELECT CAST(REPEAT('1', 9) AS INTEGER);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_37_6",
    "database_name": "duckdb_37_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select cast(repeat('1',9) as signed); -- REPEAT",
    "target_query": "SELECT CAST(REPEAT('1', 9) AS INTEGER);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_37_7",
    "database_name": "duckdb_37_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select isnull(date(NULL)), isnull(cast(NULL as DATE)); -- ISNULL, DATE",
    "target_query": "SELECT NULL IS NULL, CAST(NULL AS DATE) IS NULL;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ISNULL",
      "DATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ISNULL(expr)",
        "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
        "examples": [
          "SELECT ISNULL(NULL);",
          "SELECT ISNULL(5 + NULL);",
          "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
        ]
      },
      {
        "expression": "DATE()",
        "description": "In MySQL, the DATE function extracts the date part from a DATETIME or TIMESTAMP value.",
        "examples": [
          "SELECT DATE('2023-05-01 12:34:56') AS result;",
          "SELECT DATE(NOW()) AS current_date_result;",
          "SELECT DATE(CAST('2023-05-01' AS DATETIME)) AS date_from_datetime;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "expr IS NULL",
        "description": "Tests whether the expression evaluates to NULL.",
        "examples": [
          "SELECT NULL IS NULL;",
          "SELECT ('abc' || NULL) IS NULL;",
          "SELECT CASE WHEN status IS NULL THEN 'unknown' ELSE status END FROM orders;"
        ]
      },
      {
        "expression": "CAST()",
        "description": "DuckDB supports the CAST function to extract a DATE from a TIMESTAMP or DATETIME.",
        "examples": [
          "SELECT CAST('2023-05-01 12:34:56' AS DATE) AS result;",
          "SELECT CURRENT_DATE AS current_date_result;",
          "SELECT CAST('2023-05-01' AS DATE) AS date_from_datetime;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_37_8",
    "database_name": "duckdb_37_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select hex(cast('a' as binary(2))); -- HEX",
    "target_query": "SELECT HEX(CAST('a' AS BLOB));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_37_16",
    "database_name": "duckdb_37_16",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT HOUR(f1),MINUTE(f1),SECOND(f1) FROM t1; -- HOUR, MINUTE, SECOND",
    "target_query": "SELECT EXTRACT(HOUR FROM f1), EXTRACT(MINUTE FROM f1), EXTRACT(SECOND FROM f1) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HOUR",
      "MINUTE",
      "SECOND"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HOUR(expr)",
        "description": "Extracts the hour (0–23) from a time or datetime expression.",
        "examples": [
          "SELECT HOUR('18:45:30');",
          "SELECT HOUR('2023-10-01 08:15:00');",
          "SELECT HOUR(CURRENT_TIMESTAMP);"
        ]
      },
      {
        "expression": "MINUTE()",
        "description": "Extracts the minute part from a time or datetime value.",
        "examples": [
          "SELECT MINUTE('12:34:56');",
          "SELECT MINUTE('2025-01-01 10:30:00');",
          "SELECT MINUTE(NULL);"
        ]
      },
      {
        "expression": "SECOND(time)",
        "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
        "examples": [
          "SELECT SECOND('10:11:12');",
          "SELECT SECOND(4.99999999991e0);",
          "SELECT SECOND(CAST('2007-07-19' AS DATE));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(HOUR FROM expr)",
        "description": "Extracts the hour from a timestamp or time value.",
        "examples": [
          "SELECT EXTRACT(HOUR FROM TIME '18:45:30');",
          "SELECT EXTRACT(HOUR FROM TIMESTAMP '2023-10-01 08:15:00');",
          "SELECT EXTRACT(HOUR FROM CURRENT_TIMESTAMP);"
        ]
      },
      {
        "expression": "MINUTE()",
        "description": "Extracts the minute part from a time or timestamp value.",
        "examples": [
          "SELECT MINUTE('2025-01-01 12:34:56'::TIMESTAMP);",
          "SELECT MINUTE('12:34:56'::TIME);",
          "SELECT MINUTE(NULL::TIMESTAMP);"
        ]
      },
      {
        "expression": "EXTRACT(SECOND FROM time)",
        "description": "Extracts the second part from a TIME, INTERVAL, or timestamp value.",
        "examples": [
          "SELECT EXTRACT(SECOND FROM TIME '10:11:12');",
          "SELECT EXTRACT(SECOND FROM INTERVAL '4.99999999991');",
          "SELECT EXTRACT(SECOND FROM CAST('2007-07-19' AS DATE));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (f1 DATE);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (f1 DATE);"
    ]
  },
  {
    "sql_id": "duckdb_37_18",
    "database_name": "duckdb_37_18",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT HOUR(CAST('2007-07-19' AS DATE)),MINUTE(CAST('2007-07-19' AS DATE)),SECOND(CAST('2007-07-19' AS DATE)); -- HOUR, MINUTE, SECOND",
    "target_query": "SELECT EXTRACT(HOUR FROM CAST('2007-07-19' AS DATE)), EXTRACT(MINUTE FROM CAST('2007-07-19' AS DATE)), EXTRACT(SECOND FROM CAST('2007-07-19' AS DATE));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HOUR",
      "MINUTE",
      "SECOND"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HOUR(expr)",
        "description": "Extracts the hour (0–23) from a time or datetime expression.",
        "examples": [
          "SELECT HOUR('18:45:30');",
          "SELECT HOUR('2023-10-01 08:15:00');",
          "SELECT HOUR(CURRENT_TIMESTAMP);"
        ]
      },
      {
        "expression": "MINUTE()",
        "description": "Extracts the minute part from a time or datetime value.",
        "examples": [
          "SELECT MINUTE('12:34:56');",
          "SELECT MINUTE('2025-01-01 10:30:00');",
          "SELECT MINUTE(NULL);"
        ]
      },
      {
        "expression": "SECOND(time)",
        "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
        "examples": [
          "SELECT SECOND('10:11:12');",
          "SELECT SECOND(4.99999999991e0);",
          "SELECT SECOND(CAST('2007-07-19' AS DATE));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(HOUR FROM expr)",
        "description": "Extracts the hour from a timestamp or time value.",
        "examples": [
          "SELECT EXTRACT(HOUR FROM TIME '18:45:30');",
          "SELECT EXTRACT(HOUR FROM TIMESTAMP '2023-10-01 08:15:00');",
          "SELECT EXTRACT(HOUR FROM CURRENT_TIMESTAMP);"
        ]
      },
      {
        "expression": "MINUTE()",
        "description": "Extracts the minute part from a time or timestamp value.",
        "examples": [
          "SELECT MINUTE('2025-01-01 12:34:56'::TIMESTAMP);",
          "SELECT MINUTE('12:34:56'::TIME);",
          "SELECT MINUTE(NULL::TIMESTAMP);"
        ]
      },
      {
        "expression": "EXTRACT(SECOND FROM time)",
        "description": "Extracts the second part from a TIME, INTERVAL, or timestamp value.",
        "examples": [
          "SELECT EXTRACT(SECOND FROM TIME '10:11:12');",
          "SELECT EXTRACT(SECOND FROM INTERVAL '4.99999999991');",
          "SELECT EXTRACT(SECOND FROM CAST('2007-07-19' AS DATE));"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_37_19",
    "database_name": "duckdb_37_19",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT HOUR(CAST(NULL AS DATE)),MINUTE(CAST(NULL AS DATE)),SECOND(CAST(NULL AS DATE)); -- HOUR, MINUTE, SECOND",
    "target_query": "SELECT EXTRACT(HOUR FROM CAST(NULL AS DATE)), EXTRACT(MINUTE FROM CAST(NULL AS DATE)), EXTRACT(SECOND FROM CAST(NULL AS DATE));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HOUR",
      "MINUTE",
      "SECOND"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HOUR(expr)",
        "description": "Extracts the hour (0–23) from a time or datetime expression.",
        "examples": [
          "SELECT HOUR('18:45:30');",
          "SELECT HOUR('2023-10-01 08:15:00');",
          "SELECT HOUR(CURRENT_TIMESTAMP);"
        ]
      },
      {
        "expression": "MINUTE()",
        "description": "Extracts the minute part from a time or datetime value.",
        "examples": [
          "SELECT MINUTE('12:34:56');",
          "SELECT MINUTE('2025-01-01 10:30:00');",
          "SELECT MINUTE(NULL);"
        ]
      },
      {
        "expression": "SECOND(time)",
        "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
        "examples": [
          "SELECT SECOND('10:11:12');",
          "SELECT SECOND(4.99999999991e0);",
          "SELECT SECOND(CAST('2007-07-19' AS DATE));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(HOUR FROM expr)",
        "description": "Extracts the hour from a timestamp or time value.",
        "examples": [
          "SELECT EXTRACT(HOUR FROM TIME '18:45:30');",
          "SELECT EXTRACT(HOUR FROM TIMESTAMP '2023-10-01 08:15:00');",
          "SELECT EXTRACT(HOUR FROM CURRENT_TIMESTAMP);"
        ]
      },
      {
        "expression": "MINUTE()",
        "description": "Extracts the minute part from a time or timestamp value.",
        "examples": [
          "SELECT MINUTE('2025-01-01 12:34:56'::TIMESTAMP);",
          "SELECT MINUTE('12:34:56'::TIME);",
          "SELECT MINUTE(NULL::TIMESTAMP);"
        ]
      },
      {
        "expression": "EXTRACT(SECOND FROM time)",
        "description": "Extracts the second part from a TIME, INTERVAL, or timestamp value.",
        "examples": [
          "SELECT EXTRACT(SECOND FROM TIME '10:11:12');",
          "SELECT EXTRACT(SECOND FROM INTERVAL '4.99999999991');",
          "SELECT EXTRACT(SECOND FROM CAST('2007-07-19' AS DATE));"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_37_20",
    "database_name": "duckdb_37_20",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT HOUR(NULL),MINUTE(NULL),SECOND(NULL); -- HOUR, MINUTE, SECOND",
    "target_query": "SELECT EXTRACT(HOUR FROM CAST(NULL AS TIMESTAMP)), EXTRACT(MINUTE FROM CAST(NULL AS TIMESTAMP)), EXTRACT(SECOND FROM CAST(NULL AS TIMESTAMP));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HOUR",
      "MINUTE",
      "SECOND"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HOUR(expr)",
        "description": "Extracts the hour (0–23) from a time or datetime expression.",
        "examples": [
          "SELECT HOUR('18:45:30');",
          "SELECT HOUR('2023-10-01 08:15:00');",
          "SELECT HOUR(CURRENT_TIMESTAMP);"
        ]
      },
      {
        "expression": "MINUTE()",
        "description": "Extracts the minute part from a time or datetime value.",
        "examples": [
          "SELECT MINUTE('12:34:56');",
          "SELECT MINUTE('2025-01-01 10:30:00');",
          "SELECT MINUTE(NULL);"
        ]
      },
      {
        "expression": "SECOND(time)",
        "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
        "examples": [
          "SELECT SECOND('10:11:12');",
          "SELECT SECOND(4.99999999991e0);",
          "SELECT SECOND(CAST('2007-07-19' AS DATE));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(HOUR FROM expr)",
        "description": "Extracts the hour from a timestamp or time value.",
        "examples": [
          "SELECT EXTRACT(HOUR FROM TIME '18:45:30');",
          "SELECT EXTRACT(HOUR FROM TIMESTAMP '2023-10-01 08:15:00');",
          "SELECT EXTRACT(HOUR FROM CURRENT_TIMESTAMP);"
        ]
      },
      {
        "expression": "MINUTE()",
        "description": "Extracts the minute part from a time or timestamp value.",
        "examples": [
          "SELECT MINUTE('2025-01-01 12:34:56'::TIMESTAMP);",
          "SELECT MINUTE('12:34:56'::TIME);",
          "SELECT MINUTE(NULL::TIMESTAMP);"
        ]
      },
      {
        "expression": "EXTRACT(SECOND FROM time)",
        "description": "Extracts the second part from a TIME, INTERVAL, or timestamp value.",
        "examples": [
          "SELECT EXTRACT(SECOND FROM TIME '10:11:12');",
          "SELECT EXTRACT(SECOND FROM INTERVAL '4.99999999991');",
          "SELECT EXTRACT(SECOND FROM CAST('2007-07-19' AS DATE));"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_37_21",
    "database_name": "duckdb_37_21",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT CONVERT('a', CHAR(2049)); -- CONVERT",
    "target_query": "SELECT CAST('a' AS VARCHAR);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONVERT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONVERT(expression USING charset)",
        "description": "Converts data types or changes the character set.",
        "examples": [
          "SELECT CONVERT('Hello World' USING utf8);",
          "SELECT CONVERT(1234, CHAR);",
          "SELECT CONVERT(column_name USING latin1) FROM my_table;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CAST(expression AS target_type)",
        "description": "DuckDB uses CAST for type conversion. No direct equivalent for CONVERT TO CHARACTER SET.",
        "examples": [
          "SELECT CAST('2021-12-31' AS DATE);",
          "SELECT CAST(1234 AS VARCHAR);",
          "SELECT CAST(column_name AS VARCHAR) FROM my_table;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_37_22",
    "database_name": "duckdb_37_22",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT CONCAT(\"value=\", CAST(\"3.4e5\" AS FLOAT)); -- CONCAT",
    "target_query": "SELECT CONCAT('value=', CAST('3.4e5' AS FLOAT));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_37_23",
    "database_name": "duckdb_37_23",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT MAKETIME(1, 2, CAST(\"1.6\" AS FLOAT)); -- MAKETIME",
    "target_query": "SELECT MAKE_TIME(1, 2, 1.6);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKETIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKETIME(hours, minutes, seconds)",
        "description": "Creates a time value from the provided hours, minutes, and seconds.",
        "examples": [
          "SELECT MAKETIME(1, 30, 45);",
          "SELECT MAKETIME(12, 0, 0);",
          "SELECT MAKETIME(23, 59, 59);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "make_time(hour, minute, second)",
        "description": "Constructs a time value from the given hour, minute, and second components using the built-in make_time function.",
        "examples": [
          "SELECT make_time(1, 30, 45);",
          "SELECT make_time(12, 0, 0);",
          "SELECT make_time(23, 59, 59);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_38_3",
    "database_name": "duckdb_38_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT STRCMP(a, b) FROM t1; -- STRCMP",
    "target_query": "SELECT CASE WHEN CAST(a AS VARCHAR) = b THEN 0 ELSE 1 END FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "DuckDB does not have a STRCMP function, but the same functionality can be achieved using a CASE statement to compare strings lexicographically.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(a YEAR, b VARCHAR(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(a SMALLINT, b VARCHAR(10));"
    ]
  },
  {
    "sql_id": "duckdb_38_6",
    "database_name": "duckdb_38_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT CAST(1988 AS YEAR), REPEAT(CAST(1988 AS YEAR), 3) AS c2; -- REPEAT",
    "target_query": "SELECT CAST(1988 AS SMALLINT), REPEAT(CAST(1988 AS VARCHAR), 3) AS c2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_38_7",
    "database_name": "duckdb_38_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT CONCAT('x', CAST(1988 AS YEAR)); -- CONCAT",
    "target_query": "SELECT CONCAT('x', CAST(1988 AS VARCHAR));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_38_8",
    "database_name": "duckdb_38_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT TIME_TO_SEC(CAST('2030' AS YEAR)); -- TIME_TO_SEC",
    "target_query": "SELECT EXTRACT(EPOCH FROM CAST('20:30' AS TIME));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME_TO_SEC"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME_TO_SEC(time)",
        "description": "Converts a time value (HH:MM:SS) to the total number of seconds.",
        "examples": [
          "SELECT TIME_TO_SEC('15:12:22');",
          "SELECT TIME_TO_SEC('00:01:00');",
          "SELECT SEC_TO_TIME(TIME_TO_SEC('15:12:22') - TIME_TO_SEC('14:12:22'));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM time)",
        "description": "Extracts the number of seconds from a time value.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM TIME '15:12:22');",
          "SELECT EXTRACT(EPOCH FROM TIME '00:01:00');",
          "SELECT EXTRACT(EPOCH FROM TIME '15:12:22') - EXTRACT(EPOCH FROM TIME '14:12:22');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_38_9",
    "database_name": "duckdb_38_9",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT TIMESTAMPADD(MINUTE, 1, CAST(1988 AS YEAR)); -- TIMESTAMPADD",
    "target_query": "SELECT CAST('1988-01-01' AS TIMESTAMP) + INTERVAL '1 minute';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMPADD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMPADD(unit, interval, datetime_expr)",
        "description": "Adds a time interval to a date or timestamp expression using the specified unit.",
        "examples": [
          "SELECT TIMESTAMPADD(DAY, 2, '2023-01-01');",
          "SELECT TIMESTAMPADD(MINUTE, -5, '2023-05-10 12:00:00');",
          "SELECT TIMESTAMPADD(YEAR, 1, '2020-06-15');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "datetime_expr + INTERVAL 'n unit'",
        "description": "Performs datetime arithmetic by adding a specified time interval using INTERVAL syntax.",
        "examples": [
          "SELECT DATE '2023-01-01' + INTERVAL '2 day';",
          "SELECT TIMESTAMP '2023-05-10 12:00:00' + INTERVAL '-5 minute';",
          "SELECT DATE '2020-06-15' + INTERVAL '1 year';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_38_10",
    "database_name": "duckdb_38_10",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT CAST(STR_TO_DATE('nope','%d-%m-%Y') AS YEAR); -- STR_TO_DATE",
    "target_query": "SELECT EXTRACT(YEAR FROM STRPTIME('2025-01-01', '%Y-%m-%d'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STR_TO_DATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STR_TO_DATE('09:22', '%H:%i')",
        "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
        "examples": [
          "SELECT STR_TO_DATE('12:45', '%H:%i');",
          "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
          "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "strptime('2000-01-01', '%Y-%m-%d')",
        "description": "Converts a string to a timestamp using the specified format, where '%Y-%m-%d' corresponds to the 'Year-Month-Day' format.",
        "examples": [
          "SELECT strptime('2000-01-01', '%Y-%m-%d');",
          "SELECT strptime('2023-05-06', '%Y-%m-%d');",
          "SELECT strptime('1999-12-31', '%Y-%m-%d');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_38_13",
    "database_name": "duckdb_38_13",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT 1 FROM t WHERE CAST(a AS UNSIGNED INTEGER) = 1 AND a = IF(TRUE, NULL, 1); -- IF",
    "target_query": "SELECT 1 FROM t WHERE a = 1 AND a = CASE WHEN TRUE THEN NULL ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t (a INT NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t (a INT NOT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_40_3",
    "database_name": "duckdb_40_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT hex(a),STRCMP(a,'a'), STRCMP(a,'a ') FROM t1; -- HEX, STRCMP",
    "target_query": "SELECT hex(a), CASE WHEN a = 'a' THEN 0 WHEN a < 'a' THEN -1 ELSE 1 END, CASE WHEN a = 'a ' THEN 0 WHEN a < 'a ' THEN -1 ELSE 1 END FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "DuckDB does not have a STRCMP function, but the same functionality can be achieved using a CASE statement to compare strings lexicographically.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a char(10) not null);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a char(10) not null);"
    ]
  },
  {
    "sql_id": "duckdb_40_7",
    "database_name": "duckdb_40_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT CONCAT(b,c), CONCAT(b,c) = '0101' FROM t1; -- CONCAT",
    "target_query": "SELECT CONCAT(b,c), CONCAT(b,c) = '0101' FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE  t1 (b int(2) zerofill, c int(2) zerofill);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (b int, c int);"
    ]
  },
  {
    "sql_id": "duckdb_40_8",
    "database_name": "duckdb_40_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "EXPLAIN SELECT b,c FROM t1 WHERE b = 1 AND CONCAT(b,c) = '0101'; -- CONCAT",
    "target_query": "EXPLAIN SELECT b,c FROM t1 WHERE b = 1 AND CONCAT(b,c) = '0101';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE  t1 (b int(2) zerofill, c int(2) zerofill);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (b int, c int);"
    ]
  },
  {
    "sql_id": "duckdb_40_9",
    "database_name": "duckdb_40_9",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT b,c FROM t1 WHERE b = 1 AND CONCAT(b,c) = '0101'; -- CONCAT",
    "target_query": "SELECT b,c FROM t1 WHERE b = 1 AND CONCAT(b,c) = '0101';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE  t1 (b int(2) zerofill, c int(2) zerofill);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (b int, c int);"
    ]
  },
  {
    "sql_id": "duckdb_40_12",
    "database_name": "duckdb_40_12",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 VALUES (NOW()),(NOW()),(NOW()); -- NOW",
    "target_query": "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP),(CURRENT_TIMESTAMP),(CURRENT_TIMESTAMP);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "DuckDB also uses CURRENT_TIMESTAMP to get the current date and time, similar to PostgreSQL and MonetDB.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a TIMESTAMP);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a TIMESTAMP);"
    ]
  },
  {
    "sql_id": "duckdb_40_16",
    "database_name": "duckdb_40_16",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT ROW('1', '1') > ROW(a, '1') FROM t1; -- ROW",
    "target_query": "SELECT ROW('1', '1') > ROW(a, '1') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(a CHAR(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(a CHAR(10));"
    ]
  },
  {
    "sql_id": "duckdb_40_17",
    "database_name": "duckdb_40_17",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT ROW(a, '1') > ROW('1', '1') FROM t1; -- ROW",
    "target_query": "SELECT ROW(a, '1') > ROW('1', '1') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(a CHAR(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(a CHAR(10));"
    ]
  },
  {
    "sql_id": "duckdb_41_3",
    "database_name": "duckdb_41_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select count(distinct if(f1,3,f2)) from t1; -- COUNT, IF",
    "target_query": "SELECT COUNT(DISTINCT CASE WHEN f1 != 0 THEN 3 ELSE f2 END) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COUNT",
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN FORMAT=TREE SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      },
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      },
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (f1 int, f2 int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (f1 INT, f2 INT);"
    ]
  },
  {
    "sql_id": "duckdb_42_4",
    "database_name": "duckdb_42_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT HEX(v) FROM t1; -- HEX",
    "target_query": "SELECT HEX(v) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (v VARCHAR(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (v VARCHAR(10));"
    ]
  },
  {
    "sql_id": "duckdb_43_3",
    "database_name": "duckdb_43_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select concat(name,space(level)), concat(name, repeat(' ',level)) from t1; -- CONCAT, SPACE, REPEAT",
    "target_query": "select CONCAT(name, REPEAT(' ', level)), CONCAT(name, REPEAT(' ', level)) from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT",
      "SPACE",
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      },
      {
        "expression": "SPACE(n)",
        "description": "Returns a string consisting of n space characters.",
        "examples": [
          "SELECT LENGTH(SPACE(5));",
          "SELECT CONCAT('A', SPACE(3), 'B');",
          "SELECT CONCAT(REPEAT('-', 2), SPACE(4), '!');"
        ]
      },
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      },
      {
        "expression": "REPEAT(' ', n)",
        "description": "Returns a string consisting of n space characters by repeating a space character.",
        "examples": [
          "SELECT LENGTH(REPEAT(' ', 5));",
          "SELECT CONCAT('A', REPEAT(' ', 3), 'B');",
          "SELECT CONCAT(REPEAT('-', 2), REPEAT(' ', 4), '!');"
        ]
      },
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (name varchar(10),level smallint);"
    ],
    "target_related_schemas": [
      "create table t1 (name varchar(10),level smallint);"
    ]
  },
  {
    "sql_id": "duckdb_43_5",
    "database_name": "duckdb_43_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "create table t1 select repeat('a',4000) a; -- REPEAT",
    "target_query": "CREATE TABLE t1 AS SELECT repeat('a',4000) AS a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 select repeat('a',4000) a; -- REPEAT"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 AS SELECT repeat('a',4000) AS a;"
    ]
  },
  {
    "sql_id": "duckdb_43_14",
    "database_name": "duckdb_43_14",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT",
    "target_query": "CREATE TABLE head AS SELECT CONCAT(b1.b, b2.b) AS head FROM t1 b1, t1 b2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT"
    ],
    "target_related_schemas": [
      "CREATE TABLE head AS SELECT CONCAT(b1.b, b2.b) AS head FROM t1 b1, t1 b2;"
    ]
  },
  {
    "sql_id": "duckdb_43_15",
    "database_name": "duckdb_43_15",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "CREATE TABLE tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2; -- CONCAT",
    "target_query": "CREATE TABLE tail AS SELECT CONCAT(b1.b, b2.b) AS tail FROM t1 b1, t1 b2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT",
      "CREATE TABLE tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2; -- CONCAT"
    ],
    "target_related_schemas": [
      "CREATE TABLE head AS SELECT CONCAT(b1.b, b2.b) AS head FROM t1 b1, t1 b2;",
      "CREATE TABLE tail AS SELECT CONCAT(b1.b, b2.b) AS tail FROM t1 b1, t1 b2;"
    ]
  },
  {
    "sql_id": "duckdb_44_3",
    "database_name": "duckdb_44_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT GROUP_CONCAT(IFNULL(a,'')) FROM t1; -- GROUP_CONCAT, IFNULL",
    "target_query": "SELECT GROUP_CONCAT(COALESCE(a,'')) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GROUP_CONCAT",
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
        "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
        ]
      },
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
        "description": "The GROUP_CONCAT function in DuckDB concatenates values from multiple rows into a single string, separated by a specified delimiter.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
        ]
      },
      {
        "expression": "COALESCE(expr1, expr2)",
        "description": "DuckDB also uses COALESCE to return the first non-NULL argument, which is functionally the same as IFNULL in MySQL.",
        "examples": [
          "SELECT COALESCE(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a MEDIUMINT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INTEGER NULL);"
    ]
  },
  {
    "sql_id": "duckdb_44_4",
    "database_name": "duckdb_44_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT GROUP_CONCAT(IF(a,a,'')) FROM t1; -- GROUP_CONCAT, IF",
    "target_query": "SELECT GROUP_CONCAT(CASE WHEN a!=0 THEN a ELSE '' END) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GROUP_CONCAT",
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
        "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
        ]
      },
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
        "description": "The GROUP_CONCAT function in DuckDB concatenates values from multiple rows into a single string, separated by a specified delimiter.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
        ]
      },
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a MEDIUMINT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INTEGER NULL);"
    ]
  },
  {
    "sql_id": "duckdb_44_5",
    "database_name": "duckdb_44_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT GROUP_CONCAT(CASE WHEN a THEN a ELSE '' END) FROM t1; -- GROUP_CONCAT",
    "target_query": "SELECT GROUP_CONCAT(CASE WHEN a!=0 THEN a ELSE '' END) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GROUP_CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
        "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
        "description": "The GROUP_CONCAT function in DuckDB concatenates values from multiple rows into a single string, separated by a specified delimiter.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a MEDIUMINT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INTEGER NULL);"
    ]
  },
  {
    "sql_id": "duckdb_44_6",
    "database_name": "duckdb_44_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT COALESCE(a,'') FROM t1 GROUP BY 1; -- COALESCE",
    "target_query": "SELECT COALESCE(a,'') FROM t1 GROUP BY 1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...)",
        "description": "DuckDB supports COALESCE for NULL handling.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a MEDIUMINT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INTEGER NULL);"
    ]
  },
  {
    "sql_id": "duckdb_44_8",
    "database_name": "duckdb_44_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "CREATE TABLE t2 AS SELECT CONCAT_WS(1,2,3) FROM t1; -- CONCAT_WS",
    "target_query": "CREATE TABLE t2 AS SELECT concat_ws('1', '2', '3') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT_WS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT_WS(separator, str1, str2, ...)",
        "description": "Concatenates multiple strings with the specified separator. If any argument is NULL, it is ignored.",
        "examples": [
          "SELECT CONCAT_WS(',', 'apple', 'banana', 'cherry');",
          "SELECT CONCAT_WS('-', 'hello', 'world');",
          "SELECT CONCAT_WS(' ', 'this', NULL, 'is', 'a', 'test');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat_ws(separator, str1, str2, ...)",
        "description": "Concatenates strings using a separator, and ignores NULL values.",
        "examples": [
          "SELECT concat_ws(',', 'apple', 'banana', 'cherry');",
          "SELECT concat_ws('-', 'hello', 'world');",
          "SELECT concat_ws(' ', 'this', NULL, 'is', 'a', 'test');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 AS SELECT CONCAT_WS(1,2,3) FROM t1; -- CONCAT_WS"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 AS SELECT concat_ws('1', '2', '3') FROM t1;"
    ]
  },
  {
    "sql_id": "duckdb_44_10",
    "database_name": "duckdb_44_10",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "CREATE TABLE t2 AS SELECT LCASE(a) FROM t1; -- LCASE",
    "target_query": "CREATE TABLE t2 AS SELECT lower(a::text) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LCASE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LCASE(str)",
        "description": "Converts all characters in a string to lowercase. Equivalent to LOWER(str).",
        "examples": [
          "SELECT LCASE('TeSt');",
          "SELECT LCASE(CONCAT('A', 'B', 'C'));",
          "SELECT LCASE(456);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "lower(str)",
        "description": "Converts all alphabetic characters in a string to lowercase.",
        "examples": [
          "SELECT lower('TeSt');",
          "SELECT lower('ABC');",
          "SELECT lower(CAST(456 AS VARCHAR));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 AS SELECT LCASE(a) FROM t1; -- LCASE"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 AS SELECT lower(a::text) FROM t1;"
    ]
  },
  {
    "sql_id": "duckdb_44_12",
    "database_name": "duckdb_44_12",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "CREATE TABLE t2 AS SELECT UCASE(a) FROM t1; -- UCASE",
    "target_query": "CREATE TABLE t2 AS SELECT UPPER(a::text) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UCASE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UCASE(str)",
        "description": "Returns the string `str` with all characters converted to uppercase. UCASE is a synonym for UPPER.",
        "examples": [
          "SELECT UCASE('hello world');",
          "SELECT UCASE(CONCAT('abc', '123'));",
          "SELECT UCASE(REPLACE('test case', 'case', 'CASE'));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "UPPER(str)",
        "description": "Returns the uppercase version of the given string.",
        "examples": [
          "SELECT UPPER('hello world');",
          "SELECT UPPER(CONCAT('abc', '123'));",
          "SELECT UPPER(REPLACE('test case', 'case', 'CASE'));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 AS SELECT UCASE(a) FROM t1; -- UCASE"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 AS SELECT UPPER(a::text) FROM t1;"
    ]
  },
  {
    "sql_id": "duckdb_44_14",
    "database_name": "duckdb_44_14",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "CREATE TABLE t2 AS SELECT REPEAT(1,2) FROM t1; -- REPEAT",
    "target_query": "CREATE TABLE t2 AS SELECT REPEAT('1',2) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 AS SELECT REPEAT(1,2) FROM t1; -- REPEAT"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 AS SELECT REPEAT('1',2) FROM t1;"
    ]
  },
  {
    "sql_id": "duckdb_44_16",
    "database_name": "duckdb_44_16",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "CREATE TABLE t2 AS SELECT ELT(1,111,222,333) FROM t1; -- ELT",
    "target_query": "CREATE TABLE t2 AS SELECT [111,222,333][1] FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ELT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ELT(2, 'apple', 'banana', 'cherry')",
        "description": "Returns the N-th element from the list, where N is the first argument.",
        "examples": [
          "SELECT ELT(2, 'apple', 'banana', 'cherry');  -- Returns 'banana'",
          "SELECT ELT(1, 'red', 'green', 'blue');  -- Returns 'red'",
          "SELECT ELT(3, 'dog', 'cat', 'bird');  -- Returns 'bird'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "['str1', 'str2', 'str3'][N]",
        "description": "Simulates ELT by using array literal and 1-based indexing. Returns NULL if index is out of bounds.",
        "examples": [
          "SELECT ['apple', 'banana', 'cherry'][2];  -- Returns 'banana'",
          "SELECT ['red', 'green', 'blue'][1];  -- Returns 'red'",
          "SELECT ['dog', 'cat', 'bird'][3];  -- Returns 'bird'"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 AS SELECT ELT(1,111,222,333) FROM t1; -- ELT"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 AS SELECT [111,222,333][1] FROM t1;"
    ]
  },
  {
    "sql_id": "duckdb_45_2",
    "database_name": "duckdb_45_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT HEX(a) FROM t1; -- HEX",
    "target_query": "SELECT HEX(a) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a CHAR(10)) SELECT '' AS a;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 AS SELECT '' AS a;"
    ]
  },
  {
    "sql_id": "duckdb_45_6",
    "database_name": "duckdb_45_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT HEX(a) FROM t2; -- HEX",
    "target_query": "SELECT HEX(a) FROM t2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 (a CHAR(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (a CHAR(10));"
    ]
  },
  {
    "sql_id": "duckdb_45_11",
    "database_name": "duckdb_45_11",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select * from t1 where a=lpad('xxx',10,' '); -- LPAD",
    "target_query": "select * from t1 where a=lpad('xxx',10,' ');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a char(20));"
    ],
    "target_related_schemas": [
      "create table t1 (a char(20));"
    ]
  },
  {
    "sql_id": "duckdb_45_15",
    "database_name": "duckdb_45_15",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select ifnull(c1,''), ifnull(null,c1) from t1; -- IFNULL",
    "target_query": "select coalesce(c1,''), coalesce(null,c1) from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2)",
        "description": "DuckDB also uses COALESCE to return the first non-NULL argument, which is functionally the same as IFNULL in MySQL.",
        "examples": [
          "SELECT COALESCE(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 char(10));"
    ],
    "target_related_schemas": [
      "create table t1 (c1 char(10));"
    ]
  },
  {
    "sql_id": "duckdb_45_16",
    "database_name": "duckdb_45_16",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select if(1,c1,''), if(0,c1,'') from t1; -- IF",
    "target_query": "select CASE WHEN 1!=0 THEN c1 ELSE '' END, CASE WHEN 0!=0 THEN c1 ELSE '' END from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
        "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
        "examples": [
          "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
          "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
          "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 char(10));"
    ],
    "target_related_schemas": [
      "create table t1 (c1 char(10));"
    ]
  },
  {
    "sql_id": "duckdb_45_17",
    "database_name": "duckdb_45_17",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select coalesce('',c1), coalesce(null,c1) from t1; -- COALESCE",
    "target_query": "select coalesce('',c1), coalesce(null,c1) from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...)",
        "description": "DuckDB supports COALESCE for NULL handling.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 char(10));"
    ],
    "target_related_schemas": [
      "create table t1 (c1 char(10));"
    ]
  },
  {
    "sql_id": "duckdb_45_18",
    "database_name": "duckdb_45_18",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select least(c1,''), greatest(c1,'') from t1; -- LEAST, GREATEST",
    "target_query": "select least(c1,''), greatest(c1,'') from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST",
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      },
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the least non-null value among the provided expressions. NULLs are skipped unless all arguments are NULL. This differs from MySQL/MariaDB which return NULL if any argument is NULL.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(DATE '2024-01-01', DATE '2023-12-31');",
          "SELECT least(NULL, 2);"
        ]
      },
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 char(10));"
    ],
    "target_related_schemas": [
      "create table t1 (c1 char(10));"
    ]
  },
  {
    "sql_id": "duckdb_45_19",
    "database_name": "duckdb_45_19",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select locate(c1,''), locate('',c1) from t1; -- LOCATE",
    "target_query": "select position(c1 IN ''), position('' IN c1) from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LOCATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LOCATE(substr, str[, start_position])",
        "description": "Returns the position of the first occurrence of substring 'substr' in string 'str'. If 'start_position' is provided, the search starts from that position.",
        "examples": [
          "select locate('a', 'banana', 2);",
          "select locate('foo', 'foobar', 2);",
          "select locate('ab', 'abcab', 3);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POSITION(substr IN str)",
        "description": "Same as PostgreSQL. Returns the position of the first occurrence of substring 'substr' in string 'str'. Does not support 'start_position'.",
        "examples": [
          "select position('a' IN 'banana');",
          "select position('foo' IN 'foobar');",
          "select position('ab' IN 'abcab');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 char(10));"
    ],
    "target_related_schemas": [
      "create table t1 (c1 char(10));"
    ]
  },
  {
    "sql_id": "duckdb_45_20",
    "database_name": "duckdb_45_20",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select field(c1,''),field('',c1) from t1; -- FIELD",
    "target_query": "select coalesce(array_position(ARRAY['',c1], c1), 0), coalesce(array_position(ARRAY[c1,''], ''), 0) from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FIELD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FIELD(val, val1, val2, ..., valN)",
        "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
        "examples": [
          "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(array_position(ARRAY[val1, val2, ..., valN], val), 0)",
        "description": "Returns the index (1-based) of 'val' in the array. Returns 0 if not found, emulating MySQL FIELD().",
        "examples": [
          "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'c'), 0) AS result;",
          "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'x'), 0) AS result;",
          "SELECT COALESCE(array_position(ARRAY['b', 'b', 'b'], 'b'), 0) AS result;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 char(10));"
    ],
    "target_related_schemas": [
      "create table t1 (c1 char(10));"
    ]
  },
  {
    "sql_id": "duckdb_45_21",
    "database_name": "duckdb_45_21",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select concat(c1,''), concat('',c1) from t1; -- CONCAT",
    "target_query": "select concat(c1,''), concat('',c1) from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 char(10));"
    ],
    "target_related_schemas": [
      "create table t1 (c1 char(10));"
    ]
  },
  {
    "sql_id": "duckdb_45_22",
    "database_name": "duckdb_45_22",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select concat_ws(c1,'',''), concat_ws('',c1,'') from t1; -- CONCAT_WS",
    "target_query": "select concat_ws(c1,'',''), concat_ws('',c1,'') from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT_WS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT_WS(separator, str1, str2, ...)",
        "description": "Concatenates multiple strings with the specified separator. If any argument is NULL, it is ignored.",
        "examples": [
          "SELECT CONCAT_WS(',', 'apple', 'banana', 'cherry');",
          "SELECT CONCAT_WS('-', 'hello', 'world');",
          "SELECT CONCAT_WS(' ', 'this', NULL, 'is', 'a', 'test');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat_ws(separator, str1, str2, ...)",
        "description": "Concatenates strings using a separator, and ignores NULL values.",
        "examples": [
          "SELECT concat_ws(',', 'apple', 'banana', 'cherry');",
          "SELECT concat_ws('-', 'hello', 'world');",
          "SELECT concat_ws(' ', 'this', NULL, 'is', 'a', 'test');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 char(10));"
    ],
    "target_related_schemas": [
      "create table t1 (c1 char(10));"
    ]
  },
  {
    "sql_id": "duckdb_45_23",
    "database_name": "duckdb_45_23",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select elt(1,c1,''),elt(1,'',c1) from t1; -- ELT",
    "target_query": "select ['c1', ''][1], ['','c1'][1] from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ELT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ELT(2, 'apple', 'banana', 'cherry')",
        "description": "Returns the N-th element from the list, where N is the first argument.",
        "examples": [
          "SELECT ELT(2, 'apple', 'banana', 'cherry');  -- Returns 'banana'",
          "SELECT ELT(1, 'red', 'green', 'blue');  -- Returns 'red'",
          "SELECT ELT(3, 'dog', 'cat', 'bird');  -- Returns 'bird'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "['str1', 'str2', 'str3'][N]",
        "description": "Simulates ELT by using array literal and 1-based indexing. Returns NULL if index is out of bounds.",
        "examples": [
          "SELECT ['apple', 'banana', 'cherry'][2];  -- Returns 'banana'",
          "SELECT ['red', 'green', 'blue'][1];  -- Returns 'red'",
          "SELECT ['dog', 'cat', 'bird'][3];  -- Returns 'bird'"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 char(10));"
    ],
    "target_related_schemas": [
      "create table t1 (c1 char(10));"
    ]
  },
  {
    "sql_id": "duckdb_45_24",
    "database_name": "duckdb_45_24",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select lpad(c1,3,'x'), lpad('x',3,c1) from t1; -- LPAD",
    "target_query": "select lpad(c1,3,'x'), lpad('x',3,c1) from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 char(10));"
    ],
    "target_related_schemas": [
      "create table t1 (c1 char(10));"
    ]
  },
  {
    "sql_id": "duckdb_45_25",
    "database_name": "duckdb_45_25",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select rpad(c1,3,'x'), rpad('x',3,c1) from t1; -- RPAD",
    "target_query": "select rpad(c1,3,'x'), rpad('x',3,c1) from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "DuckDB supports RPAD for string padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123::TEXT, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 char(10));"
    ],
    "target_related_schemas": [
      "create table t1 (c1 char(10));"
    ]
  },
  {
    "sql_id": "duckdb_46_0",
    "database_name": "duckdb_46_0",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select str_to_date(concat('15-01-2001',' 2:59:58.999'),concat('%d-%m-%Y',' ','%H:%i:%s.%f')); -- STR_TO_DATE, CONCAT",
    "target_query": "SELECT strptime(CONCAT('15-01-2001', ' 2:59:58.999'), CONCAT('%d-%m-%Y', ' ','%H:%M:%S.%f'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STR_TO_DATE",
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STR_TO_DATE('09:22', '%H:%i')",
        "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
        "examples": [
          "SELECT STR_TO_DATE('12:45', '%H:%i');",
          "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
          "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
        ]
      },
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "strptime('2000-01-01', '%Y-%m-%d')",
        "description": "Converts a string to a timestamp using the specified format, where '%Y-%m-%d' corresponds to the 'Year-Month-Day' format.",
        "examples": [
          "SELECT strptime('2000-01-01', '%Y-%m-%d');",
          "SELECT strptime('2023-05-06', '%Y-%m-%d');",
          "SELECT strptime('1999-12-31', '%Y-%m-%d');"
        ]
      },
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_46_1",
    "database_name": "duckdb_46_1",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select STR_TO_DATE('2004.12.12 22.30.59','%Y.%m.%d %T'); -- STR_TO_DATE",
    "target_query": "SELECT strptime('2004.12.12 22.30.59', '%Y.%m.%d %H.%M.%S');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STR_TO_DATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STR_TO_DATE('09:22', '%H:%i')",
        "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
        "examples": [
          "SELECT STR_TO_DATE('12:45', '%H:%i');",
          "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
          "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "strptime('2000-01-01', '%Y-%m-%d')",
        "description": "Converts a string to a timestamp using the specified format, where '%Y-%m-%d' corresponds to the 'Year-Month-Day' format.",
        "examples": [
          "SELECT strptime('2000-01-01', '%Y-%m-%d');",
          "SELECT strptime('2023-05-06', '%Y-%m-%d');",
          "SELECT strptime('1999-12-31', '%Y-%m-%d');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_46_11",
    "database_name": "duckdb_46_11",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select concat('',str_to_date('8:11:2 03-01-02','%H:%i:%S %y-%m-%d')); -- CONCAT, STR_TO_DATE",
    "target_query": "SELECT CONCAT('', strptime('8:11:2 03-01-02', '%H:%M:%S %y-%m-%d'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT",
      "STR_TO_DATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      },
      {
        "expression": "STR_TO_DATE('09:22', '%H:%i')",
        "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
        "examples": [
          "SELECT STR_TO_DATE('12:45', '%H:%i');",
          "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
          "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      },
      {
        "expression": "strptime('2000-01-01', '%Y-%m-%d')",
        "description": "Converts a string to a timestamp using the specified format, where '%Y-%m-%d' corresponds to the 'Year-Month-Day' format.",
        "examples": [
          "SELECT strptime('2000-01-01', '%Y-%m-%d');",
          "SELECT strptime('2023-05-06', '%Y-%m-%d');",
          "SELECT strptime('1999-12-31', '%Y-%m-%d');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_46_15",
    "database_name": "duckdb_46_15",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select date_format(d,\"%d\") from t1 order by 1; -- DATE_FORMAT",
    "target_query": "SELECT STRFTIME(d, '%d') FROM t1 ORDER BY 1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "STRFTIME(date_expr, format_str)",
        "description": "Formats a date/time value using SQLite-compatible strftime format specifiers.",
        "examples": [
          "SELECT STRFTIME('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT STRFTIME(CURRENT_TIMESTAMP, '%Y-%m-%d %H:%M:%S');",
          "SELECT STRFTIME('2023-01-15 12:00:00', '%d-%m-%Y');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (d date);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (d DATE);"
    ]
  },
  {
    "sql_id": "duckdb_46_17",
    "database_name": "duckdb_46_17",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select date_format('2004-01-01','%W (%a), %e %M (%b) %Y'); -- DATE_FORMAT",
    "target_query": "SELECT STRFTIME('2004-01-01'::DATE, '%W (%a), %d %M (%b) %Y');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "STRFTIME(date_expr, format_str)",
        "description": "Formats a date/time value using SQLite-compatible strftime format specifiers.",
        "examples": [
          "SELECT STRFTIME('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT STRFTIME(CURRENT_TIMESTAMP, '%Y-%m-%d %H:%M:%S');",
          "SELECT STRFTIME('2023-01-15 12:00:00', '%d-%m-%Y');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_47_0",
    "database_name": "duckdb_47_0",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT TIME_FORMAT(\"24:00:00\", '%r'); -- TIME_FORMAT",
    "target_query": "SELECT strftime(TIMESTAMP '2000-01-01 24:00:00', '%I:%M:%S %p');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME_FORMAT(time, format)",
        "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
        "examples": [
          "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
          "SELECT TIME_FORMAT('18:05:07', '%r');",
          "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "strftime(timestamp, format)",
        "description": "Formats a TIMESTAMP value using strftime with POSIX-like format strings.",
        "examples": [
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%H:%M:%S');",
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%I:%M:%S %p');",
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%M:%S');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_47_1",
    "database_name": "duckdb_47_1",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT TIME_FORMAT(\"00:00:00\", '%r'); -- TIME_FORMAT",
    "target_query": "SELECT strftime(TIMESTAMP '2000-01-01 00:00:00', '%I:%M:%S %p');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME_FORMAT(time, format)",
        "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
        "examples": [
          "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
          "SELECT TIME_FORMAT('18:05:07', '%r');",
          "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "strftime(timestamp, format)",
        "description": "Formats a TIMESTAMP value using strftime with POSIX-like format strings.",
        "examples": [
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%H:%M:%S');",
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%I:%M:%S %p');",
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%M:%S');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_47_2",
    "database_name": "duckdb_47_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT TIME_FORMAT(\"12:00:00\", '%r'); -- TIME_FORMAT",
    "target_query": "SELECT strftime(TIMESTAMP '2000-01-01 12:00:00', '%I:%M:%S %p');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME_FORMAT(time, format)",
        "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
        "examples": [
          "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
          "SELECT TIME_FORMAT('18:05:07', '%r');",
          "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "strftime(timestamp, format)",
        "description": "Formats a TIMESTAMP value using strftime with POSIX-like format strings.",
        "examples": [
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%H:%M:%S');",
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%I:%M:%S %p');",
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%M:%S');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_47_3",
    "database_name": "duckdb_47_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT TIME_FORMAT(\"15:00:00\", '%r'); -- TIME_FORMAT",
    "target_query": "SELECT strftime(TIMESTAMP '2000-01-01 15:00:00', '%I:%M:%S %p');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME_FORMAT(time, format)",
        "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
        "examples": [
          "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
          "SELECT TIME_FORMAT('18:05:07', '%r');",
          "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "strftime(timestamp, format)",
        "description": "Formats a TIMESTAMP value using strftime with POSIX-like format strings.",
        "examples": [
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%H:%M:%S');",
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%I:%M:%S %p');",
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%M:%S');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_47_4",
    "database_name": "duckdb_47_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT TIME_FORMAT(\"01:00:00\", '%r'); -- TIME_FORMAT",
    "target_query": "SELECT strftime(TIMESTAMP '2000-01-01 01:00:00', '%I:%M:%S %p');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME_FORMAT(time, format)",
        "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
        "examples": [
          "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
          "SELECT TIME_FORMAT('18:05:07', '%r');",
          "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "strftime(timestamp, format)",
        "description": "Formats a TIMESTAMP value using strftime with POSIX-like format strings.",
        "examples": [
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%H:%M:%S');",
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%I:%M:%S %p');",
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%M:%S');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_47_6",
    "database_name": "duckdb_47_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT TIME_FORMAT(\"00:00:00\", '%l %p'); -- TIME_FORMAT",
    "target_query": "SELECT strftime(TIMESTAMP '2000-01-01 00:00:00', '%I %p');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME_FORMAT(time, format)",
        "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
        "examples": [
          "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
          "SELECT TIME_FORMAT('18:05:07', '%r');",
          "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "strftime(timestamp, format)",
        "description": "Formats a TIMESTAMP value using strftime with POSIX-like format strings.",
        "examples": [
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%H:%M:%S');",
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%I:%M:%S %p');",
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%M:%S');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_47_7",
    "database_name": "duckdb_47_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT TIME_FORMAT(\"01:00:00\", '%l %p'); -- TIME_FORMAT",
    "target_query": "SELECT strftime(TIMESTAMP '2000-01-01 01:00:00', '%I %p');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME_FORMAT(time, format)",
        "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
        "examples": [
          "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
          "SELECT TIME_FORMAT('18:05:07', '%r');",
          "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "strftime(timestamp, format)",
        "description": "Formats a TIMESTAMP value using strftime with POSIX-like format strings.",
        "examples": [
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%H:%M:%S');",
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%I:%M:%S %p');",
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%M:%S');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_47_8",
    "database_name": "duckdb_47_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT TIME_FORMAT(\"12:00:00\", '%l %p'); -- TIME_FORMAT",
    "target_query": "SELECT strftime(TIMESTAMP '2000-01-01 12:00:00', '%I %p');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME_FORMAT(time, format)",
        "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
        "examples": [
          "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
          "SELECT TIME_FORMAT('18:05:07', '%r');",
          "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "strftime(timestamp, format)",
        "description": "Formats a TIMESTAMP value using strftime with POSIX-like format strings.",
        "examples": [
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%H:%M:%S');",
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%I:%M:%S %p');",
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%M:%S');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_47_9",
    "database_name": "duckdb_47_9",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT TIME_FORMAT(\"23:00:00\", '%l %p'); -- TIME_FORMAT",
    "target_query": "SELECT strftime(TIMESTAMP '2000-01-01 23:00:00', '%I %p');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME_FORMAT(time, format)",
        "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
        "examples": [
          "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
          "SELECT TIME_FORMAT('18:05:07', '%r');",
          "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "strftime(timestamp, format)",
        "description": "Formats a TIMESTAMP value using strftime with POSIX-like format strings.",
        "examples": [
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%H:%M:%S');",
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%I:%M:%S %p');",
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%M:%S');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_47_10",
    "database_name": "duckdb_47_10",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT TIME_FORMAT(\"24:00:00\", '%l %p'); -- TIME_FORMAT",
    "target_query": "SELECT strftime(TIMESTAMP '2000-01-01 24:00:00', '%I %p'); -- Again, '24:00:00' means 00:00:00 of the next day.",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME_FORMAT(time, format)",
        "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
        "examples": [
          "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
          "SELECT TIME_FORMAT('18:05:07', '%r');",
          "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "strftime(timestamp, format)",
        "description": "Formats a TIMESTAMP value using strftime with POSIX-like format strings.",
        "examples": [
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%H:%M:%S');",
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%I:%M:%S %p');",
          "SELECT strftime(TIMESTAMP '2020-01-01 18:05:07', '%M:%S');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_47_13",
    "database_name": "duckdb_47_13",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select str_to_date('04 /30/2004', '%m /%d/%Y'); -- STR_TO_DATE",
    "target_query": "SELECT strptime('04 /30/2004', '%m /%d/%Y');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STR_TO_DATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STR_TO_DATE('09:22', '%H:%i')",
        "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
        "examples": [
          "SELECT STR_TO_DATE('12:45', '%H:%i');",
          "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
          "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "strptime('2000-01-01', '%Y-%m-%d')",
        "description": "Converts a string to a timestamp using the specified format, where '%Y-%m-%d' corresponds to the 'Year-Month-Day' format.",
        "examples": [
          "SELECT strptime('2000-01-01', '%Y-%m-%d');",
          "SELECT strptime('2023-05-06', '%Y-%m-%d');",
          "SELECT strptime('1999-12-31', '%Y-%m-%d');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_47_14",
    "database_name": "duckdb_47_14",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select str_to_date('04/30 /2004', '%m /%d /%Y'); -- STR_TO_DATE",
    "target_query": "SELECT strptime('04 /30 /2004', '%m /%d /%Y');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STR_TO_DATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STR_TO_DATE('09:22', '%H:%i')",
        "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
        "examples": [
          "SELECT STR_TO_DATE('12:45', '%H:%i');",
          "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
          "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "strptime('2000-01-01', '%Y-%m-%d')",
        "description": "Converts a string to a timestamp using the specified format, where '%Y-%m-%d' corresponds to the 'Year-Month-Day' format.",
        "examples": [
          "SELECT strptime('2000-01-01', '%Y-%m-%d');",
          "SELECT strptime('2023-05-06', '%Y-%m-%d');",
          "SELECT strptime('1999-12-31', '%Y-%m-%d');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_47_15",
    "database_name": "duckdb_47_15",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select str_to_date('04/30/2004 ', '%m/%d/%Y '); -- STR_TO_DATE",
    "target_query": "SELECT strptime('04/30/2004 ', '%m/%d/%Y ');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STR_TO_DATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STR_TO_DATE('09:22', '%H:%i')",
        "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
        "examples": [
          "SELECT STR_TO_DATE('12:45', '%H:%i');",
          "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
          "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "strptime('2000-01-01', '%Y-%m-%d')",
        "description": "Converts a string to a timestamp using the specified format, where '%Y-%m-%d' corresponds to the 'Year-Month-Day' format.",
        "examples": [
          "SELECT strptime('2000-01-01', '%Y-%m-%d');",
          "SELECT strptime('2023-05-06', '%Y-%m-%d');",
          "SELECT strptime('1999-12-31', '%Y-%m-%d');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_47_16",
    "database_name": "duckdb_47_16",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT DATE_FORMAT(\"0000-01-01\",'%W %d %M %Y') as valid_date; -- DATE_FORMAT",
    "target_query": "SELECT STRFTIME('2009-01-01'::DATE, '%W %d %B %Y') as valid_date;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "STRFTIME(date_expr, format_str)",
        "description": "Formats a date/time value using SQLite-compatible strftime format specifiers.",
        "examples": [
          "SELECT STRFTIME('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT STRFTIME(CURRENT_TIMESTAMP, '%Y-%m-%d %H:%M:%S');",
          "SELECT STRFTIME('2023-01-15 12:00:00', '%d-%m-%Y');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_47_17",
    "database_name": "duckdb_47_17",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT DATE_FORMAT(\"0000-02-28\",'%W %d %M %Y') as valid_date; -- DATE_FORMAT",
    "target_query": "SELECT STRFTIME('0000-02-28'::DATE, '%W %d %B %Y') as valid_date;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "STRFTIME(date_expr, format_str)",
        "description": "Formats a date/time value using SQLite-compatible strftime format specifiers.",
        "examples": [
          "SELECT STRFTIME('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT STRFTIME(CURRENT_TIMESTAMP, '%Y-%m-%d %H:%M:%S');",
          "SELECT STRFTIME('2023-01-15 12:00:00', '%d-%m-%Y');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_47_18",
    "database_name": "duckdb_47_18",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT DATE_FORMAT(\"2009-01-01\",'%W %d %M %Y') as valid_date; -- DATE_FORMAT",
    "target_query": "SELECT STRFTIME('2009-01-01'::DATE, '%W %d %B %Y') as valid_date;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "STRFTIME(date_expr, format_str)",
        "description": "Formats a date/time value using SQLite-compatible strftime format specifiers.",
        "examples": [
          "SELECT STRFTIME('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT STRFTIME(CURRENT_TIMESTAMP, '%Y-%m-%d %H:%M:%S');",
          "SELECT STRFTIME('2023-01-15 12:00:00', '%d-%m-%Y');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_48_0",
    "database_name": "duckdb_48_0",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT JSON_EXTRACT('{\"id\": \"3\", \"$name\": \"Barney\"}', \"$.id\"); -- JSON_EXTRACT",
    "target_query": "SELECT json_extract('{\"id\": \"3\", \"$name\": \"Barney\"}', '$.id'); -- JSON_EXTRACT",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "JSON_EXTRACT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "JSON_EXTRACT(json_doc, path)",
        "description": "Extracts data from a JSON document at the specified path(s). Supports dot notation and wildcards.",
        "examples": [
          "SELECT JSON_EXTRACT('{\"user\": {\"name\": \"Alice\"}}', '$.user.name');",
          "SELECT JSON_EXTRACT('{\"items\": [10, 20, 30]}', '$.items[1]');",
          "SELECT JSON_EXTRACT('{\"a\": {\"b\": [1, 2]}}', '$.a.b[0]');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "json_extract(json, path)",
        "description": "Extracts data from a JSON string using a JSONPath-style expression. Similar to MySQL.",
        "examples": [
          "SELECT json_extract('{\"user\": {\"name\": \"Alice\"}}', '$.user.name');",
          "SELECT json_extract('{\"items\": [10, 20, 30]}', '$.items[1]');",
          "SELECT json_extract('{\"a\": {\"b\": [1, 2]}}', '$.a.b[0]');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_48_1",
    "database_name": "duckdb_48_1",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT JSON_EXTRACT('{\"id\": \"3\", \"$name\": \"$Barney\"}', \"$.$name\"); -- JSON_EXTRACT",
    "target_query": "SELECT json_extract('{\"id\": \"3\", \"$name\": \"$Barney\"}', '.$name'); -- JSON_EXTRACT",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "JSON_EXTRACT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "JSON_EXTRACT(json_doc, path)",
        "description": "Extracts data from a JSON document at the specified path(s). Supports dot notation and wildcards.",
        "examples": [
          "SELECT JSON_EXTRACT('{\"user\": {\"name\": \"Alice\"}}', '$.user.name');",
          "SELECT JSON_EXTRACT('{\"items\": [10, 20, 30]}', '$.items[1]');",
          "SELECT JSON_EXTRACT('{\"a\": {\"b\": [1, 2]}}', '$.a.b[0]');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "json_extract(json, path)",
        "description": "Extracts data from a JSON string using a JSONPath-style expression. Similar to MySQL.",
        "examples": [
          "SELECT json_extract('{\"user\": {\"name\": \"Alice\"}}', '$.user.name');",
          "SELECT json_extract('{\"items\": [10, 20, 30]}', '$.items[1]');",
          "SELECT json_extract('{\"a\": {\"b\": [1, 2]}}', '$.a.b[0]');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_49_5",
    "database_name": "duckdb_49_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select concat('|', text1, '|') as c from t1 where text1='teststring' or text1 like 'teststring_%' order by c; -- CONCAT",
    "target_query": "select concat('|', text1, '|') as c from t1 where text1='teststring' or text1 like 'teststring_%' order by c;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);",
      "alter table t1 modify text1 char(32) binary not null;"
    ],
    "target_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);",
      "ALTER TABLE t1 ALTER COLUMN text1 TYPE VARCHAR(32);"
    ]
  },
  {
    "sql_id": "duckdb_49_6",
    "database_name": "duckdb_49_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select concat('|', text1, '|') from t1 where text1='teststring' or text1 > 'teststring\\\\t'; -- CONCAT",
    "target_query": "select concat('|', text1, '|') from t1 where text1='teststring' or text1 > 'teststring\\\\t';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);",
      "alter table t1 modify text1 char(32) binary not null;"
    ],
    "target_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);",
      "ALTER TABLE t1 ALTER COLUMN text1 TYPE VARCHAR(32);"
    ]
  },
  {
    "sql_id": "duckdb_49_7",
    "database_name": "duckdb_49_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select text1, length(text1) from t1 order by text1; -- LENGTH",
    "target_query": "select text1, length(text1) from t1 order by text1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);",
      "alter table t1 modify text1 char(32) binary not null;"
    ],
    "target_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);",
      "ALTER TABLE t1 ALTER COLUMN text1 TYPE VARCHAR(32);"
    ]
  },
  {
    "sql_id": "duckdb_49_9",
    "database_name": "duckdb_49_9",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select concat('|', text1, '|') from t1 order by text1; -- CONCAT",
    "target_query": "select concat('|', text1, '|') from t1 order by text1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);",
      "alter table t1 modify text1 char(32) binary not null;"
    ],
    "target_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);",
      "ALTER TABLE t1 ALTER COLUMN text1 TYPE VARCHAR(32);"
    ]
  },
  {
    "sql_id": "duckdb_49_10",
    "database_name": "duckdb_49_10",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select concat('|', text1, '|') from t1 where text1='teststring' or text1 > 'teststring\\\\t'; -- CONCAT",
    "target_query": "select concat('|', text1, '|') from t1 where text1='teststring' or text1 > 'teststring\\\\t';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);",
      "alter table t1 modify text1 char(32) binary not null;"
    ],
    "target_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);",
      "ALTER TABLE t1 ALTER COLUMN text1 TYPE VARCHAR(32);"
    ]
  },
  {
    "sql_id": "duckdb_49_11",
    "database_name": "duckdb_49_11",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select concat('|', text1, '|') from t1 where text1='teststring'; -- CONCAT",
    "target_query": "select concat('|', text1, '|') from t1 where text1='teststring';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);",
      "alter table t1 modify text1 char(32) binary not null;"
    ],
    "target_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);",
      "ALTER TABLE t1 ALTER COLUMN text1 TYPE VARCHAR(32);"
    ]
  },
  {
    "sql_id": "duckdb_49_12",
    "database_name": "duckdb_49_12",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select concat('|', text1, '|') from t1 where text1='teststring '; -- CONCAT",
    "target_query": "select concat('|', text1, '|') from t1 where text1='teststring ';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);",
      "alter table t1 modify text1 char(32) binary not null;"
    ],
    "target_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);",
      "ALTER TABLE t1 ALTER COLUMN text1 TYPE VARCHAR(32);"
    ]
  },
  {
    "sql_id": "duckdb_50_3",
    "database_name": "duckdb_50_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT CONCAT(\"Let's create some new events from the name of \", USER()); -- CONCAT, USER",
    "target_query": "SELECT CONCAT('Let''s create some new events from the name of ', '');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT",
      "USER"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      },
      {
        "expression": "USER()",
        "description": "Returns the current MySQL user and host in the format 'username@hostname'.",
        "examples": [
          "SELECT USER();"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      },
      {
        "expression": "",
        "description": "",
        "examples": []
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_51_2",
    "database_name": "duckdb_51_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 VALUES ( 2, REPEAT('-', 104) ); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES ( 2, REPEAT('-', 104) );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (f1 INTEGER,f2 LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (f1 INTEGER,f2 BLOB);"
    ]
  },
  {
    "sql_id": "duckdb_51_3",
    "database_name": "duckdb_51_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 VALUES ( 1, REPEAT('x', 104) ); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES ( 1, REPEAT('x', 104) );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (f1 INTEGER,f2 LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (f1 INTEGER,f2 BLOB);"
    ]
  },
  {
    "sql_id": "duckdb_51_7",
    "database_name": "duckdb_51_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT CONCAT(f1, '') AS dummy FROM t1 ORDER BY dummy; -- CONCAT",
    "target_query": "SELECT CONCAT(f1, '') AS dummy FROM t1 ORDER BY dummy;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( f1 VARCHAR(100) );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( f1 VARCHAR(100) );"
    ]
  },
  {
    "sql_id": "duckdb_51_11",
    "database_name": "duckdb_51_11",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT * FROM t1 ORDER BY UNIX_TIMESTAMP(f1); -- UNIX_TIMESTAMP",
    "target_query": "SELECT * FROM t1 ORDER BY EXTRACT(EPOCH FROM f1);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(EPOCH FROM timestamp)",
        "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
        "examples": [
          "SELECT EXTRACT(EPOCH FROM current_timestamp);",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
          "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( f1 INTEGER );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(f1 DATE);"
    ]
  },
  {
    "sql_id": "duckdb_51_15",
    "database_name": "duckdb_51_15",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT 'a' AS f1 FROM t1 WHERE a='8' GROUP BY f1 ORDER BY CONCAT(f1); -- CONCAT",
    "target_query": "SELECT 'a' AS f1 FROM t1 WHERE a='8' GROUP BY f1 ORDER BY CONCAT(f1);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a TEXT);"
    ]
  },
  {
    "sql_id": "duckdb_51_18",
    "database_name": "duckdb_51_18",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 VALUES (1, REPEAT('x', 40001)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (1, REPEAT('x', 40001));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ]
  },
  {
    "sql_id": "duckdb_51_19",
    "database_name": "duckdb_51_19",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 VALUES (2, REPEAT('x', 40002)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (2, REPEAT('x', 40002));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ]
  },
  {
    "sql_id": "duckdb_51_20",
    "database_name": "duckdb_51_20",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 VALUES (3, REPEAT('x', 40003)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (3, REPEAT('x', 40003));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ]
  },
  {
    "sql_id": "duckdb_51_21",
    "database_name": "duckdb_51_21",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 VALUES (4, REPEAT('x', 40005)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (4, REPEAT('x', 40005));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ]
  },
  {
    "sql_id": "duckdb_51_22",
    "database_name": "duckdb_51_22",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 VALUES (5, REPEAT('x', 40008)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (5, REPEAT('x', 40008));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ]
  },
  {
    "sql_id": "duckdb_51_23",
    "database_name": "duckdb_51_23",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 VALUES (6, REPEAT('x', 40013)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (6, REPEAT('x', 40013));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ]
  },
  {
    "sql_id": "duckdb_51_24",
    "database_name": "duckdb_51_24",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT a, LENGTH(b) FROM t1 ORDER BY a DESC; -- LENGTH",
    "target_query": "SELECT a, length(b) FROM t1 ORDER BY a DESC;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ]
  },
  {
    "sql_id": "duckdb_52_13",
    "database_name": "duckdb_52_13",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) > 3; -- LENGTH",
    "target_query": "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) > 3;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(col1_idx INT DEFAULT NULL,col2_idx INT DEFAULT NULL,col3 INT DEFAULT NULL,col4 INT NOT NULL,vc VARCHAR(30),vc_ft VARCHAR(30));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(col1_idx INT DEFAULT NULL,col2_idx INT DEFAULT NULL,col3 INT DEFAULT NULL,col4 INT NOT NULL,vc VARCHAR(30),vc_ft VARCHAR(30));"
    ]
  },
  {
    "sql_id": "duckdb_52_14",
    "database_name": "duckdb_52_14",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) = 3; -- LENGTH",
    "target_query": "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) = 3;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(col1_idx INT DEFAULT NULL,col2_idx INT DEFAULT NULL,col3 INT DEFAULT NULL,col4 INT NOT NULL,vc VARCHAR(30),vc_ft VARCHAR(30));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(col1_idx INT DEFAULT NULL,col2_idx INT DEFAULT NULL,col3 INT DEFAULT NULL,col4 INT NOT NULL,vc VARCHAR(30),vc_ft VARCHAR(30));"
    ]
  },
  {
    "sql_id": "duckdb_52_15",
    "database_name": "duckdb_52_15",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) IS NULL; -- LENGTH",
    "target_query": "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) IS NULL;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(col1_idx INT DEFAULT NULL,col2_idx INT DEFAULT NULL,col3 INT DEFAULT NULL,col4 INT NOT NULL,vc VARCHAR(30),vc_ft VARCHAR(30));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(col1_idx INT DEFAULT NULL,col2_idx INT DEFAULT NULL,col3 INT DEFAULT NULL,col4 INT NOT NULL,vc VARCHAR(30),vc_ft VARCHAR(30));"
    ]
  },
  {
    "sql_id": "duckdb_52_16",
    "database_name": "duckdb_52_16",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) IS NOT NULL; -- LENGTH",
    "target_query": "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) IS NOT NULL;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(col1_idx INT DEFAULT NULL,col2_idx INT DEFAULT NULL,col3 INT DEFAULT NULL,col4 INT NOT NULL,vc VARCHAR(30),vc_ft VARCHAR(30));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(col1_idx INT DEFAULT NULL,col2_idx INT DEFAULT NULL,col3 INT DEFAULT NULL,col4 INT NOT NULL,vc VARCHAR(30),vc_ft VARCHAR(30));"
    ]
  },
  {
    "sql_id": "duckdb_53_12",
    "database_name": "duckdb_53_12",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t VALUES(REPEAT(x'0a',1000)); -- REPEAT",
    "target_query": "INSERT INTO t VALUES(REPEAT(x'0a',1000)::BLOB);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t(b BLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t(b BLOB);"
    ]
  },
  {
    "sql_id": "duckdb_53_15",
    "database_name": "duckdb_53_15",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t VALUES(1, REPEAT('2', 257)), (1, REPEAT('1', 257)); -- REPEAT",
    "target_query": "INSERT INTO t VALUES(1,REPEAT('2',257)::BLOB),(1,REPEAT('1',257)::BLOB);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t (gid int, a varbinary(514));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t (gid int,a varbinary);"
    ]
  },
  {
    "sql_id": "duckdb_53_18",
    "database_name": "duckdb_53_18",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t VALUES(1, REPEAT('2', 255)), (1, REPEAT('1', 255)); -- REPEAT",
    "target_query": "INSERT INTO t VALUES(1,REPEAT('2',255)::BLOB),(1,REPEAT('1',255)::BLOB);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t (gid int, a varbinary(511));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t (gid int,a varbinary);"
    ]
  },
  {
    "sql_id": "duckdb_53_21",
    "database_name": "duckdb_53_21",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t VALUES(1, REPEAT('2', 32750), REPEAT('1', 32750)); -- REPEAT",
    "target_query": "INSERT INTO t VALUES(1,REPEAT('2',32750),REPEAT('1',32750));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t (gid int, a varbinary(65500), b blob);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t (gid int,a varbinary,b blob);"
    ]
  },
  {
    "sql_id": "duckdb_54_2",
    "database_name": "duckdb_54_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "insert t1 values (NULL), ('A\\0\\0\\0BBBBBBBB'), (SPACE(50000)), (SPACE(50000)); -- SPACE",
    "target_query": "INSERT INTO t1 VALUES (NULL), (X'410000004242424242424242'), (REPEAT(' ', 50000)::BLOB), (REPEAT(' ', 50000)::BLOB);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "SPACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SPACE(n)",
        "description": "Returns a string consisting of n space characters.",
        "examples": [
          "SELECT LENGTH(SPACE(5));",
          "SELECT CONCAT('A', SPACE(3), 'B');",
          "SELECT CONCAT(REPEAT('-', 2), SPACE(4), '!');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(' ', n)",
        "description": "Returns a string consisting of n space characters by repeating a space character.",
        "examples": [
          "SELECT LENGTH(REPEAT(' ', 5));",
          "SELECT CONCAT('A', REPEAT(' ', 3), 'B');",
          "SELECT CONCAT(REPEAT('-', 2), REPEAT(' ', 4), '!');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a BLOB);"
    ],
    "target_related_schemas": [
      "create table t1 (a BLOB);"
    ]
  },
  {
    "sql_id": "duckdb_54_3",
    "database_name": "duckdb_54_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select length(a) from t1; -- LENGTH",
    "target_query": "SELECT OCTET_LENGTH(a) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a BLOB);"
    ],
    "target_related_schemas": [
      "create table t1 (a BLOB);"
    ]
  },
  {
    "sql_id": "duckdb_55_3",
    "database_name": "duckdb_55_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select * from t1 where concat(A,C,B,D) = 'AAAA2003-03-011051'; -- CONCAT",
    "target_query": "SELECT * FROM t1 WHERE concat(a, c, b, d) = 'AAAA2003-03-011051';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a char(4), b double, c date, d tinyint(4));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a char(4), b double, c date, d tinyint);"
    ]
  },
  {
    "sql_id": "duckdb_55_5",
    "database_name": "duckdb_55_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select 'a' union select concat('a', -4); -- CONCAT",
    "target_query": "SELECT 'a' UNION SELECT concat('a', -4);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_55_6",
    "database_name": "duckdb_55_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select 'a' union select concat('a', -4.5); -- CONCAT",
    "target_query": "SELECT 'a' UNION SELECT concat('a', -4.5);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_55_7",
    "database_name": "duckdb_55_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select 'a' union select concat('a', -(4 + 1)); -- CONCAT",
    "target_query": "SELECT 'a' UNION SELECT concat('a', -(4 + 1));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_55_8",
    "database_name": "duckdb_55_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select 'a' union select concat('a', 4 - 5); -- CONCAT",
    "target_query": "SELECT 'a' UNION SELECT concat('a', 4 - 5);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_55_11",
    "database_name": "duckdb_55_11",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select 'a' union select concat('a', -0); -- CONCAT",
    "target_query": "SELECT 'a' UNION SELECT concat('a', -0);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_55_12",
    "database_name": "duckdb_55_12",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select 'a' union select concat('a', -0.0); -- CONCAT",
    "target_query": "SELECT 'a' UNION SELECT concat('a', -0.0);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_55_13",
    "database_name": "duckdb_55_13",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select 'a' union select concat('a', -0.0000); -- CONCAT",
    "target_query": "SELECT 'a' UNION SELECT concat('a', -0.0000);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_55_14",
    "database_name": "duckdb_55_14",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select concat((select x from (select 'a' as x) as t1 ),(select y from (select 'b' as y) as t2 )) from (select 1 union select 2 )as t3; -- CONCAT",
    "target_query": "SELECT concat((SELECT x FROM (SELECT 'a' AS x) AS t1), (SELECT y FROM (SELECT 'b' AS y) AS t2)) FROM (SELECT 1 UNION SELECT 2) AS t3;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_55_17",
    "database_name": "duckdb_55_17",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select concat(f1, 2) a from t1 union select 'x' a from t1; -- CONCAT",
    "target_query": "SELECT concat(f1, 2) a FROM t1 UNION SELECT 'x' a FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1(f1 varchar(6));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(f1 varchar(6));"
    ]
  },
  {
    "sql_id": "duckdb_55_21",
    "database_name": "duckdb_55_21",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT * FROM t1 WHERE CONCAT(c1,' ',c2) REGEXP 'First.*'; -- CONCAT",
    "target_query": "SELECT * FROM t1 WHERE CONCAT(c1, ' ', c2) ~ 'First.*';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (c1 varchar(100), c2 varchar(100));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 varchar(100), c2 varchar(100));"
    ]
  },
  {
    "sql_id": "duckdb_56_2",
    "database_name": "duckdb_56_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "insert into t1 values (date_add(NULL, INTERVAL 1 DAY)); -- DATE_ADD",
    "target_query": "insert into t1 values (CAST(NULL AS DATE) + INTERVAL '1 day');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_ADD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_ADD(datetime_expr, INTERVAL expr unit)",
        "description": "Adds a time interval to a date or datetime value.",
        "examples": [
          "SELECT DATE_ADD('2020-01-01', INTERVAL 10 DAY);",
          "SELECT DATE_ADD('2020-01-01 12:00:00', INTERVAL 3 HOUR);",
          "SELECT DATE_ADD('2020-12-31', INTERVAL 1 MONTH);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "datetime + INTERVAL 'expr unit'",
        "description": "Adds an interval to a datetime using SQL-standard interval literals.",
        "examples": [
          "SELECT TIMESTAMP '2020-01-01' + INTERVAL '10 days';",
          "SELECT TIMESTAMP '2020-01-01 12:00:00' + INTERVAL '3 hours';",
          "SELECT TIMESTAMP '2020-12-31' + INTERVAL '1 month';"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (d date);"
    ],
    "target_related_schemas": [
      "create table t1 (d date);"
    ]
  },
  {
    "sql_id": "duckdb_56_3",
    "database_name": "duckdb_56_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "insert into t1 values (date_add('2000-01-04', INTERVAL NULL DAY)); -- DATE_ADD",
    "target_query": "insert into t1 values (CAST('2000-01-04' AS DATE) + INTERVAL '1 day');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_ADD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_ADD(datetime_expr, INTERVAL expr unit)",
        "description": "Adds a time interval to a date or datetime value.",
        "examples": [
          "SELECT DATE_ADD('2020-01-01', INTERVAL 10 DAY);",
          "SELECT DATE_ADD('2020-01-01 12:00:00', INTERVAL 3 HOUR);",
          "SELECT DATE_ADD('2020-12-31', INTERVAL 1 MONTH);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "datetime + INTERVAL 'expr unit'",
        "description": "Adds an interval to a datetime using SQL-standard interval literals.",
        "examples": [
          "SELECT TIMESTAMP '2020-01-01' + INTERVAL '10 days';",
          "SELECT TIMESTAMP '2020-01-01 12:00:00' + INTERVAL '3 hours';",
          "SELECT TIMESTAMP '2020-12-31' + INTERVAL '1 month';"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (d date);"
    ],
    "target_related_schemas": [
      "create table t1 (d date);"
    ]
  },
  {
    "sql_id": "duckdb_56_4",
    "database_name": "duckdb_56_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "insert into t1 values (date_add(NULL, INTERVAL 1 DAY)); -- DATE_ADD",
    "target_query": "insert into t1 values (CAST(NULL AS DATE) + INTERVAL '1 day');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_ADD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_ADD(datetime_expr, INTERVAL expr unit)",
        "description": "Adds a time interval to a date or datetime value.",
        "examples": [
          "SELECT DATE_ADD('2020-01-01', INTERVAL 10 DAY);",
          "SELECT DATE_ADD('2020-01-01 12:00:00', INTERVAL 3 HOUR);",
          "SELECT DATE_ADD('2020-12-31', INTERVAL 1 MONTH);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "datetime + INTERVAL 'expr unit'",
        "description": "Adds an interval to a datetime using SQL-standard interval literals.",
        "examples": [
          "SELECT TIMESTAMP '2020-01-01' + INTERVAL '10 days';",
          "SELECT TIMESTAMP '2020-01-01 12:00:00' + INTERVAL '3 hours';",
          "SELECT TIMESTAMP '2020-12-31' + INTERVAL '1 month';"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (d date);"
    ],
    "target_related_schemas": [
      "create table t1 (d date);"
    ]
  },
  {
    "sql_id": "duckdb_56_5",
    "database_name": "duckdb_56_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "insert into t1 values (date_add('2000-01-04', INTERVAL 1 DAY)); -- DATE_ADD",
    "target_query": "insert into t1 values (CAST('2000-01-04' AS DATE) + INTERVAL '1 day');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_ADD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_ADD(datetime_expr, INTERVAL expr unit)",
        "description": "Adds a time interval to a date or datetime value.",
        "examples": [
          "SELECT DATE_ADD('2020-01-01', INTERVAL 10 DAY);",
          "SELECT DATE_ADD('2020-01-01 12:00:00', INTERVAL 3 HOUR);",
          "SELECT DATE_ADD('2020-12-31', INTERVAL 1 MONTH);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "datetime + INTERVAL 'expr unit'",
        "description": "Adds an interval to a datetime using SQL-standard interval literals.",
        "examples": [
          "SELECT TIMESTAMP '2020-01-01' + INTERVAL '10 days';",
          "SELECT TIMESTAMP '2020-01-01 12:00:00' + INTERVAL '3 hours';",
          "SELECT TIMESTAMP '2020-12-31' + INTERVAL '1 month';"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (d date);"
    ],
    "target_related_schemas": [
      "create table t1 (d date);"
    ]
  },
  {
    "sql_id": "duckdb_56_7",
    "database_name": "duckdb_56_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT DATE(ts) = CURRENT_DATE + INTERVAL '1' DAY AS is_tomorrow, TIME(ts)FROM (SELECT ADDDATE(TIME'00:00:00', INTERVAL 1 DAY) AS ts) AS dt; -- DATE",
    "target_query": "SELECT ((CURRENT_DATE + ts)::DATE = CURRENT_DATE + INTERVAL '1 day') AS is_tomorrow,ts FROM (SELECT TIME '00:00:00' + INTERVAL '1 day' AS ts) AS dt;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE()",
        "description": "In MySQL, the DATE function extracts the date part from a DATETIME or TIMESTAMP value.",
        "examples": [
          "SELECT DATE('2023-05-01 12:34:56') AS result;",
          "SELECT DATE(NOW()) AS current_date_result;",
          "SELECT DATE(CAST('2023-05-01' AS DATETIME)) AS date_from_datetime;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CAST()",
        "description": "DuckDB supports the CAST function to extract a DATE from a TIMESTAMP or DATETIME.",
        "examples": [
          "SELECT CAST('2023-05-01 12:34:56' AS DATE) AS result;",
          "SELECT CURRENT_DATE AS current_date_result;",
          "SELECT CAST('2023-05-01' AS DATE) AS date_from_datetime;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_57_3",
    "database_name": "duckdb_57_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select * from t1 where isnull(to_days(mydate)); -- ISNULL, TO_DAYS",
    "target_query": "SELECT * FROM t1 WHERE mydate IS NULL AND DATEDIFF('day', DATE '1970-01-01', mydate) + 719528 IS NULL;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ISNULL",
      "TO_DAYS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ISNULL(expr)",
        "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
        "examples": [
          "SELECT ISNULL(NULL);",
          "SELECT ISNULL(5 + NULL);",
          "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
        ]
      },
      {
        "expression": "TO_DAYS(date)",
        "description": "Returns the number of days since 0000-01-01 for a given date.",
        "examples": [
          "SELECT TO_DAYS('2024-05-07');",
          "SELECT TO_DAYS(CURDATE());",
          "SELECT TO_DAYS('1999-12-31 23:59:59');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "expr IS NULL",
        "description": "Tests whether the expression evaluates to NULL.",
        "examples": [
          "SELECT NULL IS NULL;",
          "SELECT ('abc' || NULL) IS NULL;",
          "SELECT CASE WHEN status IS NULL THEN 'unknown' ELSE status END FROM orders;"
        ]
      },
      {
        "expression": "DATEDIFF('day', DATE '1970-01-01', date) + 719528",
        "description": "Computes the number of days since 0000-01-01 by offsetting from 1970-01-01.",
        "examples": [
          "SELECT DATEDIFF('day', DATE '1970-01-01', DATE '2024-05-07') + 719528;",
          "SELECT DATEDIFF('day', DATE '1970-01-01', CURRENT_DATE) + 719528;",
          "SELECT DATEDIFF('day', DATE '1970-01-01', DATE '1999-12-31') + 719528;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (id int primary key not null, mydate date not null);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id INT AUTOINCREMENT PRIMARY KEY NOT NULL, mydate DATE NOT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_57_13",
    "database_name": "duckdb_57_13",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select * from t3 left join(t2 outr2 join t2 outr join t1)on (outr.pk = t3.pk) and (t1.col_int_key = t3.pk) and isnull(t1.col_date_key)and (outr2.pk <> t3.pk); -- ISNULL",
    "target_query": "SELECT * FROM t3 LEFT JOIN (t2 outr2 JOIN t2 outr JOIN t1) ON (outr.pk = t3.pk) AND (t1.col_int_key = t3.pk) AND t1.col_date_key IS NULL AND (outr2.pk <> t3.pk);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ISNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ISNULL(expr)",
        "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
        "examples": [
          "SELECT ISNULL(NULL);",
          "SELECT ISNULL(5 + NULL);",
          "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "expr IS NULL",
        "description": "Tests whether the expression evaluates to NULL.",
        "examples": [
          "SELECT NULL IS NULL;",
          "SELECT ('abc' || NULL) IS NULL;",
          "SELECT CASE WHEN status IS NULL THEN 'unknown' ELSE status END FROM orders;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t3(pk INT NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t3 (pk INT NOT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_57_14",
    "database_name": "duckdb_57_14",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select * from t3 join(t2 outr2 join t2 outr join t1)on (outr.pk = t3.pk) and (t1.col_int_key = t3.pk) and isnull(t1.col_date_key)and (outr2.pk <> t3.pk) ; -- ISNULL",
    "target_query": "SELECT * FROM t3 JOIN (t2 outr2 JOIN t2 outr JOIN t1) ON (outr.pk = t3.pk) AND (t1.col_int_key = t3.pk) AND t1.col_date_key IS NULL AND (outr2.pk <> t3.pk);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ISNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ISNULL(expr)",
        "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
        "examples": [
          "SELECT ISNULL(NULL);",
          "SELECT ISNULL(5 + NULL);",
          "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "expr IS NULL",
        "description": "Tests whether the expression evaluates to NULL.",
        "examples": [
          "SELECT NULL IS NULL;",
          "SELECT ('abc' || NULL) IS NULL;",
          "SELECT CASE WHEN status IS NULL THEN 'unknown' ELSE status END FROM orders;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t3(pk INT NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t3 (pk INT NOT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_58_4",
    "database_name": "duckdb_58_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "explain select * from t1 where a like concat('abc','%'); -- CONCAT",
    "target_query": "explain select * from t1 where a like concat('abc','%');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a varchar(10));"
    ],
    "target_related_schemas": [
      "create table t1 (a varchar(10));"
    ]
  },
  {
    "sql_id": "duckdb_58_5",
    "database_name": "duckdb_58_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select * from t1 where a like concat(\"abc\",\"%\"); -- CONCAT",
    "target_query": "select * from t1 where a like concat('abc','%');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a varchar(10));"
    ],
    "target_related_schemas": [
      "create table t1 (a varchar(10));"
    ]
  },
  {
    "sql_id": "duckdb_59_0",
    "database_name": "duckdb_59_0",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL); -- LN",
    "target_query": "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LN"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LN(x)",
        "description": "The LN() function returns the natural logarithm of x. If x is less than or equal to 0, it returns NULL.",
        "examples": [
          "select ln(exp(10));",
          "select exp(ln(sqrt(10)) * 2);",
          "select ln(-1);",
          "select ln(0);",
          "select ln(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LN(x)",
        "description": "In DuckDB, the LN() function also returns the natural logarithm of x, with NaN returned for non-positive values.",
        "examples": [
          "select ln(exp(10));",
          "select exp(ln(sqrt(10)) * 2);",
          "select ln(NULL);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_59_1",
    "database_name": "duckdb_59_1",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select log2(8),log2(15),log2(NULL); -- LOG2",
    "target_query": "select log2(8),log2(15),log2(NULL);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LOG2"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LOG2(number)",
        "description": "Returns the logarithm of a number with base 2. Returns NULL for zero or negative numbers.",
        "examples": [
          "SELECT LOG2(8);",
          "SELECT LOG2(15);",
          "SELECT LOG2(-2);",
          "SELECT LOG2(0);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LOG2(number)",
        "description": "Returns the logarithm of a number with base 2. Returns NULL for zero or negative numbers.",
        "examples": [
          "SELECT LOG2(8);",
          "SELECT LOG2(15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_59_2",
    "database_name": "duckdb_59_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select pow(10,log10(10)),power(2,4); -- POW, POWER",
    "target_query": "select pow(10,log10(10)),pow(2,4);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "POW",
      "POWER"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "POW(3, 3)",
        "description": "POW(x, y) in MySQL is used to calculate x raised to the power of y. It returns the result of x^y.",
        "examples": [
          "SELECT POW(3, 3);",
          "SELECT POW(5, 4);",
          "SELECT POW(x, 2) FROM some_table;"
        ]
      },
      {
        "expression": "SELECT POW(10, 2), POWER(2, 3), POWER(3, 3);",
        "description": "Calculates the power of a number: POW(10, 2) returns 100, POWER(2, 3) returns 8, POWER(3, 3) returns 27.",
        "examples": [
          "SELECT POW(5, 2);",
          "SELECT POWER(3, 4);",
          "SELECT POWER(10, 0);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POW(3, 3)",
        "description": "DuckDB supports the POW() function to calculate x raised to the power of y.",
        "examples": [
          "SELECT POW(3, 3);",
          "SELECT POW(5, 4);",
          "SELECT POW(x, 2) FROM some_table;"
        ]
      },
      {
        "expression": "SELECT POW(10, 2), POW(2, 3), POW(3, 3);",
        "description": "Calculates the power of a number: POW(10, 2) returns 100, POW(2, 3) returns 8, POW(3, 3) returns 27.",
        "examples": [
          "SELECT POW(5, 2);",
          "SELECT POW(3, 4);",
          "SELECT POW(10, 0);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_59_3",
    "database_name": "duckdb_59_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select ceil(0.09); -- CEIL",
    "target_query": "select ceil(0.09);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CEIL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CEIL(x)",
        "description": "Returns the smallest integer value not less than x (rounds up).",
        "examples": [
          "SELECT CEIL(1.3);",
          "SELECT CEIL(-2.8);",
          "SELECT CEIL(RAND() * 100);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CEIL(x)",
        "description": "Returns the smallest integer value not less than the input number.",
        "examples": [
          "SELECT CEIL(1.3);",
          "SELECT CEIL(-2.8);",
          "SELECT CEIL(RANDOM() * 100);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_59_4",
    "database_name": "duckdb_59_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select ceil(0.000000000000000009); -- CEIL",
    "target_query": "select ceil(0.000000000000000009);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CEIL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CEIL(x)",
        "description": "Returns the smallest integer value not less than x (rounds up).",
        "examples": [
          "SELECT CEIL(1.3);",
          "SELECT CEIL(-2.8);",
          "SELECT CEIL(RAND() * 100);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CEIL(x)",
        "description": "Returns the smallest integer value not less than the input number.",
        "examples": [
          "SELECT CEIL(1.3);",
          "SELECT CEIL(-2.8);",
          "SELECT CEIL(RANDOM() * 100);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_59_7",
    "database_name": "duckdb_59_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "insert into t1 values ('http://www.foo.com/', now()); -- NOW",
    "target_query": "insert into t1 values ('http://www.foo.com/', current_timestamp);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "DuckDB also uses CURRENT_TIMESTAMP to get the current date and time, similar to PostgreSQL and MonetDB.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a varchar(90), ts datetime not null);"
    ],
    "target_related_schemas": [
      "create table t1 (a varchar(90), ts timestamp not null);"
    ]
  },
  {
    "sql_id": "duckdb_59_8",
    "database_name": "duckdb_59_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select a from t1 where a='http://www.foo.com/' order by abs(timediff(ts, 0)); -- TIMEDIFF",
    "target_query": "SELECT a FROM t1 WHERE a = 'http://www.foo.com/' ORDER BY ABS(EXTRACT(EPOCH FROM (ts - timestamp '1970-01-01 00:00:00')));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00'",
        "description": "DuckDB supports direct subtraction between timestamps to calculate the difference, returning the result as an interval.",
        "examples": [
          "SELECT TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00';",
          "SELECT CURRENT_TIMESTAMP - TIMESTAMP '2023-06-15 10:00:00';",
          "SELECT TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00';"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a varchar(90), ts datetime not null);"
    ],
    "target_related_schemas": [
      "create table t1 (a varchar(90), ts timestamp not null);"
    ]
  },
  {
    "sql_id": "duckdb_59_10",
    "database_name": "duckdb_59_10",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select mod(cast(-2 as unsigned), 3), mod(18446744073709551614, 3), mod(-2, 3); -- MOD",
    "target_query": "select mod(cast(-2 as bigint), 3), mod(18446744073709551614, 3), mod(-2, 3);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MOD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Returns the remainder of N divided by M. Returns NULL if M = 0.",
        "examples": [
          "SELECT MOD(10, 3);",
          "SELECT 10 % 3;",
          "SELECT MOD(5, 0);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Computes the modulo operation. Division by 0 throws error.",
        "examples": [
          "SELECT MOD(13, 4);",
          "SELECT 13 % 4;",
          "SELECT MOD(3, 0);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_59_11",
    "database_name": "duckdb_59_11",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select mod(5, cast(-2 as unsigned)), mod(5, 18446744073709551614), mod(5, -2); -- MOD",
    "target_query": "select mod(5, cast(-2 as bigint)), mod(5, 18446744073709551614), mod(5, -2);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MOD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Returns the remainder of N divided by M. Returns NULL if M = 0.",
        "examples": [
          "SELECT MOD(10, 3);",
          "SELECT 10 % 3;",
          "SELECT MOD(5, 0);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Computes the modulo operation. Division by 0 throws error.",
        "examples": [
          "SELECT MOD(13, 4);",
          "SELECT 13 % 4;",
          "SELECT MOD(3, 0);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_59_12",
    "database_name": "duckdb_59_12",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select pow(cast(-2 as unsigned), 5), pow(18446744073709551614, 5), pow(-2, 5); -- POW",
    "target_query": "select pow(cast(-2 as bigint), 5), pow(18446744073709551614, 5), pow(-2, 5);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "POW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "POW(3, 3)",
        "description": "POW(x, y) in MySQL is used to calculate x raised to the power of y. It returns the result of x^y.",
        "examples": [
          "SELECT POW(3, 3);",
          "SELECT POW(5, 4);",
          "SELECT POW(x, 2) FROM some_table;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POW(3, 3)",
        "description": "DuckDB supports the POW() function to calculate x raised to the power of y.",
        "examples": [
          "SELECT POW(3, 3);",
          "SELECT POW(5, 4);",
          "SELECT POW(x, 2) FROM some_table;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_60_0",
    "database_name": "duckdb_60_0",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT ROUND(LEAST(15, -4939092, 0.2704)); -- LEAST, STDDEV",
    "target_query": "SELECT ROUND(least(15, -4939092, 0.2704));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST",
      "STDDEV"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      },
      {
        "expression": "STDDEV(amount)",
        "description": "The STDDEV function calculates the standard deviation of a numeric column in a database. It returns a measure of the amount of variation or dispersion of a set of values.",
        "examples": [
          "SELECT STDDEV(amount) FROM sales;",
          "SELECT STDDEV(amount) OVER (ROWS 2 PRECEDING) FROM sales;",
          "SELECT id, STDDEV(amount) OVER (PARTITION BY region ORDER BY amount) AS region_stddev FROM sales;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the least non-null value among the provided expressions. NULLs are skipped unless all arguments are NULL. This differs from MySQL/MariaDB which return NULL if any argument is NULL.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(DATE '2024-01-01', DATE '2023-12-31');",
          "SELECT least(NULL, 2);"
        ]
      },
      {
        "expression": "STDDEV(amount)",
        "description": "DuckDB uses the STDDEV function to calculate the standard deviation of a numeric column in a database. It returns a measure of the amount of variation or dispersion of a set of values.",
        "examples": [
          "SELECT STDDEV(amount) FROM sales;",
          "SELECT STDDEV(amount) OVER (ROWS 2 PRECEDING) FROM sales;",
          "SELECT id, STDDEV(amount) OVER (PARTITION BY region ORDER BY amount) AS region_stddev FROM sales;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_60_1",
    "database_name": "duckdb_60_1",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select (1.175494351E-37 div 1.7976931348623157E+308); -- DIV",
    "target_query": "SELECT FLOOR(1.175494351E-37 / 1.7976931348623157E+308);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DIV"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "a DIV b",
        "description": "Performs integer division between two numbers and returns the floor of the quotient.",
        "examples": [
          "SELECT 10 DIV 3;",
          "SELECT 5.8 DIV 2;",
          "SELECT 9 DIV 4 + 1;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "FLOOR(a / b)",
        "description": "Returns the floor of the result of dividing two numeric values.",
        "examples": [
          "SELECT FLOOR(10 / 3);",
          "SELECT FLOOR(5.8 / 2);",
          "SELECT FLOOR(9 / 4) + 1;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_60_4",
    "database_name": "duckdb_60_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO t1 VALUES (ln(1)); -- LN",
    "target_query": "INSERT INTO t1 VALUES (ln(1));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LN"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LN(x)",
        "description": "The LN() function returns the natural logarithm of x. If x is less than or equal to 0, it returns NULL.",
        "examples": [
          "select ln(exp(10));",
          "select exp(ln(sqrt(10)) * 2);",
          "select ln(-1);",
          "select ln(0);",
          "select ln(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LN(x)",
        "description": "In DuckDB, the LN() function also returns the natural logarithm of x, with NaN returned for non-positive values.",
        "examples": [
          "select ln(exp(10));",
          "select exp(ln(sqrt(10)) * 2);",
          "select ln(NULL);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(a DOUBLE);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(a DOUBLE);"
    ]
  },
  {
    "sql_id": "duckdb_60_6",
    "database_name": "duckdb_60_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT floor(ceil(123456789)); -- CEIL",
    "target_query": "SELECT floor(ceil(123456789));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CEIL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CEIL(x)",
        "description": "Returns the smallest integer value not less than x (rounds up).",
        "examples": [
          "SELECT CEIL(1.3);",
          "SELECT CEIL(-2.8);",
          "SELECT CEIL(RAND() * 100);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CEIL(x)",
        "description": "Returns the smallest integer value not less than the input number.",
        "examples": [
          "SELECT CEIL(1.3);",
          "SELECT CEIL(-2.8);",
          "SELECT CEIL(RANDOM() * 100);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_60_7",
    "database_name": "duckdb_60_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select cast(pow(2,63)-1024 as signed) as pp; -- POW",
    "target_query": "SELECT cast(pow(2,63)-1024 as bigint) as pp;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "POW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "POW(3, 3)",
        "description": "POW(x, y) in MySQL is used to calculate x raised to the power of y. It returns the result of x^y.",
        "examples": [
          "SELECT POW(3, 3);",
          "SELECT POW(5, 4);",
          "SELECT POW(x, 2) FROM some_table;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POW(3, 3)",
        "description": "DuckDB supports the POW() function to calculate x raised to the power of y.",
        "examples": [
          "SELECT POW(3, 3);",
          "SELECT POW(5, 4);",
          "SELECT POW(x, 2) FROM some_table;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_60_8",
    "database_name": "duckdb_60_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select cast(1-pow(2,63) as signed) as qq; -- POW",
    "target_query": "SELECT cast(1-pow(2,63) as bigint) as qq;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "POW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "POW(3, 3)",
        "description": "POW(x, y) in MySQL is used to calculate x raised to the power of y. It returns the result of x^y.",
        "examples": [
          "SELECT POW(3, 3);",
          "SELECT POW(5, 4);",
          "SELECT POW(x, 2) FROM some_table;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POW(3, 3)",
        "description": "DuckDB supports the POW() function to calculate x raised to the power of y.",
        "examples": [
          "SELECT POW(3, 3);",
          "SELECT POW(5, 4);",
          "SELECT POW(x, 2) FROM some_table;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_60_12",
    "database_name": "duckdb_60_12",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT * FROM t0 WHERE CAST(COALESCE(t0.c0, -1) AS UNSIGNED); -- COALESCE",
    "target_query": "SELECT * FROM t0 WHERE CAST(COALESCE(t0.c0, -1) AS UBIGINT);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...)",
        "description": "DuckDB supports COALESCE for NULL handling.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t0(c0 BIGINT UNSIGNED);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0(c0 UBIGINT);"
    ]
  },
  {
    "sql_id": "duckdb_60_13",
    "database_name": "duckdb_60_13",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT * FROM t0 WHERE CAST(IFNULL(t0.c0, -1) AS UNSIGNED); -- IFNULL",
    "target_query": "SELECT * FROM t0 WHERE CAST(COALESCE(t0.c0, -1) AS UBIGINT);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2)",
        "description": "DuckDB also uses COALESCE to return the first non-NULL argument, which is functionally the same as IFNULL in MySQL.",
        "examples": [
          "SELECT COALESCE(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t0(c0 BIGINT UNSIGNED);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0(c0 UBIGINT);"
    ]
  },
  {
    "sql_id": "duckdb_60_14",
    "database_name": "duckdb_60_14",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT CAST(COALESCE(t0.c0, -1) AS UNSIGNED) IS TRUE FROM t0; -- COALESCE",
    "target_query": "SELECT CAST(COALESCE(t0.c0, -1) AS UBIGINT) IS TRUE FROM t0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...)",
        "description": "DuckDB supports COALESCE for NULL handling.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t0(c0 BIGINT UNSIGNED);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0(c0 UBIGINT);"
    ]
  },
  {
    "sql_id": "duckdb_60_15",
    "database_name": "duckdb_60_15",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT CAST(COALESCE(t0.c0, -1) AS UNSIGNED) FROM t0; -- COALESCE",
    "target_query": "SELECT CAST(COALESCE(t0.c0, -1) AS UBIGINT) FROM t0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...)",
        "description": "DuckDB supports COALESCE for NULL handling.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t0(c0 BIGINT UNSIGNED);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0(c0 UBIGINT);"
    ]
  },
  {
    "sql_id": "duckdb_61_0",
    "database_name": "duckdb_61_0",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select md5('a'), hex(md5('a')); -- MD5, HEX",
    "target_query": "select md5('a'), hex(md5('a'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MD5",
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      },
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      },
      {
        "expression": "HEX(N)",
        "description": "Converts numeric or string values into their hexadecimal string representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_61_2",
    "database_name": "duckdb_61_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "create table t1 as select md5('a') as c1; -- MD5",
    "target_query": "create table t1 as select md5('a') as c1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MD5"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 as select md5('a') as c1; -- MD5"
    ],
    "target_related_schemas": [
      "create table t1 as select md5('a') as c1;"
    ]
  },
  {
    "sql_id": "duckdb_61_4",
    "database_name": "duckdb_61_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select md5('hello'); -- MD5",
    "target_query": "select md5('hello');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MD5"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_61_5",
    "database_name": "duckdb_61_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "explain select md5('hello'); -- MD5",
    "target_query": "explain select md5('hello');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MD5"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_61_6",
    "database_name": "duckdb_61_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select length(unhex(md5(\"abrakadabra\"))); -- LENGTH, UNHEX, MD5",
    "target_query": "SELECT length(CAST(from_hex(md5('abrakadabra')) AS VARCHAR));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH",
      "UNHEX",
      "MD5"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      },
      {
        "expression": "UNHEX(str)",
        "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT HEX(UNHEX('4D7953514C'));",
          "SELECT UNHEX('48656C6C6F');",
          "SELECT UNHEX(NULL);"
        ]
      },
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      },
      {
        "expression": "FROM_HEX(str)",
        "description": "Converts a hexadecimal string into a BLOB value. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT TO_HEX(FROM_HEX('4D7953514C'));",
          "SELECT FROM_HEX('48656C6C6F');",
          "SELECT FROM_HEX(NULL);"
        ]
      },
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_61_8",
    "database_name": "duckdb_61_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "insert into t1 values ( 'test',md5('test')), ('test', md5('test')); -- MD5",
    "target_query": "insert into t1 values ( 'test',md5('test')), ('test', md5('test'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MD5"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (f1 varchar(4), f2 varchar(64));"
    ],
    "target_related_schemas": [
      "create table t1 (f1 varchar(4), f2 varchar(64));"
    ]
  },
  {
    "sql_id": "duckdb_61_9",
    "database_name": "duckdb_61_9",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select * from t1 where f1='test' and (f2= md5(\"test\") or f2= md5(\"Test\")); -- MD5",
    "target_query": "SELECT * FROM t1 WHERE f1 = 'test' AND (f2 = MD5('test') OR f2 = MD5('TEST'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MD5"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (f1 varchar(4), f2 varchar(64));"
    ],
    "target_related_schemas": [
      "create table t1 (f1 varchar(4), f2 varchar(64));"
    ]
  },
  {
    "sql_id": "duckdb_61_10",
    "database_name": "duckdb_61_10",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select * from t1 where f1='test' and (f2= md5(\"TEST\") or f2= md5(\"test\")); -- MD5",
    "target_query": "SELECT * FROM t1 WHERE f1 = 'test' AND (f2 = MD5('TEST') OR f2 = MD5('test'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MD5"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (f1 varchar(4), f2 varchar(64));"
    ],
    "target_related_schemas": [
      "create table t1 (f1 varchar(4), f2 varchar(64));"
    ]
  },
  {
    "sql_id": "duckdb_62_4",
    "database_name": "duckdb_62_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select a from t1 where mid(a+0,6,3) in ( mid(20040106123400,6,3) ); -- MID",
    "target_query": "select a from t1 where substring(strftime(a, '%Y%m%d%H%M%S'), 6, 3) IN (SUBSTRING(CAST(20040106123400 AS VARCHAR), 6, 3));;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MID"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MID(str, pos, len)",
        "description": "Extracts a substring from the string `str`, starting at position `pos`, with length `len`.",
        "examples": [
          "SELECT MID('ABCDEFGHIJKL', 5, 3);",
          "SELECT CONCAT(MID('hello_world', 1, 5), MID('hello_world', 7, 5));",
          "SELECT MID('  padded_text  ', 3, 6);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "substring(str, pos, len)",
        "description": "Extracts a substring starting from character `pos`, with length `len`, using SQL-compliant `substring()`.",
        "examples": [
          "SELECT substring('ABCDEFGHIJKL', 5, 3);",
          "SELECT substring('hello_world', 1, 5) || substring('hello_world', 7, 5);",
          "SELECT substring('  padded_text  ', 3, 6);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 ( a timestamp );"
    ],
    "target_related_schemas": [
      "create table t1 ( a timestamp );"
    ]
  },
  {
    "sql_id": "duckdb_62_5",
    "database_name": "duckdb_62_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select a from t1 where mid(a+0,6,3) = ( mid(20040106123400,6,3) ); -- MID",
    "target_query": "select a from t1 where substring(strftime(a, '%Y%m%d%H%M%S'), 6, 3) = ( SUBSTRING(CAST(20040106123400 AS VARCHAR), 6, 3));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MID"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MID(str, pos, len)",
        "description": "Extracts a substring from the string `str`, starting at position `pos`, with length `len`.",
        "examples": [
          "SELECT MID('ABCDEFGHIJKL', 5, 3);",
          "SELECT CONCAT(MID('hello_world', 1, 5), MID('hello_world', 7, 5));",
          "SELECT MID('  padded_text  ', 3, 6);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "substring(str, pos, len)",
        "description": "Extracts a substring starting from character `pos`, with length `len`, using SQL-compliant `substring()`.",
        "examples": [
          "SELECT substring('ABCDEFGHIJKL', 5, 3);",
          "SELECT substring('hello_world', 1, 5) || substring('hello_world', 7, 5);",
          "SELECT substring('  padded_text  ', 3, 6);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 ( a timestamp );"
    ],
    "target_related_schemas": [
      "create table t1 ( a timestamp );"
    ]
  },
  {
    "sql_id": "duckdb_62_15",
    "database_name": "duckdb_62_15",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT DISTINCT LEAST(a, (SELECT b FROM t1 LIMIT 1)) FROM t1 UNION SELECT 1; -- LEAST",
    "target_query": "SELECT DISTINCT least(a, (SELECT CAST(b AS INT) FROM t1 LIMIT 1)) FROM t1 UNION SELECT 1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the least non-null value among the provided expressions. NULLs are skipped unless all arguments are NULL. This differs from MySQL/MariaDB which return NULL if any argument is NULL.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(DATE '2024-01-01', DATE '2023-12-31');",
          "SELECT least(NULL, 2);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a INT, b LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT, b VARCHAR);"
    ]
  },
  {
    "sql_id": "duckdb_62_16",
    "database_name": "duckdb_62_16",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT DISTINCT GREATEST(a, (SELECT b FROM t1 LIMIT 1)) FROM t1 UNION SELECT 1; -- GREATEST",
    "target_query": "SELECT DISTINCT GREATEST(a, (SELECT CAST(b AS INT) FROM t1 LIMIT 1)) FROM t1 UNION SELECT 1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a INT, b LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT, b VARCHAR);"
    ]
  },
  {
    "sql_id": "duckdb_63_0",
    "database_name": "duckdb_63_0",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select 1+1,1-1,1+1*2,8/5,8%5,mod(8,5),-(1+1)*-2; -- MOD",
    "target_query": "select 1+1,1-1,1+1*2,8/5,8%5,mod(8,5),-(1+1)*-2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MOD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Returns the remainder of N divided by M. Returns NULL if M = 0.",
        "examples": [
          "SELECT MOD(10, 3);",
          "SELECT 10 % 3;",
          "SELECT MOD(5, 0);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Computes the modulo operation. Division by 0 throws error.",
        "examples": [
          "SELECT MOD(13, 4);",
          "SELECT 13 % 4;",
          "SELECT MOD(3, 0);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_63_1",
    "database_name": "duckdb_63_1",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select 1 | (1+1),5 & 3,bit_count(7) ; -- BIT_COUNT",
    "target_query": "select 1|(1+1),5&3,length(replace(to_binary(7),'0',''));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "BIT_COUNT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "BIT_COUNT(N)",
        "description": "Returns the number of bits set to 1 in the binary representation of the given integer.",
        "examples": [
          "SELECT BIT_COUNT(0);",
          "SELECT BIT_COUNT(1);",
          "SELECT BIT_COUNT(15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(replace(to_binary(N), '0', ''))",
        "description": "Simulates bit count by converting the integer to binary and counting the number of '1' bits.",
        "examples": [
          "SELECT length(replace(to_binary(0), '0', ''));",
          "SELECT length(replace(to_binary(1), '0', ''));",
          "SELECT length(replace(to_binary(15), '0', ''));"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_63_7",
    "database_name": "duckdb_63_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select t1.a, t2.a, t2.b, bit_count(t2.b) from t1 left join t2 on t1.a=t2.a; -- BIT_COUNT",
    "target_query": "select t1.a,t2.a,t2.b,length(replace(to_binary(t2.b),'0','')) from t1 left join t2 on t1.a=t2.a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "BIT_COUNT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "BIT_COUNT(N)",
        "description": "Returns the number of bits set to 1 in the binary representation of the given integer.",
        "examples": [
          "SELECT BIT_COUNT(0);",
          "SELECT BIT_COUNT(1);",
          "SELECT BIT_COUNT(15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(replace(to_binary(N), '0', ''))",
        "description": "Simulates bit count by converting the integer to binary and counting the number of '1' bits.",
        "examples": [
          "SELECT length(replace(to_binary(0), '0', ''));",
          "SELECT length(replace(to_binary(1), '0', ''));",
          "SELECT length(replace(to_binary(15), '0', ''));"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1(a int);",
      "create table t2(a int, b int);"
    ],
    "target_related_schemas": [
      "create table t1(a int);",
      "create table t2(a int, b int);"
    ]
  },
  {
    "sql_id": "duckdb_64_0",
    "database_name": "duckdb_64_0",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select date_format(\"1997-12-31 23:59:59.000002\", \"%f\"); -- DATE_FORMAT",
    "target_query": "SELECT STRFTIME(TIMESTAMP '1997-12-31 23:59:59.000002', '%f');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "STRFTIME(date_expr, format_str)",
        "description": "Formats a date/time value using SQLite-compatible strftime format specifiers.",
        "examples": [
          "SELECT STRFTIME('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT STRFTIME(CURRENT_TIMESTAMP, '%Y-%m-%d %H:%M:%S');",
          "SELECT STRFTIME('2023-01-15 12:00:00', '%d-%m-%Y');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_64_1",
    "database_name": "duckdb_64_1",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select datediff(\"1997-12-31 23:59:59.000001\",\"1997-12-30\"); -- DATEDIFF",
    "target_query": "SELECT DATE_DIFF('day', DATE '1997-12-30', DATE '1997-12-31 23:59:59.000001');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATEDIFF(date1, date2)",
        "description": "Returns the number of days between two date or datetime expressions (date1 - date2), ignoring time part.",
        "examples": [
          "SELECT DATEDIFF('2025-12-31', '2025-12-01');",
          "SELECT DATEDIFF('2025-01-01', '2024-12-31');",
          "SELECT DATEDIFF(NULL, '2025-01-01');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "DATE_DIFF('day', date2, date1)",
        "description": "Computes the number of days between two dates as an integer by specifying the 'day' unit.",
        "examples": [
          "SELECT DATE_DIFF('day', DATE '2025-12-01', DATE '2025-12-31');",
          "SELECT DATE_DIFF('day', DATE '2024-12-31', DATE '2025-01-01');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_64_2",
    "database_name": "duckdb_64_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select datediff(\"1997-11-30 23:59:59.000001\",null); --  DATEDIFF",
    "target_query": "SELECT DATE_DIFF('day', NULL, DATE '1997-11-30 23:59:59.000001');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATEDIFF(date1, date2)",
        "description": "Returns the number of days between two date or datetime expressions (date1 - date2), ignoring time part.",
        "examples": [
          "SELECT DATEDIFF('2025-12-31', '2025-12-01');",
          "SELECT DATEDIFF('2025-01-01', '2024-12-31');",
          "SELECT DATEDIFF(NULL, '2025-01-01');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "DATE_DIFF('day', date2, date1)",
        "description": "Computes the number of days between two dates as an integer by specifying the 'day' unit.",
        "examples": [
          "SELECT DATE_DIFF('day', DATE '2025-12-01', DATE '2025-12-31');",
          "SELECT DATE_DIFF('day', DATE '2024-12-31', DATE '2025-01-01');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_64_3",
    "database_name": "duckdb_64_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select makedate(03,1); -- MAKEDATE",
    "target_query": "SELECT DATE '03-01-01' + (1 - 1) * INTERVAL '1 day';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKEDATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKEDATE(year, day_of_year)",
        "description": "Returns a date from the given year and day of the year.",
        "examples": [
          "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
          "SELECT MAKEDATE(2025, 100) AS specific_date;",
          "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "date 'year-01-01' + (day_of_year - 1) * INTERVAL '1 day'",
        "description": "Returns a date from the given year and day of the year by adding intervals.",
        "examples": [
          "SELECT date '2009-01-01' + (1 - 1) * INTERVAL '1 day' AS first_day_of_year;",
          "SELECT date '2025-01-01' + (100 - 1) * INTERVAL '1 day' AS specific_date;",
          "SELECT date '2020-01-01' + (366 - 1) * INTERVAL '1 day' AS last_day_of_year;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_64_5",
    "database_name": "duckdb_64_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select makedate(1997,1); -- MAKEDATE",
    "target_query": "SELECT DATE '1997-01-01' + (1 - 1) * INTERVAL '1 day';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKEDATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKEDATE(year, day_of_year)",
        "description": "Returns a date from the given year and day of the year.",
        "examples": [
          "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
          "SELECT MAKEDATE(2025, 100) AS specific_date;",
          "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "date 'year-01-01' + (day_of_year - 1) * INTERVAL '1 day'",
        "description": "Returns a date from the given year and day of the year by adding intervals.",
        "examples": [
          "SELECT date '2009-01-01' + (1 - 1) * INTERVAL '1 day' AS first_day_of_year;",
          "SELECT date '2025-01-01' + (100 - 1) * INTERVAL '1 day' AS specific_date;",
          "SELECT date '2020-01-01' + (366 - 1) * INTERVAL '1 day' AS last_day_of_year;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_64_6",
    "database_name": "duckdb_64_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select makedate(1997,0); -- MAKEDATE",
    "target_query": "SELECT DATE '1997-01-01' + (0 - 1) * INTERVAL '1 day';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKEDATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKEDATE(year, day_of_year)",
        "description": "Returns a date from the given year and day of the year.",
        "examples": [
          "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
          "SELECT MAKEDATE(2025, 100) AS specific_date;",
          "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "date 'year-01-01' + (day_of_year - 1) * INTERVAL '1 day'",
        "description": "Returns a date from the given year and day of the year by adding intervals.",
        "examples": [
          "SELECT date '2009-01-01' + (1 - 1) * INTERVAL '1 day' AS first_day_of_year;",
          "SELECT date '2025-01-01' + (100 - 1) * INTERVAL '1 day' AS specific_date;",
          "SELECT date '2020-01-01' + (366 - 1) * INTERVAL '1 day' AS last_day_of_year;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_64_7",
    "database_name": "duckdb_64_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select makedate(9999,365); -- MAKEDATE",
    "target_query": "SELECT DATE '9999-01-01' + (365 - 1) * INTERVAL '1 day';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKEDATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKEDATE(year, day_of_year)",
        "description": "Returns a date from the given year and day of the year.",
        "examples": [
          "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
          "SELECT MAKEDATE(2025, 100) AS specific_date;",
          "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "date 'year-01-01' + (day_of_year - 1) * INTERVAL '1 day'",
        "description": "Returns a date from the given year and day of the year by adding intervals.",
        "examples": [
          "SELECT date '2009-01-01' + (1 - 1) * INTERVAL '1 day' AS first_day_of_year;",
          "SELECT date '2025-01-01' + (100 - 1) * INTERVAL '1 day' AS specific_date;",
          "SELECT date '2020-01-01' + (366 - 1) * INTERVAL '1 day' AS last_day_of_year;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_64_8",
    "database_name": "duckdb_64_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select makedate(9999,366); -- MAKEDATE",
    "target_query": "SELECT DATE '9999-01-01' + (366 - 1) * INTERVAL '1 day';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKEDATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKEDATE(year, day_of_year)",
        "description": "Returns a date from the given year and day of the year.",
        "examples": [
          "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
          "SELECT MAKEDATE(2025, 100) AS specific_date;",
          "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "date 'year-01-01' + (day_of_year - 1) * INTERVAL '1 day'",
        "description": "Returns a date from the given year and day of the year by adding intervals.",
        "examples": [
          "SELECT date '2009-01-01' + (1 - 1) * INTERVAL '1 day' AS first_day_of_year;",
          "SELECT date '2025-01-01' + (100 - 1) * INTERVAL '1 day' AS specific_date;",
          "SELECT date '2020-01-01' + (366 - 1) * INTERVAL '1 day' AS last_day_of_year;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_64_9",
    "database_name": "duckdb_64_9",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select makedate(100,1); -- MAKEDATE",
    "target_query": "SELECT DATE '100-01-01' + (1 - 1) * INTERVAL '1 day';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKEDATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKEDATE(year, day_of_year)",
        "description": "Returns a date from the given year and day of the year.",
        "examples": [
          "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
          "SELECT MAKEDATE(2025, 100) AS specific_date;",
          "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "date 'year-01-01' + (day_of_year - 1) * INTERVAL '1 day'",
        "description": "Returns a date from the given year and day of the year by adding intervals.",
        "examples": [
          "SELECT date '2009-01-01' + (1 - 1) * INTERVAL '1 day' AS first_day_of_year;",
          "SELECT date '2025-01-01' + (100 - 1) * INTERVAL '1 day' AS specific_date;",
          "SELECT date '2020-01-01' + (366 - 1) * INTERVAL '1 day' AS last_day_of_year;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_64_10",
    "database_name": "duckdb_64_10",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select subtime(\"1997-12-31 23:59:59.000001\", \"1 1:1:1.000002\"); -- SUBTIME",
    "target_query": "SELECT TIMESTAMP '1997-12-31 23:59:59.000001' - INTERVAL '1 day 1 hour 1 minute 1.000002 second';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "SUBTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SUBTIME(expr1, expr2)",
        "description": "Subtracts a time/datetime interval from the given time or datetime.",
        "examples": [
          "SELECT SUBTIME('12:00:00', '01:30:00');",
          "SELECT SUBTIME('2025-01-01 10:00:00', '00:00:01');",
          "SELECT SUBTIME('05:00:00', '05:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "expr - INTERVAL ...",
        "description": "Supports standard SQL interval subtraction.",
        "examples": [
          "SELECT TIME '12:00:00' - INTERVAL '1 HOUR 30 MINUTE';",
          "SELECT TIMESTAMP '2025-01-01 10:00:00' - INTERVAL '1 SECOND';",
          "SELECT TIME '05:00:00' - INTERVAL '5 HOUR';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_64_11",
    "database_name": "duckdb_64_11",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select subtime(\"1997-12-31 23:59:59.999999\", \"1998-01-01 01:01:01.999999\"); -- SUBTIME",
    "target_query": "SELECT TIMESTAMP '1997-12-31 23:59:59.999999' - TIMESTAMP '1998-01-01 01:01:01.999999';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "SUBTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SUBTIME(expr1, expr2)",
        "description": "Subtracts a time/datetime interval from the given time or datetime.",
        "examples": [
          "SELECT SUBTIME('12:00:00', '01:30:00');",
          "SELECT SUBTIME('2025-01-01 10:00:00', '00:00:01');",
          "SELECT SUBTIME('05:00:00', '05:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "expr - INTERVAL ...",
        "description": "Supports standard SQL interval subtraction.",
        "examples": [
          "SELECT TIME '12:00:00' - INTERVAL '1 HOUR 30 MINUTE';",
          "SELECT TIMESTAMP '2025-01-01 10:00:00' - INTERVAL '1 SECOND';",
          "SELECT TIME '05:00:00' - INTERVAL '5 HOUR';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_64_12",
    "database_name": "duckdb_64_12",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select subtime(\"01:00:00.999999\", \"02:00:00.999998\"); -- SUBTIME",
    "target_query": "SELECT TIME '01:00:00.999999' - INTERVAL '2 hours 0 minutes 0.999998 seconds';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "SUBTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SUBTIME(expr1, expr2)",
        "description": "Subtracts a time/datetime interval from the given time or datetime.",
        "examples": [
          "SELECT SUBTIME('12:00:00', '01:30:00');",
          "SELECT SUBTIME('2025-01-01 10:00:00', '00:00:01');",
          "SELECT SUBTIME('05:00:00', '05:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "expr - INTERVAL ...",
        "description": "Supports standard SQL interval subtraction.",
        "examples": [
          "SELECT TIME '12:00:00' - INTERVAL '1 HOUR 30 MINUTE';",
          "SELECT TIMESTAMP '2025-01-01 10:00:00' - INTERVAL '1 SECOND';",
          "SELECT TIME '05:00:00' - INTERVAL '5 HOUR';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_64_13",
    "database_name": "duckdb_64_13",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select subtime(\"02:01:01.999999\", \"01:01:01.999999\"); -- SUBTIME",
    "target_query": "SELECT TIME '02:01:01.999999' - INTERVAL '1 hour 1 minute 1.999999 seconds';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "SUBTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SUBTIME(expr1, expr2)",
        "description": "Subtracts a time/datetime interval from the given time or datetime.",
        "examples": [
          "SELECT SUBTIME('12:00:00', '01:30:00');",
          "SELECT SUBTIME('2025-01-01 10:00:00', '00:00:01');",
          "SELECT SUBTIME('05:00:00', '05:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "expr - INTERVAL ...",
        "description": "Supports standard SQL interval subtraction.",
        "examples": [
          "SELECT TIME '12:00:00' - INTERVAL '1 HOUR 30 MINUTE';",
          "SELECT TIMESTAMP '2025-01-01 10:00:00' - INTERVAL '1 SECOND';",
          "SELECT TIME '05:00:00' - INTERVAL '5 HOUR';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_64_14",
    "database_name": "duckdb_64_14",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select timediff(\"1997-01-01 23:59:59.000001\",\"1995-12-31 23:59:59.000002\"); -- TIMEDIFF",
    "target_query": "SELECT TIMESTAMP '1997-01-01 23:59:59.000001' - TIMESTAMP '1995-12-31 23:59:59.000002';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00'",
        "description": "DuckDB supports direct subtraction between timestamps to calculate the difference, returning the result as an interval.",
        "examples": [
          "SELECT TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00';",
          "SELECT CURRENT_TIMESTAMP - TIMESTAMP '2023-06-15 10:00:00';",
          "SELECT TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_64_15",
    "database_name": "duckdb_64_15",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select timediff(\"1997-12-31 23:59:59.000001\",\"1997-12-30 01:01:01.000002\"); -- TIMEDIFF",
    "target_query": "SELECT TIMESTAMP '1997-12-31 23:59:59.000001' - TIMESTAMP '1997-12-30 01:01:01.000002';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00'",
        "description": "DuckDB supports direct subtraction between timestamps to calculate the difference, returning the result as an interval.",
        "examples": [
          "SELECT TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00';",
          "SELECT CURRENT_TIMESTAMP - TIMESTAMP '2023-06-15 10:00:00';",
          "SELECT TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_64_18",
    "database_name": "duckdb_64_18",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select timediff(\"2005-01-11 15:48:49.999999\", \"2005-01-11 15:48:50\"); --  TIMEDIFF",
    "target_query": "SELECT TIMESTAMP '2005-01-11 15:48:49.999999' - TIMESTAMP '2005-01-11 15:48:50';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00'",
        "description": "DuckDB supports direct subtraction between timestamps to calculate the difference, returning the result as an interval.",
        "examples": [
          "SELECT TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00';",
          "SELECT CURRENT_TIMESTAMP - TIMESTAMP '2023-06-15 10:00:00';",
          "SELECT TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_65_0",
    "database_name": "duckdb_65_0",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select maketime(10,11,12); -- MAKETIME",
    "target_query": "select make_time(10,11,12);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKETIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKETIME(hours, minutes, seconds)",
        "description": "Creates a time value from the provided hours, minutes, and seconds.",
        "examples": [
          "SELECT MAKETIME(1, 30, 45);",
          "SELECT MAKETIME(12, 0, 0);",
          "SELECT MAKETIME(23, 59, 59);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "make_time(hour, minute, second)",
        "description": "Constructs a time value from the given hour, minute, and second components using the built-in make_time function.",
        "examples": [
          "SELECT make_time(1, 30, 45);",
          "SELECT make_time(12, 0, 0);",
          "SELECT make_time(23, 59, 59);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_65_1",
    "database_name": "duckdb_65_1",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select maketime(20,11,12); -- MAKETIME",
    "target_query": "select make_time(20,11,12);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKETIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKETIME(hours, minutes, seconds)",
        "description": "Creates a time value from the provided hours, minutes, and seconds.",
        "examples": [
          "SELECT MAKETIME(1, 30, 45);",
          "SELECT MAKETIME(12, 0, 0);",
          "SELECT MAKETIME(23, 59, 59);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "make_time(hour, minute, second)",
        "description": "Constructs a time value from the given hour, minute, and second components using the built-in make_time function.",
        "examples": [
          "SELECT make_time(1, 30, 45);",
          "SELECT make_time(12, 0, 0);",
          "SELECT make_time(23, 59, 59);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_65_3",
    "database_name": "duckdb_65_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select timestamp(\"2001-12-01\", \"01:01:01.999999\"); -- TIMESTAMP",
    "target_query": "select TIMESTAMP '2001-12-01 01:01:01.999999';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
        "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
        "examples": [
          "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TIMESTAMP '2023-06-15 10:30:45'",
        "description": "DuckDB supports the TIMESTAMP function to handle date-time strings as TIMESTAMP values.",
        "examples": [
          "SELECT TIMESTAMP '2023-06-15 10:30:45';",
          "SELECT TIMESTAMP '2023-06-15 10:30:45+02:00';",
          "SELECT TIMESTAMP '2023-06-15 10:30:45' > TIMESTAMP '2023-06-14 10:30:45';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_65_4",
    "database_name": "duckdb_65_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select timestamp(\"2001-10-01\", \"01:01:01.000001\"); -- TIMESTAMP",
    "target_query": "select TIMESTAMP '2001-10-01 01:01:01.000001';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
        "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
        "examples": [
          "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TIMESTAMP '2023-06-15 10:30:45'",
        "description": "DuckDB supports the TIMESTAMP function to handle date-time strings as TIMESTAMP values.",
        "examples": [
          "SELECT TIMESTAMP '2023-06-15 10:30:45';",
          "SELECT TIMESTAMP '2023-06-15 10:30:45+02:00';",
          "SELECT TIMESTAMP '2023-06-15 10:30:45' > TIMESTAMP '2023-06-14 10:30:45';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_65_5",
    "database_name": "duckdb_65_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select timestamp(\"2001-12-01\", \"20:01:01\"); -- TIMESTAMP",
    "target_query": "select TIMESTAMP '2001-12-01 20:01:01';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
        "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
        "examples": [
          "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TIMESTAMP '2023-06-15 10:30:45'",
        "description": "DuckDB supports the TIMESTAMP function to handle date-time strings as TIMESTAMP values.",
        "examples": [
          "SELECT TIMESTAMP '2023-06-15 10:30:45';",
          "SELECT TIMESTAMP '2023-06-15 10:30:45+02:00';",
          "SELECT TIMESTAMP '2023-06-15 10:30:45' > TIMESTAMP '2023-06-14 10:30:45';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_65_6",
    "database_name": "duckdb_65_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select timestamp(\"2001-12-01\"); -- TIMESTAMP",
    "target_query": "select TIMESTAMP '2001-12-01 00:00:00';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
        "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
        "examples": [
          "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TIMESTAMP '2023-06-15 10:30:45'",
        "description": "DuckDB supports the TIMESTAMP function to handle date-time strings as TIMESTAMP values.",
        "examples": [
          "SELECT TIMESTAMP '2023-06-15 10:30:45';",
          "SELECT TIMESTAMP '2023-06-15 10:30:45+02:00';",
          "SELECT TIMESTAMP '2023-06-15 10:30:45' > TIMESTAMP '2023-06-14 10:30:45';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_65_7",
    "database_name": "duckdb_65_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select day(\"1997-12-31 23:59:59.000001\"); -- DAY",
    "target_query": "select EXTRACT(DAY FROM TIMESTAMP '1997-12-31 23:59:59.000001');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DAY"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DAY(date_expr)",
        "description": "Returns the day of the month (1-31) from a date or datetime expression.",
        "examples": [
          "SELECT DAY('2023-10-15');",
          "SELECT DAY(NOW());",
          "SELECT DAY(CAST('2024-02-29 12:34:56' AS DATE));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "EXTRACT(DAY FROM date_expr)",
        "description": "Returns the day of the month from a date or timestamp input.",
        "examples": [
          "SELECT EXTRACT(DAY FROM DATE '2023-10-15');",
          "SELECT EXTRACT(DAY FROM CURRENT_DATE);",
          "SELECT EXTRACT(DAY FROM TIMESTAMP '2024-02-29 11:59:59');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_65_8",
    "database_name": "duckdb_65_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select time(\"1997-12-31 23:59:59.000001\"); -- TIME",
    "target_query": "select strftime('%H:%M:%S.%f', TIMESTAMP '1997-12-31 23:59:59.000001');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
        "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
        "examples": [
          "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
          "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "strftime(format, datetime_expr)",
        "description": "DuckDB does not have a native TIME type, so operations involving just hours, minutes, and seconds must be done on full DateTime values. The `strftime` function can be used to extract or format time from a complete `TIMESTAMP` value. If a time value does not include year information (e.g., '14:16:00'), a default year (e.g., '1970-01-01') must be added to ensure it forms a valid `TIMESTAMP`. This is necessary to perform the time-based operations correctly.",
        "examples": [
          "SELECT strftime('%H:%M:%S', CAST(CURRENT_TIMESTAMP AS TIMESTAMP)); -- Returns the current time formatted as 'HH:MM:SS'.",
          "SELECT strftime('%H:%M:%S', CAST(CURRENT_TIMESTAMP + INTERVAL '1 hour' AS TIMESTAMP)); -- Adds 1 hour to the time, returning 'HH:MM:SS'.",
          "SELECT strftime('%H:%M:%S.%f', CAST(CONCAT('1970-01-01 ', '14:16:00') AS TIMESTAMP)); -- Returns '14:16:00.000000' with fractional seconds by concatenating time with a default date."
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_65_12",
    "database_name": "duckdb_65_12",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT TIMEDIFF(t1, t4) As ttt, TIMEDIFF(t2, t3) As qqq,TIMEDIFF(t3, t2) As eee, TIMEDIFF(t2, t4) As rrr from test; -- TIMEDIFF",
    "target_query": "SELECT (t1 - t4) AS ttt, ((DATE '1970-01-01' + t2) - (DATE '1970-01-01' + t3)) AS qqq, ((DATE '1970-01-01' + t3) - (DATE '1970-01-01' + t2)) AS eee, ((DATE '1970-01-01' + t2) - t4) AS rrr FROM test;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00'",
        "description": "DuckDB supports direct subtraction between timestamps to calculate the difference, returning the result as an interval.",
        "examples": [
          "SELECT TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00';",
          "SELECT CURRENT_TIMESTAMP - TIMESTAMP '2023-06-15 10:00:00';",
          "SELECT TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00';"
        ]
      }
    ],
    "source_related_schemas": [
      "create table test(t1 datetime, t2 time, t3 time, t4 datetime);"
    ],
    "target_related_schemas": [
      "create table test(t1 datetime, t2 time, t3 time, t4 datetime);"
    ]
  },
  {
    "sql_id": "duckdb_65_13",
    "database_name": "duckdb_65_13",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select str_to_date(\"2003-01-02 10:11:12.0012\", \"%Y-%m-%d %H:%i:%S.%f\"); -- STR_TO_DATE",
    "target_query": "select strptime('2003-01-02 10:11:12', '%Y-%m-%d %H:%M:%S');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STR_TO_DATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STR_TO_DATE('09:22', '%H:%i')",
        "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
        "examples": [
          "SELECT STR_TO_DATE('12:45', '%H:%i');",
          "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
          "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "strptime('2000-01-01', '%Y-%m-%d')",
        "description": "Converts a string to a timestamp using the specified format, where '%Y-%m-%d' corresponds to the 'Year-Month-Day' format.",
        "examples": [
          "SELECT strptime('2000-01-01', '%Y-%m-%d');",
          "SELECT strptime('2023-05-06', '%Y-%m-%d');",
          "SELECT strptime('1999-12-31', '%Y-%m-%d');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_65_14",
    "database_name": "duckdb_65_14",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select timediff('2008-09-29 20:10:10','2008-09-30 20:10:10'),time('00:00:00'); -- TIMEDIFF, TIME",
    "target_query": "select (TIMESTAMP '2008-09-29 20:10:10' - TIMESTAMP '2008-09-30 20:10:10'), strftime('%H:%M:%S', TIMESTAMP '1970-01-01 00:00:00');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF",
      "TIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      },
      {
        "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
        "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
        "examples": [
          "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
          "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00'",
        "description": "DuckDB supports direct subtraction between timestamps to calculate the difference, returning the result as an interval.",
        "examples": [
          "SELECT TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00';",
          "SELECT CURRENT_TIMESTAMP - TIMESTAMP '2023-06-15 10:00:00';",
          "SELECT TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00';"
        ]
      },
      {
        "expression": "strftime(format, datetime_expr)",
        "description": "DuckDB does not have a native TIME type, so operations involving just hours, minutes, and seconds must be done on full DateTime values. The `strftime` function can be used to extract or format time from a complete `TIMESTAMP` value. If a time value does not include year information (e.g., '14:16:00'), a default year (e.g., '1970-01-01') must be added to ensure it forms a valid `TIMESTAMP`. This is necessary to perform the time-based operations correctly.",
        "examples": [
          "SELECT strftime('%H:%M:%S', CAST(CURRENT_TIMESTAMP AS TIMESTAMP)); -- Returns the current time formatted as 'HH:MM:SS'.",
          "SELECT strftime('%H:%M:%S', CAST(CURRENT_TIMESTAMP + INTERVAL '1 hour' AS TIMESTAMP)); -- Adds 1 hour to the time, returning 'HH:MM:SS'.",
          "SELECT strftime('%H:%M:%S.%f', CAST(CONCAT('1970-01-01 ', '14:16:00') AS TIMESTAMP)); -- Returns '14:16:00.000000' with fractional seconds by concatenating time with a default date."
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_65_15",
    "database_name": "duckdb_65_15",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select timediff('2008-09-29 20:10:10','2008-09-30 20:10:10')>time('00:00:00'); -- TIMEDIFF, TIME",
    "target_query": "select (TIMESTAMP '2008-09-29 20:10:10' - TIMESTAMP '2008-09-30 20:10:10') > INTERVAL '0 seconds';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF",
      "TIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      },
      {
        "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
        "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
        "examples": [
          "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
          "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00'",
        "description": "DuckDB supports direct subtraction between timestamps to calculate the difference, returning the result as an interval.",
        "examples": [
          "SELECT TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00';",
          "SELECT CURRENT_TIMESTAMP - TIMESTAMP '2023-06-15 10:00:00';",
          "SELECT TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00';"
        ]
      },
      {
        "expression": "strftime(format, datetime_expr)",
        "description": "DuckDB does not have a native TIME type, so operations involving just hours, minutes, and seconds must be done on full DateTime values. The `strftime` function can be used to extract or format time from a complete `TIMESTAMP` value. If a time value does not include year information (e.g., '14:16:00'), a default year (e.g., '1970-01-01') must be added to ensure it forms a valid `TIMESTAMP`. This is necessary to perform the time-based operations correctly.",
        "examples": [
          "SELECT strftime('%H:%M:%S', CAST(CURRENT_TIMESTAMP AS TIMESTAMP)); -- Returns the current time formatted as 'HH:MM:SS'.",
          "SELECT strftime('%H:%M:%S', CAST(CURRENT_TIMESTAMP + INTERVAL '1 hour' AS TIMESTAMP)); -- Adds 1 hour to the time, returning 'HH:MM:SS'.",
          "SELECT strftime('%H:%M:%S.%f', CAST(CONCAT('1970-01-01 ', '14:16:00') AS TIMESTAMP)); -- Returns '14:16:00.000000' with fractional seconds by concatenating time with a default date."
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_65_16",
    "database_name": "duckdb_65_16",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select timediff('2008-09-29 20:10:10','2008-09-30 20:10:10')<time('00:00:00'); -- TIMEDIFF, TIME",
    "target_query": "SELECT (TIMESTAMP '2008-09-29 20:10:10' - TIMESTAMP '2008-09-30 20:10:10') < INTERVAL '0 seconds';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF",
      "TIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      },
      {
        "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
        "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
        "examples": [
          "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
          "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00'",
        "description": "DuckDB supports direct subtraction between timestamps to calculate the difference, returning the result as an interval.",
        "examples": [
          "SELECT TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00';",
          "SELECT CURRENT_TIMESTAMP - TIMESTAMP '2023-06-15 10:00:00';",
          "SELECT TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00';"
        ]
      },
      {
        "expression": "strftime(format, datetime_expr)",
        "description": "DuckDB does not have a native TIME type, so operations involving just hours, minutes, and seconds must be done on full DateTime values. The `strftime` function can be used to extract or format time from a complete `TIMESTAMP` value. If a time value does not include year information (e.g., '14:16:00'), a default year (e.g., '1970-01-01') must be added to ensure it forms a valid `TIMESTAMP`. This is necessary to perform the time-based operations correctly.",
        "examples": [
          "SELECT strftime('%H:%M:%S', CAST(CURRENT_TIMESTAMP AS TIMESTAMP)); -- Returns the current time formatted as 'HH:MM:SS'.",
          "SELECT strftime('%H:%M:%S', CAST(CURRENT_TIMESTAMP + INTERVAL '1 hour' AS TIMESTAMP)); -- Adds 1 hour to the time, returning 'HH:MM:SS'.",
          "SELECT strftime('%H:%M:%S.%f', CAST(CONCAT('1970-01-01 ', '14:16:00') AS TIMESTAMP)); -- Returns '14:16:00.000000' with fractional seconds by concatenating time with a default date."
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_66_1",
    "database_name": "duckdb_66_1",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT sec_to_time(86399)=TIME('23:59:59'); -- SEC_TO_TIME, TIME",
    "target_query": "SELECT ((INTERVAL 86399 SECOND) + '00:00:00'::TIME) = strftime('%H:%M:%S', CAST(CONCAT('1970-01-01 ', '23:59:59') AS TIMESTAMP));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "SEC_TO_TIME",
      "TIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SEC_TO_TIME(seconds)",
        "description": "Converts the given number of seconds into a time value in the format HH:MM:SS. Wraps around if seconds exceed 86400.",
        "examples": [
          "SELECT SEC_TO_TIME(3661); -- Returns '01:01:01'",
          "SELECT SEC_TO_TIME(3600); -- Returns '01:00:00'",
          "SELECT SEC_TO_TIME(86400); -- Returns '00:00:00'"
        ]
      },
      {
        "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
        "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
        "examples": [
          "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
          "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "(INTERVAL seconds SECOND) + '00:00:00'::TIME",
        "description": "Converts the number of seconds to an interval and adds it to a base time of '00:00:00'.",
        "examples": [
          "SELECT (INTERVAL 3661 SECOND) + '00:00:00'::TIME; -- Returns '01:01:01'",
          "SELECT (INTERVAL 3600 SECOND) + '00:00:00'::TIME; -- Returns '01:00:00'",
          "SELECT (INTERVAL 86400 SECOND) + '00:00:00'::TIME; -- Returns '00:00:00'"
        ]
      },
      {
        "expression": "strftime(format, datetime_expr)",
        "description": "DuckDB does not have a native TIME type, so operations involving just hours, minutes, and seconds must be done on full DateTime values. The `strftime` function can be used to extract or format time from a complete `TIMESTAMP` value. If a time value does not include year information (e.g., '14:16:00'), a default year (e.g., '1970-01-01') must be added to ensure it forms a valid `TIMESTAMP`. This is necessary to perform the time-based operations correctly.",
        "examples": [
          "SELECT strftime('%H:%M:%S', CAST(CURRENT_TIMESTAMP AS TIMESTAMP)); -- Returns the current time formatted as 'HH:MM:SS'.",
          "SELECT strftime('%H:%M:%S', CAST(CURRENT_TIMESTAMP + INTERVAL '1 hour' AS TIMESTAMP)); -- Adds 1 hour to the time, returning 'HH:MM:SS'.",
          "SELECT strftime('%H:%M:%S.%f', CAST(CONCAT('1970-01-01 ', '14:16:00') AS TIMESTAMP)); -- Returns '14:16:00.000000' with fractional seconds by concatenating time with a default date."
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_66_2",
    "database_name": "duckdb_66_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT sec_to_time(86399)='23:59:59'; -- SEC_TO_TIME",
    "target_query": "SELECT ((INTERVAL 86399 SECOND) + '00:00:00'::TIME) = '23:59:59';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "SEC_TO_TIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SEC_TO_TIME(seconds)",
        "description": "Converts the given number of seconds into a time value in the format HH:MM:SS. Wraps around if seconds exceed 86400.",
        "examples": [
          "SELECT SEC_TO_TIME(3661); -- Returns '01:01:01'",
          "SELECT SEC_TO_TIME(3600); -- Returns '01:00:00'",
          "SELECT SEC_TO_TIME(86400); -- Returns '00:00:00'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "(INTERVAL seconds SECOND) + '00:00:00'::TIME",
        "description": "Converts the number of seconds to an interval and adds it to a base time of '00:00:00'.",
        "examples": [
          "SELECT (INTERVAL 3661 SECOND) + '00:00:00'::TIME; -- Returns '01:01:01'",
          "SELECT (INTERVAL 3600 SECOND) + '00:00:00'::TIME; -- Returns '01:00:00'",
          "SELECT (INTERVAL 86400 SECOND) + '00:00:00'::TIME; -- Returns '00:00:00'"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_66_3",
    "database_name": "duckdb_66_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT time(sec_to_time(86399))=TIME('23:59:59'); -- TIME, SEC_TO_TIME",
    "target_query": "SELECT strftime('%H:%M:%S',CAST(CONCAT('1970-01-01 ', ((INTERVAL 86399 SECOND) + '00:00:00'::TIME)::VARCHAR) AS TIMESTAMP)) =strftime('%H:%M:%S',CAST(CONCAT('1970-01-01 ', '23:59:59') AS TIMESTAMP));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME",
      "SEC_TO_TIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
        "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
        "examples": [
          "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
          "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
        ]
      },
      {
        "expression": "SEC_TO_TIME(seconds)",
        "description": "Converts the given number of seconds into a time value in the format HH:MM:SS. Wraps around if seconds exceed 86400.",
        "examples": [
          "SELECT SEC_TO_TIME(3661); -- Returns '01:01:01'",
          "SELECT SEC_TO_TIME(3600); -- Returns '01:00:00'",
          "SELECT SEC_TO_TIME(86400); -- Returns '00:00:00'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "strftime(format, datetime_expr)",
        "description": "DuckDB does not have a native TIME type, so operations involving just hours, minutes, and seconds must be done on full DateTime values. The `strftime` function can be used to extract or format time from a complete `TIMESTAMP` value. If a time value does not include year information (e.g., '14:16:00'), a default year (e.g., '1970-01-01') must be added to ensure it forms a valid `TIMESTAMP`. This is necessary to perform the time-based operations correctly.",
        "examples": [
          "SELECT strftime('%H:%M:%S', CAST(CURRENT_TIMESTAMP AS TIMESTAMP)); -- Returns the current time formatted as 'HH:MM:SS'.",
          "SELECT strftime('%H:%M:%S', CAST(CURRENT_TIMESTAMP + INTERVAL '1 hour' AS TIMESTAMP)); -- Adds 1 hour to the time, returning 'HH:MM:SS'.",
          "SELECT strftime('%H:%M:%S.%f', CAST(CONCAT('1970-01-01 ', '14:16:00') AS TIMESTAMP)); -- Returns '14:16:00.000000' with fractional seconds by concatenating time with a default date."
        ]
      },
      {
        "expression": "(INTERVAL seconds SECOND) + '00:00:00'::TIME",
        "description": "Converts the number of seconds to an interval and adds it to a base time of '00:00:00'.",
        "examples": [
          "SELECT (INTERVAL 3661 SECOND) + '00:00:00'::TIME; -- Returns '01:01:01'",
          "SELECT (INTERVAL 3600 SECOND) + '00:00:00'::TIME; -- Returns '01:00:00'",
          "SELECT (INTERVAL 86400 SECOND) + '00:00:00'::TIME; -- Returns '00:00:00'"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_66_4",
    "database_name": "duckdb_66_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT maketime(1,0,1)='01:00:01'; -- MAKETIME",
    "target_query": "SELECT make_time(1, 0, 1) = '01:00:01';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKETIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKETIME(hours, minutes, seconds)",
        "description": "Creates a time value from the provided hours, minutes, and seconds.",
        "examples": [
          "SELECT MAKETIME(1, 30, 45);",
          "SELECT MAKETIME(12, 0, 0);",
          "SELECT MAKETIME(23, 59, 59);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "make_time(hour, minute, second)",
        "description": "Constructs a time value from the given hour, minute, and second components using the built-in make_time function.",
        "examples": [
          "SELECT make_time(1, 30, 45);",
          "SELECT make_time(12, 0, 0);",
          "SELECT make_time(23, 59, 59);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_66_6",
    "database_name": "duckdb_66_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT maketime(1,0,1)=CAST('01:00:01' AS TIME); -- MAKETIME",
    "target_query": "SELECT make_time(1, 0, 1) = CAST('01:00:01' AS TIME);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKETIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKETIME(hours, minutes, seconds)",
        "description": "Creates a time value from the provided hours, minutes, and seconds.",
        "examples": [
          "SELECT MAKETIME(1, 30, 45);",
          "SELECT MAKETIME(12, 0, 0);",
          "SELECT MAKETIME(23, 59, 59);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "make_time(hour, minute, second)",
        "description": "Constructs a time value from the given hour, minute, and second components using the built-in make_time function.",
        "examples": [
          "SELECT make_time(1, 30, 45);",
          "SELECT make_time(12, 0, 0);",
          "SELECT make_time(23, 59, 59);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_67_0",
    "database_name": "duckdb_67_0",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select elt(2,1),field(NULL,\"a\",\"b\",\"c\"); -- ELT, FIELD",
    "target_query": "SELECT ['1', '2', '3'][2], COALESCE(array_position(ARRAY['a', 'b', 'c'], NULL), 0);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ELT",
      "FIELD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ELT(2, 'apple', 'banana', 'cherry')",
        "description": "Returns the N-th element from the list, where N is the first argument.",
        "examples": [
          "SELECT ELT(2, 'apple', 'banana', 'cherry');  -- Returns 'banana'",
          "SELECT ELT(1, 'red', 'green', 'blue');  -- Returns 'red'",
          "SELECT ELT(3, 'dog', 'cat', 'bird');  -- Returns 'bird'"
        ]
      },
      {
        "expression": "FIELD(val, val1, val2, ..., valN)",
        "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
        "examples": [
          "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "['str1', 'str2', 'str3'][N]",
        "description": "Simulates ELT by using array literal and 1-based indexing. Returns NULL if index is out of bounds.",
        "examples": [
          "SELECT ['apple', 'banana', 'cherry'][2];  -- Returns 'banana'",
          "SELECT ['red', 'green', 'blue'][1];  -- Returns 'red'",
          "SELECT ['dog', 'cat', 'bird'][3];  -- Returns 'bird'"
        ]
      },
      {
        "expression": "COALESCE(array_position(ARRAY[val1, val2, ..., valN], val), 0)",
        "description": "Returns the index (1-based) of 'val' in the array. Returns 0 if not found, emulating MySQL FIELD().",
        "examples": [
          "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'c'), 0) AS result;",
          "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'x'), 0) AS result;",
          "SELECT COALESCE(array_position(ARRAY['b', 'b', 'b'], 'b'), 0) AS result;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_67_1",
    "database_name": "duckdb_67_1",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select field(\"b\",\"a\",NULL),field(1,0,NULL)+0,field(1.0,0.0,NULL)+0.0,field(1.0e1,0.0e1,NULL)+0.0e1; -- FIELD",
    "target_query": "SELECT COALESCE(array_position(ARRAY['a', NULL], 'b'), 0), COALESCE(array_position(ARRAY[0, NULL], 1), 0) + 0, COALESCE(array_position(ARRAY[0.0, NULL], 1.0), 0) + 0.0, COALESCE(array_position(ARRAY[0.0e1, NULL], 1.0e1), 0) + 0.0e1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FIELD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FIELD(val, val1, val2, ..., valN)",
        "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
        "examples": [
          "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(array_position(ARRAY[val1, val2, ..., valN], val), 0)",
        "description": "Returns the index (1-based) of 'val' in the array. Returns 0 if not found, emulating MySQL FIELD().",
        "examples": [
          "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'c'), 0) AS result;",
          "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'x'), 0) AS result;",
          "SELECT COALESCE(array_position(ARRAY['b', 'b', 'b'], 'b'), 0) AS result;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_67_2",
    "database_name": "duckdb_67_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select field(NULL,\"a\",NULL),field(NULL,0,NULL)+0,field(NULL,0.0,NULL)+0.0,field(NULL,0.0e1,NULL)+0.0e1; -- FIELD",
    "target_query": "SELECT COALESCE(array_position(ARRAY['a', NULL], NULL), 0), COALESCE(array_position(ARRAY[0, NULL], NULL), 0) + 0, COALESCE(array_position(ARRAY[0.0, NULL], NULL), 0) + 0.0, COALESCE(array_position(ARRAY[0.0e1, NULL], NULL), 0) + 0.0e1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FIELD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FIELD(val, val1, val2, ..., valN)",
        "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
        "examples": [
          "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COALESCE(array_position(ARRAY[val1, val2, ..., valN], val), 0)",
        "description": "Returns the index (1-based) of 'val' in the array. Returns 0 if not found, emulating MySQL FIELD().",
        "examples": [
          "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'c'), 0) AS result;",
          "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'x'), 0) AS result;",
          "SELECT COALESCE(array_position(ARRAY['b', 'b', 'b'], 'b'), 0) AS result;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_67_9",
    "database_name": "duckdb_67_9",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select one.id, elt(two.val,'one','two') from t1 one, t2 two where two.id=one.id; -- ELT",
    "target_query": "SELECT one.id, ['one', 'two'][two.val] FROM t1 one, t2 two WHERE two.id = one.id;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ELT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ELT(2, 'apple', 'banana', 'cherry')",
        "description": "Returns the N-th element from the list, where N is the first argument.",
        "examples": [
          "SELECT ELT(2, 'apple', 'banana', 'cherry');  -- Returns 'banana'",
          "SELECT ELT(1, 'red', 'green', 'blue');  -- Returns 'red'",
          "SELECT ELT(3, 'dog', 'cat', 'bird');  -- Returns 'bird'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "['str1', 'str2', 'str3'][N]",
        "description": "Simulates ELT by using array literal and 1-based indexing. Returns NULL if index is out of bounds.",
        "examples": [
          "SELECT ['apple', 'banana', 'cherry'][2];  -- Returns 'banana'",
          "SELECT ['red', 'green', 'blue'][1];  -- Returns 'red'",
          "SELECT ['dog', 'cat', 'bird'][3];  -- Returns 'bird'"
        ]
      }
    ],
    "source_related_schemas": [
      "create  table t1 (id int(10) not null unique);",
      "create  table t2 (id int(10) not null primary key, val int(10) not null);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id INT NOT NULL UNIQUE);",
      "CREATE TABLE t2 (id INT NOT NULL PRIMARY KEY, val INT NOT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_67_10",
    "database_name": "duckdb_67_10",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select one.id, elt(two.val,'one','two') from t1 one, t2 two where two.id=one.id order by one.id; -- ELT",
    "target_query": "SELECT one.id, ['one', 'two'][two.val] FROM t1 one, t2 two WHERE two.id = one.id ORDER BY one.id;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ELT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ELT(2, 'apple', 'banana', 'cherry')",
        "description": "Returns the N-th element from the list, where N is the first argument.",
        "examples": [
          "SELECT ELT(2, 'apple', 'banana', 'cherry');  -- Returns 'banana'",
          "SELECT ELT(1, 'red', 'green', 'blue');  -- Returns 'red'",
          "SELECT ELT(3, 'dog', 'cat', 'bird');  -- Returns 'bird'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "['str1', 'str2', 'str3'][N]",
        "description": "Simulates ELT by using array literal and 1-based indexing. Returns NULL if index is out of bounds.",
        "examples": [
          "SELECT ['apple', 'banana', 'cherry'][2];  -- Returns 'banana'",
          "SELECT ['red', 'green', 'blue'][1];  -- Returns 'red'",
          "SELECT ['dog', 'cat', 'bird'][3];  -- Returns 'bird'"
        ]
      }
    ],
    "source_related_schemas": [
      "create  table t1 (id int(10) not null unique);",
      "create  table t2 (id int(10) not null primary key, val int(10) not null);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id INT NOT NULL UNIQUE);",
      "CREATE TABLE t2 (id INT NOT NULL PRIMARY KEY, val INT NOT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_68_3",
    "database_name": "duckdb_68_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT CONCAT('\"',CONCAT_WS('\";\"',title,prio,category,program,bugdesc,created,modified,bugstatus,submitter),'\"') FROM t1; -- CONCAT, CONCAT_WS",
    "target_query": "SELECT CONCAT('\"',concat_ws('\";\"',title,prio,category,program,bugdesc,created,modified,bugstatus,submitter),'\"') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT",
      "CONCAT_WS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      },
      {
        "expression": "CONCAT_WS(separator, str1, str2, ...)",
        "description": "Concatenates multiple strings with the specified separator. If any argument is NULL, it is ignored.",
        "examples": [
          "SELECT CONCAT_WS(',', 'apple', 'banana', 'cherry');",
          "SELECT CONCAT_WS('-', 'hello', 'world');",
          "SELECT CONCAT_WS(' ', 'this', NULL, 'is', 'a', 'test');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      },
      {
        "expression": "concat_ws(separator, str1, str2, ...)",
        "description": "Concatenates strings using a separator, and ignores NULL values.",
        "examples": [
          "SELECT concat_ws(',', 'apple', 'banana', 'cherry');",
          "SELECT concat_ws('-', 'hello', 'world');",
          "SELECT concat_ws(' ', 'this', NULL, 'is', 'a', 'test');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(id int(10) NOT NULL,title varchar(255) default NULL,prio int(10) default NULL,category int(10) default NULL,program int(10) default NULL,bugdesc text,created datetime default NULL,modified timestamp NOT NULL,bugstatus int(10) default NULL,submitter int(10) default NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(id int NOT NULL,title varchar default NULL,prio int default NULL,category int default NULL,program int default NULL,bugdesc text,created datetime default NULL,modified timestamp NOT NULL,bugstatus int default NULL,submitter int default NULL);"
    ]
  },
  {
    "sql_id": "duckdb_68_4",
    "database_name": "duckdb_68_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT CONCAT('\"',CONCAT_WS('\";\"',title,prio,category,program,bugstatus,submitter),'\"') FROM t1; -- CONCAT, CONCAT_WS",
    "target_query": "SELECT CONCAT('\"',concat_ws('\";\"',title,prio,category,program,bugstatus,submitter),'\"') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT",
      "CONCAT_WS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      },
      {
        "expression": "CONCAT_WS(separator, str1, str2, ...)",
        "description": "Concatenates multiple strings with the specified separator. If any argument is NULL, it is ignored.",
        "examples": [
          "SELECT CONCAT_WS(',', 'apple', 'banana', 'cherry');",
          "SELECT CONCAT_WS('-', 'hello', 'world');",
          "SELECT CONCAT_WS(' ', 'this', NULL, 'is', 'a', 'test');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      },
      {
        "expression": "concat_ws(separator, str1, str2, ...)",
        "description": "Concatenates strings using a separator, and ignores NULL values.",
        "examples": [
          "SELECT concat_ws(',', 'apple', 'banana', 'cherry');",
          "SELECT concat_ws('-', 'hello', 'world');",
          "SELECT concat_ws(' ', 'this', NULL, 'is', 'a', 'test');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(id int(10) NOT NULL,title varchar(255) default NULL,prio int(10) default NULL,category int(10) default NULL,program int(10) default NULL,bugdesc text,created datetime default NULL,modified timestamp NOT NULL,bugstatus int(10) default NULL,submitter int(10) default NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(id int NOT NULL,title varchar default NULL,prio int default NULL,category int default NULL,program int default NULL,bugdesc text,created datetime default NULL,modified timestamp NOT NULL,bugstatus int default NULL,submitter int default NULL);"
    ]
  },
  {
    "sql_id": "duckdb_68_5",
    "database_name": "duckdb_68_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT CONCAT_WS('\";\"',title,prio,category,program,bugdesc,created,modified,bugstatus,submitter) FROM t1; -- CONCAT_WS",
    "target_query": "SELECT concat_ws('\";\"',title,prio,category,program,bugdesc,created,modified,bugstatus,submitter) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT_WS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT_WS(separator, str1, str2, ...)",
        "description": "Concatenates multiple strings with the specified separator. If any argument is NULL, it is ignored.",
        "examples": [
          "SELECT CONCAT_WS(',', 'apple', 'banana', 'cherry');",
          "SELECT CONCAT_WS('-', 'hello', 'world');",
          "SELECT CONCAT_WS(' ', 'this', NULL, 'is', 'a', 'test');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat_ws(separator, str1, str2, ...)",
        "description": "Concatenates strings using a separator, and ignores NULL values.",
        "examples": [
          "SELECT concat_ws(',', 'apple', 'banana', 'cherry');",
          "SELECT concat_ws('-', 'hello', 'world');",
          "SELECT concat_ws(' ', 'this', NULL, 'is', 'a', 'test');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(id int(10) NOT NULL,title varchar(255) default NULL,prio int(10) default NULL,category int(10) default NULL,program int(10) default NULL,bugdesc text,created datetime default NULL,modified timestamp NOT NULL,bugstatus int(10) default NULL,submitter int(10) default NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(id int NOT NULL,title varchar default NULL,prio int default NULL,category int default NULL,program int default NULL,bugdesc text,created datetime default NULL,modified timestamp NOT NULL,bugstatus int default NULL,submitter int default NULL);"
    ]
  },
  {
    "sql_id": "duckdb_68_10",
    "database_name": "duckdb_68_10",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT CONCAT(\"</a>\",RPAD(\"\",(55-LENGTH(title)),\".\")) from t1; -- CONCAT, RPAD, LENGTH",
    "target_query": "SELECT CONCAT('</a>', RPAD('', (55 - length(title))::INT, '.')) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT",
      "RPAD",
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      },
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      },
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
        "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT 'Year: ' || 2025;",
          "SELECT name || '_' || id FROM users;"
        ]
      },
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "DuckDB supports RPAD for string padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123::TEXT, 5, '0');"
        ]
      },
      {
        "expression": "length(str)",
        "description": "Returns the number of bytes in the input string.",
        "examples": [
          "SELECT length('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(title text);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(title text);"
    ]
  },
  {
    "sql_id": "duckdb_69_0",
    "database_name": "duckdb_69_0",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select 0=0,1>0,1>=1,1<0,1<=0,1!=0,strcmp(\"abc\",\"abcd\"),strcmp(\"b\",\"a\"),strcmp(\"a\",\"a\") ; -- STRCMP",
    "target_query": "SELECT 0=0, 1>0, 1>=1, 1<0, 1<=0, 1!=0, CASE WHEN 'abc' = 'abcd' THEN 0 WHEN 'abc' < 'abcd' THEN -1 ELSE 1 END, CASE WHEN 'b' = 'a' THEN 0 WHEN 'b' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'a' = 'a' THEN 0 WHEN 'a' < 'a' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "DuckDB does not have a STRCMP function, but the same functionality can be achieved using a CASE statement to compare strings lexicographically.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_69_4",
    "database_name": "duckdb_69_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT GREATEST(d,d) FROM t1 WHERE k=2; -- GREATEST",
    "target_query": "SELECT GREATEST(d,d)FROM t1 WHERE k=2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (d varchar(6), k int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(d VARCHAR(6),k INT);"
    ]
  },
  {
    "sql_id": "duckdb_69_6",
    "database_name": "duckdb_69_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select (12 mod 1) <=> null  as 'col'; -- MOD",
    "target_query": "SELECT CASE WHEN 0=0 THEN NULL ELSE 12%1 END AS col;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MOD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Returns the remainder of N divided by M. Returns NULL if M = 0.",
        "examples": [
          "SELECT MOD(10, 3);",
          "SELECT 10 % 3;",
          "SELECT MOD(5, 0);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Computes the modulo operation. Division by 0 throws error.",
        "examples": [
          "SELECT MOD(13, 4);",
          "SELECT 13 % 4;",
          "SELECT MOD(3, 0);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_69_7",
    "database_name": "duckdb_69_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select (12 mod 1) is null   as 'col'; -- MOD",
    "target_query": "SELECT CASE WHEN 0=0 THEN NULL ELSE 12%1 END IS NULL AS col;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MOD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Returns the remainder of N divided by M. Returns NULL if M = 0.",
        "examples": [
          "SELECT MOD(10, 3);",
          "SELECT 10 % 3;",
          "SELECT MOD(5, 0);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Computes the modulo operation. Division by 0 throws error.",
        "examples": [
          "SELECT MOD(13, 4);",
          "SELECT 13 % 4;",
          "SELECT MOD(3, 0);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_69_8",
    "database_name": "duckdb_69_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select mod(12.0, 1)         as 'col'; -- MOD",
    "target_query": "SELECT CASE WHEN 0=0 THEN NULL ELSE MOD(12.0,1)END AS col;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MOD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Returns the remainder of N divided by M. Returns NULL if M = 0.",
        "examples": [
          "SELECT MOD(10, 3);",
          "SELECT 10 % 3;",
          "SELECT MOD(5, 0);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Computes the modulo operation. Division by 0 throws error.",
        "examples": [
          "SELECT MOD(13, 4);",
          "SELECT 13 % 4;",
          "SELECT MOD(3, 0);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_69_9",
    "database_name": "duckdb_69_9",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "select mod(12, 1.0)         as 'col'; -- MOD",
    "target_query": "SELECT CASE WHEN 0=0 THEN NULL ELSE MOD(12,1)END AS col;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MOD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Returns the remainder of N divided by M. Returns NULL if M = 0.",
        "examples": [
          "SELECT MOD(10, 3);",
          "SELECT 10 % 3;",
          "SELECT MOD(5, 0);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Computes the modulo operation. Division by 0 throws error.",
        "examples": [
          "SELECT MOD(13, 4);",
          "SELECT 13 % 4;",
          "SELECT MOD(3, 0);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_69_10",
    "database_name": "duckdb_69_10",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT greatest( 123456789 , 234567890 ) as g; -- GREATEST",
    "target_query": "SELECT GREATEST(123456789,234567890)AS g;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_69_11",
    "database_name": "duckdb_69_11",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT least   ( 123456789 , 234567890 ) as l; -- LEAST",
    "target_query": "SELECT LEAST(123456789,234567890)AS l;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the least non-null value among the provided expressions. NULLs are skipped unless all arguments are NULL. This differs from MySQL/MariaDB which return NULL if any argument is NULL.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(DATE '2024-01-01', DATE '2023-12-31');",
          "SELECT least(NULL, 2);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_69_12",
    "database_name": "duckdb_69_12",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT greatest (123456789, -1, 234567890 ) as g; -- GREATEST",
    "target_query": "SELECT GREATEST(123456789,-1,234567890)AS g;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_69_13",
    "database_name": "duckdb_69_13",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT least    (123456789, -1, 234567890 ) as l; -- LEAST",
    "target_query": "SELECT LEAST(123456789,-1,234567890)AS l;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the least non-null value among the provided expressions. NULLs are skipped unless all arguments are NULL. This differs from MySQL/MariaDB which return NULL if any argument is NULL.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(DATE '2024-01-01', DATE '2023-12-31');",
          "SELECT least(NULL, 2);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_69_14",
    "database_name": "duckdb_69_14",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "CREATE TABLE t1 AS SELECT greatest(-1, 123456789); -- GREATEST",
    "target_query": "CREATE TABLE t1 AS SELECT GREATEST(-1,123456789);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 AS SELECT greatest(-1, 123456789); -- GREATEST"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 AS SELECT GREATEST(-1,123456789);"
    ]
  },
  {
    "sql_id": "duckdb_70_0",
    "database_name": "duckdb_70_0",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT GREATEST('11', '5', '2'); -- GREATEST",
    "target_query": "SELECT GREATEST('11', '5', '2');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_70_1",
    "database_name": "duckdb_70_1",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT GREATEST('11', 5, 2); -- GREATEST",
    "target_query": "SELECT GREATEST('11', 5, 2);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_70_2",
    "database_name": "duckdb_70_2",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT GREATEST(11, 5, 2); -- GREATEST",
    "target_query": "SELECT GREATEST(11, 5, 2);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_70_3",
    "database_name": "duckdb_70_3",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT LEAST('11', '5', '2'); -- LEAST",
    "target_query": "SELECT least('11', '5', '2');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the least non-null value among the provided expressions. NULLs are skipped unless all arguments are NULL. This differs from MySQL/MariaDB which return NULL if any argument is NULL.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(DATE '2024-01-01', DATE '2023-12-31');",
          "SELECT least(NULL, 2);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_70_4",
    "database_name": "duckdb_70_4",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT LEAST('11', 5, 2); -- LEAST",
    "target_query": "SELECT least('11', 5, 2);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the least non-null value among the provided expressions. NULLs are skipped unless all arguments are NULL. This differs from MySQL/MariaDB which return NULL if any argument is NULL.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(DATE '2024-01-01', DATE '2023-12-31');",
          "SELECT least(NULL, 2);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_70_5",
    "database_name": "duckdb_70_5",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT LEAST(11, 5, 2); -- LEAST",
    "target_query": "SELECT least(11, 5, 2);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the least non-null value among the provided expressions. NULLs are skipped unless all arguments are NULL. This differs from MySQL/MariaDB which return NULL if any argument is NULL.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(DATE '2024-01-01', DATE '2023-12-31');",
          "SELECT least(NULL, 2);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_70_6",
    "database_name": "duckdb_70_6",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT GREATEST('11', '5', '2') + 0; -- GREATEST",
    "target_query": "SELECT GREATEST('11', '5', '2')::INTEGER + 0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_70_7",
    "database_name": "duckdb_70_7",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT GREATEST('11', 5, 2) + 0; -- GREATEST",
    "target_query": "SELECT GREATEST('11', 5, 2) + 0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_70_8",
    "database_name": "duckdb_70_8",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT GREATEST(11, 5, 2) + 0; -- GREATEST",
    "target_query": "SELECT GREATEST(11, 5, 2) + 0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_70_9",
    "database_name": "duckdb_70_9",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT GREATEST('11', '5', '2') + 0.00; -- GREATEST",
    "target_query": "SELECT GREATEST('11', '5', '2')::INTEGER + 0.00;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_70_10",
    "database_name": "duckdb_70_10",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT GREATEST('11', 5, 2) + 0.00; -- GREATEST",
    "target_query": "SELECT GREATEST('11', 5, 2) + 0.00;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_70_11",
    "database_name": "duckdb_70_11",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT GREATEST(11, 5, 2) + 0.00; -- GREATEST",
    "target_query": "SELECT GREATEST(11, 5, 2) + 0.00;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_70_15",
    "database_name": "duckdb_70_15",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT greatest(18446744073709551615, NULL)FROM t0017; -- GREATEST",
    "target_query": "SELECT GREATEST(18446744073709551615, NULL) FROM t0017;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t0017 (c0002 bigint(20) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0017 (c0002 BIGINT NOT NULL);"
    ]
  },
  {
    "sql_id": "duckdb_70_20",
    "database_name": "duckdb_70_20",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT * FROM t1 WHERE (GREATEST(c1, c2) = 42) AND (c2 = 1); -- GREATEST",
    "target_query": "SELECT * FROM t1 WHERE (GREATEST(c1, c2) = 42) AND (c2 = 1);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (c1 INT, c2 INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 INT, c2 INT);"
    ]
  },
  {
    "sql_id": "duckdb_70_27",
    "database_name": "duckdb_70_27",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT SUM(LEAST(a, b)) FROM t1; -- LEAST",
    "target_query": "SELECT SUM(least(a, b)) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the least non-null value among the provided expressions. NULLs are skipped unless all arguments are NULL. This differs from MySQL/MariaDB which return NULL if any argument is NULL.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(DATE '2024-01-01', DATE '2023-12-31');",
          "SELECT least(NULL, 2);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 (a INTEGER, b INTEGER);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (a INTEGER, b INTEGER);"
    ]
  },
  {
    "sql_id": "duckdb_70_28",
    "database_name": "duckdb_70_28",
    "source_dialect": "mysql",
    "target_dialect": "duckdb",
    "source_query": "SELECT SUM(LEAST(a, b)) FROM t2; -- LEAST",
    "target_query": "SELECT SUM(least(a, b)) FROM t2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the least non-null value among the provided expressions. NULLs are skipped unless all arguments are NULL. This differs from MySQL/MariaDB which return NULL if any argument is NULL.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(DATE '2024-01-01', DATE '2023-12-31');",
          "SELECT least(NULL, 2);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 (a INTEGER, b INTEGER);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (a INTEGER, b INTEGER);"
    ]
  },
  {
    "sql_id": "duckdb_1_33",
    "database_name": "duckdb_1_33",
    "source_dialect": "postgresql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO clstr_tst (a, b, c, d) VALUES (32, 6, 'seis', repeat('xyzzy', 10000)); -- REPEAT",
    "target_query": "INSERT INTO clstr_tst (a, b, c, d) VALUES (32, 6, 'seis', REPEAT('xyzzy', 10000));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE clstr_tst (a SERIAL PRIMARY KEY,b INT,c TEXT,d TEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE clstr_tst (a INTEGER PRIMARY KEY, b INT, c TEXT, d TEXT);"
    ]
  },
  {
    "sql_id": "duckdb_10_2",
    "database_name": "duckdb_10_2",
    "source_dialect": "postgresql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO tidrangescan SELECT i,repeat('x', 100) FROM generate_series(1,200) AS s(i); -- REPEAT, GENERATE_SERIES",
    "target_query": "INSERT INTO tidrangescan SELECT i,repeat('x', 100) FROM generate_series(1,200) AS s(i);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT",
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      },
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      },
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Returns a numeric series from start to stop, with an optional step, fully compatible with PostgreSQL.",
        "examples": [
          "SELECT * FROM generate_series(1, 5);",
          "SELECT * FROM generate_series(3, 9, 2);",
          "SELECT * FROM generate_series(10, 6, -2);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE tidrangescan(id integer, data text);"
    ],
    "target_related_schemas": [
      "CREATE TABLE tidrangescan(id integer, data text);"
    ]
  },
  {
    "sql_id": "duckdb_12_0",
    "database_name": "duckdb_12_0",
    "source_dialect": "postgresql",
    "target_dialect": "duckdb",
    "source_query": "SELECT generate_series(1, 3); -- GENERATE_SERIES",
    "target_query": "SELECT * FROM generate_series(1, 3);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Returns a numeric series from start to stop, with an optional step, fully compatible with PostgreSQL.",
        "examples": [
          "SELECT * FROM generate_series(1, 5);",
          "SELECT * FROM generate_series(3, 9, 2);",
          "SELECT * FROM generate_series(10, 6, -2);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_12_1",
    "database_name": "duckdb_12_1",
    "source_dialect": "postgresql",
    "target_dialect": "duckdb",
    "source_query": "SELECT generate_series(1, 3) AS val1, generate_series(3,5) AS val2; -- GENERATE_SERIES",
    "target_query": "SELECT * FROM generate_series(1, 3) AS t1(val1), generate_series(3, 5) AS t2(val2);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Returns a numeric series from start to stop, with an optional step, fully compatible with PostgreSQL.",
        "examples": [
          "SELECT * FROM generate_series(1, 5);",
          "SELECT * FROM generate_series(3, 9, 2);",
          "SELECT * FROM generate_series(10, 6, -2);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_12_2",
    "database_name": "duckdb_12_2",
    "source_dialect": "postgresql",
    "target_dialect": "duckdb",
    "source_query": "SELECT generate_series(1, 2) AS val1, generate_series(1,4) AS val2; -- GENERATE_SERIES",
    "target_query": "SELECT * FROM generate_series(1, 2) AS t1(val1), generate_series(1, 4) AS t2(val2);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Returns a numeric series from start to stop, with an optional step, fully compatible with PostgreSQL.",
        "examples": [
          "SELECT * FROM generate_series(1, 5);",
          "SELECT * FROM generate_series(3, 9, 2);",
          "SELECT * FROM generate_series(10, 6, -2);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_2_2",
    "database_name": "duckdb_2_2",
    "source_dialect": "postgresql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO cmdata VALUES(repeat('1234567890', 1000)); -- REPEAT",
    "target_query": "INSERT INTO cmdata VALUES(repeat('1234567890', 1000));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE cmdata(f1 text);"
    ],
    "target_related_schemas": [
      "CREATE TABLE cmdata(f1 text);"
    ]
  },
  {
    "sql_id": "duckdb_2_6",
    "database_name": "duckdb_2_6",
    "source_dialect": "postgresql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO cmdata1 VALUES(repeat('1234567890', 1004)); -- REPEAT",
    "target_query": "INSERT INTO cmdata1 VALUES(repeat('1234567890', 1004));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE cmdata1(f1 TEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE cmdata1(f1 TEXT);"
    ]
  },
  {
    "sql_id": "duckdb_3_3",
    "database_name": "duckdb_3_3",
    "source_dialect": "postgresql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO delete_test (id, a, b) VALUES (2, 50, repeat('x', 10000)); -- REPEAT",
    "target_query": "INSERT INTO delete_test (id, a, b) VALUES (2, 50, REPEAT('x', 10000));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE delete_test (id SERIAL PRIMARY KEY,a INT,b text);"
    ],
    "target_related_schemas": [
      "CREATE TABLE delete_test (id INTEGER PRIMARY KEY, a INT, b text);"
    ]
  },
  {
    "sql_id": "duckdb_4_0",
    "database_name": "duckdb_4_0",
    "source_dialect": "postgresql",
    "target_dialect": "duckdb",
    "source_query": "SELECT current_timestamp = NOW(); -- NOW",
    "target_query": "SELECT current_timestamp = CURRENT_TIMESTAMP;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "In PostgreSQL, CURRENT_TIMESTAMP is used to retrieve the current date and time, equivalent to NOW() in MySQL and MariaDB.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "DuckDB also uses CURRENT_TIMESTAMP to get the current date and time, similar to PostgreSQL and MonetDB.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_5_0",
    "database_name": "duckdb_5_0",
    "source_dialect": "postgresql",
    "target_dialect": "duckdb",
    "source_query": "select current_schemas(false); -- CURRENT_SCHEMAS",
    "target_query": "SELECT current_schemas(FALSE);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CURRENT_SCHEMAS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "current_schemas(include_implicit boolean)",
        "description": "Returns a text array of schema names in the current search path. The boolean parameter controls whether implicit schemas such as pg_catalog are included.",
        "examples": [
          "SELECT current_schemas(false);",
          "SELECT current_schemas(true);",
          "SELECT unnest(current_schemas(false));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "current_schemas(include_implicit BOOLEAN)",
        "description": "Returns an array of schema names in the current search path for the session. The boolean parameter controls inclusion of implicit schemas.",
        "examples": [
          "SELECT current_schemas(FALSE);",
          "SELECT current_schemas(TRUE);",
          "SELECT UNNEST(current_schemas(FALSE));"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "duckdb_6_2",
    "database_name": "duckdb_6_2",
    "source_dialect": "postgresql",
    "target_dialect": "duckdb",
    "source_query": "create table simple1 as select generate_series(1, 200) AS id; -- GENERATE_SERIES",
    "target_query": "create table simple1 as select generate_series(1, 200) AS id;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Returns a numeric series from start to stop, with an optional step, fully compatible with PostgreSQL.",
        "examples": [
          "SELECT * FROM generate_series(1, 5);",
          "SELECT * FROM generate_series(3, 9, 2);",
          "SELECT * FROM generate_series(10, 6, -2);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table simple1 as select generate_series(1, 200) AS id; -- GENERATE_SERIES"
    ],
    "target_related_schemas": [
      "create table simple1 as select generate_series(1, 200) AS id;"
    ]
  },
  {
    "sql_id": "duckdb_6_5",
    "database_name": "duckdb_6_5",
    "source_dialect": "postgresql",
    "target_dialect": "duckdb",
    "source_query": "create table bigger_than_it_looks as select generate_series(1, 200) as id; -- GENERATE_SERIES",
    "target_query": "create table bigger_than_it_looks as select generate_series(1, 200) as id;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Returns a numeric series from start to stop, with an optional step, fully compatible with PostgreSQL.",
        "examples": [
          "SELECT * FROM generate_series(1, 5);",
          "SELECT * FROM generate_series(3, 9, 2);",
          "SELECT * FROM generate_series(10, 6, -2);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table bigger_than_it_looks as select generate_series(1, 200) as id; -- GENERATE_SERIES"
    ],
    "target_related_schemas": [
      "create table bigger_than_it_looks as select generate_series(1, 200) as id;"
    ]
  },
  {
    "sql_id": "duckdb_6_10",
    "database_name": "duckdb_6_10",
    "source_dialect": "postgresql",
    "target_dialect": "duckdb",
    "source_query": "insert into extremely_skewed select 42 as id, 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'from generate_series(1, 200); -- GENERATE_SERIES",
    "target_query": "insert into extremely_skewed select 42 as id, 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' from generate_series(1, 200);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Returns a numeric series from start to stop, with an optional step, fully compatible with PostgreSQL.",
        "examples": [
          "SELECT * FROM generate_series(1, 5);",
          "SELECT * FROM generate_series(3, 9, 2);",
          "SELECT * FROM generate_series(10, 6, -2);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table extremely_skewed (id int, t text);"
    ],
    "target_related_schemas": [
      "create table extremely_skewed (id int, t text);"
    ]
  },
  {
    "sql_id": "duckdb_6_12",
    "database_name": "duckdb_6_12",
    "source_dialect": "postgresql",
    "target_dialect": "duckdb",
    "source_query": "create table wide as select generate_series(1, 2) as id, rpad('', 320000, 'x') as t; -- GENERATE_SERIES, RPAD",
    "target_query": "create table wide as select generate_series(1, 2) as id, rpad('', 320000, 'x') as t;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GENERATE_SERIES",
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      },
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "PostgreSQL doesn't have a native RPAD, but can simulate it.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123::text, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Returns a numeric series from start to stop, with an optional step, fully compatible with PostgreSQL.",
        "examples": [
          "SELECT * FROM generate_series(1, 5);",
          "SELECT * FROM generate_series(3, 9, 2);",
          "SELECT * FROM generate_series(10, 6, -2);"
        ]
      },
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "DuckDB supports RPAD for string padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123::TEXT, 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table wide as select generate_series(1, 2) as id, rpad('', 320000, 'x') as t; -- GENERATE_SERIES, RPAD"
    ],
    "target_related_schemas": [
      "create table wide as select generate_series(1, 2) as id, rpad('', 320000, 'x') as t;"
    ]
  },
  {
    "sql_id": "duckdb_6_14",
    "database_name": "duckdb_6_14",
    "source_dialect": "postgresql",
    "target_dialect": "duckdb",
    "source_query": "create table join_foo as select generate_series(1, 3) as id, 'xxxxx'::text as t; -- GENERATE_SERIES",
    "target_query": "create table join_foo as select generate_series(1, 3) as id, 'xxxxx'::text as t;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Returns a numeric series from start to stop, with an optional step, fully compatible with PostgreSQL.",
        "examples": [
          "SELECT * FROM generate_series(1, 5);",
          "SELECT * FROM generate_series(3, 9, 2);",
          "SELECT * FROM generate_series(10, 6, -2);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table join_foo as select generate_series(1, 3) as id, 'xxxxx'::text as t; -- GENERATE_SERIES"
    ],
    "target_related_schemas": [
      "create table join_foo as select generate_series(1, 3) as id, 'xxxxx'::text as t;"
    ]
  },
  {
    "sql_id": "duckdb_6_16",
    "database_name": "duckdb_6_16",
    "source_dialect": "postgresql",
    "target_dialect": "duckdb",
    "source_query": "create table join_bar as select generate_series(1, 10000) as id, 'xxxxx'::text as t; -- GENERATE_SERIES",
    "target_query": "create table join_bar as select generate_series(1, 10000) as id, 'xxxxx'::text as t;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Returns a numeric series from start to stop, with an optional step, fully compatible with PostgreSQL.",
        "examples": [
          "SELECT * FROM generate_series(1, 5);",
          "SELECT * FROM generate_series(3, 9, 2);",
          "SELECT * FROM generate_series(10, 6, -2);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table join_bar as select generate_series(1, 10000) as id, 'xxxxx'::text as t; -- GENERATE_SERIES"
    ],
    "target_related_schemas": [
      "create table join_bar as select generate_series(1, 10000) as id, 'xxxxx'::text as t;"
    ]
  },
  {
    "sql_id": "duckdb_7_2",
    "database_name": "duckdb_7_2",
    "source_dialect": "postgresql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO pagg_tab SELECT i % 20, i % 30, to_char(i % 12, 'FM0000'), i % 30 FROM generate_series(0, 2999) i; -- TO_CHAR, GENERATE_SERIES",
    "target_query": "WITH series AS (SELECT generate_series AS i FROM generate_series(0, 2999)) INSERT INTO pagg_tab SELECT i % 20, i % 30, lpad(CAST(i % 12 AS VARCHAR), 4, '0'), i % 30 FROM series;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TO_CHAR",
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "to_char(numeric, 'FM0000')",
        "description": "Formats a number as a zero-padded 4-digit string without leading spaces.",
        "examples": [
          "SELECT to_char(5, 'FM0000');   -- 0005",
          "SELECT to_char(123, 'FM0000'); -- 0123",
          "SELECT to_char(0, 'FM0000');   -- 0000"
        ]
      },
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "lpad(CAST(value AS VARCHAR), 4, '0')",
        "description": "Pads number with zeros to 4-digit string using lpad.",
        "examples": [
          "SELECT lpad(CAST(5 AS VARCHAR), 4, '0');",
          "SELECT lpad(CAST(123 AS VARCHAR), 4, '0');",
          "SELECT lpad(CAST(0 AS VARCHAR), 4, '0');"
        ]
      },
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Returns a numeric series from start to stop, with an optional step, fully compatible with PostgreSQL.",
        "examples": [
          "SELECT * FROM generate_series(1, 5);",
          "SELECT * FROM generate_series(3, 9, 2);",
          "SELECT * FROM generate_series(10, 6, -2);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE pagg_tab (a int, b int, c text, d int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE pagg_tab (a int, b int, c text, d int);"
    ]
  },
  {
    "sql_id": "duckdb_7_7",
    "database_name": "duckdb_7_7",
    "source_dialect": "postgresql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO pagg_tab_ml SELECT i % 30, i % 10, to_char(i % 4, 'FM0000') FROM generate_series(0, 29999) i; -- TO_CHAR",
    "target_query": "WITH series AS (SELECT generate_series AS i FROM generate_series(0, 29999)) INSERT INTO pagg_tab_ml SELECT i % 30, i % 10, lpad(CAST(i % 4 AS VARCHAR), 4, '0') FROM series;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TO_CHAR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "to_char(numeric, 'FM0000')",
        "description": "Formats a number as a zero-padded 4-digit string without leading spaces.",
        "examples": [
          "SELECT to_char(5, 'FM0000');   -- 0005",
          "SELECT to_char(123, 'FM0000'); -- 0123",
          "SELECT to_char(0, 'FM0000');   -- 0000"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "lpad(CAST(value AS VARCHAR), 4, '0')",
        "description": "Pads number with zeros to 4-digit string using lpad.",
        "examples": [
          "SELECT lpad(CAST(5 AS VARCHAR), 4, '0');",
          "SELECT lpad(CAST(123 AS VARCHAR), 4, '0');",
          "SELECT lpad(CAST(0 AS VARCHAR), 4, '0');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE pagg_tab_ml (a int, b int, c text);"
    ],
    "target_related_schemas": [
      "CREATE TABLE pagg_tab_ml (a int, b int, c text);"
    ]
  },
  {
    "sql_id": "duckdb_7_9",
    "database_name": "duckdb_7_9",
    "source_dialect": "postgresql",
    "target_dialect": "duckdb",
    "source_query": "SELECT a, sum(b), array_agg(distinct c), count(*) FROM pagg_tab_ml GROUP BY a HAVING avg(b) < 3 ORDER BY 1, 2, 3; -- ARRAY_AGG",
    "target_query": "SELECT a, sum(b), array_agg(distinct c), count(*) FROM pagg_tab_ml GROUP BY a HAVING avg(b) < 3 ORDER BY 1, 2, 3;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ARRAY_AGG"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ARRAY_AGG(expression [DISTINCT])",
        "description": "Aggregate function that returns an array of all input values, optionally removing duplicates if DISTINCT is specified.",
        "examples": [
          "SELECT ARRAY_AGG(DISTINCT x) FROM (VALUES (1), (2), (1), (3)) AS t(x);",
          "SELECT id, ARRAY_AGG(value) FROM my_table GROUP BY id;",
          "SELECT ARRAY_AGG(DISTINCT LOWER(name)) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "ARRAY_AGG(expression [DISTINCT])",
        "description": "Aggregate function that collects input values into an array, optionally removing duplicates with DISTINCT. Fully equivalent to PostgreSQL's ARRAY_AGG.",
        "examples": [
          "SELECT ARRAY_AGG(DISTINCT x) FROM (VALUES (1), (2), (1), (3)) AS t(x);",
          "SELECT id, ARRAY_AGG(value) FROM my_table GROUP BY id;",
          "SELECT ARRAY_AGG(DISTINCT LOWER(name)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE pagg_tab_ml (a int, b int, c text);"
    ],
    "target_related_schemas": [
      "CREATE TABLE pagg_tab_ml (a int, b int, c text);"
    ]
  },
  {
    "sql_id": "duckdb_8_2",
    "database_name": "duckdb_8_2",
    "source_dialect": "postgresql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO prt1 SELECT i, i % 25, to_char(i, 'FM0000') FROM generate_series(0, 599) i WHERE i % 2 = 0; -- TO_CHAR, GENERATE_SERIES",
    "target_query": "WITH series AS (SELECT generate_series AS i FROM generate_series(0, 599)) INSERT INTO prt1 SELECT i, i % 25, lpad(CAST(i AS VARCHAR), 4, '0') FROM series WHERE i % 2 = 0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TO_CHAR",
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "to_char(numeric, 'FM0000')",
        "description": "Formats a number as a zero-padded 4-digit string without leading spaces.",
        "examples": [
          "SELECT to_char(5, 'FM0000');   -- 0005",
          "SELECT to_char(123, 'FM0000'); -- 0123",
          "SELECT to_char(0, 'FM0000');   -- 0000"
        ]
      },
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "lpad(CAST(value AS VARCHAR), 4, '0')",
        "description": "Pads number with zeros to 4-digit string using lpad.",
        "examples": [
          "SELECT lpad(CAST(5 AS VARCHAR), 4, '0');",
          "SELECT lpad(CAST(123 AS VARCHAR), 4, '0');",
          "SELECT lpad(CAST(0 AS VARCHAR), 4, '0');"
        ]
      },
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Returns a numeric series from start to stop, with an optional step, fully compatible with PostgreSQL.",
        "examples": [
          "SELECT * FROM generate_series(1, 5);",
          "SELECT * FROM generate_series(3, 9, 2);",
          "SELECT * FROM generate_series(10, 6, -2);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE prt1 (a int, b int, c varchar);"
    ],
    "target_related_schemas": [
      "CREATE TABLE prt1 (a int, b int, c varchar);"
    ]
  },
  {
    "sql_id": "duckdb_8_7",
    "database_name": "duckdb_8_7",
    "source_dialect": "postgresql",
    "target_dialect": "duckdb",
    "source_query": "INSERT INTO prt2 SELECT i % 25, i, to_char(i, 'FM0000') FROM generate_series(0, 599) i WHERE i % 3 = 0; -- TO_CHAR, GENERATE_SERIES",
    "target_query": "WITH series AS (SELECT generate_series AS i FROM generate_series(0, 599)) INSERT INTO prt2 SELECT i % 25, i, lpad(CAST(i AS VARCHAR), 4, '0') FROM series WHERE i % 3 = 0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TO_CHAR",
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "to_char(numeric, 'FM0000')",
        "description": "Formats a number as a zero-padded 4-digit string without leading spaces.",
        "examples": [
          "SELECT to_char(5, 'FM0000');   -- 0005",
          "SELECT to_char(123, 'FM0000'); -- 0123",
          "SELECT to_char(0, 'FM0000');   -- 0000"
        ]
      },
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "lpad(CAST(value AS VARCHAR), 4, '0')",
        "description": "Pads number with zeros to 4-digit string using lpad.",
        "examples": [
          "SELECT lpad(CAST(5 AS VARCHAR), 4, '0');",
          "SELECT lpad(CAST(123 AS VARCHAR), 4, '0');",
          "SELECT lpad(CAST(0 AS VARCHAR), 4, '0');"
        ]
      },
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Returns a numeric series from start to stop, with an optional step, fully compatible with PostgreSQL.",
        "examples": [
          "SELECT * FROM generate_series(1, 5);",
          "SELECT * FROM generate_series(3, 9, 2);",
          "SELECT * FROM generate_series(10, 6, -2);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE prt2 (a int, b int, c varchar);"
    ],
    "target_related_schemas": [
      "CREATE TABLE prt2 (a int, b int, c varchar);"
    ]
  },
  {
    "sql_id": "duckdb_9_2",
    "database_name": "duckdb_9_2",
    "source_dialect": "postgresql",
    "target_dialect": "duckdb",
    "source_query": "SELECT nextval('seq3'); -- NEXTVAL",
    "target_query": "SELECT nextval('seq3');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NEXTVAL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "nextval('sequence_name')",
        "description": "Returns the next value from a named sequence and increments the counter atomically.",
        "examples": [
          "SELECT nextval('my_seq');",
          "SELECT nextval('my_seq') + 5;",
          "SELECT nextval('my_seq') * 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "nextval('sequence_name')",
        "description": "Returns the next value from a named sequence, compatible with PostgreSQL syntax.",
        "examples": [
          "SELECT nextval('my_seq');",
          "SELECT nextval('my_seq') + 5;",
          "SELECT nextval('my_seq') * 2;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  }
]