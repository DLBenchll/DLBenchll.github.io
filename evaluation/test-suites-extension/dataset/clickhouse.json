[
  {
    "sql_id": "clickhouse_1_6",
    "database_name": "clickhouse_1_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT * FROM t0 WHERE (a, b) IN (ROW(1, 10)); -- ROW",
    "target_query": "SELECT * FROM t0 WHERE (a, b) IN (tuple(1, 10));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t0(a INT, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0(a Int32, b Int32) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_1_7",
    "database_name": "clickhouse_1_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT * FROM t0 WHERE (a, b) IN (VALUES ROW(1, 10), ROW(2, 20)); -- ROW",
    "target_query": "SELECT * FROM t0 WHERE (a, b) IN (tuple(1, 10), tuple(2, 20));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t0(a INT, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0(a Int32, b Int32) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_1_8",
    "database_name": "clickhouse_1_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT * FROM t0 WHERE (a, b) NOT IN (VALUES ROW(1, 10)); -- ROW",
    "target_query": "SELECT * FROM t0 WHERE (a, b) NOT IN (tuple(1, 10));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t0(a INT, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0(a Int32, b Int32) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_1_9",
    "database_name": "clickhouse_1_9",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT * FROM t0 WHERE (a, b) NOT IN (VALUES ROW(1, 10), ROW(2, 20)); -- ROW",
    "target_query": "SELECT * FROM t0 WHERE (a, b) NOT IN (tuple(1, 10), tuple(2, 20));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t0(a INT, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0(a Int32, b Int32) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_100_2",
    "database_name": "clickhouse_100_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 (ts) VALUES (Unix_timestamp('2002-10-27 01:00')); -- UNIX_TIMESTAMP",
    "target_query": "INSERT INTO t1 (ts) VALUES (toUnixTimestamp('2002-10-27 01:00'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp(timestamp)",
        "description": "Converts a DateTime string or value to a Unix timestamp (seconds since 1970-01-01 UTC).",
        "examples": [
          "SELECT toUnixTimestamp(now());",
          "SELECT toUnixTimestamp('2015-11-13 23:59:59+02:00');",
          "SELECT toUnixTimestamp('2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (ts int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (ts int) ENGINE=MergeTree ORDER BY ts;"
    ]
  },
  {
    "sql_id": "clickhouse_100_3",
    "database_name": "clickhouse_100_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 (ts) VALUES (Unix_timestamp('2002-10-27 02:00')); -- UNIX_TIMESTAMP",
    "target_query": "INSERT INTO t1 (ts) VALUES (toUnixTimestamp('2002-10-27 02:00'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp(timestamp)",
        "description": "Converts a DateTime string or value to a Unix timestamp (seconds since 1970-01-01 UTC).",
        "examples": [
          "SELECT toUnixTimestamp(now());",
          "SELECT toUnixTimestamp('2015-11-13 23:59:59+02:00');",
          "SELECT toUnixTimestamp('2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (ts int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (ts int) ENGINE=MergeTree ORDER BY ts;"
    ]
  },
  {
    "sql_id": "clickhouse_100_4",
    "database_name": "clickhouse_100_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 (ts) VALUES (Unix_timestamp('2002-10-27 03:00')); -- UNIX_TIMESTAMP",
    "target_query": "INSERT INTO t1 (ts) VALUES (toUnixTimestamp('2002-10-27 03:00'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp(timestamp)",
        "description": "Converts a DateTime string or value to a Unix timestamp (seconds since 1970-01-01 UTC).",
        "examples": [
          "SELECT toUnixTimestamp(now());",
          "SELECT toUnixTimestamp('2015-11-13 23:59:59+02:00');",
          "SELECT toUnixTimestamp('2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (ts int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (ts int) ENGINE=MergeTree ORDER BY ts;"
    ]
  },
  {
    "sql_id": "clickhouse_100_5",
    "database_name": "clickhouse_100_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT ts,from_unixtime(ts) FROM t1; -- FROM_UNIXTIME",
    "target_query": "SELECT ts, FROM_UNIXTIME(ts) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FROM_UNIXTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
        "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
          "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "FROM_UNIXTIME(unix_timestamp) or formatDateTime(unix_timestamp, format)",
        "description": "Converts a Unix timestamp to a DateTime. Can use formatDateTime to specify a formatted string output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT formatDateTime(1672531200, '%Y-%m-%d %H:%M:%S');",
          "SELECT id, IF(isNull(created), '-', formatDateTime(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (ts int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (ts int) ENGINE=MergeTree ORDER BY ts;"
    ]
  },
  {
    "sql_id": "clickhouse_100_7",
    "database_name": "clickhouse_100_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT TIMESTAMP( '2001-01-01 00:00:00' ); -- TIMESTAMP",
    "target_query": "SELECT toDateTime('2001-01-01 00:00:00');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
        "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
        "examples": [
          "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toDateTime('2023-06-15 10:30:45')",
        "description": "ClickHouse uses the toDateTime function to convert a date-time string to a DateTime type, without timezone support.",
        "examples": [
          "SELECT toDateTime('2023-06-15 10:30:45');",
          "SELECT toDateTime('2023-06-15 10:30:45');",
          "SELECT toDateTime('2023-06-15 10:30:45') > toDateTime('2023-06-14 10:30:45');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_100_8",
    "database_name": "clickhouse_100_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT TO_DAYS( '2001-01-01 00:00:00' ); -- TO_DAYS",
    "target_query": "SELECT toRelativeDayNum(toDate('2001-01-01 00:00:00')) + 719528;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TO_DAYS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TO_DAYS(date)",
        "description": "Returns the number of days since 0000-01-01 for a given date.",
        "examples": [
          "SELECT TO_DAYS('2024-05-07');",
          "SELECT TO_DAYS(CURDATE());",
          "SELECT TO_DAYS('1999-12-31 23:59:59');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toRelativeDayNum(date) + 719528",
        "description": "Adds offset to the days since 1970-01-01.",
        "examples": [
          "SELECT toRelativeDayNum(toDate('2024-05-07')) + 719528;",
          "SELECT toRelativeDayNum(today()) + 719528;",
          "SELECT toRelativeDayNum(toDate('1999-12-31')) + 719528;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_100_9",
    "database_name": "clickhouse_100_9",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT TO_DAYS( '2001-01-01 00:00:00' ); -- TO_DAYS",
    "target_query": "SELECT toRelativeDayNum(toDate('2001-01-01 00:00:00')) + 719528;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TO_DAYS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TO_DAYS(date)",
        "description": "Returns the number of days since 0000-01-01 for a given date.",
        "examples": [
          "SELECT TO_DAYS('2024-05-07');",
          "SELECT TO_DAYS(CURDATE());",
          "SELECT TO_DAYS('1999-12-31 23:59:59');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toRelativeDayNum(date) + 719528",
        "description": "Adds offset to the days since 1970-01-01.",
        "examples": [
          "SELECT toRelativeDayNum(toDate('2024-05-07')) + 719528;",
          "SELECT toRelativeDayNum(today()) + 719528;",
          "SELECT toRelativeDayNum(toDate('1999-12-31')) + 719528;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_100_10",
    "database_name": "clickhouse_100_10",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT DATEDIFF( '2007-12-31 23:59:59', '2007-12-30  00:00:00' ); -- DATEDIFF",
    "target_query": "SELECT dateDiff('day', toDate('2007-12-30 00:00:00'), toDate('2007-12-31 23:59:59'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATEDIFF(date1, date2)",
        "description": "Returns the number of days between two date or datetime expressions (date1 - date2), ignoring time part.",
        "examples": [
          "SELECT DATEDIFF('2025-12-31', '2025-12-01');",
          "SELECT DATEDIFF('2025-01-01', '2024-12-31');",
          "SELECT DATEDIFF(NULL, '2025-01-01');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "dateDiff('day', date2, date1)",
        "description": "Returns the number of days between two dates (date1 - date2). Must explicitly specify 'day' unit.",
        "examples": [
          "SELECT dateDiff('day', toDate('2025-12-01'), toDate('2025-12-31'));",
          "SELECT dateDiff('day', toDate('2024-12-31'), toDate('2025-01-01'));",
          "SELECT dateDiff('day', NULL, toDate('2025-01-01'));"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_100_11",
    "database_name": "clickhouse_100_11",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT TIMEDIFF( '2000:01:01 00:00:00','2000:01:01 00:00:00' ); -- TIMEDIFF",
    "target_query": "SELECT dateDiff('second', toDateTime('2000:01:01 00:00:00'), toDateTime('2000:01:01 00:00:00'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "dateDiff('second', toDateTime('2023-06-15 10:00:00'), toDateTime('2023-06-15 12:00:00'))",
        "description": "ClickHouse uses the dateDiff function to calculate the difference between two datetime values in various units.",
        "examples": [
          "SELECT dateDiff('second', toDateTime('2023-06-15 12:00:00'), toDateTime('2023-06-15 10:00:00'));",
          "SELECT dateDiff('second', now(), toDateTime('2023-06-15 10:00:00'));",
          "SELECT dateDiff('second', toDateTime('2023-06-15 12:00:00'), toDateTime('2023-06-15 10:00:00'));"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_100_12",
    "database_name": "clickhouse_100_12",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT DATE_FORMAT( '2009-10-10 23:59:59', '%W %M %Y' ); -- DATE_FORMAT",
    "target_query": "SELECT formatDateTime(toDateTime('2009-10-10 23:59:59'), '%W %M %Y');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(date_expr, format_str)",
        "description": "Formats a DateTime value using ClickHouse-supported format specifiers. Input must be a DateTime or cast to one explicitly.",
        "examples": [
          "SELECT formatDateTime(toDateTime('2024-05-06 08:30:00'), '%Y/%m/%d');",
          "SELECT formatDateTime(toDateTime('2023-07-14 15:30:00'), '%Y-%m-%d %H:%M:%S');",
          "SELECT formatDateTime(toDateTime('2022-01-01 08:45:30'), '%H:%M:%S on %d/%m/%Y');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_100_13",
    "database_name": "clickhouse_100_13",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT TIME( '2003-12-31 23:59:59' ); -- TIME",
    "target_query": "SELECT formatDateTime(toDateTime('2003-12-31 23:59:59'), '%H:%i:%s');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
        "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
        "examples": [
          "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
          "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(datetime_expr, format)",
        "description": "ClickHouse does not have a native TIME type (unlike MySQL), so operations involving just hours, minutes, and seconds must be done on full DateTime values. To extract or format time-only values like 'HH:MM:SS' or 'HH:MM:SS.SSSSSS', you must convert a full DateTime using `formatDateTime`. If only a time string like '14:16:00' is provided, you must first concatenate it with a default date (e.g., '1970-01-01') and then convert it to DateTime using `toDateTime`. \nParameters: datetime_expr (e.g., NOW(), toDateTime('1970-01-01 14:16:00')), format (e.g., '%H:%i:%s', '%H:%i:%s.%f').\nReturns: A string formatted as 'HH:MM:SS' or 'HH:MM:SS.SSSSSS'.",
        "examples": [
          "SELECT formatDateTime(NOW(), '%H:%i:%s'); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT formatDateTime(NOW(), '%H:%i:%s'); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT formatDateTime(toDateTime(concat('1970-01-01 ', '14:16:00')), '%H:%i:%s.%f'); -- Returns '14:16:00.000000' with fractional seconds."
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_100_15",
    "database_name": "clickhouse_100_15",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT TIMESTAMPADD(MINUTE, 1, '2003-01-02 23:59:59' ); -- TIMESTAMPADD",
    "target_query": "SELECT addMinutes(toDateTime('2003-01-02 23:59:59'), 1);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMPADD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMPADD(unit, interval, datetime_expr)",
        "description": "Adds a time interval to a date or timestamp expression using the specified unit.",
        "examples": [
          "SELECT TIMESTAMPADD(DAY, 2, '2023-01-01');",
          "SELECT TIMESTAMPADD(MINUTE, -5, '2023-05-10 12:00:00');",
          "SELECT TIMESTAMPADD(YEAR, 1, '2020-06-15');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "addUnit(datetime_expr, n)",
        "description": "Adds a time interval to a datetime or date using unit-specific functions like addDays, addMinutes, addYears.",
        "examples": [
          "SELECT addDays(toDate('2023-01-01'), 2);",
          "SELECT addMinutes(toDateTime('2023-05-10 12:00:00'), -5);",
          "SELECT addYears(toDate('2020-06-15'), 1);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_100_16",
    "database_name": "clickhouse_100_16",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT TIMESTAMPDIFF(MONTH, '2003-02-01 23:59:59', '2003-05-01' ); -- TIMESTAMPDIFF",
    "target_query": "SELECT dateDiff('month', toDateTime('2003-02-01 23:59:59'), toDateTime('2003-05-01'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMPDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMPDIFF(unit, datetime1, datetime2)",
        "description": "Returns the difference between two datetime values in the specified unit.",
        "examples": [
          "SELECT TIMESTAMPDIFF(YEAR, '2001-01-01', '2005-01-01');  -- 4",
          "SELECT TIMESTAMPDIFF(MONTH, '2020-01-01', '2020-03-01');  -- 2",
          "SELECT TIMESTAMPDIFF(DAY, '2020-01-01', '2020-01-31');    -- 30"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "dateDiff(unit, date1, date2)",
        "description": "Returns the number of unit intervals between two dates. The result is negative if the second date is earlier than the first.",
        "examples": [
          "SELECT dateDiff('year', toDate('2001-01-01'), toDate('2005-01-01'));  -- 4",
          "SELECT dateDiff('month', toDate('2020-01-01'), toDate('2020-03-01'));  -- 2",
          "SELECT dateDiff('day', toDate('2020-01-01'), toDate('2020-01-31'));    -- 30"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_100_17",
    "database_name": "clickhouse_100_17",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT TO_SECONDS( '2009-11-29 23:59:59' ); -- TO_SECONDS",
    "target_query": "SELECT toRelativeSecondNum(toDateTime('2009-11-29 23:59:59')) + 62167219200;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TO_SECONDS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TO_SECONDS(datetime_expr)",
        "description": "Returns the number of seconds since year 0 to the given datetime.",
        "examples": [
          "SELECT TO_SECONDS('2000-01-01 00:00:00');",
          "SELECT TO_SECONDS(NOW());",
          "SELECT TO_SECONDS(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toRelativeSecondNum(ts) + 62167219200",
        "description": "Converts timestamp to number of seconds since a reference point, then adds seconds from year 0 to 1970.",
        "examples": [
          "SELECT toRelativeSecondNum(toDateTime('2020-12-31 12:00:00')) + 62167219200;",
          "SELECT toRelativeSecondNum(now()) + 62167219200;",
          "SELECT if(null, toRelativeSecondNum(null) + 62167219200, NULL);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_100_18",
    "database_name": "clickhouse_100_18",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT UNIX_TIMESTAMP( '2015-11-13 23:59:59' ); -- UNIX_TIMESTAMP",
    "target_query": "SELECT toUnixTimestamp('2015-11-13 23:59:59');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp(timestamp)",
        "description": "Converts a DateTime string or value to a Unix timestamp (seconds since 1970-01-01 UTC).",
        "examples": [
          "SELECT toUnixTimestamp(now());",
          "SELECT toUnixTimestamp('2015-11-13 23:59:59+02:00');",
          "SELECT toUnixTimestamp('2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_101_3",
    "database_name": "clickhouse_101_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select hex(s1) from t1; -- HEX",
    "target_query": "SELECT HEX(s1) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (s1 blob);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (s1 BLOB) ENGINE=MergeTree ORDER BY s1;"
    ]
  },
  {
    "sql_id": "clickhouse_101_7",
    "database_name": "clickhouse_101_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select length(concat('*',s1,'*',s2,'*')) from t1; -- LENGTH, CONCAT",
    "target_query": "SELECT length(concat('*', s1, '*', s2, '*')) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH",
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      },
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      },
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (s1 blob, s2 blob);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (s1 BLOB, s2 BLOB) ENGINE=MergeTree ORDER BY s1;"
    ]
  },
  {
    "sql_id": "clickhouse_101_11",
    "database_name": "clickhouse_101_11",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select hex(s1),s2 from t1 order by s1,s2; -- HEX",
    "target_query": "SELECT HEX(s1), s2 FROM t1 ORDER BY s1, s2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (s1 blob, s2 varchar(1));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (s1 BLOB, s2 String) ENGINE=MergeTree ORDER BY s1;"
    ]
  },
  {
    "sql_id": "clickhouse_101_12",
    "database_name": "clickhouse_101_12",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select convert(123456789,unsigned); -- CONVERT",
    "target_query": "SELECT CAST(123456789 AS UInt64);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONVERT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONVERT(expression USING charset)",
        "description": "Converts data types or changes the character set.",
        "examples": [
          "SELECT CONVERT('Hello World' USING utf8);",
          "SELECT CONVERT(1234, CHAR);",
          "SELECT CONVERT(column_name USING latin1) FROM my_table;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CAST(expression AS target_type)",
        "description": "ClickHouse uses CAST for type conversion. No direct equivalent for CONVERT TO CHARACTER SET.",
        "examples": [
          "SELECT CAST('2021-12-31' AS Date);",
          "SELECT CAST(1234 AS String);",
          "SELECT CAST(column_name AS Date) FROM my_table;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_102_2",
    "database_name": "clickhouse_102_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 VALUES (DATE(NOW()), 1); -- DATE, NOW",
    "target_query": "INSERT INTO t1 VALUES (toDate(now()), 1);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE",
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE()",
        "description": "In MySQL, the DATE function extracts the date part from a DATETIME or TIMESTAMP value.",
        "examples": [
          "SELECT DATE('2023-05-01 12:34:56') AS result;",
          "SELECT DATE(NOW()) AS current_date_result;",
          "SELECT DATE(CAST('2023-05-01' AS DATETIME)) AS date_from_datetime;"
        ]
      },
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toDate()",
        "description": "ClickHouse uses the toDate() function to convert a DATETIME or String to a DATE type.",
        "examples": [
          "SELECT toDate('2023-05-01 12:34:56') AS result;",
          "SELECT toDate(now()) AS current_date_result;",
          "SELECT toDate(CAST('2023-05-01' AS String)) AS date_from_datetime;"
        ]
      },
      {
        "expression": "now()",
        "description": "ClickHouse uses the now() function to return the current date and time, which is equivalent to MySQL's NOW() function.",
        "examples": [
          "SELECT now();",
          "CREATE TABLE t12 AS SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > now()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (now());"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_102_3",
    "database_name": "clickhouse_102_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT COUNT(*) FROM t1 WHERE a = NOW(); -- COUNT, NOW",
    "target_query": "SELECT COUNT(*) FROM t1 WHERE a = now();",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COUNT",
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN FORMAT=TREE SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      },
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      },
      {
        "expression": "now()",
        "description": "ClickHouse uses the now() function to return the current date and time, which is equivalent to MySQL's NOW() function.",
        "examples": [
          "SELECT now();",
          "CREATE TABLE t12 AS SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > now()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (now());"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_102_4",
    "database_name": "clickhouse_102_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 VALUES (DATE(NOW()), 2); -- DATE, NOW",
    "target_query": "INSERT INTO t1 VALUES (toDate(now()), 2);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE",
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE()",
        "description": "In MySQL, the DATE function extracts the date part from a DATETIME or TIMESTAMP value.",
        "examples": [
          "SELECT DATE('2023-05-01 12:34:56') AS result;",
          "SELECT DATE(NOW()) AS current_date_result;",
          "SELECT DATE(CAST('2023-05-01' AS DATETIME)) AS date_from_datetime;"
        ]
      },
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toDate()",
        "description": "ClickHouse uses the toDate() function to convert a DATETIME or String to a DATE type.",
        "examples": [
          "SELECT toDate('2023-05-01 12:34:56') AS result;",
          "SELECT toDate(now()) AS current_date_result;",
          "SELECT toDate(CAST('2023-05-01' AS String)) AS date_from_datetime;"
        ]
      },
      {
        "expression": "now()",
        "description": "ClickHouse uses the now() function to return the current date and time, which is equivalent to MySQL's NOW() function.",
        "examples": [
          "SELECT now();",
          "CREATE TABLE t12 AS SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > now()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (now());"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_102_5",
    "database_name": "clickhouse_102_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT COUNT(*) FROM t1 WHERE a = NOW(); -- COUNT, NOW",
    "target_query": "SELECT COUNT(*) FROM t1 WHERE a = now();",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COUNT",
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN FORMAT=TREE SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      },
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      },
      {
        "expression": "now()",
        "description": "ClickHouse uses the now() function to return the current date and time, which is equivalent to MySQL's NOW() function.",
        "examples": [
          "SELECT now();",
          "CREATE TABLE t12 AS SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > now()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (now());"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_102_6",
    "database_name": "clickhouse_102_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT COUNT(*) FROM t1 WHERE a = NOW() AND b = 1; -- COUNT, NOW",
    "target_query": "SELECT COUNT(*) FROM t1 WHERE a = now() AND b = 1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COUNT",
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN FORMAT=TREE SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      },
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      },
      {
        "expression": "now()",
        "description": "ClickHouse uses the now() function to return the current date and time, which is equivalent to MySQL's NOW() function.",
        "examples": [
          "SELECT now();",
          "CREATE TABLE t12 AS SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > now()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (now());"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a DATE, b INT) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_102_8",
    "database_name": "clickhouse_102_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "CREATE TABLE t1 SELECT curdate() AS f1; -- CURDATE",
    "target_query": "CREATE TABLE t1 ENGINE=MergeTree ORDER BY f1 AS SELECT today() AS f1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CURDATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CURDATE()",
        "description": "Returns the current date without the time component.",
        "examples": [
          "SELECT CURDATE();",
          "SELECT CONCAT('Today\\'s date is: ', CURDATE());",
          "SELECT 1 WHERE CURDATE() = CURDATE();"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "today()",
        "description": "Returns the current date without the time component, equivalent to MySQL's CURDATE().",
        "examples": [
          "SELECT today();",
          "SELECT CONCAT('Today\\'s date is: ', today());",
          "SELECT 1 WHERE today() = today();"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 SELECT curdate() AS f1; -- CURDATE"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ENGINE=MergeTree ORDER BY f1 AS SELECT today() AS f1;"
    ]
  },
  {
    "sql_id": "clickhouse_102_18",
    "database_name": "clickhouse_102_18",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT 1 FROM (SELECT MAKEDATE(2011,0)) a; -- MAKEDATE",
    "target_query": "SELECT 1 FROM (SELECT makeDate(2011,0)) a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKEDATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKEDATE(year, day_of_year)",
        "description": "Returns a date from the given year and day of the year.",
        "examples": [
          "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
          "SELECT MAKEDATE(2025, 100) AS specific_date;",
          "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "makeDate(year, day_of_year)",
        "description": "Returns a date from the given year and day of the year directly using the makeDate function.",
        "examples": [
          "SELECT makeDate(2009, 1) AS first_day_of_year;",
          "SELECT makeDate(2025, 100) AS specific_date;",
          "SELECT makeDate(2020, 366) AS last_day_of_year;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_102_19",
    "database_name": "clickhouse_102_19",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT CAST(LEAST(20010101,20020202) AS DATE); -- LEAST",
    "target_query": "SELECT CAST(least(20010101,20020202) AS Date);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the smallest non-null value among arguments. NULLs are ignored unless all arguments are NULL. Use ifNull() when explicit NULL handling is needed.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(toDate('2024-01-01'), toDate('2023-12-31'));",
          "SELECT ifNull(least(NULL, 2), NULL);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_102_20",
    "database_name": "clickhouse_102_20",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT CAST(UNIX_TIMESTAMP() AS DATE); -- UNIX_TIMESTAMP",
    "target_query": "SELECT CAST(toUnixTimestamp(now()) AS Date);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp(timestamp)",
        "description": "Converts a DateTime string or value to a Unix timestamp (seconds since 1970-01-01 UTC).",
        "examples": [
          "SELECT toUnixTimestamp(now());",
          "SELECT toUnixTimestamp('2015-11-13 23:59:59+02:00');",
          "SELECT toUnixTimestamp('2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_102_21",
    "database_name": "clickhouse_102_21",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT DATE(20110512154559.6 + 0e0); -- DATE",
    "target_query": "SELECT toDate(20110512154559.6 + 0e0);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE()",
        "description": "In MySQL, the DATE function extracts the date part from a DATETIME or TIMESTAMP value.",
        "examples": [
          "SELECT DATE('2023-05-01 12:34:56') AS result;",
          "SELECT DATE(NOW()) AS current_date_result;",
          "SELECT DATE(CAST('2023-05-01' AS DATETIME)) AS date_from_datetime;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toDate()",
        "description": "ClickHouse uses the toDate() function to convert a DATETIME or String to a DATE type.",
        "examples": [
          "SELECT toDate('2023-05-01 12:34:56') AS result;",
          "SELECT toDate(now()) AS current_date_result;",
          "SELECT toDate(CAST('2023-05-01' AS String)) AS date_from_datetime;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_2_2",
    "database_name": "clickhouse_2_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "WITH recursive qn as (select 1 as n, cast('x' as char(100)) as un union all select 1+n, concat(un,'x') from qn where n<10) select * from qn; -- CONCAT",
    "target_query": "WITH recursive qn AS (SELECT 1 AS n, CAST('x' AS String) AS un UNION ALL SELECT 1 + n, concat(un, 'x') FROM qn WHERE n < 10) SELECT * FROM qn; -- CONCAT",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t(c char(3), vc varchar(3), b binary(3), vb varbinary(3));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t(c String, vc String, b String, vb String) ENGINE = MergeTree ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_3_2",
    "database_name": "clickhouse_3_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT IF (COUNT(*) > 0, \"YES\", \"NO\") AS \"IMPLICIT COMMIT\" FROM trans; -- IF",
    "target_query": "SELECT IF(COUNT(*) > 0, 'YES', 'NO') AS \"IMPLICIT COMMIT\" FROM trans;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "ClickHouse supports the `IF` function, which works similarly to MySQL. It evaluates a condition and returns different values based on whether the condition is true or false.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE trans (a INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE trans (a Int32) ENGINE = MergeTree ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_39_3",
    "database_name": "clickhouse_39_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT IF( a = 1, a, a ) AS b FROM t1 ORDER BY field( b + 1, 1 ); -- IF, FIELD",
    "target_query": "SELECT IF( a = 1, a, a ) AS b FROM t1 ORDER BY indexOf([1], b + 1);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF",
      "FIELD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      },
      {
        "expression": "FIELD(val, val1, val2, ..., valN)",
        "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
        "examples": [
          "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "ClickHouse supports the `IF` function, which works similarly to MySQL. It evaluates a condition and returns different values based on whether the condition is true or false.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      },
      {
        "expression": "indexOf([val1, val2, ..., valN], val)",
        "description": "Returns the 1-based index of 'val' in the array. Returns 0 if not found. Fully equivalent to FIELD().",
        "examples": [
          "SELECT indexOf(['a', 'b', 'c'], 'c') AS result;",
          "SELECT indexOf(['a', 'b', 'c'], 'x') AS result;",
          "SELECT indexOf(['b', 'b', 'b'], 'b') AS result;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a INT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a INT ) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_39_4",
    "database_name": "clickhouse_39_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT IF( a = 1, a, a ) AS b FROM t1 ORDER BY field( b, 1 ); -- IF, FIELD",
    "target_query": "SELECT IF( a = 1, a, a ) AS b FROM t1 ORDER BY indexOf([1], b);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF",
      "FIELD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      },
      {
        "expression": "FIELD(val, val1, val2, ..., valN)",
        "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
        "examples": [
          "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "ClickHouse supports the `IF` function, which works similarly to MySQL. It evaluates a condition and returns different values based on whether the condition is true or false.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      },
      {
        "expression": "indexOf([val1, val2, ..., valN], val)",
        "description": "Returns the 1-based index of 'val' in the array. Returns 0 if not found. Fully equivalent to FIELD().",
        "examples": [
          "SELECT indexOf(['a', 'b', 'c'], 'c') AS result;",
          "SELECT indexOf(['a', 'b', 'c'], 'x') AS result;",
          "SELECT indexOf(['b', 'b', 'b'], 'b') AS result;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a INT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a INT ) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_4_4",
    "database_name": "clickhouse_4_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775807 AND TRIM(a) = b; -- TRIM",
    "target_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775807 AND TRIM(BOTH ' ' FROM toString(a)) = b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TRIM"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "Clickhouse's TRIM function works the same way as MySQL, allowing for removal of unwanted characters from both sides, the start, or the end of the string.",
        "examples": [
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (id INT AUTO_INCREMENT PRIMARY KEY,a BIGINT(20) UNSIGNED,b VARCHAR(20));",
      "UPDATE t1 SET b = a;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id UInt64, a UInt64, b String) ENGINE = MergeTree ORDER BY id;",
      "ALTER TABLE t1 UPDATE b = toString(a) WHERE 1 = 1;"
    ]
  },
  {
    "sql_id": "clickhouse_4_5",
    "database_name": "clickhouse_4_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775806 AND TRIM(a) = b; -- TRIM",
    "target_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775806 AND TRIM(BOTH ' ' FROM toString(a)) = b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TRIM"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "Clickhouse's TRIM function works the same way as MySQL, allowing for removal of unwanted characters from both sides, the start, or the end of the string.",
        "examples": [
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (id INT AUTO_INCREMENT PRIMARY KEY,a BIGINT(20) UNSIGNED,b VARCHAR(20));",
      "UPDATE t1 SET b = a;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id UInt64, a UInt64, b String) ENGINE = MergeTree ORDER BY id;",
      "ALTER TABLE t1 UPDATE b = toString(a) WHERE 1 = 1;"
    ]
  },
  {
    "sql_id": "clickhouse_4_6",
    "database_name": "clickhouse_4_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775805 AND TRIM(a) = b; -- TRIM",
    "target_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775805 AND TRIM(BOTH ' ' FROM toString(a)) = b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TRIM"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "Clickhouse's TRIM function works the same way as MySQL, allowing for removal of unwanted characters from both sides, the start, or the end of the string.",
        "examples": [
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (id INT AUTO_INCREMENT PRIMARY KEY,a BIGINT(20) UNSIGNED,b VARCHAR(20));",
      "UPDATE t1 SET b = a;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id UInt64, a UInt64, b String) ENGINE = MergeTree ORDER BY id;",
      "ALTER TABLE t1 UPDATE b = toString(a) WHERE 1 = 1;"
    ]
  },
  {
    "sql_id": "clickhouse_4_7",
    "database_name": "clickhouse_4_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 0 AND TRIM(a) = b; -- TRIM",
    "target_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 0 AND TRIM(BOTH ' ' FROM toString(a)) = b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TRIM"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "Clickhouse's TRIM function works the same way as MySQL, allowing for removal of unwanted characters from both sides, the start, or the end of the string.",
        "examples": [
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (id INT AUTO_INCREMENT PRIMARY KEY,a BIGINT(20) UNSIGNED,b VARCHAR(20));",
      "UPDATE t1 SET b = a;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id UInt64, a UInt64, b String) ENGINE = MergeTree ORDER BY id;",
      "ALTER TABLE t1 UPDATE b = toString(a) WHERE 1 = 1;"
    ]
  },
  {
    "sql_id": "clickhouse_4_11",
    "database_name": "clickhouse_4_11",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT * FROM t1 WHERE coalesce(a) BETWEEN 0 and 0.9; -- COALESCE",
    "target_query": "SELECT * FROM t1 WHERE coalesce(toFloat64(a)) BETWEEN 0 AND 0.9;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "coalesce(expr1, expr2, ...)",
        "description": "ClickHouse supports COALESCE via SQL-compatible functions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a BIGINT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a Int64) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_4_12",
    "database_name": "clickhouse_4_12",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT * FROM t1 WHERE coalesce(a)=0.9; -- COALESCE",
    "target_query": "SELECT * FROM t1 WHERE coalesce(toFloat64(a)) = 0.9;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "coalesce(expr1, expr2, ...)",
        "description": "ClickHouse supports COALESCE via SQL-compatible functions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a BIGINT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a Int64) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_4_13",
    "database_name": "clickhouse_4_13",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT * FROM t1 WHERE coalesce(a) in (0.8,0.9); -- COALESCE",
    "target_query": "SELECT * FROM t1 WHERE coalesce(toFloat64(a)) IN (0.8, 0.9);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "coalesce(expr1, expr2, ...)",
        "description": "ClickHouse supports COALESCE via SQL-compatible functions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a BIGINT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a Int64) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_5_6",
    "database_name": "clickhouse_5_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT USER(); -- USER",
    "target_query": "SELECT currentUser(); -- USER",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "USER"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "USER()",
        "description": "Returns the current MySQL user and host in the format 'username@hostname'.",
        "examples": [
          "SELECT USER();"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "currentUser()",
        "description": "Returns the current user in ClickHouse.",
        "examples": [
          "SELECT currentUser();"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_6_3",
    "database_name": "clickhouse_6_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT HEX(c1) FROM t1; -- HEX",
    "target_query": "SELECT HEX(c1) FROM t1; -- HEX",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(c1 CHAR(4));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(c1 String) ENGINE = MergeTree() ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_6_5",
    "database_name": "clickhouse_6_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "CREATE TABLE t1 SELECT repeat('a',4000) a; -- REPEAT",
    "target_query": "CREATE TABLE t1 ENGINE = MergeTree() ORDER BY a AS SELECT repeat('a',4000) AS a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 SELECT repeat('a',4000) a; -- REPEAT"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ENGINE = MergeTree() ORDER BY a AS SELECT repeat('a',4000) AS a;"
    ]
  },
  {
    "sql_id": "clickhouse_6_12",
    "database_name": "clickhouse_6_12",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT",
    "target_query": "CREATE TABLE head ENGINE = MergeTree() ORDER BY head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT"
    ],
    "target_related_schemas": [
      "CREATE TABLE head ENGINE = MergeTree() ORDER BY head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT"
    ]
  },
  {
    "sql_id": "clickhouse_6_13",
    "database_name": "clickhouse_6_13",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "CREATE TABLE tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2; -- CONCAT",
    "target_query": "CREATE TABLE tail ENGINE = MergeTree() ORDER BY tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2; -- CONCAT",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT",
      "CREATE TABLE tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2; -- CONCAT"
    ],
    "target_related_schemas": [
      "CREATE TABLE head ENGINE = MergeTree() ORDER BY head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT",
      "CREATE TABLE tail ENGINE = MergeTree() ORDER BY tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2; -- CONCAT"
    ]
  },
  {
    "sql_id": "clickhouse_6_19",
    "database_name": "clickhouse_6_19",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT COUNT(*) FROM t1 WHERE a<>'' AND OCTET_LENGTH(a)=2; -- OCTET_LENGTH",
    "target_query": "SELECT COUNT(*) FROM t1 WHERE a<>'' AND LENGTH(a)=2; -- LENGTH (Equivalent to OCTET_LENGTH in MySQL)",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "OCTET_LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "OCTET_LENGTH()",
        "description": "Returns the number of bytes in a string.",
        "examples": [
          "SELECT OCTET_LENGTH('Hello World');",
          "SELECT OCTET_LENGTH('Test String') = 11;",
          "SELECT CASE WHEN OCTET_LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LENGTH()",
        "description": "Returns the number of bytes in a string (UTF-8 encoded).",
        "examples": [
          "SELECT LENGTH('Hello World');",
          "SELECT LENGTH('Test String') = 11;",
          "SELECT CASE WHEN LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 AS SELECT '111111' AS code, ' ' AS a LIMIT 1;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ENGINE = MergeTree() ORDER BY code AS SELECT '111111' AS code, ' ' AS a LIMIT 1;"
    ]
  },
  {
    "sql_id": "clickhouse_6_20",
    "database_name": "clickhouse_6_20",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT * FROM t1 WHERE CHAR_LENGTH(a)=2; -- CHAR_LENGTH",
    "target_query": "SELECT * FROM t1 WHERE lengthUTF8(a)=2; -- CHAR_LENGTH",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CHAR_LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CHAR_LENGTH(expr)",
        "description": "Returns the number of characters in the string, not bytes.",
        "examples": [
          "SELECT CHAR_LENGTH('abc');",
          "SELECT CHAR_LENGTH('你好');",
          "SELECT CHAR_LENGTH('a你b好c');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "lengthUTF8(expr)",
        "description": "Returns the number of characters in a UTF-8 encoded string.",
        "examples": [
          "SELECT lengthUTF8('abc');",
          "SELECT lengthUTF8('你好');",
          "SELECT lengthUTF8('a你b好c');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 AS SELECT '111111' AS code, ' ' AS a LIMIT 1;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ENGINE = MergeTree() ORDER BY code AS SELECT '111111' AS code, ' ' AS a LIMIT 1;"
    ]
  },
  {
    "sql_id": "clickhouse_6_21",
    "database_name": "clickhouse_6_21",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT COUNT(*) FROM t1 WHERE a<>'' AND OCTET_LENGTH(a)=3; -- OCTET_LENGTH",
    "target_query": "SELECT COUNT(*) FROM t1 WHERE a<>'' AND LENGTH(a)=3; -- LENGTH (Equivalent to OCTET_LENGTH in MySQL)",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "OCTET_LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "OCTET_LENGTH()",
        "description": "Returns the number of bytes in a string.",
        "examples": [
          "SELECT OCTET_LENGTH('Hello World');",
          "SELECT OCTET_LENGTH('Test String') = 11;",
          "SELECT CASE WHEN OCTET_LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LENGTH()",
        "description": "Returns the number of bytes in a string (UTF-8 encoded).",
        "examples": [
          "SELECT LENGTH('Hello World');",
          "SELECT LENGTH('Test String') = 11;",
          "SELECT CASE WHEN LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 AS SELECT '111111' AS code, ' ' AS a LIMIT 1;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ENGINE = MergeTree() ORDER BY code AS SELECT '111111' AS code, ' ' AS a LIMIT 1;"
    ]
  },
  {
    "sql_id": "clickhouse_7_4",
    "database_name": "clickhouse_7_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT c1, LENGTH(c1) FROM h; -- LENGTH",
    "target_query": "SELECT c1, length(c1) FROM h; -- LENGTH",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20)) ENGINE = MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_7_5",
    "database_name": "clickhouse_7_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT c1, LPAD(c1, 20, ' ') FROM h; -- LPAD",
    "target_query": "SELECT c1, LPAD(c1, 20, ' ') FROM h; -- LPAD",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20)) ENGINE = MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_7_6",
    "database_name": "clickhouse_7_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT c1, RPAD(c1, 20, '52') FROM h; -- RPAD",
    "target_query": "SELECT c1, RPAD(c1, 20, '52') FROM h; -- RPAD",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "ClickHouse uses the RPAD function for padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(toString(123), 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20)) ENGINE = MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_7_9",
    "database_name": "clickhouse_7_9",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT INSTR(c1, 'h') FROM h; -- INSTR",
    "target_query": "SELECT position(c1, 'h') FROM h; -- INSTR",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "INSTR(str, substr)",
        "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
        "examples": [
          "SELECT INSTR('foobar', 'bar');  -- Returns 4",
          "SELECT INSTR('foobar', 'baz');  -- Returns 0",
          "SELECT INSTR('foobar', '');     -- Returns 1",
          "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position(str, substr)",
        "description": "Returns the position (1-based) of substr in str. Returns 0 if not found.",
        "examples": [
          "SELECT position('foobar', 'bar');   -- Returns 4",
          "SELECT position('hello', 'x');      -- Returns 0"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20)) ENGINE = MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_7_10",
    "database_name": "clickhouse_7_10",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT INSTR(c1, '') FROM h; -- INSTR",
    "target_query": "SELECT position(c1, '') FROM h; -- INSTR",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "INSTR(str, substr)",
        "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
        "examples": [
          "SELECT INSTR('foobar', 'bar');  -- Returns 4",
          "SELECT INSTR('foobar', 'baz');  -- Returns 0",
          "SELECT INSTR('foobar', '');     -- Returns 1",
          "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position(str, substr)",
        "description": "Returns the position (1-based) of substr in str. Returns 0 if not found.",
        "examples": [
          "SELECT position('foobar', 'bar');   -- Returns 4",
          "SELECT position('hello', 'x');      -- Returns 0"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20)) ENGINE = MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_7_11",
    "database_name": "clickhouse_7_11",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT INSTR(c1, '52') FROM h; -- INSTR",
    "target_query": "SELECT position(c1, '52') FROM h; -- INSTR",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "INSTR(str, substr)",
        "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
        "examples": [
          "SELECT INSTR('foobar', 'bar');  -- Returns 4",
          "SELECT INSTR('foobar', 'baz');  -- Returns 0",
          "SELECT INSTR('foobar', '');     -- Returns 1",
          "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position(str, substr)",
        "description": "Returns the position (1-based) of substr in str. Returns 0 if not found.",
        "examples": [
          "SELECT position('foobar', 'bar');   -- Returns 4",
          "SELECT position('hello', 'x');      -- Returns 0"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20)) ENGINE = MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_7_12",
    "database_name": "clickhouse_7_12",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT INSTR(c1, '54') FROM h; -- INSTR",
    "target_query": "SELECT position(c1, '54') FROM h; -- INSTR",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "INSTR(str, substr)",
        "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
        "examples": [
          "SELECT INSTR('foobar', 'bar');  -- Returns 4",
          "SELECT INSTR('foobar', 'baz');  -- Returns 0",
          "SELECT INSTR('foobar', '');     -- Returns 1",
          "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position(str, substr)",
        "description": "Returns the position (1-based) of substr in str. Returns 0 if not found.",
        "examples": [
          "SELECT position('foobar', 'bar');   -- Returns 4",
          "SELECT position('hello', 'x');      -- Returns 0"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20)) ENGINE = MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_7_13",
    "database_name": "clickhouse_7_13",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT INSTR(c1, '31') FROM h; -- INSTR",
    "target_query": "SELECT position(c1, '31') FROM h; -- INSTR",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "INSTR(str, substr)",
        "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
        "examples": [
          "SELECT INSTR('foobar', 'bar');  -- Returns 4",
          "SELECT INSTR('foobar', 'baz');  -- Returns 0",
          "SELECT INSTR('foobar', '');     -- Returns 1",
          "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position(str, substr)",
        "description": "Returns the position (1-based) of substr in str. Returns 0 if not found.",
        "examples": [
          "SELECT position('foobar', 'bar');   -- Returns 4",
          "SELECT position('hello', 'x');      -- Returns 0"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20)) ENGINE = MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_7_23",
    "database_name": "clickhouse_7_23",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT c1, TRIM(c1) FROM h; -- TRIM",
    "target_query": "SELECT c1, TRIM(c1) FROM h; -- TRIM",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TRIM"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "Clickhouse's TRIM function works the same way as MySQL, allowing for removal of unwanted characters from both sides, the start, or the end of the string.",
        "examples": [
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE h (c1 CHAR(20)) ENGINE = MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_71_0",
    "database_name": "clickhouse_71_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select from_unixtime(123456789); -- FROM_UNIXTIME",
    "target_query": "SELECT FROM_UNIXTIME(123456789);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FROM_UNIXTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
        "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
          "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "FROM_UNIXTIME(unix_timestamp) or formatDateTime(unix_timestamp, format)",
        "description": "Converts a Unix timestamp to a DateTime. Can use formatDateTime to specify a formatted string output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT formatDateTime(1672531200, '%Y-%m-%d %H:%M:%S');",
          "SELECT id, IF(isNull(created), '-', formatDateTime(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_71_1",
    "database_name": "clickhouse_71_1",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select from_unixtime(234567890); -- FROM_UNIXTIME",
    "target_query": "SELECT FROM_UNIXTIME(234567890);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FROM_UNIXTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
        "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
          "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "FROM_UNIXTIME(unix_timestamp) or formatDateTime(unix_timestamp, format)",
        "description": "Converts a Unix timestamp to a DateTime. Can use formatDateTime to specify a formatted string output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT formatDateTime(1672531200, '%Y-%m-%d %H:%M:%S');",
          "SELECT id, IF(isNull(created), '-', formatDateTime(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_71_2",
    "database_name": "clickhouse_71_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select from_unixtime(1); -- FROM_UNIXTIME",
    "target_query": "SELECT FROM_UNIXTIME(1);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FROM_UNIXTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
        "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
          "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "FROM_UNIXTIME(unix_timestamp) or formatDateTime(unix_timestamp, format)",
        "description": "Converts a Unix timestamp to a DateTime. Can use formatDateTime to specify a formatted string output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT formatDateTime(1672531200, '%Y-%m-%d %H:%M:%S');",
          "SELECT id, IF(isNull(created), '-', formatDateTime(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_71_3",
    "database_name": "clickhouse_71_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select unix_timestamp(from_unixtime(123456789)); -- UNIX_TIMESTAMP, FROM_UNIXTIME",
    "target_query": "SELECT toUnixTimestamp(FROM_UNIXTIME(123456789));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP",
      "FROM_UNIXTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      },
      {
        "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
        "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
          "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp(timestamp)",
        "description": "Converts a DateTime string or value to a Unix timestamp (seconds since 1970-01-01 UTC).",
        "examples": [
          "SELECT toUnixTimestamp(now());",
          "SELECT toUnixTimestamp('2015-11-13 23:59:59+02:00');",
          "SELECT toUnixTimestamp('2038-01-19 04:14:07');"
        ]
      },
      {
        "expression": "FROM_UNIXTIME(unix_timestamp) or formatDateTime(unix_timestamp, format)",
        "description": "Converts a Unix timestamp to a DateTime. Can use formatDateTime to specify a formatted string output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT formatDateTime(1672531200, '%Y-%m-%d %H:%M:%S');",
          "SELECT id, IF(isNull(created), '-', formatDateTime(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_71_4",
    "database_name": "clickhouse_71_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select unix_timestamp(from_unixtime(234567890)); -- UNIX_TIMESTAMP, FROM_UNIXTIME",
    "target_query": "SELECT toUnixTimestamp(FROM_UNIXTIME(234567890));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP",
      "FROM_UNIXTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      },
      {
        "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
        "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
          "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp(timestamp)",
        "description": "Converts a DateTime string or value to a Unix timestamp (seconds since 1970-01-01 UTC).",
        "examples": [
          "SELECT toUnixTimestamp(now());",
          "SELECT toUnixTimestamp('2015-11-13 23:59:59+02:00');",
          "SELECT toUnixTimestamp('2038-01-19 04:14:07');"
        ]
      },
      {
        "expression": "FROM_UNIXTIME(unix_timestamp) or formatDateTime(unix_timestamp, format)",
        "description": "Converts a Unix timestamp to a DateTime. Can use formatDateTime to specify a formatted string output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT formatDateTime(1672531200, '%Y-%m-%d %H:%M:%S');",
          "SELECT id, IF(isNull(created), '-', formatDateTime(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_71_5",
    "database_name": "clickhouse_71_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select unix_timestamp('2039-01-20 01:00:00'); -- UNIX_TIMESTAMP",
    "target_query": "SELECT toUnixTimestamp('2039-01-20 01:00:00');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp(timestamp)",
        "description": "Converts a DateTime string or value to a Unix timestamp (seconds since 1970-01-01 UTC).",
        "examples": [
          "SELECT toUnixTimestamp(now());",
          "SELECT toUnixTimestamp('2015-11-13 23:59:59+02:00');",
          "SELECT toUnixTimestamp('2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_71_6",
    "database_name": "clickhouse_71_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select unix_timestamp('2038-02-10 01:00:00'); -- UNIX_TIMESTAMP",
    "target_query": "SELECT toUnixTimestamp('2038-02-10 01:00:00');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp(timestamp)",
        "description": "Converts a DateTime string or value to a Unix timestamp (seconds since 1970-01-01 UTC).",
        "examples": [
          "SELECT toUnixTimestamp(now());",
          "SELECT toUnixTimestamp('2015-11-13 23:59:59+02:00');",
          "SELECT toUnixTimestamp('2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_71_7",
    "database_name": "clickhouse_71_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select unix_timestamp('1970-01-01 01:00:00'),unix_timestamp('1970-01-01 01:00:01'),unix_timestamp('2038-01-19 04:14:07'),unix_timestamp('2038-01-19 04:14:08'); -- UNIX_TIMESTAMP",
    "target_query": "SELECT toUnixTimestamp('1970-01-01 01:00:00'), toUnixTimestamp('1970-01-01 01:00:01'), toUnixTimestamp('2038-01-19 04:14:07'), toUnixTimestamp('2038-01-19 04:14:08');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp(timestamp)",
        "description": "Converts a DateTime string or value to a Unix timestamp (seconds since 1970-01-01 UTC).",
        "examples": [
          "SELECT toUnixTimestamp(now());",
          "SELECT toUnixTimestamp('2015-11-13 23:59:59+02:00');",
          "SELECT toUnixTimestamp('2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_71_11",
    "database_name": "clickhouse_71_11",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT a, FROM_UNIXTIME(a) FROM t1; -- FROM_UNIXTIME",
    "target_query": "SELECT a, FROM_UNIXTIME(a) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FROM_UNIXTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
        "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
          "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "FROM_UNIXTIME(unix_timestamp) or formatDateTime(unix_timestamp, format)",
        "description": "Converts a Unix timestamp to a DateTime. Can use formatDateTime to specify a formatted string output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT formatDateTime(1672531200, '%Y-%m-%d %H:%M:%S');",
          "SELECT id, IF(isNull(created), '-', formatDateTime(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a BIGINT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a BIGINT) Engine=MergeTree() ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_71_13",
    "database_name": "clickhouse_71_13",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT UNIX_TIMESTAMP(\"3001-01-19 08:59:59\"); -- UNIX_TIMESTAMP",
    "target_query": "SELECT toUnixTimestamp('3001-01-19 08:59:59');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp(timestamp)",
        "description": "Converts a DateTime string or value to a Unix timestamp (seconds since 1970-01-01 UTC).",
        "examples": [
          "SELECT toUnixTimestamp(now());",
          "SELECT toUnixTimestamp('2015-11-13 23:59:59+02:00');",
          "SELECT toUnixTimestamp('2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_72_4",
    "database_name": "clickhouse_72_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "EXPLAIN SELECT * FROM t WHERE CONCAT(x,x) = 'XX'; -- CONCAT",
    "target_query": "EXPLAIN SELECT * FROM t WHERE concat(x, x) = 'XX';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t(x VARCHAR(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t(x String) ENGINE = MergeTree ORDER BY x;"
    ]
  },
  {
    "sql_id": "clickhouse_74_2",
    "database_name": "clickhouse_74_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "insert into t1(f1) select if(max(f1) is null, '2000',max(f1)) from t1; -- IF, MAX",
    "target_query": "INSERT INTO t1 (f1) SELECT IF(max(f1) IS NULL, '2000', max(f1)) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF",
      "MAX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      },
      {
        "expression": "MAX(expr)",
        "description": "Returns the maximum value of the expression in an aggregation context.",
        "examples": [
          "SELECT MAX(10), MAX(5), MAX(20);",
          "SELECT MAX('apple'), MAX('banana'), MAX('pear');",
          "SELECT MAX(ABS(-5)), MAX(ABS(3));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "ClickHouse supports the `IF` function, which works similarly to MySQL. It evaluates a condition and returns different values based on whether the condition is true or false.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      },
      {
        "expression": "max(expr)",
        "description": "Computes the maximum of values in an aggregation context.",
        "examples": [
          "SELECT max(11), max(6), max(20);",
          "SELECT max('alpha'), max('beta'), max('gamma');",
          "SELECT max(abs(-9)), max(abs(4));"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1(f1 varchar(5));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (f1 VARCHAR(5)) ENGINE=MergeTree ORDER BY f1;"
    ]
  },
  {
    "sql_id": "clickhouse_74_6",
    "database_name": "clickhouse_74_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT (SELECT SUM(LENGTH(c)) FROM t1 WHERE c='13_characters') FROM t1; -- LENGTH",
    "target_query": "SELECT (SELECT sum(length(c)) FROM t1 WHERE c='13_characters') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (c VARCHAR(30));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c VARCHAR(30)) ENGINE=MergeTree ORDER BY c;"
    ]
  },
  {
    "sql_id": "clickhouse_74_9",
    "database_name": "clickhouse_74_9",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t2 (d)SELECT (SELECT SUM(LENGTH(c)) FROM t1 WHERE c='13_characters') FROM t1; -- LENGTH",
    "target_query": "INSERT INTO t2 (d) SELECT (SELECT sum(length(c)) FROM t1 WHERE c='13_characters') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 (d VARCHAR(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (d VARCHAR(10)) ENGINE=MergeTree ORDER BY d;"
    ]
  },
  {
    "sql_id": "clickhouse_74_10",
    "database_name": "clickhouse_74_10",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t2 (d)SELECT (SELECT SUM(LENGTH(c)) FROM t1 WHERE c='7_chars') FROM t1; -- LENGTH",
    "target_query": "INSERT INTO t2 (d) SELECT (SELECT sum(length(c)) FROM t1 WHERE c='7_chars') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 (d VARCHAR(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (d VARCHAR(10)) ENGINE=MergeTree ORDER BY d;"
    ]
  },
  {
    "sql_id": "clickhouse_74_16",
    "database_name": "clickhouse_74_16",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT *, HEX(a) FROM t1; -- HEX",
    "target_query": "SELECT *, HEX(a) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (id INT PRIMARY KEY,a VARCHAR(100));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id INT, a VARCHAR(100)) ENGINE=MergeTree ORDER BY id;"
    ]
  },
  {
    "sql_id": "clickhouse_74_17",
    "database_name": "clickhouse_74_17",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT *, HEX(a) FROM t1 WHERE a = 'abc-def'; -- HEX",
    "target_query": "SELECT *, HEX(a) FROM t1 WHERE a = 'abc-def';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (id INT PRIMARY KEY,a VARCHAR(100));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id INT, a VARCHAR(100)) ENGINE=MergeTree ORDER BY id;"
    ]
  },
  {
    "sql_id": "clickhouse_75_2",
    "database_name": "clickhouse_75_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 VALUES('valid-string',1),(UNHEX('11'),2); -- UNHEX",
    "target_query": "INSERT INTO t1 VALUES('valid-string',1),(unhex('11'),2);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNHEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNHEX(str)",
        "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT HEX(UNHEX('4D7953514C'));",
          "SELECT UNHEX('48656C6C6F');",
          "SELECT UNHEX(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "unhex(str)",
        "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT hex(unhex('4D7953514C'));",
          "SELECT unhex('48656C6C6F');",
          "SELECT unhex(NULL);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (tx TEXT NULL,pk INTEGER PRIMARY KEY);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (tx String, pk UInt32) ENGINE=MergeTree ORDER BY pk;"
    ]
  },
  {
    "sql_id": "clickhouse_75_3",
    "database_name": "clickhouse_75_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT pk,OCTET_LENGTH(tx),LENGTH(tx) FROM t1; -- OCTET_LENGTH, LENGTH",
    "target_query": "SELECT pk,length(tx),length(tx) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "OCTET_LENGTH",
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "OCTET_LENGTH()",
        "description": "Returns the number of bytes in a string.",
        "examples": [
          "SELECT OCTET_LENGTH('Hello World');",
          "SELECT OCTET_LENGTH('Test String') = 11;",
          "SELECT CASE WHEN OCTET_LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
        ]
      },
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LENGTH()",
        "description": "Returns the number of bytes in a string (UTF-8 encoded).",
        "examples": [
          "SELECT LENGTH('Hello World');",
          "SELECT LENGTH('Test String') = 11;",
          "SELECT CASE WHEN LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
        ]
      },
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (tx TEXT NULL,pk INTEGER PRIMARY KEY);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (tx String, pk UInt32) ENGINE=MergeTree ORDER BY pk;"
    ]
  },
  {
    "sql_id": "clickhouse_76_2",
    "database_name": "clickhouse_76_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "insert ignore t1 values (1, repeat('a',110), repeat('b', 210)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (1, repeat('a', 110), repeat('b', 210));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (i int, a char(200), b text, unique (a), unique (b(300)));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (i Int32, a String, b String) ENGINE = MergeTree ORDER BY i;"
    ]
  },
  {
    "sql_id": "clickhouse_76_3",
    "database_name": "clickhouse_76_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select i, length(a), length(b), char_length(a), char_length(b) from t1; -- LENGTH, CHAR_LENGTH",
    "target_query": "SELECT i, length(a), length(b), lengthUTF8(a), lengthUTF8(b) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH",
      "CHAR_LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      },
      {
        "expression": "CHAR_LENGTH(expr)",
        "description": "Returns the number of characters in the string, not bytes.",
        "examples": [
          "SELECT CHAR_LENGTH('abc');",
          "SELECT CHAR_LENGTH('你好');",
          "SELECT CHAR_LENGTH('a你b好c');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      },
      {
        "expression": "lengthUTF8(expr)",
        "description": "Returns the number of characters in a UTF-8 encoded string.",
        "examples": [
          "SELECT lengthUTF8('abc');",
          "SELECT lengthUTF8('你好');",
          "SELECT lengthUTF8('a你b好c');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (i int, a char(200), b text, unique (a), unique (b(300)));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (i Int32, a String, b String) ENGINE = MergeTree ORDER BY i;"
    ]
  },
  {
    "sql_id": "clickhouse_76_6",
    "database_name": "clickhouse_76_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "insert into t1 values(1, 'a', 'a', NOW()), (1, 'b', 'b', NOW()); -- NOW",
    "target_query": "INSERT INTO t1 VALUES (1, 'a', 'a', now()), (1, 'b', 'b', now());",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "now()",
        "description": "ClickHouse uses the now() function to return the current date and time, which is equivalent to MySQL's NOW() function.",
        "examples": [
          "SELECT now();",
          "CREATE TABLE t12 AS SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > now()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (now());"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 int,c2 char(12),c3 varchar(123),c4 timestamp NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 Int32, c2 String, c3 String, c4 DateTime NOT NULL) ENGINE = MergeTree ORDER BY  c1;"
    ]
  },
  {
    "sql_id": "clickhouse_77_3",
    "database_name": "clickhouse_77_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select t1.time,t1.date,t1.timestamp,concat(date,\" \",time),t1.quarter+t1.week, t1.year+timestampadd,  timestampdiff from t1; -- CONCAT",
    "target_query": "select t1.time,t1.date,t1.timestamp,concat(date,' ',time),t1.quarter+t1.week, t1.year+timestampadd,  timestampdiff from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (time time, date date, timestamp timestamp,quarter int, week int, year int, timestampadd int, timestampdiff int);"
    ],
    "target_related_schemas": [
      "create table t1 (time String, date date, timestamp timestamp,quarter int, week int, year int, timestampadd int, timestampdiff int) ENGINE=MergeTree ORDER BY time;"
    ]
  },
  {
    "sql_id": "clickhouse_78_2",
    "database_name": "clickhouse_78_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select concat('|',a,'|'), concat('|',b,'|') from t1; -- CONCAT",
    "target_query": "SELECT concat('|', a, '|'), concat('|', b, '|') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a text, b text);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a String, b String) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_78_5",
    "database_name": "clickhouse_78_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT HEX(val) FROM t1; -- HEX",
    "target_query": "SELECT HEX(val) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (val TEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (val String) ENGINE=MergeTree ORDER BY val;"
    ]
  },
  {
    "sql_id": "clickhouse_78_8",
    "database_name": "clickhouse_78_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT HEX(a) FROM t1; -- HEX",
    "target_query": "SELECT HEX(a) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(a VARCHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a String) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_79_3",
    "database_name": "clickhouse_79_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT a, date_format(a,'%a') as abday, dayname(a) as day FROM t1 ORDER BY a; -- DATE_FORMAT, DAYNAME",
    "target_query": "SELECT a, formatDateTime(toDateTime(a), '%a') as abday, CASE toDayOfWeek(toDate(a)) WHEN 1 THEN 'Monday' WHEN 2 THEN 'Tuesday' WHEN 3 THEN 'Wednesday' WHEN 4 THEN 'Thursday' WHEN 5 THEN 'Friday' WHEN 6 THEN 'Saturday' WHEN 7 THEN 'Sunday' END as day FROM t1 ORDER BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT",
      "DAYNAME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      },
      {
        "expression": "DAYNAME(date)",
        "description": "Returns the full name of the day for a given date.",
        "examples": [
          "SELECT DAYNAME('2023-11-25');",
          "SELECT DAYNAME('2022-01-01');",
          "SELECT DAYNAME('1999-03-14');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(date_expr, format_str)",
        "description": "Formats a DateTime value using ClickHouse-supported format specifiers. Input must be a DateTime or cast to one explicitly.",
        "examples": [
          "SELECT formatDateTime(toDateTime('2024-05-06 08:30:00'), '%Y/%m/%d');",
          "SELECT formatDateTime(toDateTime('2023-07-14 15:30:00'), '%Y-%m-%d %H:%M:%S');",
          "SELECT formatDateTime(toDateTime('2022-01-01 08:45:30'), '%H:%M:%S on %d/%m/%Y');"
        ]
      },
      {
        "expression": "CASE toDayOfWeek(toDate(date)) WHEN 1 THEN 'Monday' WHEN 2 THEN 'Tuesday' WHEN 3 THEN 'Wednesday' WHEN 4 THEN 'Thursday' WHEN 5 THEN 'Friday' WHEN 6 THEN 'Saturday' WHEN 7 THEN 'Sunday' END",
        "description": "ClickHouse does not have a direct DAYNAME function, so we use a CASE expression with toDayOfWeek and a mapping to the day names.",
        "examples": [
          "SELECT CASE toDayOfWeek(toDate('2023-11-25')) WHEN 1 THEN 'Monday' WHEN 2 THEN 'Tuesday' WHEN 3 THEN 'Wednesday' WHEN 4 THEN 'Thursday' WHEN 5 THEN 'Friday' WHEN 6 THEN 'Saturday' WHEN 7 THEN 'Sunday' END;",
          "SELECT CASE toDayOfWeek(toDate('2022-01-01')) WHEN 1 THEN 'Monday' WHEN 2 THEN 'Tuesday' WHEN 3 THEN 'Wednesday' WHEN 4 THEN 'Thursday' WHEN 5 THEN 'Friday' WHEN 6 THEN 'Saturday' WHEN 7 THEN 'Sunday' END;",
          "SELECT CASE toDayOfWeek(toDate('1999-03-14')) WHEN 1 THEN 'Monday' WHEN 2 THEN 'Tuesday' WHEN 3 THEN 'Wednesday' WHEN 4 THEN 'Thursday' WHEN 5 THEN 'Friday' WHEN 6 THEN 'Saturday' WHEN 7 THEN 'Sunday' END;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a DATE);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a DATE) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_79_7",
    "database_name": "clickhouse_79_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT a, date_format(a,'%b') as abmon, monthname(a) as mon FROM t1 ORDER BY a; -- DATE_FORMAT, MONTHNAME",
    "target_query": "SELECT a, formatDateTime(toDateTime(a), '%b') as abmon, monthName(toDate(a)) as mon FROM t1 ORDER BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT",
      "MONTHNAME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      },
      {
        "expression": "MONTHNAME(date)",
        "description": "Returns the full English name of the month for a given date.",
        "examples": [
          "SELECT MONTHNAME(DATE '2023-05-01') AS mon1;",
          "SELECT MONTHNAME(STR_TO_DATE('2024-12-31', '%Y-%m-%d')) AS mon2;",
          "SELECT MONTHNAME(NOW()) AS current_month;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(date_expr, format_str)",
        "description": "Formats a DateTime value using ClickHouse-supported format specifiers. Input must be a DateTime or cast to one explicitly.",
        "examples": [
          "SELECT formatDateTime(toDateTime('2024-05-06 08:30:00'), '%Y/%m/%d');",
          "SELECT formatDateTime(toDateTime('2023-07-14 15:30:00'), '%Y-%m-%d %H:%M:%S');",
          "SELECT formatDateTime(toDateTime('2022-01-01 08:45:30'), '%H:%M:%S on %d/%m/%Y');"
        ]
      },
      {
        "expression": "monthName(date)",
        "description": "Returns the full English name of the month for a given date.",
        "examples": [
          "SELECT monthName(toDate('2023-05-01')) AS mon1;",
          "SELECT monthName(toDate('2024-12-31')) AS mon2;",
          "SELECT monthName(now()) AS current_month;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a DATE);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a DATE) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_79_9",
    "database_name": "clickhouse_79_9",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT DATE_FORMAT('2001-01-01', '%w %a %W'); -- DATE_FORMAT",
    "target_query": "SELECT formatDateTime(toDateTime('2001-01-01'), '%w %a %W');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(date_expr, format_str)",
        "description": "Formats a DateTime value using ClickHouse-supported format specifiers. Input must be a DateTime or cast to one explicitly.",
        "examples": [
          "SELECT formatDateTime(toDateTime('2024-05-06 08:30:00'), '%Y/%m/%d');",
          "SELECT formatDateTime(toDateTime('2023-07-14 15:30:00'), '%Y-%m-%d %H:%M:%S');",
          "SELECT formatDateTime(toDateTime('2022-01-01 08:45:30'), '%H:%M:%S on %d/%m/%Y');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_79_10",
    "database_name": "clickhouse_79_10",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT DATE_FORMAT('2001-01-01', '%c %b %M'); -- DATE_FORMAT",
    "target_query": "SELECT formatDateTime(toDateTime('2001-01-01'), '%c %b %M');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(date_expr, format_str)",
        "description": "Formats a DateTime value using ClickHouse-supported format specifiers. Input must be a DateTime or cast to one explicitly.",
        "examples": [
          "SELECT formatDateTime(toDateTime('2024-05-06 08:30:00'), '%Y/%m/%d');",
          "SELECT formatDateTime(toDateTime('2023-07-14 15:30:00'), '%Y-%m-%d %H:%M:%S');",
          "SELECT formatDateTime(toDateTime('2022-01-01 08:45:30'), '%H:%M:%S on %d/%m/%Y');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_79_11",
    "database_name": "clickhouse_79_11",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT DATE_FORMAT('2010-03-23 11:00:00','%h %p'); -- DATE_FORMAT",
    "target_query": "SELECT formatDateTime(toDateTime('2010-03-23 11:00:00'), '%h %p');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(date_expr, format_str)",
        "description": "Formats a DateTime value using ClickHouse-supported format specifiers. Input must be a DateTime or cast to one explicitly.",
        "examples": [
          "SELECT formatDateTime(toDateTime('2024-05-06 08:30:00'), '%Y/%m/%d');",
          "SELECT formatDateTime(toDateTime('2023-07-14 15:30:00'), '%Y-%m-%d %H:%M:%S');",
          "SELECT formatDateTime(toDateTime('2022-01-01 08:45:30'), '%H:%M:%S on %d/%m/%Y');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_8_0",
    "database_name": "clickhouse_8_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select strcmp('','ae'),strcmp('ae',''),strcmp('aeq','q'),strcmp('q','aeq'); -- STRCMP",
    "target_query": "SELECT CASE WHEN '' = 'ae' THEN 0 WHEN '' < 'ae' THEN -1 ELSE 1 END, CASE WHEN 'ae' = '' THEN 0 WHEN 'ae' < '' THEN -1 ELSE 1 END, CASE WHEN 'aeq' = 'q' THEN 0 WHEN 'aeq' < 'q' THEN -1 ELSE 1 END, CASE WHEN 'q' = 'aeq' THEN 0 WHEN 'q' < 'aeq' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "ClickHouse does not have a direct STRCMP function, but the same behavior can be simulated using the CASE statement to compare two strings lexicographically and return 0, -1, or 1 based on the comparison.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_8_1",
    "database_name": "clickhouse_8_1",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select strcmp('ss',''),strcmp('','ss'),strcmp('s','sss'),strcmp('q','ssq'); -- STRCMP",
    "target_query": "SELECT CASE WHEN 'ss' = '' THEN 0 WHEN 'ss' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'ss' THEN 0 WHEN '' < 'ss' THEN -1 ELSE 1 END, CASE WHEN 's' = 'sss' THEN 0 WHEN 's' < 'sss' THEN -1 ELSE 1 END, CASE WHEN 'q' = 'ssq' THEN 0 WHEN 'q' < 'ssq' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "ClickHouse does not have a direct STRCMP function, but the same behavior can be simulated using the CASE statement to compare two strings lexicographically and return 0, -1, or 1 based on the comparison.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_8_2",
    "database_name": "clickhouse_8_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select strcmp('','af'),strcmp('a',''),strcmp('','aeq'),strcmp('','aeaeq'); -- STRCMP",
    "target_query": "SELECT CASE WHEN '' = 'af' THEN 0 WHEN '' < 'af' THEN -1 ELSE 1 END, CASE WHEN 'a' = '' THEN 0 WHEN 'a' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'aeq' THEN 0 WHEN '' < 'aeq' THEN -1 ELSE 1 END, CASE WHEN '' = 'aeaeq' THEN 0 WHEN '' < 'aeaeq' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "ClickHouse does not have a direct STRCMP function, but the same behavior can be simulated using the CASE statement to compare two strings lexicographically and return 0, -1, or 1 based on the comparison.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_8_3",
    "database_name": "clickhouse_8_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select strcmp('ss','a'),strcmp('','ssa'),strcmp('sa','sssb'),strcmp('s',''); -- STRCMP",
    "target_query": "SELECT CASE WHEN 'ss' = 'a' THEN 0 WHEN 'ss' < 'a' THEN -1 ELSE 1 END, CASE WHEN '' = 'ssa' THEN 0 WHEN '' < 'ssa' THEN -1 ELSE 1 END, CASE WHEN 'sa' = 'sssb' THEN 0 WHEN 'sa' < 'sssb' THEN -1 ELSE 1 END, CASE WHEN 's' = '' THEN 0 WHEN 's' < '' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "ClickHouse does not have a direct STRCMP function, but the same behavior can be simulated using the CASE statement to compare two strings lexicographically and return 0, -1, or 1 based on the comparison.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_8_4",
    "database_name": "clickhouse_8_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select strcmp('','o'),strcmp('','u'),strcmp('','oeb'); -- STRCMP",
    "target_query": "SELECT CASE WHEN '' = 'o' THEN 0 WHEN '' < 'o' THEN -1 ELSE 1 END, CASE WHEN '' = 'u' THEN 0 WHEN '' < 'u' THEN -1 ELSE 1 END, CASE WHEN '' = 'oeb' THEN 0 WHEN '' < 'oeb' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "ClickHouse does not have a direct STRCMP function, but the same behavior can be simulated using the CASE statement to compare two strings lexicographically and return 0, -1, or 1 based on the comparison.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_8_5",
    "database_name": "clickhouse_8_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select strcmp('af',''),strcmp('','a'),strcmp('aeq',''),strcmp('aeaeq',''); -- STRCMP",
    "target_query": "SELECT CASE WHEN 'af' = '' THEN 0 WHEN 'af' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'a' THEN 0 WHEN '' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'aeq' = '' THEN 0 WHEN 'aeq' < '' THEN -1 ELSE 1 END, CASE WHEN 'aeaeq' = '' THEN 0 WHEN 'aeaeq' < '' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "ClickHouse does not have a direct STRCMP function, but the same behavior can be simulated using the CASE statement to compare two strings lexicographically and return 0, -1, or 1 based on the comparison.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_8_6",
    "database_name": "clickhouse_8_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select strcmp('a','ss'),strcmp('ssa',''),strcmp('sssb','sa'),strcmp('','s'); -- STRCMP",
    "target_query": "SELECT CASE WHEN 'a' = 'ss' THEN 0 WHEN 'a' < 'ss' THEN -1 ELSE 1 END, CASE WHEN 'ssa' = '' THEN 0 WHEN 'ssa' < '' THEN -1 ELSE 1 END, CASE WHEN 'sssb' = 'sa' THEN 0 WHEN 'sssb' < 'sa' THEN -1 ELSE 1 END, CASE WHEN '' = 's' THEN 0 WHEN '' < 's' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "ClickHouse does not have a direct STRCMP function, but the same behavior can be simulated using the CASE statement to compare two strings lexicographically and return 0, -1, or 1 based on the comparison.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_8_7",
    "database_name": "clickhouse_8_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select strcmp('u','a'),strcmp('u',''); -- STRCMP",
    "target_query": "SELECT CASE WHEN 'u' = 'a' THEN 0 WHEN 'u' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'u' = '' THEN 0 WHEN 'u' < '' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "ClickHouse does not have a direct STRCMP function, but the same behavior can be simulated using the CASE statement to compare two strings lexicographically and return 0, -1, or 1 based on the comparison.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_8_8",
    "database_name": "clickhouse_8_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select strcmp('s', 'a'), strcmp('a', 'x'); -- STRCMP",
    "target_query": "SELECT CASE WHEN 's' = 'a' THEN 0 WHEN 's' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'a' = 'x' THEN 0 WHEN 'a' < 'x' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "ClickHouse does not have a direct STRCMP function, but the same behavior can be simulated using the CASE statement to compare two strings lexicographically and return 0, -1, or 1 based on the comparison.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_8_13",
    "database_name": "clickhouse_8_13",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT FIELD('ue',s1), FIELD('',s1), s1='ue', s1='' FROM t1; -- FIELD",
    "target_query": "SELECT indexOf([s1], 'ue'), indexOf([s1], ''), s1='ue', s1='' FROM t1; -- FIELD",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FIELD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FIELD(val, val1, val2, ..., valN)",
        "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
        "examples": [
          "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "indexOf([val1, val2, ..., valN], val)",
        "description": "Returns the 1-based index of 'val' in the array. Returns 0 if not found. Fully equivalent to FIELD().",
        "examples": [
          "SELECT indexOf(['a', 'b', 'c'], 'c') AS result;",
          "SELECT indexOf(['a', 'b', 'c'], 'x') AS result;",
          "SELECT indexOf(['b', 'b', 'b'], 'b') AS result;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (s1 CHAR(5));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (s1 CHAR(5)) ENGINE = MergeTree ORDER BY s1;"
    ]
  },
  {
    "sql_id": "clickhouse_8_17",
    "database_name": "clickhouse_8_17",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select * from t1 where length(s1)=2 and s1='oe'; -- LENGTH",
    "target_query": "select * from t1 where length(s1)=2 and s1='oe'; -- LENGTH",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (s1 char(5));"
    ],
    "target_related_schemas": [
      "create table t1 (s1 char(5)) ENGINE = MergeTree ORDER BY s1;"
    ]
  },
  {
    "sql_id": "clickhouse_80_0",
    "database_name": "clickhouse_80_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT LPAD(NULL, 5, 'x') AS result; -- LPAD",
    "target_query": "SELECT LPAD(NULL, 5, 'x') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_80_1",
    "database_name": "clickhouse_80_1",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT LPAD(NULL, NULL, 'x') AS result; -- LPAD",
    "target_query": "SELECT LPAD(NULL, NULL, 'x') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_80_2",
    "database_name": "clickhouse_80_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT LPAD(NULL, NULL, NULL) AS result; -- LPAD",
    "target_query": "SELECT LPAD(NULL, NULL, NULL) AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_80_3",
    "database_name": "clickhouse_80_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT LPAD('a', NULL, 'x') AS result; -- LPAD",
    "target_query": "SELECT LPAD('a', NULL, 'x') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_80_4",
    "database_name": "clickhouse_80_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT LPAD('a', NULL, NULL) AS result; -- LPAD",
    "target_query": "SELECT LPAD('a', NULL, NULL) AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_80_5",
    "database_name": "clickhouse_80_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT LPAD('a', 5, NULL) AS result; -- LPAD",
    "target_query": "SELECT LPAD('a', 5, NULL) AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_80_6",
    "database_name": "clickhouse_80_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT LPAD(NULL, 5, NULL) AS result; -- LPAD",
    "target_query": "SELECT LPAD(NULL, 5, NULL) AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_80_7",
    "database_name": "clickhouse_80_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT LPAD('a', 0, 'x') AS result; -- LPAD",
    "target_query": "SELECT LPAD('a', 0, 'x') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_80_8",
    "database_name": "clickhouse_80_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT LPAD('a', 0, '') AS result; -- LPAD",
    "target_query": "SELECT LPAD('a', 0, '') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_80_9",
    "database_name": "clickhouse_80_9",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT LPAD('', 0, 'x') AS result; -- LPAD",
    "target_query": "SELECT LPAD('', 0, 'x') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_80_10",
    "database_name": "clickhouse_80_10",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT LPAD('', 0, '') AS result; -- LPAD",
    "target_query": "SELECT LPAD('', 0, '') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_80_12",
    "database_name": "clickhouse_80_12",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT LPAD('123', 5, 'x'); -- LPAD",
    "target_query": "SELECT LPAD('123', 5, 'x');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_80_13",
    "database_name": "clickhouse_80_13",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT LPAD('a', 5, 'xy'); -- LPAD",
    "target_query": "SELECT LPAD('a', 5, 'xy');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_80_14",
    "database_name": "clickhouse_80_14",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT LPAD(\"I LOVE SQL\", 20, \" \"); -- LPAD",
    "target_query": "SELECT LPAD('I LOVE SQL', 20, ' ');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_80_15",
    "database_name": "clickhouse_80_15",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT LPAD(\"I LOVE SQL in the morning\", 20, \" \"); -- LPAD",
    "target_query": "SELECT LPAD('I LOVE SQL in the morning', 20, ' ');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_81_2",
    "database_name": "clickhouse_81_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 VALUES(REPEAT('a', 1024), 0), (REPEAT('b', 1024), 1),(REPEAT('c', 1024), 2), (REPEAT('d', 1024), 3),(REPEAT('e', 1024), 4), (REPEAT('f', 1024), 5); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES(repeat('a', 1024), 0), (repeat('b', 1024), 1), (repeat('c', 1024), 2), (repeat('d', 1024), 3), (repeat('e', 1024), 4), (repeat('f', 1024), 5);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (f1 LONGTEXT , f2  INTEGER);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (f1 String, f2 Int32) ENGINE = MergeTree() ORDER BY f1;"
    ]
  },
  {
    "sql_id": "clickhouse_81_15",
    "database_name": "clickhouse_81_15",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT SUM(LENGTH(f1)) FROM t1; -- LENGTH",
    "target_query": "SELECT SUM(length(f1)) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (f1 LONGTEXT , f2  INTEGER);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (f1 String, f2 Int32) ENGINE = MergeTree() ORDER BY f1;"
    ]
  },
  {
    "sql_id": "clickhouse_82_3",
    "database_name": "clickhouse_82_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT COALESCE(d, d), IFNULL(d, d), IF(i, d, d),CASE i WHEN i THEN d ELSE d END, GREATEST(d, d), LEAST(d, d)FROM t1 ORDER BY RAND(); -- COALESCE, IFNULL, IF, GREATEST, LEAST",
    "target_query": "SELECT coalesce(d, d), ifNull(d, d), IF(toUInt8(i), d, d), CASE i WHEN i THEN d ELSE d END, GREATEST(d, d), least(d, d) FROM t1 ORDER BY RAND();",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE",
      "IFNULL",
      "IF",
      "GREATEST",
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      },
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      },
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      },
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      },
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "coalesce(expr1, expr2, ...)",
        "description": "ClickHouse supports COALESCE via SQL-compatible functions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1;"
        ]
      },
      {
        "expression": "ifNull(expr1, expr2)",
        "description": "ClickHouse's ifNull is functionally equivalent to MySQL's IFNULL. It returns expr2 if expr1 is NULL; otherwise, it returns expr1.",
        "examples": [
          "SELECT ifNull(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT ifNull(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = ifNull(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      },
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "ClickHouse supports the `IF` function, which works similarly to MySQL. It evaluates a condition and returns different values based on whether the condition is true or false.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      },
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      },
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the smallest non-null value among arguments. NULLs are ignored unless all arguments are NULL. Use ifNull() when explicit NULL handling is needed.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(toDate('2024-01-01'), toDate('2023-12-31'));",
          "SELECT ifNull(least(NULL, 2), NULL);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (i INT, d DATE);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (i INT, d DATE) ENGINE=MergeTree ORDER BY i;"
    ]
  },
  {
    "sql_id": "clickhouse_83_3",
    "database_name": "clickhouse_83_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT HEX(c1) FROM AB; -- HEX",
    "target_query": "SELECT HEX(c1) FROM AB;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE AB (c1 CHAR(100));"
    ],
    "target_related_schemas": [
      "CREATE TABLE AB (c1 String) ENGINE=MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_84_2",
    "database_name": "clickhouse_84_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "insert into t5 values (1, date_format('2001-01-01','%W')); -- DATE_FORMAT",
    "target_query": "INSERT INTO t5 VALUES (1, formatDateTime(toDateTime('2001-01-01'), '%W'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(date_expr, format_str)",
        "description": "Formats a DateTime value using ClickHouse-supported format specifiers. Input must be a DateTime or cast to one explicitly.",
        "examples": [
          "SELECT formatDateTime(toDateTime('2024-05-06 08:30:00'), '%Y/%m/%d');",
          "SELECT formatDateTime(toDateTime('2023-07-14 15:30:00'), '%Y-%m-%d %H:%M:%S');",
          "SELECT formatDateTime(toDateTime('2022-01-01 08:45:30'), '%H:%M:%S on %d/%m/%Y');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t5 (c1 int, c2 varchar(128) not null);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t5 (c1 Int32, c2 String NOT NULL) ENGINE=MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_84_3",
    "database_name": "clickhouse_84_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "insert into t5 values (2, date_format('2001-01-01','%W')); -- DATE_FORMAT",
    "target_query": "INSERT INTO t5 VALUES (2, formatDateTime(toDateTime('2001-01-01'), '%W'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(date_expr, format_str)",
        "description": "Formats a DateTime value using ClickHouse-supported format specifiers. Input must be a DateTime or cast to one explicitly.",
        "examples": [
          "SELECT formatDateTime(toDateTime('2024-05-06 08:30:00'), '%Y/%m/%d');",
          "SELECT formatDateTime(toDateTime('2023-07-14 15:30:00'), '%Y-%m-%d %H:%M:%S');",
          "SELECT formatDateTime(toDateTime('2022-01-01 08:45:30'), '%H:%M:%S on %d/%m/%Y');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t5 (c1 int, c2 varchar(128) not null);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t5 (c1 Int32, c2 String NOT NULL) ENGINE=MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_84_4",
    "database_name": "clickhouse_84_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "insert into t5 values (3, date_format('2001-01-01','%W')); -- DATE_FORMAT",
    "target_query": "INSERT INTO t5 VALUES (3, formatDateTime(toDateTime('2001-01-01'), '%W'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(date_expr, format_str)",
        "description": "Formats a DateTime value using ClickHouse-supported format specifiers. Input must be a DateTime or cast to one explicitly.",
        "examples": [
          "SELECT formatDateTime(toDateTime('2024-05-06 08:30:00'), '%Y/%m/%d');",
          "SELECT formatDateTime(toDateTime('2023-07-14 15:30:00'), '%Y-%m-%d %H:%M:%S');",
          "SELECT formatDateTime(toDateTime('2022-01-01 08:45:30'), '%H:%M:%S on %d/%m/%Y');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t5 (c1 int, c2 varchar(128) not null);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t5 (c1 Int32, c2 String NOT NULL) ENGINE=MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_84_8",
    "database_name": "clickhouse_84_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select hex(a) from t1; -- HEX",
    "target_query": "SELECT HEX(a) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a varchar(64));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a String) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_84_11",
    "database_name": "clickhouse_84_11",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 VALUES (1,USER()); -- USER",
    "target_query": "INSERT INTO t1 VALUES (1, currentUser());",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "USER"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "USER()",
        "description": "Returns the current MySQL user and host in the format 'username@hostname'.",
        "examples": [
          "SELECT USER();"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "currentUser()",
        "description": "Returns the current user in ClickHouse.",
        "examples": [
          "SELECT currentUser();"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a INT, b CHAR(64));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a Int32, b String) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_85_2",
    "database_name": "clickhouse_85_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 123)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (repeat('ManyMegaByteBlck', 123));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (c1 LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 String) ENGINE=MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_85_3",
    "database_name": "clickhouse_85_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 234)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (repeat('ManyMegaByteBlck', 234));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (c1 LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 String) ENGINE=MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_85_4",
    "database_name": "clickhouse_85_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 345)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (repeat('ManyMegaByteBlck', 345));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (c1 LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 String) ENGINE=MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_85_5",
    "database_name": "clickhouse_85_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 456)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (repeat('ManyMegaByteBlck', 456));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (c1 LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 String) ENGINE=MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_85_6",
    "database_name": "clickhouse_85_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT LENGTH(c1) FROM t1; -- LENGTH",
    "target_query": "SELECT length(c1) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (c1 LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 String) ENGINE=MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_86_0",
    "database_name": "clickhouse_86_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select null,isnull(null),isnull(1/0),isnull(1/0 = null),ifnull(null,1),ifnull(null,\"TRUE\"),ifnull(\"TRUE\",\"ERROR\"),1/0 is null,1 is not null; -- ISNULL, IFNULL",
    "target_query": "SELECT NULL, NULL IS NULL, NULL IS NULL, NULL IS NULL, ifNull(NULL, 1), ifNull(NULL, 'TRUE'), ifNull('TRUE', 'ERROR'), (1 / 0) IS NULL, 1 IS NOT NULL;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ISNULL",
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ISNULL(expr)",
        "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
        "examples": [
          "SELECT ISNULL(NULL);",
          "SELECT ISNULL(5 + NULL);",
          "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
        ]
      },
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "expr IS NULL",
        "description": "Checks whether an expression is NULL.",
        "examples": [
          "SELECT NULL IS NULL;",
          "SELECT (number / NULL) IS NULL FROM numbers(1);",
          "SELECT IF(score IS NULL, 'N/A', toString(score)) FROM student_scores;"
        ]
      },
      {
        "expression": "ifNull(expr1, expr2)",
        "description": "ClickHouse's ifNull is functionally equivalent to MySQL's IFNULL. It returns expr2 if expr1 is NULL; otherwise, it returns expr1.",
        "examples": [
          "SELECT ifNull(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT ifNull(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = ifNull(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_86_1",
    "database_name": "clickhouse_86_1",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select NULL=NULL,NULL<>NULL,IFNULL(NULL,1.1)+0,IFNULL(NULL,1) | 0; -- IFNULL",
    "target_query": "SELECT NULL = NULL, NULL != NULL, ifNull(NULL, 1.1) + 0, ifNull(NULL, 1) or 0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "ifNull(expr1, expr2)",
        "description": "ClickHouse's ifNull is functionally equivalent to MySQL's IFNULL. It returns expr2 if expr1 is NULL; otherwise, it returns expr1.",
        "examples": [
          "SELECT ifNull(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT ifNull(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = ifNull(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_86_2",
    "database_name": "clickhouse_86_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select strcmp(\"a\",NULL),(1<NULL),NULL regexp \"a\",null like \"a%\",\"a%\" like null; -- STRCMP",
    "target_query": "SELECT CASE WHEN 'a' = NULL THEN 0 WHEN 'a' < NULL THEN -1 ELSE 1 END, (1 < NULL), NULL REGEXP 'a', NULL LIKE 'a%', 'a%' LIKE NULL;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "ClickHouse does not have a direct STRCMP function, but the same behavior can be simulated using the CASE statement to compare two strings lexicographically and return 0, -1, or 1 based on the comparison.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_86_3",
    "database_name": "clickhouse_86_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select repeat(\"a\",0),repeat(\"ab\",5+5),repeat(\"ab\",-1),reverse(NULL); -- REPEAT",
    "target_query": "SELECT repeat('a', 0), repeat('ab', 5 + 5), repeat('ab', -1), reverse(NULL);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_86_4",
    "database_name": "clickhouse_86_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select field(NULL,\"a\",\"b\",\"c\"); -- FIELD",
    "target_query": "SELECT indexOf(['a', 'b', 'c'], NULL);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FIELD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FIELD(val, val1, val2, ..., valN)",
        "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
        "examples": [
          "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "indexOf([val1, val2, ..., valN], val)",
        "description": "Returns the 1-based index of 'val' in the array. Returns 0 if not found. Fully equivalent to FIELD().",
        "examples": [
          "SELECT indexOf(['a', 'b', 'c'], 'c') AS result;",
          "SELECT indexOf(['a', 'b', 'c'], 'x') AS result;",
          "SELECT indexOf(['b', 'b', 'b'], 'b') AS result;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_86_9",
    "database_name": "clickhouse_86_9",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "CREATE TABLE t2 SELECT IFNULL(a, b) FROM t1; -- IFNULL",
    "target_query": "CREATE TABLE t2 ENGINE=MergeTree ORDER BY tuple() AS SELECT ifNull(a, b) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "ifNull(expr1, expr2)",
        "description": "ClickHouse's ifNull is functionally equivalent to MySQL's IFNULL. It returns expr2 if expr1 is NULL; otherwise, it returns expr1.",
        "examples": [
          "SELECT ifNull(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT ifNull(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = ifNull(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 SELECT IFNULL(a, b) FROM t1; -- IFNULL"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 ENGINE=MergeTree ORDER BY tuple() AS SELECT ifNull(a, b) FROM t1;"
    ]
  },
  {
    "sql_id": "clickhouse_86_11",
    "database_name": "clickhouse_86_11",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "CREATE TABLE t2 SELECT IFNULL(a, NULL) FROM t1; -- IFNULL",
    "target_query": "CREATE TABLE t2 ENGINE=MergeTree ORDER BY tuple() AS SELECT ifNull(a, NULL) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "ifNull(expr1, expr2)",
        "description": "ClickHouse's ifNull is functionally equivalent to MySQL's IFNULL. It returns expr2 if expr1 is NULL; otherwise, it returns expr1.",
        "examples": [
          "SELECT ifNull(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT ifNull(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = ifNull(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 SELECT IFNULL(a, NULL) FROM t1; -- IFNULL"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 ENGINE=MergeTree ORDER BY tuple() AS SELECT ifNull(a, NULL) FROM t1;"
    ]
  },
  {
    "sql_id": "clickhouse_86_13",
    "database_name": "clickhouse_86_13",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "CREATE TABLE t2 SELECT IFNULL(NULL, b) FROM t1; -- IFNULL",
    "target_query": "CREATE TABLE t2 ENGINE=MergeTree ORDER BY tuple() AS SELECT ifNull(NULL, b) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "ifNull(expr1, expr2)",
        "description": "ClickHouse's ifNull is functionally equivalent to MySQL's IFNULL. It returns expr2 if expr1 is NULL; otherwise, it returns expr1.",
        "examples": [
          "SELECT ifNull(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT ifNull(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = ifNull(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 SELECT IFNULL(NULL, b) FROM t1; -- IFNULL"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 ENGINE=MergeTree ORDER BY tuple() AS SELECT ifNull(NULL, b) FROM t1;"
    ]
  },
  {
    "sql_id": "clickhouse_87_2",
    "database_name": "clickhouse_87_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 VALUES ( repeat( 'a', 10 ), 1),( repeat( 'b', 10 ), 2); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES ( repeat( 'a', 10 ), 1),( repeat( 'b', 10 ), 2);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1( a VARCHAR( 10 ), b INT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1( a VARCHAR( 10 ), b INT ) ENGINE=MergeTree() ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_87_3",
    "database_name": "clickhouse_87_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT GROUP_CONCAT(a) FROM t1; -- GROUP_CONCAT",
    "target_query": "SELECT arrayStringConcat(groupArray(a), ', ') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GROUP_CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
        "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "groupArray(X)arrayStringConcat(groupArray(X), Y)",
        "description": "In ClickHouse, the equivalent of group_concat(X) is achieved using groupArray(X), which collects values into an array. To concatenate the array elements into a string with a separator, use arrayStringConcat(groupArray(X), Y). If Y is omitted, the default separator is an empty string.",
        "examples": [
          "SELECT arrayStringConcat(groupArray(name), ', ') FROM students; -- Returns a comma-separated list of names",
          "SELECT arrayStringConcat(groupArray(name), ' | ') FROM students; -- Returns names separated by '|'"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1( a VARCHAR( 10 ), b INT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1( a VARCHAR( 10 ), b INT ) ENGINE=MergeTree() ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_87_5",
    "database_name": "clickhouse_87_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT UNIX_TIMESTAMP(); -- UNIX_TIMESTAMP",
    "target_query": "SELECT toUnixTimestamp(now());",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp(timestamp)",
        "description": "Converts a DateTime string or value to a Unix timestamp (seconds since 1970-01-01 UTC).",
        "examples": [
          "SELECT toUnixTimestamp(now());",
          "SELECT toUnixTimestamp('2015-11-13 23:59:59+02:00');",
          "SELECT toUnixTimestamp('2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_88_0",
    "database_name": "clickhouse_88_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select repeat('a',2000); -- REPEAT",
    "target_query": "select repeat('a',2000);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_88_1",
    "database_name": "clickhouse_88_1",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT length(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\") as len; -- LENGTH",
    "target_query": "SELECT length('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa') as len;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_88_2",
    "database_name": "clickhouse_88_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select length(repeat('a',2000)); -- LENGTH, REPEAT",
    "target_query": "select length(repeat('a',2000));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH",
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      },
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      },
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_88_9",
    "database_name": "clickhouse_88_9",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT c11, LENGTH(c12) FROM t1; -- LENGTH",
    "target_query": "SELECT c11, length(c12) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 (c21 INT NOT NULL, c22 LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (c21 INT NOT NULL, c22 String) ENGINE=MergeTree ORDER BY c21;"
    ]
  },
  {
    "sql_id": "clickhouse_89_3",
    "database_name": "clickhouse_89_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select hex(a) from t1 where a like 'A_'; -- HEX",
    "target_query": "select hex(a) from t1 where a like 'A_';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a varchar(50));"
    ],
    "target_related_schemas": [
      "create table t1 (a varchar(50)) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_89_5",
    "database_name": "clickhouse_89_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "explain select hex(a) from t1 where a like 'A_'; -- HEX",
    "target_query": "explain select hex(a) from t1 where a like 'A_';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a varchar(50));"
    ],
    "target_related_schemas": [
      "create table t1 (a varchar(50)) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_89_6",
    "database_name": "clickhouse_89_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select hex(a) from t1; -- HEX",
    "target_query": "select hex(a) from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a varchar(50));"
    ],
    "target_related_schemas": [
      "create table t1 (a varchar(50)) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_9_0",
    "database_name": "clickhouse_9_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT IF(0,\"ERROR\",\"this\"),IF(1,\"is\",\"ERROR\"),IF(NULL,\"ERROR\",\"a\"),IF(1,2,3),IF(1,2.0,3.0)+0; -- IF",
    "target_query": "SELECT IF(0, 'ERROR', 'this'), IF(1, 'is', 'ERROR'), IF(NULL, 'ERROR', 'a'), (IF(1, 2, 3)), IF(1, 2.0, 3.0) + 0; -- AE",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "ClickHouse supports the `IF` function, which works similarly to MySQL. It evaluates a condition and returns different values based on whether the condition is true or false.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_9_4",
    "database_name": "clickhouse_9_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT IF(1,st,st) s FROM t1 ORDER BY s; -- IF",
    "target_query": "SELECT IF(1, st, st) AS s FROM t1 ORDER BY s;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "ClickHouse supports the `IF` function, which works similarly to MySQL. It evaluates a condition and returns different values based on whether the condition is true or false.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (st String, u Int32) ENGINE = MergeTree ORDER BY st;"
    ]
  },
  {
    "sql_id": "clickhouse_9_5",
    "database_name": "clickhouse_9_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT IF(u=1,st,st) s FROM t1 ORDER BY s; -- IF",
    "target_query": "SELECT IF(u = 1, st, st) AS s FROM t1 ORDER BY s;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "ClickHouse supports the `IF` function, which works similarly to MySQL. It evaluates a condition and returns different values based on whether the condition is true or false.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (st String, u Int32) ENGINE = MergeTree ORDER BY st;"
    ]
  },
  {
    "sql_id": "clickhouse_9_7",
    "database_name": "clickhouse_9_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select nullif(u, 1) from t1; -- NULLIF",
    "target_query": "SELECT NULLIF(u, 1) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NULLIF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NULLIF(a, b)",
        "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
        "examples": [
          "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
          "SELECT NULLIF(YEAR('2021-01-01'), 2021) AS year_check;",
          "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "NULLIF(a, b)",
        "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
        "examples": [
          "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
          "SELECT NULLIF(toYear(toDate('2021-01-01')), 2021) AS year_check;",
          "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (st String, u Int32) ENGINE = MergeTree ORDER BY st;"
    ]
  },
  {
    "sql_id": "clickhouse_9_8",
    "database_name": "clickhouse_9_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "explain select nullif(u, 1) from t1; -- NULLIF",
    "target_query": "EXPLAIN SELECT NULLIF(u, 1) FROM t1; -- AE",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NULLIF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NULLIF(a, b)",
        "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
        "examples": [
          "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
          "SELECT NULLIF(YEAR('2021-01-01'), 2021) AS year_check;",
          "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "NULLIF(a, b)",
        "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
        "examples": [
          "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
          "SELECT NULLIF(toYear(toDate('2021-01-01')), 2021) AS year_check;",
          "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (st String, u Int32) ENGINE = MergeTree ORDER BY st;"
    ]
  },
  {
    "sql_id": "clickhouse_9_12",
    "database_name": "clickhouse_9_12",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select sum(if(num is null,0.00,num)) from t1; -- IF",
    "target_query": "SELECT SUM(IF(num IS NULL, 0.00, num)) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "ClickHouse supports the `IF` function, which works similarly to MySQL. It evaluates a condition and returns different values based on whether the condition is true or false.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (num  double(12,2));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (num Float64) ENGINE = MergeTree ORDER BY num;"
    ]
  },
  {
    "sql_id": "clickhouse_9_16",
    "database_name": "clickhouse_9_16",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select min(if(y -x > 5,y,NULL)), max(if(y - x > 5,y,NULL)) from t1; -- IF",
    "target_query": "SELECT MIN(IF(y - x > 5, y, NULL)), MAX(IF(y - x > 5, y, NULL)) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "ClickHouse supports the `IF` function, which works similarly to MySQL. It evaluates a condition and returns different values based on whether the condition is true or false.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (x int, y int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (x Int32, y Int32) ENGINE = MergeTree ORDER BY x;"
    ]
  },
  {
    "sql_id": "clickhouse_9_18",
    "database_name": "clickhouse_9_18",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT NULLIF(5,5) IS NULL, NULLIF(5,5) IS NOT NULL; -- NULLIF",
    "target_query": "SELECT NULLIF(5, 5) IS NULL, NULLIF(5, 5) IS NOT NULL;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NULLIF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NULLIF(a, b)",
        "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
        "examples": [
          "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
          "SELECT NULLIF(YEAR('2021-01-01'), 2021) AS year_check;",
          "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "NULLIF(a, b)",
        "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
        "examples": [
          "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
          "SELECT NULLIF(toYear(toDate('2021-01-01')), 2021) AS year_check;",
          "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_9_21",
    "database_name": "clickhouse_9_21",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT id, IF(date IS NULL, '-', FROM_UNIXTIME(date, '%d-%m-%Y')) AS date_ord, text FROM t1 ORDER BY date_ord ASC; -- IF, FROM_UNIXTIME",
    "target_query": "SELECT id, IF(date IS NULL, '-', FROM_UNIXTIME(date, '%d-%m-%Y')) AS date_ord, text FROM t1 ORDER BY date_ord ASC;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF",
      "FROM_UNIXTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      },
      {
        "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
        "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
          "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "ClickHouse supports the `IF` function, which works similarly to MySQL. It evaluates a condition and returns different values based on whether the condition is true or false.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      },
      {
        "expression": "FROM_UNIXTIME(unix_timestamp) or formatDateTime(unix_timestamp, format)",
        "description": "Converts a Unix timestamp to a DateTime. Can use formatDateTime to specify a formatted string output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT formatDateTime(1672531200, '%Y-%m-%d %H:%M:%S');",
          "SELECT id, IF(isNull(created), '-', formatDateTime(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE `t1` (`id` int(11) NOT NULL ,`date` int(10) default NULL,`text` varchar(32) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id Int32, date Int32, text String) ENGINE = MergeTree ORDER BY id;"
    ]
  },
  {
    "sql_id": "clickhouse_9_22",
    "database_name": "clickhouse_9_22",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT id, IF(date IS NULL, '-', FROM_UNIXTIME(date, '%d-%m-%Y')) AS date_ord, text FROM t1 ORDER BY date_ord DESC; -- IF, FROM_UNIXTIME",
    "target_query": "SELECT id, IF(date IS NULL, '-', FROM_UNIXTIME(date, '%d-%m-%Y')) AS date_ord, text FROM t1 ORDER BY date_ord DESC;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF",
      "FROM_UNIXTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      },
      {
        "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
        "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
          "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "ClickHouse supports the `IF` function, which works similarly to MySQL. It evaluates a condition and returns different values based on whether the condition is true or false.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      },
      {
        "expression": "FROM_UNIXTIME(unix_timestamp) or formatDateTime(unix_timestamp, format)",
        "description": "Converts a Unix timestamp to a DateTime. Can use formatDateTime to specify a formatted string output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT formatDateTime(1672531200, '%Y-%m-%d %H:%M:%S');",
          "SELECT id, IF(isNull(created), '-', formatDateTime(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE `t1` (`id` int(11) NOT NULL ,`date` int(10) default NULL,`text` varchar(32) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id Int32, date Int32, text String) ENGINE = MergeTree ORDER BY id;"
    ]
  },
  {
    "sql_id": "clickhouse_9_26",
    "database_name": "clickhouse_9_26",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT * FROM (SELECT MAX(IF(1, CAST(c AS UNSIGNED), 0)) FROM t1) AS te; -- IF",
    "target_query": "SELECT * FROM (SELECT MAX(IF(1, CAST(c AS UInt64), 0)) FROM t1) AS te;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "ClickHouse supports the `IF` function, which works similarly to MySQL. It evaluates a condition and returns different values based on whether the condition is true or false.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (c LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c String) ENGINE = Memory;"
    ]
  },
  {
    "sql_id": "clickhouse_9_27",
    "database_name": "clickhouse_9_27",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT * FROM (SELECT MAX(IFNULL(CAST(c AS UNSIGNED), 0)) FROM t1) AS te; -- IFNULL",
    "target_query": "SELECT * FROM (SELECT MAX(IFNULL(CAST(c AS UInt64), 0)) FROM t1) AS te;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "ifNull(expr1, expr2)",
        "description": "ClickHouse's ifNull is functionally equivalent to MySQL's IFNULL. It returns expr2 if expr1 is NULL; otherwise, it returns expr1.",
        "examples": [
          "SELECT ifNull(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT ifNull(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = ifNull(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (c LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c String) ENGINE = Memory;"
    ]
  },
  {
    "sql_id": "clickhouse_9_29",
    "database_name": "clickhouse_9_29",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT AVG(NULLIF(YEAR('2001-01-01'),10)); -- NULLIF, YEAR",
    "target_query": "SELECT AVG(NULLIF(toYear(toDate('2001-01-01')), 10));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NULLIF",
      "YEAR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NULLIF(a, b)",
        "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
        "examples": [
          "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
          "SELECT NULLIF(YEAR('2021-01-01'), 2021) AS year_check;",
          "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
        ]
      },
      {
        "expression": "YEAR(date)",
        "description": "Extracts the year from a date or datetime and returns it as an integer.",
        "examples": [
          "SELECT YEAR('2023-04-10');",
          "SELECT YEAR(NOW());",
          "SELECT YEAR('2022-03-15');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "NULLIF(a, b)",
        "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
        "examples": [
          "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
          "SELECT NULLIF(toYear(toDate('2021-01-01')), 2021) AS year_check;",
          "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
        ]
      },
      {
        "expression": "toYear(date)",
        "description": "Extracts the year from a date or datetime and returns it as an integer.",
        "examples": [
          "SELECT toYear(toDate('2023-04-10'));",
          "SELECT toYear(NOW());",
          "SELECT toYear(toDate('2022-03-15'));"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_90_0",
    "database_name": "clickhouse_90_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT FROM_DAYS(3652499), FROM_DAYS(3652500), FROM_DAYS(3652501); -- FROM_DAYS",
    "target_query": "SELECT toDate('0000-01-01') + 3652499, toDate('0000-01-01') + 3652500, toDate('0000-01-01') + 3652501;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FROM_DAYS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FROM_DAYS(n)",
        "description": "Returns a date corresponding to the number of days since year 0.",
        "examples": [
          "SELECT FROM_DAYS(1);",
          "SELECT FROM_DAYS(730000);",
          "SELECT CONCAT('Date is: ', FROM_DAYS(738000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toDate('0000-01-01') + n",
        "description": "Converts an integer n to a date by adding n days to the date '0000-01-01'.",
        "examples": [
          "SELECT toDate('0000-01-01') + 1;",
          "SELECT toDate('0000-01-01') + 730000;",
          "SELECT concat('Date is: ', toDate('0000-01-01') + 738000);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_90_1",
    "database_name": "clickhouse_90_1",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT FROM_DAYS(42949670), FROM_DAYS(42949671), FROM_DAYS(42949673); -- FROM_DAYS",
    "target_query": "SELECT toDate('0000-01-01') + 42949670, toDate('0000-01-01') + 42949671, toDate('0000-01-01') + 42949673;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FROM_DAYS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FROM_DAYS(n)",
        "description": "Returns a date corresponding to the number of days since year 0.",
        "examples": [
          "SELECT FROM_DAYS(1);",
          "SELECT FROM_DAYS(730000);",
          "SELECT CONCAT('Date is: ', FROM_DAYS(738000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toDate('0000-01-01') + n",
        "description": "Converts an integer n to a date by adding n days to the date '0000-01-01'.",
        "examples": [
          "SELECT toDate('0000-01-01') + 1;",
          "SELECT toDate('0000-01-01') + 730000;",
          "SELECT concat('Date is: ', toDate('0000-01-01') + 738000);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_91_2",
    "database_name": "clickhouse_91_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t VALUES (0, REPEAT('x', 120000)), (1, REPEAT('z', 12000)); -- REPEAT",
    "target_query": "INSERT INTO t VALUES (0, repeat('x', 120000)), (1, repeat('z', 12000));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t(i int, b LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t(i int, b LONGTEXT) ENGINE=MergeTree ORDER BY i;"
    ]
  },
  {
    "sql_id": "clickhouse_91_4",
    "database_name": "clickhouse_91_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT LENGTH(b) FROM (SELECT * FROM t INTERSECT SELECT * FROM t) derived; -- LENGTH",
    "target_query": "SELECT length(b) FROM (SELECT * FROM t INTERSECT SELECT * FROM t) derived;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t(i int, b LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t(i int, b LONGTEXT) ENGINE=MergeTree ORDER BY i;"
    ]
  },
  {
    "sql_id": "clickhouse_92_2",
    "database_name": "clickhouse_92_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT argument FROM test_log WHERE argument LIKE CONCAT('%azun','dris%'); -- CONCAT",
    "target_query": "SELECT argument FROM test_log WHERE argument LIKE concat('%azun', 'dris%');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE test_log (argument TEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE test_log (argument String) ENGINE=MergeTree ORDER BY argument;"
    ]
  },
  {
    "sql_id": "clickhouse_93_0",
    "database_name": "clickhouse_93_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select row(10,2,3) IN (row(3,2,3), row(1,2,3), row(1,3,3)); -- ROW",
    "target_query": "select tuple(10,2,3) IN (tuple(3,2,3), tuple(1,2,3), tuple(1,3,3));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_93_1",
    "database_name": "clickhouse_93_1",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select row(1,2,3) IN (row(3,NULL,3), row(1,2,3), row(1,3,3)); -- ROW",
    "target_query": "select tuple(1,2,3) IN (tuple(3,NULL,3), tuple(1,2,3), tuple(1,3,3));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_93_2",
    "database_name": "clickhouse_93_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select row(10,2,3) IN (row(3,NULL,3), row(1,2,3), row(1,3,3)); -- ROW",
    "target_query": "select tuple(10,2,3) IN (tuple(3,NULL,3), tuple(1,2,3), tuple(1,3,3));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_93_5",
    "database_name": "clickhouse_93_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select row('a',0,3) IN (row(3,2,3), row('a','0','3'), row(1,3,3)); -- ROW",
    "target_query": "select tuple('a',0,3) IN (tuple(3,2,3), tuple('a','0','3'), tuple(1,3,3));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_93_6",
    "database_name": "clickhouse_93_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select row('a',1.5,3) IN (row(3,NULL,3), row('a',1.5,3), row(1,3,3)); -- ROW",
    "target_query": "select tuple('a',1.5,3) IN (tuple(3,NULL,3), tuple('a',1.5,3), tuple(1,3,3));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_93_7",
    "database_name": "clickhouse_93_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select row('b',1.5,3) IN (row(3,NULL,3), row('a',1.5,3), row(1,3,3)); -- ROW",
    "target_query": "select tuple('b',1.5,3) IN (tuple(3,NULL,3), tuple('a',1.5,3), tuple(1,3,3));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_93_8",
    "database_name": "clickhouse_93_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select row('b',1.5,3) IN (row('b',NULL,3), row('a',1.5,3), row(1,3,3)); -- ROW",
    "target_query": "select tuple('b',1.5,3) IN (tuple('b',NULL,3), tuple('a',1.5,3), tuple(1,3,3));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_93_9",
    "database_name": "clickhouse_93_9",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select row('b',1.5,3) IN (row('b',NULL,4), row('a',1.5,3), row(1,3,3)); -- ROW",
    "target_query": "select tuple('b',1.5,3) IN (tuple('b',NULL,4), tuple('a',1.5,3), tuple(1,3,3));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_93_10",
    "database_name": "clickhouse_93_10",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select row(1,2,row(3,4)) IN (row(3,2,row(3,4)), row(1,2,row(3,NULL))); -- ROW",
    "target_query": "select tuple(1,2,tuple(3,4)) IN (tuple(3,2,tuple(3,4)), tuple(1,2,tuple(3,NULL)));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_93_11",
    "database_name": "clickhouse_93_11",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "explain select row(1,2,row(3,4)) IN (row(3,2,row(3,4)), row(1,2,row(3,NULL))); -- ROW",
    "target_query": "explain select tuple(1,2,tuple(3,4)) IN (tuple(3,2,tuple(3,4)), tuple(1,2,tuple(3,NULL)));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_93_12",
    "database_name": "clickhouse_93_12",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select row(1,2,row(3,null)) IN (row(3,2,row(3,4)), row(1,2,row(4,5))); -- ROW",
    "target_query": "select tuple(1,2,tuple(3,null)) IN (tuple(3,2,tuple(3,4)), tuple(1,2,tuple(4,5)));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_93_13",
    "database_name": "clickhouse_93_13",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select row(1,2,row(3,null)) IN (row(3,2,row(3,4)), row(1,2,row(3,5))); -- ROW",
    "target_query": "select tuple(1,2,tuple(3,null)) IN (tuple(3,2,tuple(3,4)), tuple(1,2,tuple(3,5)));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_93_14",
    "database_name": "clickhouse_93_14",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT ROW(1,2,3)=ROW(1,2,3); -- ROW",
    "target_query": "SELECT tuple(1,2,3)=tuple(1,2,3);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_93_15",
    "database_name": "clickhouse_93_15",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT ROW(2,2,3)=ROW(1+1,2,3); -- ROW",
    "target_query": "SELECT tuple(2,2,3)=tuple(1+1,2,3);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_93_16",
    "database_name": "clickhouse_93_16",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT ROW(1,2,3)=ROW(1+1,2,3); -- ROW",
    "target_query": "SELECT tuple(1,2,3)=tuple(1+1,2,3);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_93_17",
    "database_name": "clickhouse_93_17",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT ROW(1,2,3)<ROW(1+1,2,3); -- ROW",
    "target_query": "SELECT tuple(1,2,3)<tuple(1+1,2,3);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_93_18",
    "database_name": "clickhouse_93_18",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT ROW(1,2,3)>ROW(1+1,2,3); -- ROW",
    "target_query": "SELECT tuple(1,2,3)>tuple(1+1,2,3);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_93_19",
    "database_name": "clickhouse_93_19",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT ROW(1,2,3)<=ROW(1+1,2,3); -- ROW",
    "target_query": "SELECT tuple(1,2,3)<=tuple(1+1,2,3);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_93_20",
    "database_name": "clickhouse_93_20",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT ROW(1,2,3)>=ROW(1+1,2,3); -- ROW",
    "target_query": "SELECT tuple(1,2,3)>=tuple(1+1,2,3);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_93_21",
    "database_name": "clickhouse_93_21",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT ROW(1,2,3)<>ROW(1+1,2,3); -- ROW",
    "target_query": "SELECT tuple(1,2,3)<>tuple(1+1,2,3);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_93_22",
    "database_name": "clickhouse_93_22",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT ROW(NULL,2,3)=ROW(NULL,2,3); -- ROW",
    "target_query": "SELECT tuple(NULL,2,3)=tuple(NULL,2,3);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_93_23",
    "database_name": "clickhouse_93_23",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT ROW(1,2,ROW(3,4,5))=ROW(1,2,ROW(3,4,5)); -- ROW",
    "target_query": "SELECT tuple(1,2,tuple(3,4,5))=tuple(1,2,tuple(3,4,5));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_93_24",
    "database_name": "clickhouse_93_24",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT ROW('test',2,3.33)=ROW('test',2,3.33); -- ROW",
    "target_query": "SELECT tuple('test',2,3.33)=tuple('test',2,3.33);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_93_25",
    "database_name": "clickhouse_93_25",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT ROW('test',2,ROW(3,33))=ROW('test',2,ROW(3,33)); -- ROW",
    "target_query": "SELECT tuple('test',2,tuple(3,33))=tuple('test',2,tuple(3,33));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_93_26",
    "database_name": "clickhouse_93_26",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT ROW('test',2,ROW(3,33))=ROW('test',2,ROW(3,3)); -- ROW",
    "target_query": "SELECT tuple('test',2,tuple(3,33))=tuple('test',2,tuple(3,3));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_93_27",
    "database_name": "clickhouse_93_27",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT ROW('test',2,ROW(3,33))=ROW('test',2,ROW(3,NULL)); -- ROW",
    "target_query": "SELECT tuple('test',2,tuple(3,33))=tuple('test',2,tuple(3,NULL));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_94_3",
    "database_name": "clickhouse_94_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select * from t1 where ROW(1,2,3)=ROW(a,b,c); -- ROW",
    "target_query": "SELECT * FROM t1 WHERE tuple(1,2,3) = tuple(a,b,c);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 ( a int, b int, c int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a Int32, b Int32, c Int32) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_94_4",
    "database_name": "clickhouse_94_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select * from t1 where ROW(0,2,3)=ROW(a,b,c); -- ROW",
    "target_query": "SELECT * FROM t1 WHERE tuple(0,2,3) = tuple(a,b,c);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 ( a int, b int, c int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a Int32, b Int32, c Int32) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_94_5",
    "database_name": "clickhouse_94_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select * from t1 where ROW(1,2,3)<ROW(a,b,c); -- ROW",
    "target_query": "SELECT * FROM t1 WHERE tuple(1,2,3) < tuple(a,b,c);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 ( a int, b int, c int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a Int32, b Int32, c Int32) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_94_8",
    "database_name": "clickhouse_94_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select ROW(a,b,c) IN(row(1,2,3), row(3,2,1)) from t1; -- ROW",
    "target_query": "SELECT tuple(a,b,c) IN (tuple(1,2,3), tuple(3,2,1)) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 ( a int, b int, c int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a Int32, b Int32, c Int32) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_94_11",
    "database_name": "clickhouse_94_11",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT ROW(1,1,1) = ROW(1,1,1), ROW(1,1,1) = ROW(1,2,1), ROW(1,NULL,1) = ROW(2,2,1), ROW(1,NULL,1) = ROW(1,2,2), ROW(1,NULL,1) = ROW(1,2,1) ; -- ROW",
    "target_query": "SELECT tuple(1,1,1) = tuple(1,1,1), tuple(1,1,1) = tuple(1,2,1), tuple(1,NULL,1) = tuple(2,2,1), tuple(1,NULL,1) = tuple(1,2,2), tuple(1,NULL,1) = tuple(1,2,1);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_95_3",
    "database_name": "clickhouse_95_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT ROW(a, 1) IN (SELECT SUM(b), 1) FROM t1 GROUP BY a; -- ROW",
    "target_query": "SELECT tuple(a, 1) IN (SELECT tuple(SUM(b), 1) FROM t1 GROUP BY a) FROM t1 GROUP BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a INT, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a Int32, b Int32) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_95_4",
    "database_name": "clickhouse_95_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT ROW(a, 1) IN (SELECT SUM(b), 3) FROM t1 GROUP BY a; -- ROW",
    "target_query": "SELECT tuple(a, 1) IN (SELECT tuple(SUM(b), 3) FROM t1 GROUP BY a) FROM t1 GROUP BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a INT, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a Int32, b Int32) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_95_8",
    "database_name": "clickhouse_95_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT 1 FROM t1 WHERE ROW(a, b) >=ROW('1', (SELECT 1 FROM t1 WHERE a > '1234')); -- ROW",
    "target_query": "SELECT 1 FROM t1 WHERE tuple(a, b) >= tuple('1', (SELECT 1 FROM t1 WHERE a > '1234'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a INT NOT NULL, b TINYINT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT NOT NULL, b Int8) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_95_18",
    "database_name": "clickhouse_95_18",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "EXPLAIN SELECT row( min(a), 1 ) = row( a, 1 ) AS al FROM t1 GROUP BY a; -- ROW",
    "target_query": "EXPLAIN SELECT tuple( min(a), 1 ) = tuple( a, 1 ) AS al FROM t1 GROUP BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a INT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a Int32 ) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_95_19",
    "database_name": "clickhouse_95_19",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT row( min(a), 1 ) = row( a, 1 ) AS al FROM t1 GROUP BY a; -- ROW",
    "target_query": "SELECT tuple( min(a), 1 ) = tuple( a, 1 ) AS al FROM t1 GROUP BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a INT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a Int32 ) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_96_0",
    "database_name": "clickhouse_96_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT RPAD(NULL, 5, 'x') AS result; -- RPAD",
    "target_query": "SELECT RPAD(NULL, 5, 'x') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "ClickHouse uses the RPAD function for padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(toString(123), 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_96_1",
    "database_name": "clickhouse_96_1",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT RPAD(NULL, NULL, 'x') AS result; -- RPAD",
    "target_query": "SELECT RPAD(NULL, NULL, 'x') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "ClickHouse uses the RPAD function for padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(toString(123), 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_96_2",
    "database_name": "clickhouse_96_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT RPAD(NULL, NULL, NULL) AS result; -- RPAD",
    "target_query": "SELECT RPAD(NULL, NULL, NULL) AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "ClickHouse uses the RPAD function for padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(toString(123), 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_96_3",
    "database_name": "clickhouse_96_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT RPAD('a', NULL, 'x') AS result; -- RPAD",
    "target_query": "SELECT RPAD('a', NULL, 'x') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "ClickHouse uses the RPAD function for padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(toString(123), 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_96_4",
    "database_name": "clickhouse_96_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT RPAD('a', NULL, NULL) AS result; -- RPAD",
    "target_query": "SELECT RPAD('a', NULL, NULL) AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "ClickHouse uses the RPAD function for padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(toString(123), 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_96_5",
    "database_name": "clickhouse_96_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT RPAD('a', 5, NULL) AS result; -- RPAD",
    "target_query": "SELECT RPAD('a', 5, NULL) AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "ClickHouse uses the RPAD function for padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(toString(123), 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_96_6",
    "database_name": "clickhouse_96_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT RPAD(NULL, 5, NULL) AS result; -- RPAD",
    "target_query": "SELECT RPAD(NULL, 5, NULL) AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "ClickHouse uses the RPAD function for padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(toString(123), 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_96_7",
    "database_name": "clickhouse_96_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT RPAD('a', 0, 'x') AS result; -- RPAD",
    "target_query": "SELECT RPAD('a', 0, 'x') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "ClickHouse uses the RPAD function for padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(toString(123), 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_96_8",
    "database_name": "clickhouse_96_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT RPAD('a', 0, '') AS result; -- RPAD",
    "target_query": "SELECT RPAD('a', 0, '') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "ClickHouse uses the RPAD function for padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(toString(123), 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_96_9",
    "database_name": "clickhouse_96_9",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT RPAD('', 0, 'x') AS result; -- RPAD",
    "target_query": "SELECT RPAD('', 0, 'x') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "ClickHouse uses the RPAD function for padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(toString(123), 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_96_10",
    "database_name": "clickhouse_96_10",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT RPAD('', 0, '') AS result; -- RPAD",
    "target_query": "SELECT RPAD('', 0, '') AS result;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "ClickHouse uses the RPAD function for padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(toString(123), 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_96_12",
    "database_name": "clickhouse_96_12",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT RPAD('123456787890', 1, 'x'); -- RPAD",
    "target_query": "SELECT RPAD('123456787890', 1, 'x');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "ClickHouse uses the RPAD function for padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(toString(123), 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_96_13",
    "database_name": "clickhouse_96_13",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT RPAD('a', 5, 'xy'); -- RPAD",
    "target_query": "SELECT RPAD('a', 5, 'xy');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "ClickHouse uses the RPAD function for padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(toString(123), 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_96_14",
    "database_name": "clickhouse_96_14",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT RPAD(\"I LOVE SQL\", 20, \" \"); -- RPAD",
    "target_query": "SELECT RPAD('I LOVE SQL', 20, ' ');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "ClickHouse uses the RPAD function for padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(toString(123), 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_96_15",
    "database_name": "clickhouse_96_15",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT RPAD(\"I LOVE SQL in the morning\", 20, \" \"); -- RPAD",
    "target_query": "SELECT RPAD('I LOVE SQL in the morning', 20, ' ');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "ClickHouse uses the RPAD function for padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(toString(123), 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_97_6",
    "database_name": "clickhouse_97_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "EXPLAIN SELECT * FROM t1 WHERE ISNULL(t1.a IN (SELECT t3.a FROM t1 t3)); -- ISNULL",
    "target_query": "EXPLAIN SELECT * FROM t1 WHERE t1.a IN (SELECT t3.a FROM t1 t3) IS NULL;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ISNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ISNULL(expr)",
        "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
        "examples": [
          "SELECT ISNULL(NULL);",
          "SELECT ISNULL(5 + NULL);",
          "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "expr IS NULL",
        "description": "Checks whether an expression is NULL.",
        "examples": [
          "SELECT NULL IS NULL;",
          "SELECT (number / NULL) IS NULL FROM numbers(1);",
          "SELECT IF(score IS NULL, 'N/A', toString(score)) FROM student_scores;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(a INT, b INT);",
      "ALTER TABLE t1 MODIFY a INT NOT NULL;",
      "ALTER TABLE t1 MODIFY a INT NULL;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(a INT, b INT) ENGINE=MergeTree ORDER BY tuple();",
      "ALTER TABLE t1 MODIFY COLUMN a INT;",
      "ALTER TABLE t1 MODIFY COLUMN a Nullable(INT);"
    ]
  },
  {
    "sql_id": "clickhouse_97_7",
    "database_name": "clickhouse_97_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT * FROM t1 WHERE ISNULL(t1.a IN (SELECT t3.a FROM t1 t3)); -- ISNULL",
    "target_query": "SELECT * FROM t1 WHERE t1.a IN (SELECT t3.a FROM t1 t3) IS NULL;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ISNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ISNULL(expr)",
        "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
        "examples": [
          "SELECT ISNULL(NULL);",
          "SELECT ISNULL(5 + NULL);",
          "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "expr IS NULL",
        "description": "Checks whether an expression is NULL.",
        "examples": [
          "SELECT NULL IS NULL;",
          "SELECT (number / NULL) IS NULL FROM numbers(1);",
          "SELECT IF(score IS NULL, 'N/A', toString(score)) FROM student_scores;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(a INT, b INT);",
      "ALTER TABLE t1 MODIFY a INT NOT NULL;",
      "ALTER TABLE t1 MODIFY a INT NULL;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(a INT, b INT) ENGINE=MergeTree ORDER BY tuple();",
      "ALTER TABLE t1 MODIFY COLUMN a INT;",
      "ALTER TABLE t1 MODIFY COLUMN a Nullable(INT);"
    ]
  },
  {
    "sql_id": "clickhouse_98_4",
    "database_name": "clickhouse_98_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "EXPLAIN SELECT * FROM t1 WHERE (SELECT b FROM t2 WHERE CAST(UUID() AS CHAR) = CAST(t2.a AS CHAR)) > 0; -- UUID",
    "target_query": "EXPLAIN SELECT * FROM t1 WHERE (SELECT b FROM t2 WHERE CAST(generateUUIDv4() AS TEXT) = CAST(t2.a AS TEXT)) > 0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UUID"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UUID()",
        "description": "In MySQL, the UUID() function generates a unique 128-bit identifier, typically represented as a string containing numbers and letters, in the standard UUID format.",
        "examples": [
          "SELECT UUID();",
          "SELECT CONCAT(UUID(), 'some_random_string');",
          "SELECT UPPER(UUID());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "generateUUIDv4()",
        "description": "ClickHouse supports the generateUUIDv4() function to generate a UUID following the UUID v4 standard.",
        "examples": [
          "SELECT generateUUIDv4();",
          "SELECT CONCAT(generateUUIDv4(), 'some_random_string');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2(a INT, b INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2(a INT, b INT) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_99_6",
    "database_name": "clickhouse_99_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT TRIM(f1), COUNT(*) FROM table_varchar_pad_space GROUP BY f1; -- TRIM, COUNT",
    "target_query": "SELECT TRIM(f1), COUNT(*) FROM table_varchar_pad_space GROUP BY f1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TRIM",
      "COUNT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
        "examples": [
          "SELECT TRIM('x' FROM 'xxabcx');",
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      },
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN FORMAT=TREE SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
        "description": "Clickhouse's TRIM function works the same way as MySQL, allowing for removal of unwanted characters from both sides, the start, or the end of the string.",
        "examples": [
          "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
          "SELECT TRIM(LEADING '0' FROM '000123');"
        ]
      },
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE table_varchar_pad_space (f1 VARCHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE table_varchar_pad_space (f1 String) ENGINE=MergeTree ORDER BY f1;"
    ]
  },
  {
    "sql_id": "clickhouse_10_4",
    "database_name": "clickhouse_10_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select concat(a1,min(c)),b from t1 where a1 < 'd' group by a1,a2,b; -- CONCAT",
    "target_query": "SELECT concat(a1, min(c)), b FROM t1 WHERE a1 < 'd' GROUP BY a1, a2, b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a1 String, a2 String, b String, c String NOT NULL, d String, dummy String DEFAULT ' ') ENGINE = Memory;"
    ]
  },
  {
    "sql_id": "clickhouse_10_5",
    "database_name": "clickhouse_10_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select concat(a1,min(c)),b,max(c) from t1 where a1 < 'd' group by a1,a2,b; -- CONCAT",
    "target_query": "SELECT concat(a1, min(c)), b, max(c) FROM t1 WHERE a1 < 'd' GROUP BY a1, a2, b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a1 String, a2 String, b String, c String NOT NULL, d String, dummy String DEFAULT ' ') ENGINE = Memory;"
    ]
  },
  {
    "sql_id": "clickhouse_10_6",
    "database_name": "clickhouse_10_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select concat(a1,a2),b,min(c),max(c) from t1 where a1 < 'd' group by a1,a2,b; -- CONCAT",
    "target_query": "SELECT concat(a1, a2), b, min(c), max(c) FROM t1 WHERE a1 < 'd' GROUP BY a1, a2, b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a1 String, a2 String, b String, c String NOT NULL, d String, dummy String DEFAULT ' ') ENGINE = Memory;"
    ]
  },
  {
    "sql_id": "clickhouse_11_3",
    "database_name": "clickhouse_11_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select Fld1, max(Fld2) from t1 group by Fld1 having std(Fld2) is not null; -- STD",
    "target_query": "SELECT Fld1, max(Fld2) FROM t1 GROUP BY Fld1 HAVING stddevSamp(Fld2) IS NOT NULL;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STD(expression)",
        "description": "Calculates the standard deviation for the sample of a given expression.",
        "examples": [
          "SELECT some_dimension, COUNT(*), MIN(some_expression), MAX(some_expression), SUM(some_expression), AVG(some_expression), STD(some_expression) FROM some_data GROUP BY some_dimension LIMIT 5;",
          "SELECT another_dimension, COUNT(*), STD(expression1 / expression2) FROM another_data GROUP BY another_dimension ORDER BY another_dimension;",
          "SELECT ROUND(STD(expression1 / expression2), 5) FROM more_data;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "stddevSamp(expression)",
        "description": "Calculates the standard deviation for the sample of a given expression.",
        "examples": [
          "SELECT some_dimension, COUNT(*), MIN(some_expression), MAX(some_expression), SUM(some_expression), AVG(some_expression), stddevSamp(some_expression) FROM some_data GROUP BY some_dimension LIMIT 5;",
          "SELECT another_dimension, COUNT(*), stddevSamp(expression1 / expression2) FROM another_data GROUP BY another_dimension ORDER BY another_dimension;",
          "SELECT ROUND(stddevSamp(expression1 / expression2), 5) FROM more_data;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (Fld1 int(11) default NULL,Fld2 int(11) default NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (Fld1 Int32, Fld2 Nullable(Int32)) ENGINE = MergeTree ORDER BY Fld1;"
    ]
  },
  {
    "sql_id": "clickhouse_11_4",
    "database_name": "clickhouse_11_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select Fld1, max(Fld2) from t1 group by Fld1 having variance(Fld2) is not null; -- VARIANCE",
    "target_query": "SELECT Fld1, max(Fld2) FROM t1 GROUP BY Fld1 HAVING varPop(Fld2) IS NOT NULL;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "VARIANCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "VARIANCE(column1)",
        "description": "In MySQL, the VARIANCE() function calculates the variance of a given column of numeric values. It is used to measure the spread or dispersion of the data in a column.",
        "examples": [
          "SELECT VARIANCE(column1) AS variance_value FROM some_table;",
          "SELECT department, VARIANCE(salary) AS department_salary_variance FROM employees GROUP BY department;",
          "SELECT VARIANCE(price) AS price_variance FROM items;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "varPop(column1)",
        "description": "ClickHouse uses 'varPop' for calculating population variance and 'varSamp' for sample variance. These functions provide similar functionality to VARIANCE() in other databases, but with explicit population or sample variance distinction.",
        "examples": [
          "SELECT varPop(column1) AS variance_value FROM some_table;",
          "SELECT department, varPop(salary) AS department_salary_variance FROM employees GROUP BY department;",
          "SELECT varPop(price) AS price_variance FROM items;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (Fld1 int(11) default NULL,Fld2 int(11) default NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (Fld1 Int32, Fld2 Nullable(Int32)) ENGINE = MergeTree ORDER BY Fld1;"
    ]
  },
  {
    "sql_id": "clickhouse_12_8",
    "database_name": "clickhouse_12_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "insert into t3 select concat('c-', 1000+A.a, '=w'), concat('c-', 2000+A.a, '=w'),'filler-1' from t2 A; -- CONCAT",
    "target_query": "INSERT INTO t3 SELECT concat('c-', toString(1000 + A.a), '=w'), concat('c-', toString(2000 + A.a), '=w'), 'filler-1' FROM t2 A;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t3 (a char(8) not null, b char(8) not null, filler char(200));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t3 (a String NOT NULL, b String NOT NULL, filler String) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_12_9",
    "database_name": "clickhouse_12_9",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "insert into t3 select concat('c-', 1000+A.a, '=w'), concat('c-', 3000+A.a, '=w'),'filler-2' from t2 A; -- CONCAT",
    "target_query": "INSERT INTO t3 SELECT concat('c-', toString(1000 + A.a), '=w'), concat('c-', toString(3000 + A.a), '=w'), 'filler-2' FROM t2 A;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t3 (a char(8) not null, b char(8) not null, filler char(200));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t3 (a String NOT NULL, b String NOT NULL, filler String) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_12_23",
    "database_name": "clickhouse_12_23",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "update t1 set b=repeat(char(65+a), 20) where a < 25; -- REPEAT",
    "target_query": "ALTER TABLE t1 UPDATE b = repeat(char(65 + a), 20) WHERE a < 25;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t0 (a int);",
      "create table t1 (a int, b char(20), filler char(200));",
      "update t1 set b=repeat(char(65+a), 20) where a < 25; -- REPEAT"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0 (a Int32) ENGINE = MergeTree ORDER BY a;",
      "CREATE TABLE t1 (a Int32, b String, filler String) ENGINE = Memory;",
      "ALTER TABLE t1 UPDATE b = repeat(char(65 + a), 20) WHERE a < 25;"
    ]
  },
  {
    "sql_id": "clickhouse_12_24",
    "database_name": "clickhouse_12_24",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "explain select * from t1 where a < 10 and b = repeat(char(65+a), 20); -- REPEAT",
    "target_query": "EXPLAIN SELECT * FROM t1 WHERE a < 10 AND b = repeat(char(65 + a), 20);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t0 (a int);",
      "create table t1 (a int, b char(20), filler char(200));",
      "update t1 set b=repeat(char(65+a), 20) where a < 25; -- REPEAT"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0 (a Int32) ENGINE = MergeTree ORDER BY a;",
      "CREATE TABLE t1 (a Int32, b String, filler String) ENGINE = Memory;",
      "ALTER TABLE t1 UPDATE b = repeat(char(65 + a), 20) WHERE a < 25;"
    ]
  },
  {
    "sql_id": "clickhouse_12_25",
    "database_name": "clickhouse_12_25",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select * from t1 where a < 10 and b = repeat(char(65+a), 20); -- REPEAT",
    "target_query": "SELECT * FROM t1 WHERE a < 10 AND b = repeat(char(65 + a), 20);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t0 (a int);",
      "create table t1 (a int, b char(20), filler char(200));",
      "update t1 set b=repeat(char(65+a), 20) where a < 25; -- REPEAT"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0 (a Int32) ENGINE = MergeTree ORDER BY a;",
      "CREATE TABLE t1 (a Int32, b String, filler String) ENGINE = Memory;",
      "ALTER TABLE t1 UPDATE b = repeat(char(65 + a), 20) WHERE a < 25;"
    ]
  },
  {
    "sql_id": "clickhouse_13_6",
    "database_name": "clickhouse_13_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select a,hex(b),hex(c),filler from t1 order by filler; -- HEX",
    "target_query": "SELECT a, HEX(b), HEX(c), filler FROM t1 ORDER BY filler;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a int, b char(10), c char(10), filler char(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a Int32, b String, c String, filler String) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_14_4",
    "database_name": "clickhouse_14_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select length(data) from t1; -- LENGTH",
    "target_query": "SELECT length(data) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (data LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (data String) ENGINE = MergeTree ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_14_7",
    "database_name": "clickhouse_14_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 (data) VALUES (repeat('a',1*1024)); -- REPEAT",
    "target_query": "INSERT INTO t1 (data) VALUES (repeat('a', toUInt32(1*1024)));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (data LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (data String) ENGINE = MergeTree ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_14_8",
    "database_name": "clickhouse_14_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 (data) VALUES (repeat('b',16*1024-1024)); -- REPEAT",
    "target_query": "INSERT INTO t1 (data) VALUES (repeat('b', toUInt32(16*1024 - 1024)));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (data LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (data String) ENGINE = MergeTree ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_14_13",
    "database_name": "clickhouse_14_13",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 set data=repeat('a',18*1024); -- REPEAT",
    "target_query": "INSERT INTO t1 (data) VALUES (repeat('a', toUInt32(18*1024)));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (data LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (data String) ENGINE = MergeTree ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_14_14",
    "database_name": "clickhouse_14_14",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select length(data) from t1; -- LENGTH",
    "target_query": "SELECT length(data) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (data LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (data String) ENGINE = MergeTree ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_15_0",
    "database_name": "clickhouse_15_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT UNIX_TIMESTAMP('2011-01-01 00:00:00') as time_t,UNIX_TIMESTAMP('2011-01-01 00:00:00') % 3 as part,1234567890 % 3 as part2; -- UNIX_TIMESTAMP",
    "target_query": "SELECT toUnixTimestamp('2011-01-01 00:00:00') AS time_t, toUnixTimestamp('2011-01-01 00:00:00') % 3 AS part, 1234567890 % 3 AS part2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp(timestamp)",
        "description": "Converts a DateTime string or value to a Unix timestamp (seconds since 1970-01-01 UTC).",
        "examples": [
          "SELECT toUnixTimestamp(now());",
          "SELECT toUnixTimestamp('2015-11-13 23:59:59+02:00');",
          "SELECT toUnixTimestamp('2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_15_3",
    "database_name": "clickhouse_15_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t3 (a) VALUES (NOW()); -- NOW",
    "target_query": "INSERT INTO t3 (a) VALUES (now());",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "now()",
        "description": "ClickHouse uses the now() function to return the current date and time, which is equivalent to MySQL's NOW() function.",
        "examples": [
          "SELECT now();",
          "CREATE TABLE t12 AS SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > now()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (now());"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t3(a timestamp,b char(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t3 (a DateTime, b String) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_15_13",
    "database_name": "clickhouse_15_13",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t2 VALUES (1 + (SELECT a FROM t1),CONCAT(\"subq: \", (SELECT b FROM t1))); -- CONCAT",
    "target_query": "INSERT INTO t2 (a, b) SELECT 1 + a, concat('subq: ', b) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 (a INT, b VARCHAR(64));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (a Int32, b String) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_16_0",
    "database_name": "clickhouse_16_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select USER(),CURRENT_USER(); -- USER, CURRENT_USER",
    "target_query": "SELECT currentUser(), currentUser();",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "USER",
      "CURRENT_USER"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "USER()",
        "description": "Returns the current MySQL user and host in the format 'username@hostname'.",
        "examples": [
          "SELECT USER();"
        ]
      },
      {
        "expression": "CURRENT_USER()",
        "description": "Returns the account name of the user that the server used to authenticate the current client, in 'user_name@host_name' format.",
        "examples": [
          "SELECT CURRENT_USER();",
          "SELECT USER(), CURRENT_USER();",
          "SELECT CURRENT_USER() = USER();"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "currentUser()",
        "description": "Returns the current user in ClickHouse.",
        "examples": [
          "SELECT currentUser();"
        ]
      },
      {
        "expression": "currentUser()",
        "description": "Returns the name of the current authenticated user in the session context.",
        "examples": [
          "SELECT currentUser();",
          "SELECT currentUser() = 'default';",
          "SELECT currentUser() LIKE '%';"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_2",
    "database_name": "clickhouse_17_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR",
    "target_query": "SELECT position('a', 'abc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_3",
    "database_name": "clickhouse_17_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR",
    "target_query": "SELECT position('b', 'abc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_4",
    "database_name": "clickhouse_17_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR",
    "target_query": "SELECT position('c', 'abc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_5",
    "database_name": "clickhouse_17_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR",
    "target_query": "SELECT position('d', 'abc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_6",
    "database_name": "clickhouse_17_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR",
    "target_query": "SELECT position('a', NULL);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_7",
    "database_name": "clickhouse_17_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR",
    "target_query": "SELECT position(NULL, 'a');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_8",
    "database_name": "clickhouse_17_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( NULL, NULL ); -- REGEXP_INSTR",
    "target_query": "SELECT position(NULL, NULL);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_9",
    "database_name": "clickhouse_17_9",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT hex( concat(regexp_instr( 'a', 'a' )) ); -- HEX, CONCAT, REGEXP_INSTR",
    "target_query": "SELECT HEX(CONCAT(toString(position('a', 'a')), ''));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "CONCAT",
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      },
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      },
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_10",
    "database_name": "clickhouse_17_10",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( 1, 'a' ); -- REGEXP_INSTR",
    "target_query": "SELECT position('a', toString(1));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_11",
    "database_name": "clickhouse_17_11",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( 1.1, 'a' ); -- REGEXP_INSTR",
    "target_query": "SELECT position('a', toString(1.1));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_12",
    "database_name": "clickhouse_17_12",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( 'a', 1 ); -- REGEXP_INSTR",
    "target_query": "SELECT position(toString(1), 'a');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_13",
    "database_name": "clickhouse_17_13",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( 'a', 1.1 ); -- REGEXP_INSTR",
    "target_query": "SELECT position(toString(1.1), 'a');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_14",
    "database_name": "clickhouse_17_14",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( subject, pattern ) FROM t1; -- REGEXP_INSTR",
    "target_query": "SELECT position(pattern, subject) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (subject char(10),pattern char(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (subject String, pattern String)  ENGINE = MergeTree ORDER BY subject;"
    ]
  },
  {
    "sql_id": "clickhouse_17_15",
    "database_name": "clickhouse_17_15",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1 ); -- REGEXP_INSTR",
    "target_query": "SELECT position('a+', 'abcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_16",
    "database_name": "clickhouse_17_16",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 2 ); -- REGEXP_INSTR",
    "target_query": "SELECT position('a+', 'abcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_17",
    "database_name": "clickhouse_17_17",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'b+', 1 ); -- REGEXP_INSTR",
    "target_query": "SELECT position('b+', 'abcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_18",
    "database_name": "clickhouse_17_18",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'b+', 2 ); -- REGEXP_INSTR",
    "target_query": "SELECT position('b+', 'abcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_19",
    "database_name": "clickhouse_17_19",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'b+', 3 ); -- REGEXP_INSTR",
    "target_query": "SELECT position('b+', 'abcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_20",
    "database_name": "clickhouse_17_20",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 2 ); -- REGEXP_INSTR",
    "target_query": "SELECT position('a+', 'abcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_21",
    "database_name": "clickhouse_17_21",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 3 ); -- REGEXP_INSTR",
    "target_query": "SELECT position('a+', 'abcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_22",
    "database_name": "clickhouse_17_22",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 4 ); -- REGEXP_INSTR",
    "target_query": "SELECT position('a+', 'abcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_23",
    "database_name": "clickhouse_17_23",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 4, 2 ); -- REGEXP_INSTR",
    "target_query": "SELECT position('a+', 'abcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_24",
    "database_name": "clickhouse_17_24",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( 'a', 'a+', 1, 1, NULL ); -- REGEXP_INSTR",
    "target_query": "SELECT position('a+', 'a');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_25",
    "database_name": "clickhouse_17_25",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 0 ); -- REGEXP_INSTR",
    "target_query": "SELECT position('a+', 'abcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_26",
    "database_name": "clickhouse_17_26",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 1 ); -- REGEXP_INSTR",
    "target_query": "SELECT position('a+', 'abcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_27",
    "database_name": "clickhouse_17_27",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( 'aaabcabcabc', 'a+', 1, 1, 1 ); -- REGEXP_INSTR",
    "target_query": "SELECT position('a+', 'aaabcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_28",
    "database_name": "clickhouse_17_28",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'c' ); -- REGEXP_INSTR",
    "target_query": "SELECT position('A+', 'aaabcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_29",
    "database_name": "clickhouse_17_29",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'i' ); -- REGEXP_INSTR",
    "target_query": "SELECT position('A+', 'aaabcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_30",
    "database_name": "clickhouse_17_30",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'ci' ); -- REGEXP_INSTR",
    "target_query": "SELECT position('A+', 'aaabcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_31",
    "database_name": "clickhouse_17_31",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'cic' ); -- REGEXP_INSTR",
    "target_query": "SELECT position('A+', 'aaabcabcabc');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_17_32",
    "database_name": "clickhouse_17_32",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_instr( 'a', 'a+', 1, 1, 1, NULL ); -- REGEXP_INSTR",
    "target_query": "SELECT position('a+', 'a');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_18_0",
    "database_name": "clickhouse_18_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_replace( 'aaa', 'a', 'X' ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaa', 'a', 'X');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all substrings in the input string matching the regular expression pattern with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_18_1",
    "database_name": "clickhouse_18_1",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('abc', 'b', 'X');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all substrings in the input string matching the regular expression pattern with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_18_2",
    "database_name": "clickhouse_18_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_replace( NULL, 'a', 'X' ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace(NULL, 'a', 'X');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all substrings in the input string matching the regular expression pattern with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_18_3",
    "database_name": "clickhouse_18_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_replace( 'aaa', NULL, 'X' ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaa', NULL, 'X');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all substrings in the input string matching the regular expression pattern with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_18_4",
    "database_name": "clickhouse_18_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_replace( 'aaa', 'a', NULL ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaa', 'a', NULL);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all substrings in the input string matching the regular expression pattern with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_18_5",
    "database_name": "clickhouse_18_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT concat( regexp_replace( 'aaa', 'a', 'X' ), 'x' ); -- CONCAT, REGEXP_REPLACE",
    "target_query": "SELECT concat(regexp_replace('aaa', 'a', 'X'), 'x');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT",
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      },
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      },
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all substrings in the input string matching the regular expression pattern with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_18_6",
    "database_name": "clickhouse_18_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_replace( 'aaa', 'a', 'X', 1 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaa', 'a', 'X');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all substrings in the input string matching the regular expression pattern with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_18_7",
    "database_name": "clickhouse_18_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 1 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaabbccbbddaa', 'b+', 'X');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all substrings in the input string matching the regular expression pattern with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_18_8",
    "database_name": "clickhouse_18_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 2 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaabbccbbddaa', 'b+', 'X');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all substrings in the input string matching the regular expression pattern with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_18_9",
    "database_name": "clickhouse_18_9",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>', 1, 2 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaabbccbbddaa', '(b+)', '<$1>');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all substrings in the input string matching the regular expression pattern with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_18_10",
    "database_name": "clickhouse_18_10",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x', 1, 0 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaabbccbbddaa', 'x+', 'x');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all substrings in the input string matching the regular expression pattern with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_18_11",
    "database_name": "clickhouse_18_11",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x', 1, 0 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaabbccbbddaa', 'b+', 'x');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all substrings in the input string matching the regular expression pattern with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_18_12",
    "database_name": "clickhouse_18_12",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_replace( 'aaab', 'b', 'x', 1, 2 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaab', 'b', 'x');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all substrings in the input string matching the regular expression pattern with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_18_13",
    "database_name": "clickhouse_18_13",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_replace( 'aaabccc', 'b', 'x', 1, 2 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaabccc', 'b', 'x');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all substrings in the input string matching the regular expression pattern with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_18_14",
    "database_name": "clickhouse_18_14",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('abc', 'b', 'X');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all substrings in the input string matching the regular expression pattern with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_18_15",
    "database_name": "clickhouse_18_15",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_replace( 'abcbdb', 'b', 'X' ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('abcbdb', 'b', 'X');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all substrings in the input string matching the regular expression pattern with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_18_16",
    "database_name": "clickhouse_18_16",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_replace( 'abcbdb', 'b', 'X', 3 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('abcbdb', 'b', 'X');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all substrings in the input string matching the regular expression pattern with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_18_17",
    "database_name": "clickhouse_18_17",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 1 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaabcbdb', 'b', 'X');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all substrings in the input string matching the regular expression pattern with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_18_18",
    "database_name": "clickhouse_18_18",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 2 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaabcbdb', 'b', 'X');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all substrings in the input string matching the regular expression pattern with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_18_19",
    "database_name": "clickhouse_18_19",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 3 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaabcbdb', 'b', 'X');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all substrings in the input string matching the regular expression pattern with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_18_20",
    "database_name": "clickhouse_18_20",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_replace( 'aaa', 'a', 'X', 2 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaa', 'a', 'X');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all substrings in the input string matching the regular expression pattern with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_18_21",
    "database_name": "clickhouse_18_21",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_replace( 'aaa', 'a', 'XX', 2 ); -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace('aaa', 'a', 'XX');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all substrings in the input string matching the regular expression pattern with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_19_2",
    "database_name": "clickhouse_19_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 VALUES ( regexp_instr('a', 'a'),regexp_instr('a', 'a'),regexp_instr('a', 'a'),regexp_instr('a', 'a') ); -- REGEXP_INSTR",
    "target_query": "INSERT INTO t1 VALUES ( position('a', 'a'), position('a', 'a'), position('a', 'a'), position('a', 'a') );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_INSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_INSTR('hello world', 'o')",
        "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
        "examples": [
          "SELECT REGEXP_INSTR('hello world', 'o');",
          "SELECT REGEXP_INSTR('hello world', 'x');",
          "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position('o', 'hello world')",
        "description": "ClickHouse does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
        "examples": [
          "SELECT position('o', 'hello world');",
          "SELECT position('x', 'hello world');",
          "SELECT position('a', 'openai');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(a REAL,b INT,c CHAR(100),d DECIMAL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(a REAL,b INT,c CHAR(100),d DECIMAL) ENGINE = MergeTree ORDER BY tuple();;"
    ]
  },
  {
    "sql_id": "clickhouse_19_6",
    "database_name": "clickhouse_19_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 ( c ) VALUES ( regexp_replace('a', 'a', 'a') ); -- REGEXP_REPLACE",
    "target_query": "INSERT INTO t1 ( c ) VALUES ( regexp_replace('a', 'a', 'a') );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all substrings in the input string matching the regular expression pattern with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(a REAL,b INT,c CHAR(100),d DECIMAL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(a REAL,b INT,c CHAR(100),d DECIMAL) ENGINE = MergeTree ORDER BY tuple();;"
    ]
  },
  {
    "sql_id": "clickhouse_19_12",
    "database_name": "clickhouse_19_12",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 VALUES ( repeat( 'a', 16384 ) ); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES ( repeat('a', 16384) );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a TEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a String) ENGINE = MergeTree ORDER BY tuple();;"
    ]
  },
  {
    "sql_id": "clickhouse_19_13",
    "database_name": "clickhouse_19_13",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT char_length ( regexp_replace( a, 'a', 'b' ) ) FROM t1; -- CHAR_LENGTH, REGEXP_REPLACE",
    "target_query": "SELECT lengthUTF8(regexp_replace(a, 'a', 'b')) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CHAR_LENGTH",
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CHAR_LENGTH(expr)",
        "description": "Returns the number of characters in the string, not bytes.",
        "examples": [
          "SELECT CHAR_LENGTH('abc');",
          "SELECT CHAR_LENGTH('你好');",
          "SELECT CHAR_LENGTH('a你b好c');"
        ]
      },
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "lengthUTF8(expr)",
        "description": "Returns the number of characters in a UTF-8 encoded string.",
        "examples": [
          "SELECT lengthUTF8('abc');",
          "SELECT lengthUTF8('你好');",
          "SELECT lengthUTF8('a你b好c');"
        ]
      },
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all substrings in the input string matching the regular expression pattern with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a TEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a String) ENGINE = MergeTree ORDER BY tuple();;"
    ]
  },
  {
    "sql_id": "clickhouse_19_17",
    "database_name": "clickhouse_19_17",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT regexp_replace(a, '^([[:alpha:]]+)[[:space:]].*$', '$1') FROM t1; -- REGEXP_REPLACE",
    "target_query": "SELECT regexp_replace(a, '^([[:alpha:]]+)[[:space:]].*$', '$1') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REGEXP_REPLACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
        "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
        "examples": [
          "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
          "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
          "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "regexp_replace(string, pattern, replacement)",
        "description": "Replaces all substrings in the input string matching the regular expression pattern with the replacement string.",
        "examples": [
          "SELECT regexp_replace('abcabcabc', 'b', 'X');",
          "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
          "SELECT regexp_replace('qwe123rty456', '\\\\d+', '_');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a VARCHAR(10) );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ( a String ) ENGINE = MergeTree ORDER BY tuple();;"
    ]
  },
  {
    "sql_id": "clickhouse_20_2",
    "database_name": "clickhouse_20_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT SUM(DISTINCT LENGTH(name)) s1 FROM t1; -- LENGTH",
    "target_query": "SELECT SUM(DISTINCT length(name)) s1 FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (id INTEGER NOT NULL PRIMARY KEY,gender CHAR(1),name VARCHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id INTEGER NOT NULL, gender CHAR(1), name VARCHAR(20)) ENGINE = MergeTree ORDER BY id;"
    ]
  },
  {
    "sql_id": "clickhouse_20_6",
    "database_name": "clickhouse_20_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT SUM(DISTINCT LENGTH(name)) s1 FROM t1; -- LENGTH",
    "target_query": "SELECT SUM(DISTINCT length(name)) s1 FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (id INTEGER NOT NULL PRIMARY KEY,gender CHAR(1),name VARCHAR(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id INTEGER NOT NULL, gender CHAR(1), name VARCHAR(20)) ENGINE = MergeTree ORDER BY id;"
    ]
  },
  {
    "sql_id": "clickhouse_20_10",
    "database_name": "clickhouse_20_10",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT (SELECT SUM(DISTINCT LENGTH(name)) FROM t1) FROM t2; -- LENGTH",
    "target_query": "SELECT (SELECT SUM(DISTINCT length(name)) FROM t1) FROM t2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 SELECT name FROM t1;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 ENGINE = MergeTree ORDER BY tuple() AS SELECT name FROM t1;"
    ]
  },
  {
    "sql_id": "clickhouse_20_13",
    "database_name": "clickhouse_20_13",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t2 VALUES (1,'18:19:29',NOW()); -- NOW",
    "target_query": "INSERT INTO t2 VALUES (1, '2025-05-21 18:19:29', now());",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "now()",
        "description": "ClickHouse uses the now() function to return the current date and time, which is equivalent to MySQL's NOW() function.",
        "examples": [
          "SELECT now();",
          "CREATE TABLE t12 AS SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > now()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (now());"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 (pk int(11) NOT NULL PRIMARY KEY,time_nokey time DEFAULT NULL,datetime_key time DEFAULT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (pk Int32 NOT NULL, time_nokey DateTime DEFAULT now(), datetime_key DateTime DEFAULT now()) ENGINE = MergeTree ORDER BY pk;"
    ]
  },
  {
    "sql_id": "clickhouse_21_10",
    "database_name": "clickhouse_21_10",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select one.id, two.val, elt(two.val,'one','two') from t1 one, t2 two where two.id=one.id order by one.id; -- ELT",
    "target_query": "SELECT one.id, two.val, arrayElement(['one', 'two'], two.val) FROM t1 one INNER JOIN t2 two ON two.id = one.id ORDER BY one.id;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ELT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ELT(2, 'apple', 'banana', 'cherry')",
        "description": "Returns the N-th element from the list, where N is the first argument.",
        "examples": [
          "SELECT ELT(2, 'apple', 'banana', 'cherry');  -- Returns 'banana'",
          "SELECT ELT(1, 'red', 'green', 'blue');  -- Returns 'red'",
          "SELECT ELT(3, 'dog', 'cat', 'bird');  -- Returns 'bird'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "arrayElement(['apple', 'banana', 'cherry'], 2)",
        "description": "Returns the N-th element from the array, where N is the second argument.",
        "examples": [
          "SELECT arrayElement(['apple', 'banana', 'cherry'], 2);  -- Returns 'banana'",
          "SELECT arrayElement(['red', 'green', 'blue'], 1);  -- Returns 'red'",
          "SELECT arrayElement(['dog', 'cat', 'bird'], 3);  -- Returns 'bird'"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (id int(10) not null unique);",
      "create table t2 (id int(10) not null primary key,val int(10) not null);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id Int32) ENGINE = MergeTree ORDER BY tuple();",
      "CREATE TABLE t2 (id Int32, val Int32) ENGINE = MergeTree ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_22_0",
    "database_name": "clickhouse_22_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT LEAST(CAST('01-01-01' AS DATETIME), '01-01:02'); -- LEAST",
    "target_query": "SELECT least(toDateTime('2001-01-01 00:00:00'), toDateTime('2001-01-01 00:01:02'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the smallest non-null value among arguments. NULLs are ignored unless all arguments are NULL. Use ifNull() when explicit NULL handling is needed.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(toDate('2024-01-01'), toDate('2023-12-31'));",
          "SELECT ifNull(least(NULL, 2), NULL);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_22_1",
    "database_name": "clickhouse_22_1",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT LEAST(CAST('2001-12-10' AS DATE), '2001-12/11'); -- LEAST",
    "target_query": "SELECT least(toDate('2001-12-10'), toDate('2001-12-11'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the smallest non-null value among arguments. NULLs are ignored unless all arguments are NULL. Use ifNull() when explicit NULL handling is needed.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(toDate('2024-01-01'), toDate('2023-12-31'));",
          "SELECT ifNull(least(NULL, 2), NULL);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_22_2",
    "database_name": "clickhouse_22_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT LEAST(CAST('10:11:12' AS TIME), '10:11:13 '); -- LEAST",
    "target_query": "SELECT least(toTime(toDateTime(concat('2025-05-21 ', '10:11:12'))), toTime(toDateTime(concat('2025-05-21 ', '10:11:13'))));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the smallest non-null value among arguments. NULLs are ignored unless all arguments are NULL. Use ifNull() when explicit NULL handling is needed.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(toDate('2024-01-01'), toDate('2023-12-31'));",
          "SELECT ifNull(least(NULL, 2), NULL);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_23_0",
    "database_name": "clickhouse_23_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select unix_timestamp(utc_timestamp())-unix_timestamp(current_timestamp()); -- UNIX_TIMESTAMP, UTC_TIMESTAMP, CURRENT_TIMESTAMP",
    "target_query": "SELECT toUnixTimestamp(now('UTC')) - toUnixTimestamp(now());",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP",
      "UTC_TIMESTAMP",
      "CURRENT_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      },
      {
        "expression": "UTC_TIMESTAMP()",
        "description": "Returns the current UTC date and time as a DATETIME value.",
        "examples": [
          "SELECT UTC_TIMESTAMP();",
          "SELECT YEAR(UTC_TIMESTAMP());",
          "SELECT UNIX_TIMESTAMP(UTC_TIMESTAMP());"
        ]
      },
      {
        "expression": "CURRENT_TIMESTAMP(6)",
        "description": "Returns the current date and time, with precision up to microseconds.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP(6);",
          "SELECT CURRENT_TIMESTAMP(6) = LOCALTIMESTAMP(6);",
          "SELECT CURRENT_TIMESTAMP(6) > '2025-01-01 00:00:00.000000';"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp(timestamp)",
        "description": "Converts a DateTime string or value to a Unix timestamp (seconds since 1970-01-01 UTC).",
        "examples": [
          "SELECT toUnixTimestamp(now());",
          "SELECT toUnixTimestamp('2015-11-13 23:59:59+02:00');",
          "SELECT toUnixTimestamp('2038-01-19 04:14:07');"
        ]
      },
      {
        "expression": "now('UTC')",
        "description": "Returns the current UTC timestamp using ClickHouse's timezone-aware function.",
        "examples": [
          "SELECT now('UTC');",
          "SELECT toYear(now('UTC'));",
          "SELECT toUnixTimestamp(now('UTC'));"
        ]
      },
      {
        "expression": "now()",
        "description": "Returns the current date and time, with precision up to seconds. No microsecond precision.",
        "examples": [
          "SELECT now();",
          "SELECT now() = toDateTime('2025-05-06 12:34:56');",
          "SELECT now() > toDateTime('2025-01-01 00:00:00');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_23_3",
    "database_name": "clickhouse_23_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "insert into t1 (i, ts) values(unix_timestamp('2003-03-01 00:00:00'),'2003-03-01 00:00:00'); -- UNIX_TIMESTAMP",
    "target_query": "INSERT INTO t1 (i, ts) VALUES(toUnixTimestamp('2003-03-01 00:00:00'), '2003-03-01 00:00:00');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp(timestamp)",
        "description": "Converts a DateTime string or value to a Unix timestamp (seconds since 1970-01-01 UTC).",
        "examples": [
          "SELECT toUnixTimestamp(now());",
          "SELECT toUnixTimestamp('2015-11-13 23:59:59+02:00');",
          "SELECT toUnixTimestamp('2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (i int, ts timestamp);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (i Int32, ts DateTime) ENGINE = MergeTree() ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_23_4",
    "database_name": "clickhouse_23_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "insert into t1 (i, ts) values(unix_timestamp('2003-03-30 01:59:59'),'2003-03-30 01:59:59'),(unix_timestamp('2003-03-30 02:30:00'),'2003-03-30 02:30:00'),(unix_timestamp('2003-03-30 03:00:00'),'2003-03-30 03:00:00'); -- UNIX_TIMESTAMP",
    "target_query": "INSERT INTO t1 (i, ts) VALUES(toUnixTimestamp('2003-03-30 01:59:59'), '2003-03-30 01:59:59'), (toUnixTimestamp('2003-03-30 02:30:00'), '2003-03-30 02:30:00'), (toUnixTimestamp('2003-03-30 03:00:00'), '2003-03-30 03:00:00');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp(timestamp)",
        "description": "Converts a DateTime string or value to a Unix timestamp (seconds since 1970-01-01 UTC).",
        "examples": [
          "SELECT toUnixTimestamp(now());",
          "SELECT toUnixTimestamp('2015-11-13 23:59:59+02:00');",
          "SELECT toUnixTimestamp('2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (i int, ts timestamp);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (i Int32, ts DateTime) ENGINE = MergeTree() ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_23_5",
    "database_name": "clickhouse_23_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "insert into t1 (i, ts) values(unix_timestamp(20030330015959),20030330015959),(unix_timestamp(20030330023000),20030330023000),(unix_timestamp(20030330030000),20030330030000); -- UNIX_TIMESTAMP",
    "target_query": "INSERT INTO t1 (i, ts) VALUES(toUnixTimestamp('2003-03-30 01:59:59'), '2003-03-30 01:59:59'), (toUnixTimestamp('2003-03-30 02:30:00'), '2003-03-30 02:30:00'), (toUnixTimestamp('2003-03-30 03:00:00'), '2003-03-30 03:00:00');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp(timestamp)",
        "description": "Converts a DateTime string or value to a Unix timestamp (seconds since 1970-01-01 UTC).",
        "examples": [
          "SELECT toUnixTimestamp(now());",
          "SELECT toUnixTimestamp('2015-11-13 23:59:59+02:00');",
          "SELECT toUnixTimestamp('2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (i int, ts timestamp);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (i Int32, ts DateTime) ENGINE = MergeTree() ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_23_6",
    "database_name": "clickhouse_23_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "insert into t1 (i, ts) values(unix_timestamp('2003-05-01 00:00:00'),'2003-05-01 00:00:00'); -- UNIX_TIMESTAMP",
    "target_query": "INSERT INTO t1 (i, ts) VALUES(toUnixTimestamp('2003-05-01 00:00:00'), '2003-05-01 00:00:00');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp(timestamp)",
        "description": "Converts a DateTime string or value to a Unix timestamp (seconds since 1970-01-01 UTC).",
        "examples": [
          "SELECT toUnixTimestamp(now());",
          "SELECT toUnixTimestamp('2015-11-13 23:59:59+02:00');",
          "SELECT toUnixTimestamp('2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (i int, ts timestamp);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (i Int32, ts DateTime) ENGINE = MergeTree() ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_23_7",
    "database_name": "clickhouse_23_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "insert into t1 (i, ts) values(unix_timestamp('2003-10-26 01:00:00'),'2003-10-26 01:00:00'),(unix_timestamp('2003-10-26 02:00:00'),'2003-10-26 02:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'),(unix_timestamp('2003-10-26 04:00:00'),'2003-10-26 04:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'); -- UNIX_TIMESTAMP",
    "target_query": "INSERT INTO t1 (i, ts) VALUES(toUnixTimestamp('2003-10-26 01:00:00'), '2003-10-26 01:00:00'), (toUnixTimestamp('2003-10-26 02:00:00'), '2003-10-26 02:00:00'), (toUnixTimestamp('2003-10-26 02:59:59'), '2003-10-26 02:59:59'), (toUnixTimestamp('2003-10-26 04:00:00'), '2003-10-26 04:00:00'), (toUnixTimestamp('2003-10-26 02:59:59'), '2003-10-26 02:59:59');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp(timestamp)",
        "description": "Converts a DateTime string or value to a Unix timestamp (seconds since 1970-01-01 UTC).",
        "examples": [
          "SELECT toUnixTimestamp(now());",
          "SELECT toUnixTimestamp('2015-11-13 23:59:59+02:00');",
          "SELECT toUnixTimestamp('2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (i int, ts timestamp);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (i Int32, ts DateTime) ENGINE = MergeTree() ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_23_10",
    "database_name": "clickhouse_23_10",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select from_unixtime(362793609); -- FROM_UNIXTIME",
    "target_query": "SELECT FROM_UNIXTIME(362793609);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FROM_UNIXTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
        "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
          "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "FROM_UNIXTIME(unix_timestamp) or formatDateTime(unix_timestamp, format)",
        "description": "Converts a Unix timestamp to a DateTime. Can use formatDateTime to specify a formatted string output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT formatDateTime(1672531200, '%Y-%m-%d %H:%M:%S');",
          "SELECT id, IF(isNull(created), '-', formatDateTime(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_23_12",
    "database_name": "clickhouse_23_12",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "insert into t1 (ts) values (now()); -- NOW",
    "target_query": "INSERT INTO t1 (ts) VALUES (now());",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "now()",
        "description": "ClickHouse uses the now() function to return the current date and time, which is equivalent to MySQL's NOW() function.",
        "examples": [
          "SELECT now();",
          "CREATE TABLE t12 AS SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > now()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (now());"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (ts timestamp);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (ts DateTime) ENGINE = MergeTree() ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_23_15",
    "database_name": "clickhouse_23_15",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 VALUES('2003-03-30 01:59:59', 'Before the gap'),('2003-03-30 02:30:00', 'Inside the gap'),('2003-03-30 03:00:00',  'After the gap'); -- UNIX_TIMESTAMP",
    "target_query": "INSERT INTO t1 VALUES('2003-03-30 01:59:59', 'Before the gap'), ('2003-03-30 02:30:00', 'Inside the gap'), ('2003-03-30 03:00:00', 'After the gap');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp(timestamp)",
        "description": "Converts a DateTime string or value to a Unix timestamp (seconds since 1970-01-01 UTC).",
        "examples": [
          "SELECT toUnixTimestamp(now());",
          "SELECT toUnixTimestamp('2015-11-13 23:59:59+02:00');",
          "SELECT toUnixTimestamp('2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a TIMESTAMP, b VARCHAR(30));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a DateTime, b String) ENGINE = MergeTree() ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_23_18",
    "database_name": "clickhouse_23_18",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT UNIX_TIMESTAMP('2003-03-30 01:59:59'), 'Before the gap' AS b; -- UNIX_TIMESTAMP",
    "target_query": "SELECT toUnixTimestamp('2003-03-30 01:59:59'), 'Before the gap' AS b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp(timestamp)",
        "description": "Converts a DateTime string or value to a Unix timestamp (seconds since 1970-01-01 UTC).",
        "examples": [
          "SELECT toUnixTimestamp(now());",
          "SELECT toUnixTimestamp('2015-11-13 23:59:59+02:00');",
          "SELECT toUnixTimestamp('2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_23_19",
    "database_name": "clickhouse_23_19",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT UNIX_TIMESTAMP('2003-03-30 02:30:00'), 'Inside the gap' AS b; -- UNIX_TIMESTAMP",
    "target_query": "SELECT toUnixTimestamp('2003-03-30 02:30:00'), 'Inside the gap' AS b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp(timestamp)",
        "description": "Converts a DateTime string or value to a Unix timestamp (seconds since 1970-01-01 UTC).",
        "examples": [
          "SELECT toUnixTimestamp(now());",
          "SELECT toUnixTimestamp('2015-11-13 23:59:59+02:00');",
          "SELECT toUnixTimestamp('2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_23_20",
    "database_name": "clickhouse_23_20",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT UNIX_TIMESTAMP('2003-03-30 03:00:00'), 'After the gap' AS b; -- UNIX_TIMESTAMP",
    "target_query": "SELECT toUnixTimestamp('2003-03-30 03:00:00'), 'After the gap' AS b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp(timestamp)",
        "description": "Converts a DateTime string or value to a Unix timestamp (seconds since 1970-01-01 UTC).",
        "examples": [
          "SELECT toUnixTimestamp(now());",
          "SELECT toUnixTimestamp('2015-11-13 23:59:59+02:00');",
          "SELECT toUnixTimestamp('2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_23_21",
    "database_name": "clickhouse_23_21",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT FROM_UNIXTIME(0); -- FROM_UNIXTIME",
    "target_query": "SELECT FROM_UNIXTIME(0);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FROM_UNIXTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
        "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
          "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "FROM_UNIXTIME(unix_timestamp) or formatDateTime(unix_timestamp, format)",
        "description": "Converts a Unix timestamp to a DateTime. Can use formatDateTime to specify a formatted string output.",
        "examples": [
          "SELECT FROM_UNIXTIME(1672531200);",
          "SELECT formatDateTime(1672531200, '%Y-%m-%d %H:%M:%S');",
          "SELECT id, IF(isNull(created), '-', formatDateTime(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_23_22",
    "database_name": "clickhouse_23_22",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT UNIX_TIMESTAMP(\"1969-12-31 15:59:59\"); -- UNIX_TIMESTAMP",
    "target_query": "SELECT toUnixTimestamp('1969-12-31 15:59:59');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp(timestamp)",
        "description": "Converts a DateTime string or value to a Unix timestamp (seconds since 1970-01-01 UTC).",
        "examples": [
          "SELECT toUnixTimestamp(now());",
          "SELECT toUnixTimestamp('2015-11-13 23:59:59+02:00');",
          "SELECT toUnixTimestamp('2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_23_23",
    "database_name": "clickhouse_23_23",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT UNIX_TIMESTAMP(\"1969-12-31 16:00:00\"); -- UNIX_TIMESTAMP",
    "target_query": "SELECT toUnixTimestamp('1969-12-31 16:00:00');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp(timestamp)",
        "description": "Converts a DateTime string or value to a Unix timestamp (seconds since 1970-01-01 UTC).",
        "examples": [
          "SELECT toUnixTimestamp(now());",
          "SELECT toUnixTimestamp('2015-11-13 23:59:59+02:00');",
          "SELECT toUnixTimestamp('2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_23_24",
    "database_name": "clickhouse_23_24",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT UNIX_TIMESTAMP(\"1969-12-31 16:00:01\"); -- UNIX_TIMESTAMP",
    "target_query": "SELECT toUnixTimestamp('1969-12-31 16:00:01');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp(timestamp)",
        "description": "Converts a DateTime string or value to a Unix timestamp (seconds since 1970-01-01 UTC).",
        "examples": [
          "SELECT toUnixTimestamp(now());",
          "SELECT toUnixTimestamp('2015-11-13 23:59:59+02:00');",
          "SELECT toUnixTimestamp('2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_23_25",
    "database_name": "clickhouse_23_25",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT UNIX_TIMESTAMP(\"1970-01-01 00:00:01\"); -- UNIX_TIMESTAMP",
    "target_query": "SELECT toUnixTimestamp('1970-01-01 00:00:01');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp(timestamp)",
        "description": "Converts a DateTime string or value to a Unix timestamp (seconds since 1970-01-01 UTC).",
        "examples": [
          "SELECT toUnixTimestamp(now());",
          "SELECT toUnixTimestamp('2015-11-13 23:59:59+02:00');",
          "SELECT toUnixTimestamp('2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_23_26",
    "database_name": "clickhouse_23_26",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT UNIX_TIMESTAMP(\"2022-01-01 16:00:01\"); -- UNIX_TIMESTAMP",
    "target_query": "SELECT toUnixTimestamp('2022-01-01 16:00:01');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp(timestamp)",
        "description": "Converts a DateTime string or value to a Unix timestamp (seconds since 1970-01-01 UTC).",
        "examples": [
          "SELECT toUnixTimestamp(now());",
          "SELECT toUnixTimestamp('2015-11-13 23:59:59+02:00');",
          "SELECT toUnixTimestamp('2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_24_3",
    "database_name": "clickhouse_24_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select hex(a) from t1; -- HEX",
    "target_query": "SELECT HEX(a) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a bit(64));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a UInt64) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_24_7",
    "database_name": "clickhouse_24_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select hex(a) from t1; -- HEX",
    "target_query": "SELECT HEX(a) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a bit);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a UInt8) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_24_11",
    "database_name": "clickhouse_24_11",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select hex(min(a)) from t1; -- HEX, MIN",
    "target_query": "SELECT HEX(min(a)) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "MIN"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a bit(7), b bit(9));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a UInt8, b UInt8) ENGINE = MergeTree ORDER BY (a, b);"
    ]
  },
  {
    "sql_id": "clickhouse_24_12",
    "database_name": "clickhouse_24_12",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select hex(min(b)) from t1; -- HEX, MIN",
    "target_query": "SELECT HEX(min(b)) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "MIN"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a bit(7), b bit(9));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a UInt8, b UInt8) ENGINE = MergeTree ORDER BY (a, b);"
    ]
  },
  {
    "sql_id": "clickhouse_24_13",
    "database_name": "clickhouse_24_13",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select hex(min(a)), hex(max(a)), hex(min(b)), hex(max(b)) from t1; -- HEX, MIN, MAX",
    "target_query": "SELECT HEX(min(a)), HEX(max(a)), HEX(min(b)), HEX(max(b)) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "MIN",
      "MAX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      },
      {
        "expression": "MAX(expr)",
        "description": "Returns the maximum value of the expression in an aggregation context.",
        "examples": [
          "SELECT MAX(10), MAX(5), MAX(20);",
          "SELECT MAX('apple'), MAX('banana'), MAX('pear');",
          "SELECT MAX(ABS(-5)), MAX(ABS(3));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      },
      {
        "expression": "max(expr)",
        "description": "Computes the maximum of values in an aggregation context.",
        "examples": [
          "SELECT max(11), max(6), max(20);",
          "SELECT max('alpha'), max('beta'), max('gamma');",
          "SELECT max(abs(-9)), max(abs(4));"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a bit(7), b bit(9));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a UInt8, b UInt8) ENGINE = MergeTree ORDER BY (a, b);"
    ]
  },
  {
    "sql_id": "clickhouse_24_17",
    "database_name": "clickhouse_24_17",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select hex(min(b)) from t1 where a = 4; -- HEX, MIN",
    "target_query": "SELECT HEX(min(b)) FROM t1 WHERE a = 4;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "MIN"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a int not null, b bit, c bit(9));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a Int32 NOT NULL, b UInt8, c UInt8) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_24_18",
    "database_name": "clickhouse_24_18",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select hex(min(c)) from t1 where a = 4 and b = 0; -- HEX, MIN",
    "target_query": "SELECT HEX(min(c)) FROM t1 WHERE a = 4 AND b = 0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "MIN"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a int not null, b bit, c bit(9));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a Int32 NOT NULL, b UInt8, c UInt8) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_24_19",
    "database_name": "clickhouse_24_19",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select hex(max(b)) from t1; -- HEX",
    "target_query": "SELECT HEX(max(b)) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a int not null, b bit, c bit(9));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a Int32 NOT NULL, b UInt8, c UInt8) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_24_27",
    "database_name": "clickhouse_24_27",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT HEX(GROUP_CONCAT(DISTINCT b)) FROM t1 GROUP BY a; -- HEX, GROUP_CONCAT",
    "target_query": "SELECT HEX(arrayStringConcat(groupArray(DISTINCT b), ',')) FROM t1 GROUP BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "GROUP_CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
        "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "groupArray(X)arrayStringConcat(groupArray(X), Y)",
        "description": "In ClickHouse, the equivalent of group_concat(X) is achieved using groupArray(X), which collects values into an array. To concatenate the array elements into a string with a separator, use arrayStringConcat(groupArray(X), Y). If Y is omitted, the default separator is an empty string.",
        "examples": [
          "SELECT arrayStringConcat(groupArray(name), ', ') FROM students; -- Returns a comma-separated list of names",
          "SELECT arrayStringConcat(groupArray(name), ' | ') FROM students; -- Returns names separated by '|'"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a INT, b BIT(2));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a Int32, b UInt8) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_25_3",
    "database_name": "clickhouse_25_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT HEX(b), i2 FROM t1 WHERE (i2>=100 AND i2<201) AND b=TRUE; -- HEX",
    "target_query": "SELECT hex(b),i2 FROM t1 WHERE (i2>=100 AND i2<201) AND b=1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (b BIT NOT NULL, i2 INTEGER NOT NULL, s VARCHAR(255) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (b UInt8,i2 INTEGER,s VARCHAR(255)) ENGINE = MergeTree ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_25_7",
    "database_name": "clickhouse_25_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT HEX(b1), i2 FROM t2 WHERE (i2>=100 AND i2<201) AND b1=TRUE; -- HEX",
    "target_query": "SELECT hex(b1),i2 FROM t2 WHERE (i2>=100 AND i2<201) AND b1=1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 (b1 BIT NOT NULL, b2 BIT NOT NULL, i2 INTEGER NOT NULL,s VARCHAR(255) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (b1 UInt8,b2 UInt8,i2 INTEGER,s VARCHAR(255)) ENGINE = MergeTree ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_25_8",
    "database_name": "clickhouse_25_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT HEX(b2), i2 FROM t2 WHERE (i2>=100 AND i2<201) AND b2=FALSE; -- HEX",
    "target_query": "SELECT hex(b2),i2 FROM t2 WHERE (i2>=100 AND i2<201) AND b2=0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 (b1 BIT NOT NULL, b2 BIT NOT NULL, i2 INTEGER NOT NULL,s VARCHAR(255) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (b1 UInt8,b2 UInt8,i2 INTEGER,s VARCHAR(255)) ENGINE = MergeTree ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_25_13",
    "database_name": "clickhouse_25_13",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT HEX(GROUP_CONCAT(DISTINCT b)) FROM t1 GROUP BY a; -- HEX, GROUP_CONCAT",
    "target_query": "SELECT hex(arrayStringConcat(groupArray(DISTINCT b),',')) FROM t1 GROUP BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "GROUP_CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
        "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "groupArray(X)arrayStringConcat(groupArray(X), Y)",
        "description": "In ClickHouse, the equivalent of group_concat(X) is achieved using groupArray(X), which collects values into an array. To concatenate the array elements into a string with a separator, use arrayStringConcat(groupArray(X), Y). If Y is omitted, the default separator is an empty string.",
        "examples": [
          "SELECT arrayStringConcat(groupArray(name), ', ') FROM students; -- Returns a comma-separated list of names",
          "SELECT arrayStringConcat(groupArray(name), ' | ') FROM students; -- Returns names separated by '|'"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a INT, b BIT(2));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT,b String) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_25_15",
    "database_name": "clickhouse_25_15",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT HEX(t2.b) FROM t2; -- HEX",
    "target_query": "SELECT hex(b) FROM t2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a INT, b BIT(2));",
      "CREATE TABLE t2 AS SELECT DISTINCT b FROM t1;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT,b String) ENGINE = MergeTree ORDER BY a;",
      "CREATE TABLE t2 ENGINE = MergeTree ORDER BY tuple() AS SELECT DISTINCT b FROM t1 ;"
    ]
  },
  {
    "sql_id": "clickhouse_25_16",
    "database_name": "clickhouse_25_16",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT a, HEX(b) FROM t1 ORDER BY b; -- HEX",
    "target_query": "SELECT a,hex(b) FROM t1 ORDER BY b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a INT, b BIT(2));",
      "CREATE TABLE t2 AS SELECT DISTINCT b FROM t1;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT,b String) ENGINE = MergeTree ORDER BY a;",
      "CREATE TABLE t2 ENGINE = MergeTree ORDER BY tuple() AS SELECT DISTINCT b FROM t1 ;"
    ]
  },
  {
    "sql_id": "clickhouse_26_3",
    "database_name": "clickhouse_26_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select hex(a) from t1 order by a; -- HEX",
    "target_query": "SELECT hex(a) FROM t1 ORDER BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE table t1 (a blob);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a String) ENGINE = MergeTree() ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_26_4",
    "database_name": "clickhouse_26_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select hex(concat(a,'\\\\0')) as b from t1 order by concat(a,'\\\\0'); -- HEX, CONCAT",
    "target_query": "SELECT hex(concat(a,'\\\\0')) AS b FROM t1 ORDER BY concat(a,'\\\\0');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE table t1 (a blob);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a String) ENGINE = MergeTree() ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_26_6",
    "database_name": "clickhouse_26_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select hex(a) from t1 order by a; -- HEX",
    "target_query": "SELECT hex(a) FROM t1 ORDER BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE table t1 (a blob);",
      "alter table t1 modify a varbinary(5);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a String) ENGINE = MergeTree() ORDER BY tuple();",
      "ALTER TABLE t1 ALTER COLUMN a TYPE String;"
    ]
  },
  {
    "sql_id": "clickhouse_26_10",
    "database_name": "clickhouse_26_10",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t (c) VALUES (REPEAT('3',65535)); -- REPEAT",
    "target_query": "INSERT INTO t (c) VALUES (REPEAT('3',65535));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t (c TEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t (c String) ENGINE = MergeTree() ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_26_11",
    "database_name": "clickhouse_26_11",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT LENGTH(c), CHAR_LENGTH(c) FROM t; -- LENGTH, CHAR_LENGTH",
    "target_query": "SELECT LENGTH(c), lengthUTF8(c) FROM t;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH",
      "CHAR_LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      },
      {
        "expression": "CHAR_LENGTH(expr)",
        "description": "Returns the number of characters in the string, not bytes.",
        "examples": [
          "SELECT CHAR_LENGTH('abc');",
          "SELECT CHAR_LENGTH('你好');",
          "SELECT CHAR_LENGTH('a你b好c');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      },
      {
        "expression": "lengthUTF8(expr)",
        "description": "Returns the number of characters in a UTF-8 encoded string.",
        "examples": [
          "SELECT lengthUTF8('abc');",
          "SELECT lengthUTF8('你好');",
          "SELECT lengthUTF8('a你b好c');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t (c TEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t (c String) ENGINE = MergeTree() ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_26_16",
    "database_name": "clickhouse_26_16",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT LENGTH(c) FROM t2; -- LENGTH",
    "target_query": "SELECT LENGTH(c) FROM t2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2(id INT NOT NULL, c TEXT NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2(id INT NOT NULL, c String NOT NULL) ENGINE = MergeTree() ORDER BY id;"
    ]
  },
  {
    "sql_id": "clickhouse_27_0",
    "database_name": "clickhouse_27_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select least(-1.1111111111111111111111111,- group_concat(1.7976931348623157E+308)) as foo; -- LEAST, GROUP_CONCAT",
    "target_query": "SELECT least(-1.1111111111111111111111111, -CAST(arrayStringConcat(groupArray(x), ',') AS Float64)) AS foo FROM (SELECT 1.7976931348623157E+308 AS x);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST",
      "GROUP_CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      },
      {
        "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
        "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the smallest non-null value among arguments. NULLs are ignored unless all arguments are NULL. Use ifNull() when explicit NULL handling is needed.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(toDate('2024-01-01'), toDate('2023-12-31'));",
          "SELECT ifNull(least(NULL, 2), NULL);"
        ]
      },
      {
        "expression": "groupArray(X)arrayStringConcat(groupArray(X), Y)",
        "description": "In ClickHouse, the equivalent of group_concat(X) is achieved using groupArray(X), which collects values into an array. To concatenate the array elements into a string with a separator, use arrayStringConcat(groupArray(X), Y). If Y is omitted, the default separator is an empty string.",
        "examples": [
          "SELECT arrayStringConcat(groupArray(name), ', ') FROM students; -- Returns a comma-separated list of names",
          "SELECT arrayStringConcat(groupArray(name), ' | ') FROM students; -- Returns names separated by '|'"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_28_7",
    "database_name": "clickhouse_28_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "insert into t1 values (now()); -- NOW",
    "target_query": "INSERT INTO t1 VALUES (now());",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "now()",
        "description": "ClickHouse uses the now() function to return the current date and time, which is equivalent to MySQL's NOW() function.",
        "examples": [
          "SELECT now();",
          "CREATE TABLE t12 AS SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > now()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (now());"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a timestamp NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a DateTime NOT NULL) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_28_8",
    "database_name": "clickhouse_28_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select date_format(a,\"%Y %y\"),year(a),year(now()) from t1; -- DATE_FORMAT, YEAR, NOW",
    "target_query": "SELECT formatDateTime(a, '%Y %y'), toYear(a), toYear(now()) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT",
      "YEAR",
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      },
      {
        "expression": "YEAR(date)",
        "description": "Extracts the year from a date or datetime and returns it as an integer.",
        "examples": [
          "SELECT YEAR('2023-04-10');",
          "SELECT YEAR(NOW());",
          "SELECT YEAR('2022-03-15');"
        ]
      },
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(date_expr, format_str)",
        "description": "Formats a DateTime value using ClickHouse-supported format specifiers. Input must be a DateTime or cast to one explicitly.",
        "examples": [
          "SELECT formatDateTime(toDateTime('2024-05-06 08:30:00'), '%Y/%m/%d');",
          "SELECT formatDateTime(toDateTime('2023-07-14 15:30:00'), '%Y-%m-%d %H:%M:%S');",
          "SELECT formatDateTime(toDateTime('2022-01-01 08:45:30'), '%H:%M:%S on %d/%m/%Y');"
        ]
      },
      {
        "expression": "toYear(date)",
        "description": "Extracts the year from a date or datetime and returns it as an integer.",
        "examples": [
          "SELECT toYear(toDate('2023-04-10'));",
          "SELECT toYear(NOW());",
          "SELECT toYear(toDate('2022-03-15'));"
        ]
      },
      {
        "expression": "now()",
        "description": "ClickHouse uses the now() function to return the current date and time, which is equivalent to MySQL's NOW() function.",
        "examples": [
          "SELECT now();",
          "CREATE TABLE t12 AS SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > now()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (now());"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a timestamp NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a DateTime NOT NULL) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_28_10",
    "database_name": "clickhouse_28_10",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT TIMESTAMP('2000-01-27','23:13:41') - TIMESTAMP('2003-05-16','23:53:29'); -- TIMESTAMP",
    "target_query": "SELECT toDateTime('2000-01-27 23:13:41') - toDateTime('2003-05-16 23:53:29');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
        "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
        "examples": [
          "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toDateTime('2023-06-15 10:30:45')",
        "description": "ClickHouse uses the toDateTime function to convert a date-time string to a DateTime type, without timezone support.",
        "examples": [
          "SELECT toDateTime('2023-06-15 10:30:45');",
          "SELECT toDateTime('2023-06-15 10:30:45');",
          "SELECT toDateTime('2023-06-15 10:30:45') > toDateTime('2023-06-14 10:30:45');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_30_5",
    "database_name": "clickhouse_30_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select length(v),length(c),length(e),length(t) from t1; -- LENGTH",
    "target_query": "SELECT length(v), length(c), length(e), length(t) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (v varchar(30), c char(3), e char(3), t text);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (v String, c FixedString(3), e FixedString(3), t String) ENGINE = MergeTree ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_30_8",
    "database_name": "clickhouse_30_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 VALUES(SUBSTR(f1, 1, 3)); -- SUBSTR",
    "target_query": "INSERT INTO t1 VALUES ('tes');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "SUBSTR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
        "description": "The substr(str,pos[,len]) function returns a substring from string str starting at position pos.\nIf len is specified, returns a substring len characters long starting at position pos.\nIf pos is positive, the position is counted from the start of the string.\nIf pos is negative, the position is counted from the end of the string.\nlen must be positive. If len is omitted, returns all characters to the end of the string.\nReturns NULL if any argument is NULL.",
        "examples": [
          "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
          "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "substring(str, start, length) | substring(str, start)",
        "description": "The substring(str, start, length) function extracts a substring from the given string str. It starts at position start and extracts length characters. If length is omitted, the function returns the substring from start to the end of the string. The first character in ClickHouse is indexed as 1, similar to SQLite. If start is negative, it counts from the end of the string.",
        "examples": [
          "SELECT substring('Hello World', 1, 5); -- Returns 'Hello'",
          "SELECT substring('Hello World', -5, 3); -- Returns 'Wor'"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(f1 VARCHAR(100) DEFAULT 'test');"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (f1 String) ENGINE = MergeTree ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_30_12",
    "database_name": "clickhouse_30_12",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT a,(a DIV 2) FROM t1 ORDER BY a; -- DIV",
    "target_query": "SELECT a, intDiv(toInt32(a), 2) FROM t1 ORDER BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DIV"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "a DIV b",
        "description": "Performs integer division between two numbers and returns the floor of the quotient.",
        "examples": [
          "SELECT 10 DIV 3;",
          "SELECT 5.8 DIV 2;",
          "SELECT 9 DIV 4 + 1;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "intDiv(a, b)",
        "description": "Returns integer division result by discarding any fractional part.",
        "examples": [
          "SELECT intDiv(10, 3);",
          "SELECT intDiv(6, 2);",
          "SELECT intDiv(9, 4) + 1;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a CHAR(2));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a FixedString(2)) ENGINE = MergeTree ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_31_2",
    "database_name": "clickhouse_31_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "insert into t1 values (now()); -- NOW",
    "target_query": "INSERT INTO t1 VALUES (toYear(now()));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "now()",
        "description": "ClickHouse uses the now() function to return the current date and time, which is equivalent to MySQL's NOW() function.",
        "examples": [
          "SELECT now();",
          "CREATE TABLE t12 AS SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > now()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (now());"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (y year);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (y Int16) ENGINE = MergeTree ORDER BY y;"
    ]
  },
  {
    "sql_id": "clickhouse_31_3",
    "database_name": "clickhouse_31_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select if(y = now(), 1, 0) from t1; -- IF, NOW",
    "target_query": "SELECT IF(y = toYear(now()), 1, 0) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF",
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      },
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "ClickHouse supports the `IF` function, which works similarly to MySQL. It evaluates a condition and returns different values based on whether the condition is true or false.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      },
      {
        "expression": "now()",
        "description": "ClickHouse uses the now() function to return the current date and time, which is equivalent to MySQL's NOW() function.",
        "examples": [
          "SELECT now();",
          "CREATE TABLE t12 AS SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > now()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (now());"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (y year);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (y Int16) ENGINE = MergeTree ORDER BY y;"
    ]
  },
  {
    "sql_id": "clickhouse_31_9",
    "database_name": "clickhouse_31_9",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT * FROM t4 WHERE yyyy = NOW(); -- NOW",
    "target_query": "SELECT * FROM t4 WHERE yyyy = toYear(now());",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "now()",
        "description": "ClickHouse uses the now() function to return the current date and time, which is equivalent to MySQL's NOW() function.",
        "examples": [
          "SELECT now();",
          "CREATE TABLE t12 AS SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > now()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (now());"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t4(yyyy YEAR, c4 CHAR(4));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t4(yyyy Int16, c4 String) ENGINE = MergeTree ORDER BY yyyy;"
    ]
  },
  {
    "sql_id": "clickhouse_31_19",
    "database_name": "clickhouse_31_19",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT TIMESTAMPDIFF(QUARTER, LEAST(y1, y2), dbl)FROM t1; -- TIMESTAMPDIFF, LEAST",
    "target_query": "SELECT dateDiff('quarter', toDate(concat(toString(least(y1, y2)), '-01-01')), d) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMPDIFF",
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMPDIFF(unit, datetime1, datetime2)",
        "description": "Returns the difference between two datetime values in the specified unit.",
        "examples": [
          "SELECT TIMESTAMPDIFF(YEAR, '2001-01-01', '2005-01-01');  -- 4",
          "SELECT TIMESTAMPDIFF(MONTH, '2020-01-01', '2020-03-01');  -- 2",
          "SELECT TIMESTAMPDIFF(DAY, '2020-01-01', '2020-01-31');    -- 30"
        ]
      },
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "dateDiff(unit, date1, date2)",
        "description": "Returns the number of unit intervals between two dates. The result is negative if the second date is earlier than the first.",
        "examples": [
          "SELECT dateDiff('year', toDate('2001-01-01'), toDate('2005-01-01'));  -- 4",
          "SELECT dateDiff('month', toDate('2020-01-01'), toDate('2020-03-01'));  -- 2",
          "SELECT dateDiff('day', toDate('2020-01-01'), toDate('2020-01-31'));    -- 30"
        ]
      },
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the smallest non-null value among arguments. NULLs are ignored unless all arguments are NULL. Use ifNull() when explicit NULL handling is needed.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(toDate('2024-01-01'), toDate('2023-12-31'));",
          "SELECT ifNull(least(NULL, 2), NULL);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (d DATE DEFAULT NULL,y1 YEAR DEFAULT NULL,y2 YEAR DEFAULT NULL,dbl DOUBLE DEFAULT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (d Date, y1 Nullable(Int16) DEFAULT NULL, y2 Nullable(Int16) DEFAULT NULL, dbl Nullable(Float64) DEFAULT NULL) ENGINE = MergeTree ORDER BY d;"
    ]
  },
  {
    "sql_id": "clickhouse_31_20",
    "database_name": "clickhouse_31_20",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT HOUR(GREATEST(y1, y2))FROM t1; -- HOUR, GREATEST",
    "target_query": "SELECT toHour(now()) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HOUR",
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HOUR(expr)",
        "description": "Extracts the hour (0–23) from a time or datetime expression.",
        "examples": [
          "SELECT HOUR('18:45:30');",
          "SELECT HOUR('2023-10-01 08:15:00');",
          "SELECT HOUR(CURRENT_TIMESTAMP);"
        ]
      },
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toHour(expr)",
        "description": "Extracts the hour from a DateTime expression.",
        "examples": [
          "SELECT toHour(toDateTime('2023-10-01 18:45:30'));",
          "SELECT toHour(now());"
        ]
      },
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (d DATE DEFAULT NULL,y1 YEAR DEFAULT NULL,y2 YEAR DEFAULT NULL,dbl DOUBLE DEFAULT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (d Date, y1 Nullable(Int16) DEFAULT NULL, y2 Nullable(Int16) DEFAULT NULL, dbl Nullable(Float64) DEFAULT NULL) ENGINE = MergeTree ORDER BY d;"
    ]
  },
  {
    "sql_id": "clickhouse_32_12",
    "database_name": "clickhouse_32_12",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT y, CONCAT('\"', c, '\"') FROM t1; -- CONCAT",
    "target_query": "SELECT y, concat('\"', c, '\"') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (y YEAR NOT NULL DEFAULT 0,i INT NOT NULL DEFAULT 0,c VARCHAR(20) NOT NULL DEFAULT '');"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (y Int16 NOT NULL, i Int32 NOT NULL, c String NOT NULL) ENGINE = MergeTree() ORDER BY y;"
    ]
  },
  {
    "sql_id": "clickhouse_33_3",
    "database_name": "clickhouse_33_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select hex(b) from t1 order by pk1; -- HEX",
    "target_query": "SELECT HEX(b) FROM t1 ORDER BY pk1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (pk1 int not null auto_increment primary key,b bit(64));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (pk1 Int32 NOT NULL, b FixedString(8)) ENGINE = MergeTree ORDER BY pk1;"
    ]
  },
  {
    "sql_id": "clickhouse_33_7",
    "database_name": "clickhouse_33_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select hex(b) from t1 order by pk1; -- HEX",
    "target_query": "SELECT HEX(b) FROM t1 ORDER BY pk1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (pk1 int not null auto_increment primary key,b bit(9));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (pk1 Int32 NOT NULL, b FixedString(1)) ENGINE = MergeTree ORDER BY pk1;"
    ]
  },
  {
    "sql_id": "clickhouse_34_8",
    "database_name": "clickhouse_34_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select concat(\"*\",name, \"*\") from t1 order by 1; -- CONCAT",
    "target_query": "SELECT concat('*', name, '*') FROM t1 ORDER BY 1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t2 (name char(20) not null, primary key (name));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (name String NOT NULL, PRIMARY KEY (name)) ENGINE = MergeTree ORDER BY (name);"
    ]
  },
  {
    "sql_id": "clickhouse_34_9",
    "database_name": "clickhouse_34_9",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select min(name),min(concat(\"*\",name,\"*\")),max(name),max(concat(\"*\",name,\"*\")) from t1; -- CONCAT",
    "target_query": "SELECT min(name), min(concat('*', name, '*')), max(name), max(concat('*', name, '*')) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t2 (name char(20) not null, primary key (name));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (name String NOT NULL, PRIMARY KEY (name)) ENGINE = MergeTree ORDER BY (name);"
    ]
  },
  {
    "sql_id": "clickhouse_34_14",
    "database_name": "clickhouse_34_14",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select concat(\"-\",a,\"-\",b,\"-\") from t1 where a=\"hello\"; -- CONCAT",
    "target_query": "SELECT concat('-', a, '-', b, '-') FROM t1 WHERE a = 'hello';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a char(10) not null, b char(10) not null);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a String NOT NULL, b String NOT NULL) ENGINE = MergeTree ORDER BY (a);"
    ]
  },
  {
    "sql_id": "clickhouse_34_16",
    "database_name": "clickhouse_34_16",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select concat(\"-\",a,\"-\",b,\"-\") from t1 where a=\"hello\"; -- CONCAT",
    "target_query": "SELECT concat('-', a, '-', b, '-') FROM t1 WHERE a = 'hello';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a char(10) not null, b char(10) not null);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a String NOT NULL, b String NOT NULL) ENGINE = MergeTree ORDER BY (a);"
    ]
  },
  {
    "sql_id": "clickhouse_34_20",
    "database_name": "clickhouse_34_20",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select hex(col1) from t1; -- HEX",
    "target_query": "SELECT HEX(col1) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (col1 binary(4));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (col1 FixedString(4)) ENGINE = MergeTree ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_34_22",
    "database_name": "clickhouse_34_22",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select hex(col1) from t1; -- HEX",
    "target_query": "SELECT HEX(col1) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (col1 binary(4));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (col1 FixedString(4)) ENGINE = MergeTree ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_34_24",
    "database_name": "clickhouse_34_24",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select hex(col1) from t1; -- HEX",
    "target_query": "SELECT HEX(col1) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (col1 binary(4));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (col1 FixedString(4)) ENGINE = MergeTree ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_35_2",
    "database_name": "clickhouse_35_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029087575'); -- UNHEX",
    "target_query": "INSERT INTO t1 VALUES (unhex('1F9480179366F2BF567E1C4B964C1EF029087575'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNHEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNHEX(str)",
        "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT HEX(UNHEX('4D7953514C'));",
          "SELECT UNHEX('48656C6C6F');",
          "SELECT UNHEX(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "unhex(str)",
        "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT hex(unhex('4D7953514C'));",
          "SELECT unhex('48656C6C6F');",
          "SELECT unhex(NULL);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a binary(20) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a String NOT NULL) ENGINE = MergeTree ORDER BY (a);"
    ]
  },
  {
    "sql_id": "clickhouse_35_3",
    "database_name": "clickhouse_35_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029082020'); -- UNHEX",
    "target_query": "INSERT INTO t1 VALUES (unhex('1F9480179366F2BF567E1C4B964C1EF029082020'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNHEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNHEX(str)",
        "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT HEX(UNHEX('4D7953514C'));",
          "SELECT UNHEX('48656C6C6F');",
          "SELECT UNHEX(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "unhex(str)",
        "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT hex(unhex('4D7953514C'));",
          "SELECT unhex('48656C6C6F');",
          "SELECT unhex(NULL);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a binary(20) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a String NOT NULL) ENGINE = MergeTree ORDER BY (a);"
    ]
  },
  {
    "sql_id": "clickhouse_35_4",
    "database_name": "clickhouse_35_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029080707'); -- UNHEX",
    "target_query": "INSERT INTO t1 VALUES (unhex('1F9480179366F2BF567E1C4B964C1EF029080707'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNHEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNHEX(str)",
        "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT HEX(UNHEX('4D7953514C'));",
          "SELECT UNHEX('48656C6C6F');",
          "SELECT UNHEX(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "unhex(str)",
        "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT hex(unhex('4D7953514C'));",
          "SELECT unhex('48656C6C6F');",
          "SELECT unhex(NULL);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a binary(20) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a String NOT NULL) ENGINE = MergeTree ORDER BY (a);"
    ]
  },
  {
    "sql_id": "clickhouse_35_5",
    "database_name": "clickhouse_35_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT hex(a) FROM t1 order by a; -- HEX",
    "target_query": "SELECT hex(a) FROM t1 ORDER BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a binary(20) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a String NOT NULL) ENGINE = MergeTree ORDER BY (a);"
    ]
  },
  {
    "sql_id": "clickhouse_35_6",
    "database_name": "clickhouse_35_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "EXPLAIN SELECT hex(a) FROM t1 order by a; -- HEX",
    "target_query": "EXPLAIN SELECT hex(a) FROM t1 ORDER BY a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a binary(20) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a String NOT NULL) ENGINE = MergeTree ORDER BY (a);"
    ]
  },
  {
    "sql_id": "clickhouse_35_7",
    "database_name": "clickhouse_35_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT hex(a) from t1 WHERE a=unhex('1F9480179366F2BF567E1C4B964C1EF029082020'); -- HEX, UNHEX",
    "target_query": "SELECT hex(a) FROM t1 WHERE a = unhex('1F9480179366F2BF567E1C4B964C1EF029082020');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "UNHEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "UNHEX(str)",
        "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT HEX(UNHEX('4D7953514C'));",
          "SELECT UNHEX('48656C6C6F');",
          "SELECT UNHEX(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "unhex(str)",
        "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT hex(unhex('4D7953514C'));",
          "SELECT unhex('48656C6C6F');",
          "SELECT unhex(NULL);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a binary(20) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a String NOT NULL) ENGINE = MergeTree ORDER BY (a);"
    ]
  },
  {
    "sql_id": "clickhouse_35_8",
    "database_name": "clickhouse_35_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT hex(a) from t1 WHERE a=unhex('1F9480179366F2BF567E1C4B964C1EF02908'); -- HEX, UNHEX",
    "target_query": "SELECT hex(a) FROM t1 WHERE a = unhex('1F9480179366F2BF567E1C4B964C1EF02908');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "UNHEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "UNHEX(str)",
        "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT HEX(UNHEX('4D7953514C'));",
          "SELECT UNHEX('48656C6C6F');",
          "SELECT UNHEX(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "unhex(str)",
        "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT hex(unhex('4D7953514C'));",
          "SELECT unhex('48656C6C6F');",
          "SELECT unhex(NULL);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a binary(20) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a String NOT NULL) ENGINE = MergeTree ORDER BY (a);"
    ]
  },
  {
    "sql_id": "clickhouse_36_0",
    "database_name": "clickhouse_36_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT IF(NULL AND 1, 1, 2), IF(1 AND NULL, 1, 2); -- IF",
    "target_query": "SELECT IF(NULL AND 1, 1, 2), IF(1 AND NULL, 1, 2);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "ClickHouse supports the `IF` function, which works similarly to MySQL. It evaluates a condition and returns different values based on whether the condition is true or false.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_36_4",
    "database_name": "clickhouse_36_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT * FROM t1 WHERE IF(a AND 1, 0, 1); -- IF",
    "target_query": "SELECT * FROM t1 WHERE IF(a AND 1, 0, 1);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "ClickHouse supports the `IF` function, which works similarly to MySQL. It evaluates a condition and returns different values based on whether the condition is true or false.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a Int32) ENGINE = MergeTree ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_36_5",
    "database_name": "clickhouse_36_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT * FROM t1 WHERE IF(1 AND a, 0, 1); -- IF",
    "target_query": "SELECT * FROM t1 WHERE IF(1 AND a, 0, 1);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "ClickHouse supports the `IF` function, which works similarly to MySQL. It evaluates a condition and returns different values based on whether the condition is true or false.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a Int32) ENGINE = MergeTree ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_36_9",
    "database_name": "clickhouse_36_9",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select ifnull(A, 'N') as A, ifnull(B, 'N') as B, ifnull(not A, 'N') as nA, ifnull(not B, 'N') as nB, ifnull(A and B, 'N') as AB, ifnull(not (A and B), 'N') as `n(AB)`, ifnull((not A or not B), 'N') as nAonB, ifnull(A or B, 'N') as AoB, ifnull(not(A or B), 'N') as `n(AoB)`, ifnull(not A and not B, 'N') as nAnB from t1; -- IFNULL",
    "target_query": "SELECT ifNull(a, 'N') AS A, ifNull(b, 'N') AS B, ifNull(NOT a, 'N') AS nA, ifNull(NOT b, 'N') AS nB, ifNull(a AND b, 'N') AS AB, ifNull(NOT (a AND b), 'N') AS \"n(AB)\", ifNull((NOT a OR NOT b), 'N') AS nAonB, ifNull(a OR b, 'N') AS AoB, ifNull(NOT(a OR b), 'N') AS \"n(AoB)\", ifNull(NOT a AND NOT b, 'N') AS nAnB FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "ifNull(expr1, expr2)",
        "description": "ClickHouse's ifNull is functionally equivalent to MySQL's IFNULL. It returns expr2 if expr1 is NULL; otherwise, it returns expr1.",
        "examples": [
          "SELECT ifNull(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT ifNull(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = ifNull(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a int, b int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a Int32, b Int32) ENGINE = MergeTree ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_36_10",
    "database_name": "clickhouse_36_10",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select ifnull(A=1, 'N') as A, ifnull(B=1, 'N') as B, ifnull(not (A=1), 'N') as nA, ifnull(not (B=1), 'N') as nB, ifnull((A=1) and (B=1), 'N') as AB, ifnull(not ((A=1) and (B=1)), 'N') as `n(AB)`, ifnull((not (A=1) or not (B=1)), 'N') as nAonB, ifnull((A=1) or (B=1), 'N') as AoB, ifnull(not((A=1) or (B=1)), 'N') as `n(AoB)`, ifnull(not (A=1) and not (B=1), 'N') as nAnB from t1; -- IFNULL",
    "target_query": "SELECT ifNull(a=1, 'N') AS A, ifNull(b=1, 'N') AS B, ifNull(NOT (a=1), 'N') AS nA, ifNull(NOT (b=1), 'N') AS nB, ifNull((a=1) AND (b=1), 'N') AS AB, ifNull(NOT ((a=1) AND (b=1)), 'N') AS \"n(AB)\", ifNull((NOT (a=1) OR NOT (b=1)), 'N') AS nAonB, ifNull((a=1) OR (b=1), 'N') AS AoB, ifNull(NOT((a=1) OR (b=1)), 'N') AS \"n(AoB)\", ifNull(NOT (a=1) AND NOT (b=1), 'N') AS nAnB FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "ifNull(expr1, expr2)",
        "description": "ClickHouse's ifNull is functionally equivalent to MySQL's IFNULL. It returns expr2 if expr1 is NULL; otherwise, it returns expr1.",
        "examples": [
          "SELECT ifNull(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT ifNull(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = ifNull(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a int, b int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a Int32, b Int32) ENGINE = MergeTree ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_37_0",
    "database_name": "clickhouse_37_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select CONVERT(\"2004-01-22 21:45:33\",DATE); -- CONVERT",
    "target_query": "SELECT (NULL IS NULL), (NULL IS NULL);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONVERT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONVERT(expression USING charset)",
        "description": "Converts data types or changes the character set.",
        "examples": [
          "SELECT CONVERT('Hello World' USING utf8);",
          "SELECT CONVERT(1234, CHAR);",
          "SELECT CONVERT(column_name USING latin1) FROM my_table;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CAST(expression AS target_type)",
        "description": "ClickHouse uses CAST for type conversion. No direct equivalent for CONVERT TO CHARACTER SET.",
        "examples": [
          "SELECT CAST('2021-12-31' AS Date);",
          "SELECT CAST(1234 AS String);",
          "SELECT CAST(column_name AS Date) FROM my_table;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_37_1",
    "database_name": "clickhouse_37_1",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select timediff(cast('2004-12-30 12:00:00' as time), '12:00:00'); -- TIMEDIFF",
    "target_query": "SELECT dateDiff('second', toDateTime('2004-12-30 12:00:00'), toDateTime('2004-12-30 12:00:00'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "dateDiff('second', toDateTime('2023-06-15 10:00:00'), toDateTime('2023-06-15 12:00:00'))",
        "description": "ClickHouse uses the dateDiff function to calculate the difference between two datetime values in various units.",
        "examples": [
          "SELECT dateDiff('second', toDateTime('2023-06-15 12:00:00'), toDateTime('2023-06-15 10:00:00'));",
          "SELECT dateDiff('second', now(), toDateTime('2023-06-15 10:00:00'));",
          "SELECT dateDiff('second', toDateTime('2023-06-15 12:00:00'), toDateTime('2023-06-15 10:00:00'));"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_37_2",
    "database_name": "clickhouse_37_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select timediff(cast('1 12:00:00' as time), '12:00:00'); -- TIMEDIFF",
    "target_query": "SELECT dateDiff('second', toDateTime('2025-01-01 12:00:00'), toDateTime('2025-01-01 00:12:00'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "dateDiff('second', toDateTime('2023-06-15 10:00:00'), toDateTime('2023-06-15 12:00:00'))",
        "description": "ClickHouse uses the dateDiff function to calculate the difference between two datetime values in various units.",
        "examples": [
          "SELECT dateDiff('second', toDateTime('2023-06-15 12:00:00'), toDateTime('2023-06-15 10:00:00'));",
          "SELECT dateDiff('second', now(), toDateTime('2023-06-15 10:00:00'));",
          "SELECT dateDiff('second', toDateTime('2023-06-15 12:00:00'), toDateTime('2023-06-15 10:00:00'));"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_37_3",
    "database_name": "clickhouse_37_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select cast(concat('12345','6789') as unsigned); -- CONCAT",
    "target_query": "SELECT CAST(concat('12345', '6789') AS UInt64);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_37_4",
    "database_name": "clickhouse_37_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select cast(concat('12345','6789') as signed); -- CONCAT",
    "target_query": "SELECT CAST(concat('12345', '6789') AS Int64);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_37_5",
    "database_name": "clickhouse_37_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select cast(repeat('1',9) as unsigned); -- REPEAT",
    "target_query": "SELECT CAST(repeat('1', 9) AS UInt64);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_37_6",
    "database_name": "clickhouse_37_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select cast(repeat('1',9) as signed); -- REPEAT",
    "target_query": "SELECT CAST(repeat('1', 9) AS Int64);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_37_7",
    "database_name": "clickhouse_37_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select isnull(date(NULL)), isnull(cast(NULL as DATE)); -- ISNULL, DATE",
    "target_query": "SELECT (NULL IS NULL), (NULL IS NULL);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ISNULL",
      "DATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ISNULL(expr)",
        "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
        "examples": [
          "SELECT ISNULL(NULL);",
          "SELECT ISNULL(5 + NULL);",
          "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
        ]
      },
      {
        "expression": "DATE()",
        "description": "In MySQL, the DATE function extracts the date part from a DATETIME or TIMESTAMP value.",
        "examples": [
          "SELECT DATE('2023-05-01 12:34:56') AS result;",
          "SELECT DATE(NOW()) AS current_date_result;",
          "SELECT DATE(CAST('2023-05-01' AS DATETIME)) AS date_from_datetime;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "expr IS NULL",
        "description": "Checks whether an expression is NULL.",
        "examples": [
          "SELECT NULL IS NULL;",
          "SELECT (number / NULL) IS NULL FROM numbers(1);",
          "SELECT IF(score IS NULL, 'N/A', toString(score)) FROM student_scores;"
        ]
      },
      {
        "expression": "toDate()",
        "description": "ClickHouse uses the toDate() function to convert a DATETIME or String to a DATE type.",
        "examples": [
          "SELECT toDate('2023-05-01 12:34:56') AS result;",
          "SELECT toDate(now()) AS current_date_result;",
          "SELECT toDate(CAST('2023-05-01' AS String)) AS date_from_datetime;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_37_8",
    "database_name": "clickhouse_37_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select hex(cast('a' as binary(2))); -- HEX",
    "target_query": "SELECT HEX(CAST('a' AS FixedString(2)));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_37_12",
    "database_name": "clickhouse_37_12",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT cast(date(d1) as signed) FROM t1; -- DATE",
    "target_query": "SELECT CAST(toDate(d1) AS Int64) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE()",
        "description": "In MySQL, the DATE function extracts the date part from a DATETIME or TIMESTAMP value.",
        "examples": [
          "SELECT DATE('2023-05-01 12:34:56') AS result;",
          "SELECT DATE(NOW()) AS current_date_result;",
          "SELECT DATE(CAST('2023-05-01' AS DATETIME)) AS date_from_datetime;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toDate()",
        "description": "ClickHouse uses the toDate() function to convert a DATETIME or String to a DATE type.",
        "examples": [
          "SELECT toDate('2023-05-01 12:34:56') AS result;",
          "SELECT toDate(now()) AS current_date_result;",
          "SELECT toDate(CAST('2023-05-01' AS String)) AS date_from_datetime;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (d1 datetime);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (d1 DateTime) ENGINE = MergeTree ORDER BY d1;"
    ]
  },
  {
    "sql_id": "clickhouse_37_16",
    "database_name": "clickhouse_37_16",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT HOUR(f1),MINUTE(f1),SECOND(f1) FROM t1; -- HOUR, MINUTE, SECOND",
    "target_query": "SELECT toHour(toDateTime(f1)), toMinute(toDateTime(f1)), (toUnixTimestamp(toDateTime(f1)) % 60) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HOUR",
      "MINUTE",
      "SECOND"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HOUR(expr)",
        "description": "Extracts the hour (0–23) from a time or datetime expression.",
        "examples": [
          "SELECT HOUR('18:45:30');",
          "SELECT HOUR('2023-10-01 08:15:00');",
          "SELECT HOUR(CURRENT_TIMESTAMP);"
        ]
      },
      {
        "expression": "MINUTE()",
        "description": "Extracts the minute part from a time or datetime value.",
        "examples": [
          "SELECT MINUTE('12:34:56');",
          "SELECT MINUTE('2025-01-01 10:30:00');",
          "SELECT MINUTE(NULL);"
        ]
      },
      {
        "expression": "SECOND(time)",
        "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
        "examples": [
          "SELECT SECOND('10:11:12');",
          "SELECT SECOND(4.99999999991e0);",
          "SELECT SECOND(CAST('2007-07-19' AS DATE));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toHour(expr)",
        "description": "Extracts the hour from a DateTime expression.",
        "examples": [
          "SELECT toHour(toDateTime('2023-10-01 18:45:30'));",
          "SELECT toHour(now());"
        ]
      },
      {
        "expression": "MINUTE()",
        "description": "Extracts the minute part from a datetime or timestamp value. Input should be in date or datetime type.",
        "examples": [
          "SELECT MINUTE(toDateTime('2025-01-01 12:34:56'));",
          "SELECT MINUTE(toDateTime('2025-01-01 10:30:00'));",
          "SELECT MINUTE(NULL);"
        ]
      },
      {
        "expression": "toUnixTimestamp(time) % 60",
        "description": "Extracts the second part from a TIME or DATETIME value by using Unix timestamp.",
        "examples": [
          "SELECT toUnixTimestamp(4.99999999991e0) % 60;",
          "SELECT toUnixTimestamp(toDateTime('2007-07-19 00:00:00')) % 60;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (f1 DATE);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (f1 Date) ENGINE = MergeTree ORDER BY f1;"
    ]
  },
  {
    "sql_id": "clickhouse_37_18",
    "database_name": "clickhouse_37_18",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT HOUR(CAST('2007-07-19' AS DATE)),MINUTE(CAST('2007-07-19' AS DATE)),SECOND(CAST('2007-07-19' AS DATE)); -- HOUR, MINUTE, SECOND",
    "target_query": "SELECT toHour(toDateTime('2007-07-19')), toMinute(toDateTime('2007-07-19')), (toUnixTimestamp(toDateTime('2007-07-19')) % 60);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HOUR",
      "MINUTE",
      "SECOND"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HOUR(expr)",
        "description": "Extracts the hour (0–23) from a time or datetime expression.",
        "examples": [
          "SELECT HOUR('18:45:30');",
          "SELECT HOUR('2023-10-01 08:15:00');",
          "SELECT HOUR(CURRENT_TIMESTAMP);"
        ]
      },
      {
        "expression": "MINUTE()",
        "description": "Extracts the minute part from a time or datetime value.",
        "examples": [
          "SELECT MINUTE('12:34:56');",
          "SELECT MINUTE('2025-01-01 10:30:00');",
          "SELECT MINUTE(NULL);"
        ]
      },
      {
        "expression": "SECOND(time)",
        "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
        "examples": [
          "SELECT SECOND('10:11:12');",
          "SELECT SECOND(4.99999999991e0);",
          "SELECT SECOND(CAST('2007-07-19' AS DATE));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toHour(expr)",
        "description": "Extracts the hour from a DateTime expression.",
        "examples": [
          "SELECT toHour(toDateTime('2023-10-01 18:45:30'));",
          "SELECT toHour(now());"
        ]
      },
      {
        "expression": "MINUTE()",
        "description": "Extracts the minute part from a datetime or timestamp value. Input should be in date or datetime type.",
        "examples": [
          "SELECT MINUTE(toDateTime('2025-01-01 12:34:56'));",
          "SELECT MINUTE(toDateTime('2025-01-01 10:30:00'));",
          "SELECT MINUTE(NULL);"
        ]
      },
      {
        "expression": "toUnixTimestamp(time) % 60",
        "description": "Extracts the second part from a TIME or DATETIME value by using Unix timestamp.",
        "examples": [
          "SELECT toUnixTimestamp(4.99999999991e0) % 60;",
          "SELECT toUnixTimestamp(toDateTime('2007-07-19 00:00:00')) % 60;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_37_19",
    "database_name": "clickhouse_37_19",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT HOUR(CAST(NULL AS DATE)),MINUTE(CAST(NULL AS DATE)),SECOND(CAST(NULL AS DATE)); -- HOUR, MINUTE, SECOND",
    "target_query": "SELECT toHour(NULL), toMinute(NULL), (toUnixTimestamp(NULL) % 60);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HOUR",
      "MINUTE",
      "SECOND"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HOUR(expr)",
        "description": "Extracts the hour (0–23) from a time or datetime expression.",
        "examples": [
          "SELECT HOUR('18:45:30');",
          "SELECT HOUR('2023-10-01 08:15:00');",
          "SELECT HOUR(CURRENT_TIMESTAMP);"
        ]
      },
      {
        "expression": "MINUTE()",
        "description": "Extracts the minute part from a time or datetime value.",
        "examples": [
          "SELECT MINUTE('12:34:56');",
          "SELECT MINUTE('2025-01-01 10:30:00');",
          "SELECT MINUTE(NULL);"
        ]
      },
      {
        "expression": "SECOND(time)",
        "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
        "examples": [
          "SELECT SECOND('10:11:12');",
          "SELECT SECOND(4.99999999991e0);",
          "SELECT SECOND(CAST('2007-07-19' AS DATE));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toHour(expr)",
        "description": "Extracts the hour from a DateTime expression.",
        "examples": [
          "SELECT toHour(toDateTime('2023-10-01 18:45:30'));",
          "SELECT toHour(now());"
        ]
      },
      {
        "expression": "MINUTE()",
        "description": "Extracts the minute part from a datetime or timestamp value. Input should be in date or datetime type.",
        "examples": [
          "SELECT MINUTE(toDateTime('2025-01-01 12:34:56'));",
          "SELECT MINUTE(toDateTime('2025-01-01 10:30:00'));",
          "SELECT MINUTE(NULL);"
        ]
      },
      {
        "expression": "toUnixTimestamp(time) % 60",
        "description": "Extracts the second part from a TIME or DATETIME value by using Unix timestamp.",
        "examples": [
          "SELECT toUnixTimestamp(4.99999999991e0) % 60;",
          "SELECT toUnixTimestamp(toDateTime('2007-07-19 00:00:00')) % 60;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_37_20",
    "database_name": "clickhouse_37_20",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT HOUR(NULL),MINUTE(NULL),SECOND(NULL); -- HOUR, MINUTE, SECOND",
    "target_query": "SELECT toHour(NULL), toMinute(NULL), (toUnixTimestamp(NULL) % 60);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HOUR",
      "MINUTE",
      "SECOND"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HOUR(expr)",
        "description": "Extracts the hour (0–23) from a time or datetime expression.",
        "examples": [
          "SELECT HOUR('18:45:30');",
          "SELECT HOUR('2023-10-01 08:15:00');",
          "SELECT HOUR(CURRENT_TIMESTAMP);"
        ]
      },
      {
        "expression": "MINUTE()",
        "description": "Extracts the minute part from a time or datetime value.",
        "examples": [
          "SELECT MINUTE('12:34:56');",
          "SELECT MINUTE('2025-01-01 10:30:00');",
          "SELECT MINUTE(NULL);"
        ]
      },
      {
        "expression": "SECOND(time)",
        "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
        "examples": [
          "SELECT SECOND('10:11:12');",
          "SELECT SECOND(4.99999999991e0);",
          "SELECT SECOND(CAST('2007-07-19' AS DATE));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toHour(expr)",
        "description": "Extracts the hour from a DateTime expression.",
        "examples": [
          "SELECT toHour(toDateTime('2023-10-01 18:45:30'));",
          "SELECT toHour(now());"
        ]
      },
      {
        "expression": "MINUTE()",
        "description": "Extracts the minute part from a datetime or timestamp value. Input should be in date or datetime type.",
        "examples": [
          "SELECT MINUTE(toDateTime('2025-01-01 12:34:56'));",
          "SELECT MINUTE(toDateTime('2025-01-01 10:30:00'));",
          "SELECT MINUTE(NULL);"
        ]
      },
      {
        "expression": "toUnixTimestamp(time) % 60",
        "description": "Extracts the second part from a TIME or DATETIME value by using Unix timestamp.",
        "examples": [
          "SELECT toUnixTimestamp(4.99999999991e0) % 60;",
          "SELECT toUnixTimestamp(toDateTime('2007-07-19 00:00:00')) % 60;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_37_21",
    "database_name": "clickhouse_37_21",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT CONVERT('a', CHAR(2049)); -- CONVERT",
    "target_query": "SELECT CAST('a' AS String);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONVERT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONVERT(expression USING charset)",
        "description": "Converts data types or changes the character set.",
        "examples": [
          "SELECT CONVERT('Hello World' USING utf8);",
          "SELECT CONVERT(1234, CHAR);",
          "SELECT CONVERT(column_name USING latin1) FROM my_table;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CAST(expression AS target_type)",
        "description": "ClickHouse uses CAST for type conversion. No direct equivalent for CONVERT TO CHARACTER SET.",
        "examples": [
          "SELECT CAST('2021-12-31' AS Date);",
          "SELECT CAST(1234 AS String);",
          "SELECT CAST(column_name AS Date) FROM my_table;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_37_22",
    "database_name": "clickhouse_37_22",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT CONCAT(\"value=\", CAST(\"3.4e5\" AS FLOAT)); -- CONCAT",
    "target_query": "SELECT concat('value=', toString(CAST('3.4e5' AS Float32)));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_37_23",
    "database_name": "clickhouse_37_23",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT MAKETIME(1, 2, CAST(\"1.6\" AS FLOAT)); -- MAKETIME",
    "target_query": "SELECT formatDateTime(toDateTime('1970-01-01 01:02:01'), '%H:%M:%S');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKETIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKETIME(hours, minutes, seconds)",
        "description": "Creates a time value from the provided hours, minutes, and seconds.",
        "examples": [
          "SELECT MAKETIME(1, 30, 45);",
          "SELECT MAKETIME(12, 0, 0);",
          "SELECT MAKETIME(23, 59, 59);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(toDateTime('1970-01-01 HH:MM:SS'), '%H:%i:%s')",
        "description": "ClickHouse does not have a direct equivalent to MAKETIME. Therefore, we construct a DateTime using a fixed date (e.g., '1970-01-01') and extract only the time part using `formatDateTime`.",
        "examples": [
          "SELECT formatDateTime(toDateTime('1970-01-01 01:30:45'), '%H:%i:%s');",
          "SELECT formatDateTime(toDateTime('1970-01-01 12:00:00'), '%H:%i:%s');",
          "SELECT formatDateTime(toDateTime('1970-01-01 23:59:59'), '%H:%i:%s');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_38_3",
    "database_name": "clickhouse_38_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT STRCMP(a, b) FROM t1; -- STRCMP",
    "target_query": "SELECT CASE WHEN toString(a) = b THEN 0 WHEN toUInt16(a) < 0 THEN -1 ELSE 1 END FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "ClickHouse does not have a direct STRCMP function, but the same behavior can be simulated using the CASE statement to compare two strings lexicographically and return 0, -1, or 1 based on the comparison.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(a YEAR, b VARCHAR(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(a Int16, b String) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_38_5",
    "database_name": "clickhouse_38_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT CAST(JSON_EXTRACT('{\\\"key_year\\\":1934}', '$.key_year') AS YEAR); -- JSON_EXTRACT",
    "target_query": "SELECT toInt16(JSONExtractInt('{\"key_year\":1934}', 'key_year'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "JSON_EXTRACT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "JSON_EXTRACT(json_doc, path)",
        "description": "Extracts data from a JSON document at the specified path(s). Supports dot notation and wildcards.",
        "examples": [
          "SELECT JSON_EXTRACT('{\"user\": {\"name\": \"Alice\"}}', '$.user.name');",
          "SELECT JSON_EXTRACT('{\"items\": [10, 20, 30]}', '$.items[1]');",
          "SELECT JSON_EXTRACT('{\"a\": {\"b\": [1, 2]}}', '$.a.b[0]');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "JSONExtractString(JSONExtractRaw(json_str, 'key'), 'nested_key')",
        "description": "ClickHouse does not support full JSONPath. Instead, it provides basic key-based access using `JSONExtractRaw`, which returns a raw JSON string of the nested object. Then `JSONExtractString`, `JSONExtractInt` etc., can be used to extract scalar fields. However, it does not support accessing array elements by index, or deep paths like 'a.b[0]'.",
        "examples": [
          "SELECT JSONExtractString(JSONExtractRaw('{\"user\": {\"name\": \"Alice\"}}', 'user'), 'name');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_38_6",
    "database_name": "clickhouse_38_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT CAST(1988 AS YEAR), REPEAT(CAST(1988 AS YEAR), 3) AS c2; -- REPEAT",
    "target_query": "SELECT toInt16(1988), repeat(toString(toInt16(1988)), 3) AS c2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_38_7",
    "database_name": "clickhouse_38_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT CONCAT('x', CAST(1988 AS YEAR)); -- CONCAT",
    "target_query": "SELECT concat('x', toString(toInt16(1988)));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_38_8",
    "database_name": "clickhouse_38_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT TIME_TO_SEC(CAST('2030' AS YEAR)); -- TIME_TO_SEC",
    "target_query": "SELECT toUnixTimestamp(concat('1970-01-01 20:00:00',''));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME_TO_SEC"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME_TO_SEC(time)",
        "description": "Converts a time value (HH:MM:SS) to the total number of seconds.",
        "examples": [
          "SELECT TIME_TO_SEC('15:12:22');",
          "SELECT TIME_TO_SEC('00:01:00');",
          "SELECT SEC_TO_TIME(TIME_TO_SEC('15:12:22') - TIME_TO_SEC('14:12:22'));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp('1970-01-01 15:12:22')",
        "description": "Converts a time value to Unix timestamp (seconds). A date portion is required to convert time to Unix timestamp.",
        "examples": [
          "SELECT toUnixTimestamp('1970-01-01 15:12:22');",
          "SELECT toUnixTimestamp('1970-01-01 00:01:00');",
          "SELECT toString(toUnixTimestamp('1970-01-01 15:12:22') - toUnixTimestamp('1970-01-01 14:12:22'));"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_38_9",
    "database_name": "clickhouse_38_9",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT TIMESTAMPADD(MINUTE, 1, CAST(1988 AS YEAR)); -- TIMESTAMPADD",
    "target_query": "SELECT addMinutes(toDateTime('1970-01-01 19:88:00'), 1);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMPADD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMPADD(unit, interval, datetime_expr)",
        "description": "Adds a time interval to a date or timestamp expression using the specified unit.",
        "examples": [
          "SELECT TIMESTAMPADD(DAY, 2, '2023-01-01');",
          "SELECT TIMESTAMPADD(MINUTE, -5, '2023-05-10 12:00:00');",
          "SELECT TIMESTAMPADD(YEAR, 1, '2020-06-15');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "addUnit(datetime_expr, n)",
        "description": "Adds a time interval to a datetime or date using unit-specific functions like addDays, addMinutes, addYears.",
        "examples": [
          "SELECT addDays(toDate('2023-01-01'), 2);",
          "SELECT addMinutes(toDateTime('2023-05-10 12:00:00'), -5);",
          "SELECT addYears(toDate('2020-06-15'), 1);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_38_10",
    "database_name": "clickhouse_38_10",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT CAST(STR_TO_DATE('nope','%d-%m-%Y') AS YEAR); -- STR_TO_DATE",
    "target_query": "SELECT toInt16(0);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STR_TO_DATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STR_TO_DATE('09:22', '%H:%i')",
        "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
        "examples": [
          "SELECT STR_TO_DATE('12:45', '%H:%i');",
          "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
          "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "parseDateTimeBestEffort('09:22')",
        "description": "Clickhouse uses parseDateTimeBestEffort to try and automatically parse the string '09:22' into a DateTime type.",
        "examples": [
          "SELECT parseDateTimeBestEffort('12:45');",
          "SELECT toDateTime('2000-01-01');",
          "SELECT parseDateTimeBestEffort('2023-05-06 12:34:56');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_38_13",
    "database_name": "clickhouse_38_13",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT 1 FROM t WHERE CAST(a AS UNSIGNED INTEGER) = 1 AND a = IF(TRUE, NULL, 1); -- IF",
    "target_query": "SELECT 1 FROM t WHERE a = 1 AND a = IF(TRUE, NULL, 1);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "ClickHouse supports the `IF` function, which works similarly to MySQL. It evaluates a condition and returns different values based on whether the condition is true or false.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t (a INT NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t (a Int32 NOT NULL) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_40_3",
    "database_name": "clickhouse_40_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT hex(a),STRCMP(a,'a'), STRCMP(a,'a ') FROM t1; -- HEX, STRCMP",
    "target_query": "SELECT HEX(a), CASE WHEN a = 'a' THEN 0 WHEN a < 'a' THEN -1 ELSE 1 END, CASE WHEN a = 'a ' THEN 0 WHEN a < 'a ' THEN -1 ELSE 1 END FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX",
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      },
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "ClickHouse does not have a direct STRCMP function, but the same behavior can be simulated using the CASE statement to compare two strings lexicographically and return 0, -1, or 1 based on the comparison.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a char(10) not null);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a FixedString(10) NOT NULL) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_40_7",
    "database_name": "clickhouse_40_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT CONCAT(b,c), CONCAT(b,c) = '0101' FROM t1; -- CONCAT",
    "target_query": "SELECT concat(toString(b), toString(c)), concat(toString(b), toString(c)) = '0101' FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE  t1 (b int(2) zerofill, c int(2) zerofill);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (b Int32, c Int32) ENGINE = MergeTree ORDER BY tuple(b, c);"
    ]
  },
  {
    "sql_id": "clickhouse_40_8",
    "database_name": "clickhouse_40_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "EXPLAIN SELECT b,c FROM t1 WHERE b = 1 AND CONCAT(b,c) = '0101'; -- CONCAT",
    "target_query": "EXPLAIN SELECT b, c FROM t1 WHERE b = 1 AND concat(toString(b), toString(c)) = '0101';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE  t1 (b int(2) zerofill, c int(2) zerofill);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (b Int32, c Int32) ENGINE = MergeTree ORDER BY tuple(b, c);"
    ]
  },
  {
    "sql_id": "clickhouse_40_9",
    "database_name": "clickhouse_40_9",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT b,c FROM t1 WHERE b = 1 AND CONCAT(b,c) = '0101'; -- CONCAT",
    "target_query": "SELECT b, c FROM t1 WHERE b = 1 AND concat(toString(b), toString(c)) = '0101';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE  t1 (b int(2) zerofill, c int(2) zerofill);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (b Int32, c Int32) ENGINE = MergeTree ORDER BY tuple(b, c);"
    ]
  },
  {
    "sql_id": "clickhouse_40_12",
    "database_name": "clickhouse_40_12",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 VALUES (NOW()),(NOW()),(NOW()); -- NOW",
    "target_query": "INSERT INTO t1 VALUES (now()),(now()),(now());",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "now()",
        "description": "ClickHouse uses the now() function to return the current date and time, which is equivalent to MySQL's NOW() function.",
        "examples": [
          "SELECT now();",
          "CREATE TABLE t12 AS SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > now()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (now());"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a TIMESTAMP);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a DateTime) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_40_16",
    "database_name": "clickhouse_40_16",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT ROW('1', '1') > ROW(a, '1') FROM t1; -- ROW",
    "target_query": "SELECT tuple('1', '1') > tuple(a, '1') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(a CHAR(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(a FixedString(10)) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_40_17",
    "database_name": "clickhouse_40_17",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT ROW(a, '1') > ROW('1', '1') FROM t1; -- ROW",
    "target_query": "SELECT tuple(a, '1') > tuple('1', '1') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ROW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
        "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
        "examples": [
          "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
          "SELECT ROW(10, 20) = ROW(5, 15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT tuple(10, 2, 3) IN (tuple(3, 2, 3), tuple(1, 2, 3), tuple(1, 3, 3));",
        "description": "ClickHouse does not support ROW, but it uses tuple to represent multiple values, which can be used in comparisons.",
        "examples": [
          "SELECT tuple(1, 2) IN (tuple(1, 2), tuple(3, 4));",
          "SELECT tuple(10, 20) = tuple(5, 15);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(a CHAR(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(a FixedString(10)) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_41_3",
    "database_name": "clickhouse_41_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select count(distinct if(f1,3,f2)) from t1; -- COUNT, IF",
    "target_query": "SELECT count(DISTINCT if(f1 != 0, 3, f2)) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COUNT",
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN FORMAT=TREE SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      },
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "COUNT()",
        "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
        "examples": [
          "EXPLAIN SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
          "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
          "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
        ]
      },
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "ClickHouse supports the `IF` function, which works similarly to MySQL. It evaluates a condition and returns different values based on whether the condition is true or false.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (f1 int, f2 int);"
    ],
    "target_related_schemas": [
      "create table t1 (f1 int, f2 int)ENGINE = MergeTree ORDER BY (f1, f2);"
    ]
  },
  {
    "sql_id": "clickhouse_42_0",
    "database_name": "clickhouse_42_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT inet6_ntoa(inet_ntoa('1')); -- INET6_NTOA, INET_NTOA",
    "target_query": "SELECT IPv6NumToString(toIPv6(INET_NTOA(1)));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "INET6_NTOA",
      "INET_NTOA"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "INET6_NTOA(CAST(ip AS BINARY(16)))",
        "description": "Converts a 16-byte binary IPv6 address to its textual representation in standard IPv6 format.",
        "examples": [
          "SELECT INET6_NTOA(CAST('::1' AS BINARY(16)));",
          "SELECT INET6_NTOA(CAST('2001:0db8:85a3:0000:0000:8a2e:0370:7334' AS BINARY(16)));",
          "SELECT INET6_NTOA(CAST('fe80::1ff:fe23:4567:890a' AS BINARY(16)));"
        ]
      },
      {
        "expression": "INET_NTOA(ip)",
        "description": "The INET_NTOA function converts an integer representation of an IPv4 address to a standard dotted-decimal format string.",
        "examples": [
          "SELECT INET_NTOA(3232235776);",
          "SELECT INET_NTOA(16777343);",
          "SELECT INET_NTOA(2886733345);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "IPv6NumToString(toIPv6(ip))",
        "description": "ClickHouse converts IPv6 address strings to IPv6 type using toIPv6, then uses IPv6NumToString to convert it to its textual representation.",
        "examples": [
          "SELECT IPv6NumToString(toIPv6('::1'));",
          "SELECT IPv6NumToString(toIPv6('2001:0db8:85a3:0000:0000:8a2e:0370:7334'));",
          "SELECT IPv6NumToString(toIPv6('fe80::1ff:fe23:4567:890a'));"
        ]
      },
      {
        "expression": "INET_NTOA(ip)",
        "description": "ClickHouse supports INET_NTOA just like MySQL and MariaDB, converting an integer IPv4 address to a dotted-decimal string.",
        "examples": [
          "SELECT INET_NTOA(3232235776);",
          "SELECT INET_NTOA(16777343);",
          "SELECT INET_NTOA(2886733345);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_42_4",
    "database_name": "clickhouse_42_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT HEX(v) FROM t1; -- HEX",
    "target_query": "SELECT HEX(v) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (v VARCHAR(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (v String) ENGINE = MergeTree ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_43_3",
    "database_name": "clickhouse_43_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select concat(name,space(level)), concat(name, repeat(' ',level)) from t1; -- CONCAT, SPACE, REPEAT",
    "target_query": "select concat(name, repeat(' ', level)), concat(name, repeat(' ', level)) from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT",
      "SPACE",
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      },
      {
        "expression": "SPACE(n)",
        "description": "Returns a string consisting of n space characters.",
        "examples": [
          "SELECT LENGTH(SPACE(5));",
          "SELECT CONCAT('A', SPACE(3), 'B');",
          "SELECT CONCAT(REPEAT('-', 2), SPACE(4), '!');"
        ]
      },
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      },
      {
        "expression": "repeat(' ', n)",
        "description": "Returns a string consisting of n space characters by repeating a space character.",
        "examples": [
          "SELECT length(repeat(' ', 5));",
          "SELECT concat('A', repeat(' ', 3), 'B');",
          "SELECT concat(repeat('-', 2), repeat(' ', 4), '!');"
        ]
      },
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (name varchar(10),level smallint);"
    ],
    "target_related_schemas": [
      "create table t1 (name varchar(10),level smallint)ENGINE = MergeTree ORDER BY(name,level);"
    ]
  },
  {
    "sql_id": "clickhouse_43_5",
    "database_name": "clickhouse_43_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "create table t1 select repeat('a',4000) a; -- REPEAT",
    "target_query": "CREATE TABLE t1 ENGINE = MergeTree ORDER BY a AS SELECT repeat('a', 4000) AS a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 select repeat('a',4000) a; -- REPEAT"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ENGINE = MergeTree ORDER BY a AS SELECT repeat('a', 4000) AS a;"
    ]
  },
  {
    "sql_id": "clickhouse_43_14",
    "database_name": "clickhouse_43_14",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT",
    "target_query": "CREATE TABLE head ENGINE = MergeTree ORDER BY head  AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT"
    ],
    "target_related_schemas": [
      "CREATE TABLE head ENGINE = MergeTree ORDER BY head  AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2;"
    ]
  },
  {
    "sql_id": "clickhouse_43_15",
    "database_name": "clickhouse_43_15",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "CREATE TABLE tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2; -- CONCAT",
    "target_query": "CREATE TABLE tail ENGINE = MergeTree ORDER BY tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT",
      "CREATE TABLE tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2; -- CONCAT"
    ],
    "target_related_schemas": [
      "CREATE TABLE head ENGINE = MergeTree ORDER BY head  AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2;",
      "CREATE TABLE tail ENGINE = MergeTree ORDER BY tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2;"
    ]
  },
  {
    "sql_id": "clickhouse_43_17",
    "database_name": "clickhouse_43_17",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT inet6_ntoa(inet_ntoa('1')); -- INET6_NTOA, INET_NTOA",
    "target_query": "SELECT toIPv6(IPv4NumToString(1));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "INET6_NTOA",
      "INET_NTOA"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "INET6_NTOA(CAST(ip AS BINARY(16)))",
        "description": "Converts a 16-byte binary IPv6 address to its textual representation in standard IPv6 format.",
        "examples": [
          "SELECT INET6_NTOA(CAST('::1' AS BINARY(16)));",
          "SELECT INET6_NTOA(CAST('2001:0db8:85a3:0000:0000:8a2e:0370:7334' AS BINARY(16)));",
          "SELECT INET6_NTOA(CAST('fe80::1ff:fe23:4567:890a' AS BINARY(16)));"
        ]
      },
      {
        "expression": "INET_NTOA(ip)",
        "description": "The INET_NTOA function converts an integer representation of an IPv4 address to a standard dotted-decimal format string.",
        "examples": [
          "SELECT INET_NTOA(3232235776);",
          "SELECT INET_NTOA(16777343);",
          "SELECT INET_NTOA(2886733345);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "IPv6NumToString(toIPv6(ip))",
        "description": "ClickHouse converts IPv6 address strings to IPv6 type using toIPv6, then uses IPv6NumToString to convert it to its textual representation.",
        "examples": [
          "SELECT IPv6NumToString(toIPv6('::1'));",
          "SELECT IPv6NumToString(toIPv6('2001:0db8:85a3:0000:0000:8a2e:0370:7334'));",
          "SELECT IPv6NumToString(toIPv6('fe80::1ff:fe23:4567:890a'));"
        ]
      },
      {
        "expression": "INET_NTOA(ip)",
        "description": "ClickHouse supports INET_NTOA just like MySQL and MariaDB, converting an integer IPv4 address to a dotted-decimal string.",
        "examples": [
          "SELECT INET_NTOA(3232235776);",
          "SELECT INET_NTOA(16777343);",
          "SELECT INET_NTOA(2886733345);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_44_3",
    "database_name": "clickhouse_44_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT GROUP_CONCAT(IFNULL(a,'')) FROM t1; -- GROUP_CONCAT, IFNULL",
    "target_query": "SELECT arrayStringConcat(groupArray(ifNull(toString(a), '')), '') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GROUP_CONCAT",
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
        "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
        ]
      },
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "groupArray(X)arrayStringConcat(groupArray(X), Y)",
        "description": "In ClickHouse, the equivalent of group_concat(X) is achieved using groupArray(X), which collects values into an array. To concatenate the array elements into a string with a separator, use arrayStringConcat(groupArray(X), Y). If Y is omitted, the default separator is an empty string.",
        "examples": [
          "SELECT arrayStringConcat(groupArray(name), ', ') FROM students; -- Returns a comma-separated list of names",
          "SELECT arrayStringConcat(groupArray(name), ' | ') FROM students; -- Returns names separated by '|'"
        ]
      },
      {
        "expression": "ifNull(expr1, expr2)",
        "description": "ClickHouse's ifNull is functionally equivalent to MySQL's IFNULL. It returns expr2 if expr1 is NULL; otherwise, it returns expr1.",
        "examples": [
          "SELECT ifNull(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT ifNull(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = ifNull(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a MEDIUMINT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a Int32 NULL) ENGINE = MergeTree ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_44_4",
    "database_name": "clickhouse_44_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT GROUP_CONCAT(IF(a,a,'')) FROM t1; -- GROUP_CONCAT, IF",
    "target_query": "SELECT arrayStringConcat(groupArray(IF(a != 0, toString(a), '')), '') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GROUP_CONCAT",
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
        "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
        ]
      },
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "groupArray(X)arrayStringConcat(groupArray(X), Y)",
        "description": "In ClickHouse, the equivalent of group_concat(X) is achieved using groupArray(X), which collects values into an array. To concatenate the array elements into a string with a separator, use arrayStringConcat(groupArray(X), Y). If Y is omitted, the default separator is an empty string.",
        "examples": [
          "SELECT arrayStringConcat(groupArray(name), ', ') FROM students; -- Returns a comma-separated list of names",
          "SELECT arrayStringConcat(groupArray(name), ' | ') FROM students; -- Returns names separated by '|'"
        ]
      },
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "ClickHouse supports the `IF` function, which works similarly to MySQL. It evaluates a condition and returns different values based on whether the condition is true or false.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a MEDIUMINT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a Int32 NULL) ENGINE = MergeTree ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_44_5",
    "database_name": "clickhouse_44_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT GROUP_CONCAT(CASE WHEN a THEN a ELSE '' END) FROM t1; -- GROUP_CONCAT",
    "target_query": "SELECT arrayStringConcat(groupArray(CASE WHEN a != 0 THEN toString(a) ELSE '' END), '') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GROUP_CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
        "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
        "examples": [
          "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
          "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "groupArray(X)arrayStringConcat(groupArray(X), Y)",
        "description": "In ClickHouse, the equivalent of group_concat(X) is achieved using groupArray(X), which collects values into an array. To concatenate the array elements into a string with a separator, use arrayStringConcat(groupArray(X), Y). If Y is omitted, the default separator is an empty string.",
        "examples": [
          "SELECT arrayStringConcat(groupArray(name), ', ') FROM students; -- Returns a comma-separated list of names",
          "SELECT arrayStringConcat(groupArray(name), ' | ') FROM students; -- Returns names separated by '|'"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a MEDIUMINT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a Int32 NULL) ENGINE = MergeTree ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_44_6",
    "database_name": "clickhouse_44_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT COALESCE(a,'') FROM t1 GROUP BY 1; -- COALESCE",
    "target_query": "SELECT coalesce(toString(a), '') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "coalesce(expr1, expr2, ...)",
        "description": "ClickHouse supports COALESCE via SQL-compatible functions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a MEDIUMINT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a Int32 NULL) ENGINE = MergeTree ORDER BY tuple();"
    ]
  },
  {
    "sql_id": "clickhouse_44_8",
    "database_name": "clickhouse_44_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "CREATE TABLE t2 AS SELECT CONCAT_WS(1,2,3) FROM t1; -- CONCAT_WS",
    "target_query": "CREATE TABLE t2 ENGINE = MergeTree ORDER BY tuple() AS SELECT concat_ws('1', '2', '3') AS col1 FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT_WS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT_WS(separator, str1, str2, ...)",
        "description": "Concatenates multiple strings with the specified separator. If any argument is NULL, it is ignored.",
        "examples": [
          "SELECT CONCAT_WS(',', 'apple', 'banana', 'cherry');",
          "SELECT CONCAT_WS('-', 'hello', 'world');",
          "SELECT CONCAT_WS(' ', 'this', NULL, 'is', 'a', 'test');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat_ws(separator, str1, str2, ...)",
        "description": "Concatenates strings using a specified separator, and ignores NULL values.",
        "examples": [
          "SELECT concat_ws(',', 'apple', 'banana', 'cherry');",
          "SELECT concat_ws('-', 'hello', 'world');",
          "SELECT concat_ws(' ', 'this', NULL, 'is', 'a', 'test');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 AS SELECT CONCAT_WS(1,2,3) FROM t1; -- CONCAT_WS"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 ENGINE = MergeTree ORDER BY tuple() AS SELECT concat_ws('1', '2', '3') AS col1 FROM t1;"
    ]
  },
  {
    "sql_id": "clickhouse_44_10",
    "database_name": "clickhouse_44_10",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "CREATE TABLE t2 AS SELECT LCASE(a) FROM t1; -- LCASE",
    "target_query": "CREATE TABLE t2 ENGINE = MergeTree ORDER BY tuple() AS SELECT lower(toString(a)) AS col1 FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LCASE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LCASE(str)",
        "description": "Converts all characters in a string to lowercase. Equivalent to LOWER(str).",
        "examples": [
          "SELECT LCASE('TeSt');",
          "SELECT LCASE(CONCAT('A', 'B', 'C'));",
          "SELECT LCASE(456);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "lower(str)",
        "description": "Returns the input string with all characters converted to lowercase.",
        "examples": [
          "SELECT lower('TeSt');",
          "SELECT lower(concat('A', 'B', 'C'));",
          "SELECT lower(toString(456));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 AS SELECT LCASE(a) FROM t1; -- LCASE"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 ENGINE = MergeTree ORDER BY tuple() AS SELECT lower(toString(a)) AS col1 FROM t1;"
    ]
  },
  {
    "sql_id": "clickhouse_44_12",
    "database_name": "clickhouse_44_12",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "CREATE TABLE t2 AS SELECT UCASE(a) FROM t1; -- UCASE",
    "target_query": "CREATE TABLE t2 ENGINE = MergeTree ORDER BY tuple() AS SELECT upper(toString(a)) AS col1 FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UCASE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UCASE(str)",
        "description": "Returns the string `str` with all characters converted to uppercase. UCASE is a synonym for UPPER.",
        "examples": [
          "SELECT UCASE('hello world');",
          "SELECT UCASE(CONCAT('abc', '123'));",
          "SELECT UCASE(REPLACE('test case', 'case', 'CASE'));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "upper(str)",
        "description": "Returns the input string converted to uppercase. Case conversion is supported using the `upper` function.",
        "examples": [
          "SELECT upper('hello world');",
          "SELECT upper(concat('abc', '123'));",
          "SELECT upper(replace('test case', 'case', 'CASE'));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 AS SELECT UCASE(a) FROM t1; -- UCASE"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 ENGINE = MergeTree ORDER BY tuple() AS SELECT upper(toString(a)) AS col1 FROM t1;"
    ]
  },
  {
    "sql_id": "clickhouse_44_14",
    "database_name": "clickhouse_44_14",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "CREATE TABLE t2 AS SELECT REPEAT(1,2) FROM t1; -- REPEAT",
    "target_query": "CREATE TABLE t2 ENGINE = MergeTree ORDER BY tuple() AS SELECT repeat('1', 2) AS col1 FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 AS SELECT REPEAT(1,2) FROM t1; -- REPEAT"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 ENGINE = MergeTree ORDER BY tuple() AS SELECT repeat('1', 2) AS col1 FROM t1;"
    ]
  },
  {
    "sql_id": "clickhouse_44_16",
    "database_name": "clickhouse_44_16",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "CREATE TABLE t2 AS SELECT ELT(1,111,222,333) FROM t1; -- ELT",
    "target_query": "CREATE TABLE t2 ENGINE = MergeTree ORDER BY tuple() AS SELECT arrayElement(['111', '222', '333'], 0) AS col1 FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ELT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ELT(2, 'apple', 'banana', 'cherry')",
        "description": "Returns the N-th element from the list, where N is the first argument.",
        "examples": [
          "SELECT ELT(2, 'apple', 'banana', 'cherry');  -- Returns 'banana'",
          "SELECT ELT(1, 'red', 'green', 'blue');  -- Returns 'red'",
          "SELECT ELT(3, 'dog', 'cat', 'bird');  -- Returns 'bird'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "arrayElement(['apple', 'banana', 'cherry'], 2)",
        "description": "Returns the N-th element from the array, where N is the second argument.",
        "examples": [
          "SELECT arrayElement(['apple', 'banana', 'cherry'], 2);  -- Returns 'banana'",
          "SELECT arrayElement(['red', 'green', 'blue'], 1);  -- Returns 'red'",
          "SELECT arrayElement(['dog', 'cat', 'bird'], 3);  -- Returns 'bird'"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 AS SELECT ELT(1,111,222,333) FROM t1; -- ELT"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 ENGINE = MergeTree ORDER BY tuple() AS SELECT arrayElement(['111', '222', '333'], 0) AS col1 FROM t1;"
    ]
  },
  {
    "sql_id": "clickhouse_45_2",
    "database_name": "clickhouse_45_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT HEX(a) FROM t1; -- HEX",
    "target_query": "SELECT HEX(a) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a CHAR(10)) SELECT '' AS a;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 ENGINE=MergeTree ORDER BY a AS SELECT '' AS a;"
    ]
  },
  {
    "sql_id": "clickhouse_45_6",
    "database_name": "clickhouse_45_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT HEX(a) FROM t2; -- HEX",
    "target_query": "SELECT HEX(a) FROM t2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 (a CHAR(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (a CHAR(10)) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_45_11",
    "database_name": "clickhouse_45_11",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select * from t1 where a=lpad('xxx',10,' '); -- LPAD",
    "target_query": "SELECT * FROM t1 WHERE a=LPAD('xxx',10,' ');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a char(20));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a CHAR(20)) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_45_15",
    "database_name": "clickhouse_45_15",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select ifnull(c1,''), ifnull(null,c1) from t1; -- IFNULL",
    "target_query": "SELECT ifNull(c1,''), ifNull(NULL,c1) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "ifNull(expr1, expr2)",
        "description": "ClickHouse's ifNull is functionally equivalent to MySQL's IFNULL. It returns expr2 if expr1 is NULL; otherwise, it returns expr1.",
        "examples": [
          "SELECT ifNull(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT ifNull(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = ifNull(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 char(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 CHAR(10)) ENGINE=MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_45_16",
    "database_name": "clickhouse_45_16",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select if(1,c1,''), if(0,c1,'') from t1; -- IF",
    "target_query": "SELECT IF(1,c1,''), IF(0,c1,'') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "IF(condition, true_value, false_value)",
        "description": "ClickHouse supports the `IF` function, which works similarly to MySQL. It evaluates a condition and returns different values based on whether the condition is true or false.",
        "examples": [
          "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
          "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
          "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 char(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 CHAR(10)) ENGINE=MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_45_17",
    "database_name": "clickhouse_45_17",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select coalesce('',c1), coalesce(null,c1) from t1; -- COALESCE",
    "target_query": "SELECT coalesce('',c1), coalesce(NULL,c1) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "coalesce(expr1, expr2, ...)",
        "description": "ClickHouse supports COALESCE via SQL-compatible functions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 char(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 CHAR(10)) ENGINE=MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_45_18",
    "database_name": "clickhouse_45_18",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select least(c1,''), greatest(c1,'') from t1; -- LEAST, GREATEST",
    "target_query": "SELECT least(c1,''), greatest(c1,'') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST",
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      },
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the smallest non-null value among arguments. NULLs are ignored unless all arguments are NULL. Use ifNull() when explicit NULL handling is needed.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(toDate('2024-01-01'), toDate('2023-12-31'));",
          "SELECT ifNull(least(NULL, 2), NULL);"
        ]
      },
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 char(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 CHAR(10)) ENGINE=MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_45_19",
    "database_name": "clickhouse_45_19",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select locate(c1,''), locate('',c1) from t1; -- LOCATE",
    "target_query": "SELECT position(c1,''), position('',c1) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LOCATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LOCATE(substr, str[, start_position])",
        "description": "Returns the position of the first occurrence of substring 'substr' in string 'str'. If 'start_position' is provided, the search starts from that position.",
        "examples": [
          "select locate('a', 'banana', 2);",
          "select locate('foo', 'foobar', 2);",
          "select locate('ab', 'abcab', 3);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "position(str, substr)",
        "description": "Returns the position of the first occurrence of substring 'substr' in string 'str'. Does not support 'start_position'.",
        "examples": [
          "select position('banana', 'a');",
          "select position('foobar', 'foo');",
          "select position('abcab', 'ab');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 char(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 CHAR(10)) ENGINE=MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_45_20",
    "database_name": "clickhouse_45_20",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select field(c1,''),field('',c1) from t1; -- FIELD",
    "target_query": "SELECT indexOf(['',c1],c1), indexOf([c1,''],c1) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FIELD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FIELD(val, val1, val2, ..., valN)",
        "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
        "examples": [
          "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "indexOf([val1, val2, ..., valN], val)",
        "description": "Returns the 1-based index of 'val' in the array. Returns 0 if not found. Fully equivalent to FIELD().",
        "examples": [
          "SELECT indexOf(['a', 'b', 'c'], 'c') AS result;",
          "SELECT indexOf(['a', 'b', 'c'], 'x') AS result;",
          "SELECT indexOf(['b', 'b', 'b'], 'b') AS result;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 char(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 CHAR(10)) ENGINE=MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_45_21",
    "database_name": "clickhouse_45_21",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select concat(c1,''), concat('',c1) from t1; -- CONCAT",
    "target_query": "SELECT concat(c1,''), concat('',c1) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 char(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 CHAR(10)) ENGINE=MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_45_23",
    "database_name": "clickhouse_45_23",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select elt(1,c1,''),elt(1,'',c1) from t1; -- ELT",
    "target_query": "SELECT arrayElement([c1,''],1), arrayElement(['',c1],1) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ELT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ELT(2, 'apple', 'banana', 'cherry')",
        "description": "Returns the N-th element from the list, where N is the first argument.",
        "examples": [
          "SELECT ELT(2, 'apple', 'banana', 'cherry');  -- Returns 'banana'",
          "SELECT ELT(1, 'red', 'green', 'blue');  -- Returns 'red'",
          "SELECT ELT(3, 'dog', 'cat', 'bird');  -- Returns 'bird'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "arrayElement(['apple', 'banana', 'cherry'], 2)",
        "description": "Returns the N-th element from the array, where N is the second argument.",
        "examples": [
          "SELECT arrayElement(['apple', 'banana', 'cherry'], 2);  -- Returns 'banana'",
          "SELECT arrayElement(['red', 'green', 'blue'], 1);  -- Returns 'red'",
          "SELECT arrayElement(['dog', 'cat', 'bird'], 3);  -- Returns 'bird'"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 char(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 CHAR(10)) ENGINE=MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_45_24",
    "database_name": "clickhouse_45_24",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select lpad(c1,3,'x'), lpad('x',3,c1) from t1; -- LPAD",
    "target_query": "SELECT LPAD(c1,3,'x') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(string, length, pad_string)",
        "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
        "examples": [
          "SELECT LPAD('hello', 10, 'x');",
          "SELECT LPAD('abc', 6, '123');",
          "SELECT LPAD('123', 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 char(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 CHAR(10)) ENGINE=MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_45_25",
    "database_name": "clickhouse_45_25",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select rpad(c1,3,'x'), rpad('x',3,c1) from t1; -- RPAD",
    "target_query": "SELECT RPAD(c1,3,'x') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "ClickHouse uses the RPAD function for padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(toString(123), 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (c1 char(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 CHAR(10)) ENGINE=MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_46_15",
    "database_name": "clickhouse_46_15",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select date_format(d,\"%d\") from t1 order by 1; -- DATE_FORMAT",
    "target_query": "SELECT formatDateTime(d, '%d') FROM t1 ORDER BY 1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(date_expr, format_str)",
        "description": "Formats a DateTime value using ClickHouse-supported format specifiers. Input must be a DateTime or cast to one explicitly.",
        "examples": [
          "SELECT formatDateTime(toDateTime('2024-05-06 08:30:00'), '%Y/%m/%d');",
          "SELECT formatDateTime(toDateTime('2023-07-14 15:30:00'), '%Y-%m-%d %H:%M:%S');",
          "SELECT formatDateTime(toDateTime('2022-01-01 08:45:30'), '%H:%M:%S on %d/%m/%Y');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (d date);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (d Date) ENGINE = MergeTree ORDER BY d;"
    ]
  },
  {
    "sql_id": "clickhouse_46_17",
    "database_name": "clickhouse_46_17",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select date_format('2004-01-01','%W (%a), %e %M (%b) %Y'); -- DATE_FORMAT",
    "target_query": "SELECT formatDateTime(toDateTime('2004-01-01'), '%W (%a), %e %M (%b) %Y');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(date_expr, format_str)",
        "description": "Formats a DateTime value using ClickHouse-supported format specifiers. Input must be a DateTime or cast to one explicitly.",
        "examples": [
          "SELECT formatDateTime(toDateTime('2024-05-06 08:30:00'), '%Y/%m/%d');",
          "SELECT formatDateTime(toDateTime('2023-07-14 15:30:00'), '%Y-%m-%d %H:%M:%S');",
          "SELECT formatDateTime(toDateTime('2022-01-01 08:45:30'), '%H:%M:%S on %d/%m/%Y');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_47_0",
    "database_name": "clickhouse_47_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT TIME_FORMAT(\"24:00:00\", '%r'); -- TIME_FORMAT",
    "target_query": "SELECT formatDateTime(toDateTime('1970-01-01 24:00:00'), '%r');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME_FORMAT(time, format)",
        "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
        "examples": [
          "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
          "SELECT TIME_FORMAT('18:05:07', '%r');",
          "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(toDateTime(string_time), format)",
        "description": "Formats a string-parsed datetime value using formatDateTime with format specifiers.",
        "examples": [
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%H:%M:%S');",
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%r');",
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%M:%S');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_47_1",
    "database_name": "clickhouse_47_1",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT TIME_FORMAT(\"00:00:00\", '%r'); -- TIME_FORMAT",
    "target_query": "SELECT formatDateTime(toDateTime('1970-01-01 00:00:00'), '%r');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME_FORMAT(time, format)",
        "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
        "examples": [
          "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
          "SELECT TIME_FORMAT('18:05:07', '%r');",
          "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(toDateTime(string_time), format)",
        "description": "Formats a string-parsed datetime value using formatDateTime with format specifiers.",
        "examples": [
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%H:%M:%S');",
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%r');",
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%M:%S');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_47_2",
    "database_name": "clickhouse_47_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT TIME_FORMAT(\"12:00:00\", '%r'); -- TIME_FORMAT",
    "target_query": "SELECT formatDateTime(toDateTime('1970-01-01 12:00:00'), '%r');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME_FORMAT(time, format)",
        "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
        "examples": [
          "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
          "SELECT TIME_FORMAT('18:05:07', '%r');",
          "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(toDateTime(string_time), format)",
        "description": "Formats a string-parsed datetime value using formatDateTime with format specifiers.",
        "examples": [
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%H:%M:%S');",
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%r');",
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%M:%S');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_47_3",
    "database_name": "clickhouse_47_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT TIME_FORMAT(\"15:00:00\", '%r'); -- TIME_FORMAT",
    "target_query": "SELECT formatDateTime(toDateTime('1970-01-01 15:00:00'), '%r');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME_FORMAT(time, format)",
        "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
        "examples": [
          "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
          "SELECT TIME_FORMAT('18:05:07', '%r');",
          "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(toDateTime(string_time), format)",
        "description": "Formats a string-parsed datetime value using formatDateTime with format specifiers.",
        "examples": [
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%H:%M:%S');",
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%r');",
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%M:%S');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_47_4",
    "database_name": "clickhouse_47_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT TIME_FORMAT(\"01:00:00\", '%r'); -- TIME_FORMAT",
    "target_query": "SELECT formatDateTime(toDateTime('1970-01-01 01:00:00'), '%r');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME_FORMAT(time, format)",
        "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
        "examples": [
          "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
          "SELECT TIME_FORMAT('18:05:07', '%r');",
          "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(toDateTime(string_time), format)",
        "description": "Formats a string-parsed datetime value using formatDateTime with format specifiers.",
        "examples": [
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%H:%M:%S');",
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%r');",
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%M:%S');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_47_5",
    "database_name": "clickhouse_47_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT TIME_FORMAT(\"25:00:00\", '%r'); -- TIME_FORMAT",
    "target_query": "SELECT formatDateTime(toDateTime('1970-01-01 25:00:00'), '%r');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME_FORMAT(time, format)",
        "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
        "examples": [
          "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
          "SELECT TIME_FORMAT('18:05:07', '%r');",
          "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(toDateTime(string_time), format)",
        "description": "Formats a string-parsed datetime value using formatDateTime with format specifiers.",
        "examples": [
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%H:%M:%S');",
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%r');",
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%M:%S');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_47_6",
    "database_name": "clickhouse_47_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT TIME_FORMAT(\"00:00:00\", '%l %p'); -- TIME_FORMAT",
    "target_query": "SELECT formatDateTime(toDateTime('1970-01-01 00:00:00'), '%l %p');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME_FORMAT(time, format)",
        "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
        "examples": [
          "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
          "SELECT TIME_FORMAT('18:05:07', '%r');",
          "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(toDateTime(string_time), format)",
        "description": "Formats a string-parsed datetime value using formatDateTime with format specifiers.",
        "examples": [
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%H:%M:%S');",
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%r');",
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%M:%S');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_47_7",
    "database_name": "clickhouse_47_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT TIME_FORMAT(\"01:00:00\", '%l %p'); -- TIME_FORMAT",
    "target_query": "SELECT formatDateTime(toDateTime('1970-01-01 01:00:00'), '%l %p');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME_FORMAT(time, format)",
        "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
        "examples": [
          "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
          "SELECT TIME_FORMAT('18:05:07', '%r');",
          "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(toDateTime(string_time), format)",
        "description": "Formats a string-parsed datetime value using formatDateTime with format specifiers.",
        "examples": [
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%H:%M:%S');",
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%r');",
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%M:%S');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_47_8",
    "database_name": "clickhouse_47_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT TIME_FORMAT(\"12:00:00\", '%l %p'); -- TIME_FORMAT",
    "target_query": "SELECT formatDateTime(toDateTime('1970-01-01 12:00:00'), '%l %p');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME_FORMAT(time, format)",
        "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
        "examples": [
          "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
          "SELECT TIME_FORMAT('18:05:07', '%r');",
          "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(toDateTime(string_time), format)",
        "description": "Formats a string-parsed datetime value using formatDateTime with format specifiers.",
        "examples": [
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%H:%M:%S');",
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%r');",
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%M:%S');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_47_9",
    "database_name": "clickhouse_47_9",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT TIME_FORMAT(\"23:00:00\", '%l %p'); -- TIME_FORMAT",
    "target_query": "SELECT formatDateTime(toDateTime('1970-01-01 23:00:00'), '%l %p');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME_FORMAT(time, format)",
        "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
        "examples": [
          "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
          "SELECT TIME_FORMAT('18:05:07', '%r');",
          "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(toDateTime(string_time), format)",
        "description": "Formats a string-parsed datetime value using formatDateTime with format specifiers.",
        "examples": [
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%H:%M:%S');",
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%r');",
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%M:%S');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_47_10",
    "database_name": "clickhouse_47_10",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT TIME_FORMAT(\"24:00:00\", '%l %p'); -- TIME_FORMAT",
    "target_query": "SELECT formatDateTime(toDateTime('1970-01-01 24:00:00'), '%l %p');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME_FORMAT(time, format)",
        "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
        "examples": [
          "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
          "SELECT TIME_FORMAT('18:05:07', '%r');",
          "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(toDateTime(string_time), format)",
        "description": "Formats a string-parsed datetime value using formatDateTime with format specifiers.",
        "examples": [
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%H:%M:%S');",
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%r');",
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%M:%S');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_47_11",
    "database_name": "clickhouse_47_11",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT TIME_FORMAT(\"25:00:00\", '%l %p'); -- TIME_FORMAT",
    "target_query": "SELECT formatDateTime(toDateTime('1970-01-01 25:00:00'), '%l %p');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME_FORMAT(time, format)",
        "description": "Formats a TIME value according to the given format string using MySQL-style format specifiers.",
        "examples": [
          "SELECT TIME_FORMAT('18:05:07', '%H:%i:%s');",
          "SELECT TIME_FORMAT('18:05:07', '%r');",
          "SELECT TIME_FORMAT('18:05:07', '%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(toDateTime(string_time), format)",
        "description": "Formats a string-parsed datetime value using formatDateTime with format specifiers.",
        "examples": [
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%H:%M:%S');",
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%r');",
          "SELECT formatDateTime(toDateTime('1970-01-01 18:05:07'), '%M:%S');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_47_12",
    "database_name": "clickhouse_47_12",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT DATE_FORMAT('%Y-%m-%d %H:%i:%s', 1151414896); -- DATE_FORMAT",
    "target_query": "SELECT formatDateTime(toDateTime('1970-01-01 00:00:00') + 1151414896, '%Y-%m-%d %H:%i:%s');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(date_expr, format_str)",
        "description": "Formats a DateTime value using ClickHouse-supported format specifiers. Input must be a DateTime or cast to one explicitly.",
        "examples": [
          "SELECT formatDateTime(toDateTime('2024-05-06 08:30:00'), '%Y/%m/%d');",
          "SELECT formatDateTime(toDateTime('2023-07-14 15:30:00'), '%Y-%m-%d %H:%M:%S');",
          "SELECT formatDateTime(toDateTime('2022-01-01 08:45:30'), '%H:%M:%S on %d/%m/%Y');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_47_15",
    "database_name": "clickhouse_47_15",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select str_to_date('04/30/2004 ', '%m/%d/%Y '); -- STR_TO_DATE",
    "target_query": "SELECT parseDateTimeBestEffort('04/30/2004 ');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STR_TO_DATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STR_TO_DATE('09:22', '%H:%i')",
        "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
        "examples": [
          "SELECT STR_TO_DATE('12:45', '%H:%i');",
          "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
          "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "parseDateTimeBestEffort('09:22')",
        "description": "Clickhouse uses parseDateTimeBestEffort to try and automatically parse the string '09:22' into a DateTime type.",
        "examples": [
          "SELECT parseDateTimeBestEffort('12:45');",
          "SELECT toDateTime('2000-01-01');",
          "SELECT parseDateTimeBestEffort('2023-05-06 12:34:56');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_47_16",
    "database_name": "clickhouse_47_16",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT DATE_FORMAT(\"0000-01-01\",'%W %d %M %Y') as valid_date; -- DATE_FORMAT",
    "target_query": "SELECT formatDateTime(toDateTime('0000-01-01'), '%W %d %M %Y') as valid_date;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(date_expr, format_str)",
        "description": "Formats a DateTime value using ClickHouse-supported format specifiers. Input must be a DateTime or cast to one explicitly.",
        "examples": [
          "SELECT formatDateTime(toDateTime('2024-05-06 08:30:00'), '%Y/%m/%d');",
          "SELECT formatDateTime(toDateTime('2023-07-14 15:30:00'), '%Y-%m-%d %H:%M:%S');",
          "SELECT formatDateTime(toDateTime('2022-01-01 08:45:30'), '%H:%M:%S on %d/%m/%Y');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_47_17",
    "database_name": "clickhouse_47_17",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT DATE_FORMAT(\"0000-02-28\",'%W %d %M %Y') as valid_date; -- DATE_FORMAT",
    "target_query": "SELECT formatDateTime(toDateTime('0000-02-28'), '%W %d %M %Y') as valid_date;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(date_expr, format_str)",
        "description": "Formats a DateTime value using ClickHouse-supported format specifiers. Input must be a DateTime or cast to one explicitly.",
        "examples": [
          "SELECT formatDateTime(toDateTime('2024-05-06 08:30:00'), '%Y/%m/%d');",
          "SELECT formatDateTime(toDateTime('2023-07-14 15:30:00'), '%Y-%m-%d %H:%M:%S');",
          "SELECT formatDateTime(toDateTime('2022-01-01 08:45:30'), '%H:%M:%S on %d/%m/%Y');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_47_18",
    "database_name": "clickhouse_47_18",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT DATE_FORMAT(\"2009-01-01\",'%W %d %M %Y') as valid_date; -- DATE_FORMAT",
    "target_query": "SELECT formatDateTime(toDateTime('2009-01-01'), '%W %d %M %Y') as valid_date;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(date_expr, format_str)",
        "description": "Formats a DateTime value using ClickHouse-supported format specifiers. Input must be a DateTime or cast to one explicitly.",
        "examples": [
          "SELECT formatDateTime(toDateTime('2024-05-06 08:30:00'), '%Y/%m/%d');",
          "SELECT formatDateTime(toDateTime('2023-07-14 15:30:00'), '%Y-%m-%d %H:%M:%S');",
          "SELECT formatDateTime(toDateTime('2022-01-01 08:45:30'), '%H:%M:%S on %d/%m/%Y');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_48_0",
    "database_name": "clickhouse_48_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT JSON_EXTRACT('{\"id\": \"3\", \"$name\": \"Barney\"}', \"$.id\"); -- JSON_EXTRACT",
    "target_query": "SELECT JSONExtractString(JSONExtractRaw('{\"id\": \"3\", \"$name\": \"Barney\"}', 'id'), '');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "JSON_EXTRACT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "JSON_EXTRACT(json_doc, path)",
        "description": "Extracts data from a JSON document at the specified path(s). Supports dot notation and wildcards.",
        "examples": [
          "SELECT JSON_EXTRACT('{\"user\": {\"name\": \"Alice\"}}', '$.user.name');",
          "SELECT JSON_EXTRACT('{\"items\": [10, 20, 30]}', '$.items[1]');",
          "SELECT JSON_EXTRACT('{\"a\": {\"b\": [1, 2]}}', '$.a.b[0]');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "JSONExtractString(JSONExtractRaw(json_str, 'key'), 'nested_key')",
        "description": "ClickHouse does not support full JSONPath. Instead, it provides basic key-based access using `JSONExtractRaw`, which returns a raw JSON string of the nested object. Then `JSONExtractString`, `JSONExtractInt` etc., can be used to extract scalar fields. However, it does not support accessing array elements by index, or deep paths like 'a.b[0]'.",
        "examples": [
          "SELECT JSONExtractString(JSONExtractRaw('{\"user\": {\"name\": \"Alice\"}}', 'user'), 'name');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_48_1",
    "database_name": "clickhouse_48_1",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT JSON_EXTRACT('{\"id\": \"3\", \"$name\": \"$Barney\"}', \"$.$name\"); -- JSON_EXTRACT",
    "target_query": "SELECT JSONExtractString(JSONExtractRaw('{\"id\": \"3\", \"$name\": \"$Barney\"}', '$name'), '');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "JSON_EXTRACT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "JSON_EXTRACT(json_doc, path)",
        "description": "Extracts data from a JSON document at the specified path(s). Supports dot notation and wildcards.",
        "examples": [
          "SELECT JSON_EXTRACT('{\"user\": {\"name\": \"Alice\"}}', '$.user.name');",
          "SELECT JSON_EXTRACT('{\"items\": [10, 20, 30]}', '$.items[1]');",
          "SELECT JSON_EXTRACT('{\"a\": {\"b\": [1, 2]}}', '$.a.b[0]');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "JSONExtractString(JSONExtractRaw(json_str, 'key'), 'nested_key')",
        "description": "ClickHouse does not support full JSONPath. Instead, it provides basic key-based access using `JSONExtractRaw`, which returns a raw JSON string of the nested object. Then `JSONExtractString`, `JSONExtractInt` etc., can be used to extract scalar fields. However, it does not support accessing array elements by index, or deep paths like 'a.b[0]'.",
        "examples": [
          "SELECT JSONExtractString(JSONExtractRaw('{\"user\": {\"name\": \"Alice\"}}', 'user'), 'name');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_49_5",
    "database_name": "clickhouse_49_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select concat('|', text1, '|') as c from t1 where text1='teststring' or text1 like 'teststring_%' order by c; -- CONCAT",
    "target_query": "SELECT concat('|', text1, '|') AS c FROM t1 WHERE text1='teststring' OR text1 LIKE 'teststring\\_%' ORDER BY c;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);",
      "alter table t1 modify text1 char(32) binary not null;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (text1 VARCHAR(32) NOT NULL) ENGINE = MergeTree ORDER BY text1;",
      "ALTER TABLE t1 ALTER COLUMN text1 TYPE VARCHAR(32);"
    ]
  },
  {
    "sql_id": "clickhouse_49_6",
    "database_name": "clickhouse_49_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select concat('|', text1, '|') from t1 where text1='teststring' or text1 > 'teststring\\\\t'; -- CONCAT",
    "target_query": "SELECT concat('|', text1, '|') FROM t1 WHERE text1='teststring' OR text1 > 'teststring\\\\\\t';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);",
      "alter table t1 modify text1 char(32) binary not null;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (text1 VARCHAR(32) NOT NULL) ENGINE = MergeTree ORDER BY text1;",
      "ALTER TABLE t1 ALTER COLUMN text1 TYPE VARCHAR(32);"
    ]
  },
  {
    "sql_id": "clickhouse_49_7",
    "database_name": "clickhouse_49_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select text1, length(text1) from t1 order by text1; -- LENGTH",
    "target_query": "SELECT text1, length(text1) FROM t1 ORDER BY text1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);",
      "alter table t1 modify text1 char(32) binary not null;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (text1 VARCHAR(32) NOT NULL) ENGINE = MergeTree ORDER BY text1;",
      "ALTER TABLE t1 ALTER COLUMN text1 TYPE VARCHAR(32);"
    ]
  },
  {
    "sql_id": "clickhouse_49_9",
    "database_name": "clickhouse_49_9",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select concat('|', text1, '|') from t1 order by text1; -- CONCAT",
    "target_query": "SELECT concat('|', text1, '|') FROM t1 ORDER BY text1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);",
      "alter table t1 modify text1 char(32) binary not null;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (text1 VARCHAR(32) NOT NULL) ENGINE = MergeTree ORDER BY text1;",
      "ALTER TABLE t1 ALTER COLUMN text1 TYPE VARCHAR(32);"
    ]
  },
  {
    "sql_id": "clickhouse_49_10",
    "database_name": "clickhouse_49_10",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select concat('|', text1, '|') from t1 where text1='teststring' or text1 > 'teststring\\\\t'; -- CONCAT",
    "target_query": "SELECT concat('|', text1, '|') FROM t1 WHERE text1='teststring' OR text1 > 'teststring\\\\\\t';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);",
      "alter table t1 modify text1 char(32) binary not null;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (text1 VARCHAR(32) NOT NULL) ENGINE = MergeTree ORDER BY text1;",
      "ALTER TABLE t1 ALTER COLUMN text1 TYPE VARCHAR(32);"
    ]
  },
  {
    "sql_id": "clickhouse_49_11",
    "database_name": "clickhouse_49_11",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select concat('|', text1, '|') from t1 where text1='teststring'; -- CONCAT",
    "target_query": "SELECT concat('|', text1, '|') FROM t1 WHERE text1='teststring';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);",
      "alter table t1 modify text1 char(32) binary not null;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (text1 VARCHAR(32) NOT NULL) ENGINE = MergeTree ORDER BY text1;",
      "ALTER TABLE t1 ALTER COLUMN text1 TYPE VARCHAR(32);"
    ]
  },
  {
    "sql_id": "clickhouse_49_12",
    "database_name": "clickhouse_49_12",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select concat('|', text1, '|') from t1 where text1='teststring '; -- CONCAT",
    "target_query": "SELECT concat('|', text1, '|') FROM t1 WHERE text1='teststring ';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (text1 varchar(32) not NULL);",
      "alter table t1 modify text1 char(32) binary not null;"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (text1 VARCHAR(32) NOT NULL) ENGINE = MergeTree ORDER BY text1;",
      "ALTER TABLE t1 ALTER COLUMN text1 TYPE VARCHAR(32);"
    ]
  },
  {
    "sql_id": "clickhouse_50_3",
    "database_name": "clickhouse_50_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT CONCAT(\"Let's create some new events from the name of \", USER()); -- CONCAT, USER",
    "target_query": "SELECT concat('Let\\'s create some new events from the name of ', currentUser());",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT",
      "USER"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      },
      {
        "expression": "USER()",
        "description": "Returns the current MySQL user and host in the format 'username@hostname'.",
        "examples": [
          "SELECT USER();"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      },
      {
        "expression": "currentUser()",
        "description": "Returns the current user in ClickHouse.",
        "examples": [
          "SELECT currentUser();"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_51_2",
    "database_name": "clickhouse_51_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 VALUES ( 2, REPEAT('-', 104) ); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (2, repeat('-', 104));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (f1 INTEGER,f2 LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (f1 INTEGER, f2 String) ENGINE = MergeTree ORDER BY f1;"
    ]
  },
  {
    "sql_id": "clickhouse_51_3",
    "database_name": "clickhouse_51_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 VALUES ( 1, REPEAT('x', 104) ); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (1, repeat('x', 104));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (f1 INTEGER,f2 LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (f1 INTEGER, f2 String) ENGINE = MergeTree ORDER BY f1;"
    ]
  },
  {
    "sql_id": "clickhouse_51_7",
    "database_name": "clickhouse_51_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT CONCAT(f1, '') AS dummy FROM t1 ORDER BY dummy; -- CONCAT",
    "target_query": "SELECT concat(f1, '') AS dummy FROM t1 ORDER BY dummy;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( f1 VARCHAR(100) );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (f1 String) ENGINE = MergeTree ORDER BY f1;"
    ]
  },
  {
    "sql_id": "clickhouse_51_11",
    "database_name": "clickhouse_51_11",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT * FROM t1 ORDER BY UNIX_TIMESTAMP(f1); -- UNIX_TIMESTAMP",
    "target_query": "SELECT * FROM t1 ORDER BY toUnixTimestamp(f1);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "UNIX_TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "UNIX_TIMESTAMP(expr)",
        "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
        "examples": [
          "SELECT UNIX_TIMESTAMP(NOW());",
          "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
          "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toUnixTimestamp(timestamp)",
        "description": "Converts a DateTime string or value to a Unix timestamp (seconds since 1970-01-01 UTC).",
        "examples": [
          "SELECT toUnixTimestamp(now());",
          "SELECT toUnixTimestamp('2015-11-13 23:59:59+02:00');",
          "SELECT toUnixTimestamp('2038-01-19 04:14:07');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( f1 INTEGER );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (f1 DATE) ENGINE = MergeTree ORDER BY f1;"
    ]
  },
  {
    "sql_id": "clickhouse_51_15",
    "database_name": "clickhouse_51_15",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT 'a' AS f1 FROM t1 WHERE a='8' GROUP BY f1 ORDER BY CONCAT(f1); -- CONCAT",
    "target_query": "SELECT 'a' AS f1 FROM t1 WHERE a='8' GROUP BY f1 ORDER BY concat(f1);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a LONGTEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a String) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_51_18",
    "database_name": "clickhouse_51_18",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 VALUES (1, REPEAT('x', 40001)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (1, repeat('x', 40001));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INTEGER, b String) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_51_19",
    "database_name": "clickhouse_51_19",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 VALUES (2, REPEAT('x', 40002)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (2, repeat('x', 40002));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INTEGER, b String) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_51_20",
    "database_name": "clickhouse_51_20",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 VALUES (3, REPEAT('x', 40003)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (3, repeat('x', 40003));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INTEGER, b String) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_51_21",
    "database_name": "clickhouse_51_21",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 VALUES (4, REPEAT('x', 40005)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (4, repeat('x', 40005));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INTEGER, b String) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_51_22",
    "database_name": "clickhouse_51_22",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 VALUES (5, REPEAT('x', 40008)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (5, repeat('x', 40008));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INTEGER, b String) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_51_23",
    "database_name": "clickhouse_51_23",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 VALUES (6, REPEAT('x', 40013)); -- REPEAT",
    "target_query": "INSERT INTO t1 VALUES (6, repeat('x', 40013));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INTEGER, b String) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_51_24",
    "database_name": "clickhouse_51_24",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT a, LENGTH(b) FROM t1 ORDER BY a DESC; -- LENGTH",
    "target_query": "SELECT a, length(b) FROM t1 ORDER BY a DESC;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 ( a INTEGER, b TEXT );"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INTEGER, b String) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_52_13",
    "database_name": "clickhouse_52_13",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) > 3; -- LENGTH",
    "target_query": "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) > 3;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(col1_idx INT DEFAULT NULL,col2_idx INT DEFAULT NULL,col3 INT DEFAULT NULL,col4 INT NOT NULL,vc VARCHAR(30),vc_ft VARCHAR(30));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(col1_idx Int32,col2_idx Int32,col3 Int32,col4 Int32 NOT NULL,vc String,vc_ft String) ENGINE = MergeTree ORDER BY col1_idx;"
    ]
  },
  {
    "sql_id": "clickhouse_52_14",
    "database_name": "clickhouse_52_14",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) = 3; -- LENGTH",
    "target_query": "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) = 3;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(col1_idx INT DEFAULT NULL,col2_idx INT DEFAULT NULL,col3 INT DEFAULT NULL,col4 INT NOT NULL,vc VARCHAR(30),vc_ft VARCHAR(30));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(col1_idx Int32,col2_idx Int32,col3 Int32,col4 Int32 NOT NULL,vc String,vc_ft String) ENGINE = MergeTree ORDER BY col1_idx;"
    ]
  },
  {
    "sql_id": "clickhouse_52_15",
    "database_name": "clickhouse_52_15",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) IS NULL; -- LENGTH",
    "target_query": "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) IS NULL;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(col1_idx INT DEFAULT NULL,col2_idx INT DEFAULT NULL,col3 INT DEFAULT NULL,col4 INT NOT NULL,vc VARCHAR(30),vc_ft VARCHAR(30));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(col1_idx Int32,col2_idx Int32,col3 Int32,col4 Int32 NOT NULL,vc String,vc_ft String) ENGINE = MergeTree ORDER BY col1_idx;"
    ]
  },
  {
    "sql_id": "clickhouse_52_16",
    "database_name": "clickhouse_52_16",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) IS NOT NULL; -- LENGTH",
    "target_query": "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) IS NOT NULL;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(col1_idx INT DEFAULT NULL,col2_idx INT DEFAULT NULL,col3 INT DEFAULT NULL,col4 INT NOT NULL,vc VARCHAR(30),vc_ft VARCHAR(30));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(col1_idx Int32,col2_idx Int32,col3 Int32,col4 Int32 NOT NULL,vc String,vc_ft String) ENGINE = MergeTree ORDER BY col1_idx;"
    ]
  },
  {
    "sql_id": "clickhouse_53_12",
    "database_name": "clickhouse_53_12",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t VALUES(REPEAT(x'0a',1000)); -- REPEAT",
    "target_query": "INSERT INTO t VALUES(repeat(x'0a',1000));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t(b BLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t(b String) ENGINE = MergeTree ORDER BY b;"
    ]
  },
  {
    "sql_id": "clickhouse_53_15",
    "database_name": "clickhouse_53_15",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t VALUES(1, REPEAT('2', 257)), (1, REPEAT('1', 257)); -- REPEAT",
    "target_query": "INSERT INTO t VALUES(1,repeat('2',257)),(1,repeat('1',257));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t (gid int, a varbinary(514));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t (gid Int32,a String) ENGINE = MergeTree ORDER BY gid;"
    ]
  },
  {
    "sql_id": "clickhouse_53_18",
    "database_name": "clickhouse_53_18",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t VALUES(1, REPEAT('2', 255)), (1, REPEAT('1', 255)); -- REPEAT",
    "target_query": "INSERT INTO t VALUES(1,repeat('2',255)),(1,repeat('1',255));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t (gid int, a varbinary(511));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t (gid Int32,a String) ENGINE = MergeTree ORDER BY gid;"
    ]
  },
  {
    "sql_id": "clickhouse_53_21",
    "database_name": "clickhouse_53_21",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t VALUES(1, REPEAT('2', 32750), REPEAT('1', 32750)); -- REPEAT",
    "target_query": "INSERT INTO t VALUES(1,repeat('2',32750),repeat('1',32750));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t (gid int, a varbinary(65500), b blob);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t (gid Int32,a String,b String) ENGINE = MergeTree ORDER BY gid;"
    ]
  },
  {
    "sql_id": "clickhouse_54_2",
    "database_name": "clickhouse_54_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "insert t1 values (NULL), ('A\\0\\0\\0BBBBBBBB'), (SPACE(50000)), (SPACE(50000)); -- SPACE",
    "target_query": "insert into t1 values (NULL), ('A\\0\\0\\0BBBBBBBB'), (repeat(' ', 50000)), (repeat(' ', 50000));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "SPACE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SPACE(n)",
        "description": "Returns a string consisting of n space characters.",
        "examples": [
          "SELECT LENGTH(SPACE(5));",
          "SELECT CONCAT('A', SPACE(3), 'B');",
          "SELECT CONCAT(REPEAT('-', 2), SPACE(4), '!');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(' ', n)",
        "description": "Returns a string consisting of n space characters by repeating a space character.",
        "examples": [
          "SELECT length(repeat(' ', 5));",
          "SELECT concat('A', repeat(' ', 3), 'B');",
          "SELECT concat(repeat('-', 2), repeat(' ', 4), '!');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a BLOB);"
    ],
    "target_related_schemas": [
      "create table t1 (a String)ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_54_3",
    "database_name": "clickhouse_54_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select length(a) from t1; -- LENGTH",
    "target_query": "select length(a) from t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a BLOB);"
    ],
    "target_related_schemas": [
      "create table t1 (a String)ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_55_3",
    "database_name": "clickhouse_55_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select * from t1 where concat(A,C,B,D) = 'AAAA2003-03-011051'; -- CONCAT",
    "target_query": "SELECT * FROM t1 WHERE concat(a, c, b, d) = 'AAAA2003-03-011051';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a char(4), b double, c date, d tinyint(4));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a String, b Float64, c Date, d Int8) ENGINE = MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_55_5",
    "database_name": "clickhouse_55_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select 'a' union select concat('a', -4); -- CONCAT",
    "target_query": "SELECT 'a' UNION ALL SELECT concat('a', -4);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_55_6",
    "database_name": "clickhouse_55_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select 'a' union select concat('a', -4.5); -- CONCAT",
    "target_query": "SELECT 'a' UNION ALL SELECT concat('a', -4.5);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_55_7",
    "database_name": "clickhouse_55_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select 'a' union select concat('a', -(4 + 1)); -- CONCAT",
    "target_query": "SELECT 'a' UNION ALL SELECT concat('a', -(4 + 1));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_55_8",
    "database_name": "clickhouse_55_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select 'a' union select concat('a', 4 - 5); -- CONCAT",
    "target_query": "SELECT 'a' UNION ALL SELECT concat('a', 4 - 5);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_55_11",
    "database_name": "clickhouse_55_11",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select 'a' union select concat('a', -0); -- CONCAT",
    "target_query": "SELECT 'a' UNION ALL SELECT concat('a', -0);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_55_12",
    "database_name": "clickhouse_55_12",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select 'a' union select concat('a', -0.0); -- CONCAT",
    "target_query": "SELECT 'a' UNION ALL SELECT concat('a', -0.0);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_55_13",
    "database_name": "clickhouse_55_13",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select 'a' union select concat('a', -0.0000); -- CONCAT",
    "target_query": "SELECT 'a' UNION ALL SELECT concat('a', -0.0000);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_55_14",
    "database_name": "clickhouse_55_14",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select concat((select x from (select 'a' as x) as t1 ),(select y from (select 'b' as y) as t2 )) from (select 1 union select 2 )as t3; -- CONCAT",
    "target_query": "SELECT concat((SELECT x FROM (SELECT 'a' AS x) AS t1), (SELECT y FROM (SELECT 'b' AS y) AS t2)) FROM (SELECT 1 UNION ALL SELECT 2) AS t3;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_55_17",
    "database_name": "clickhouse_55_17",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select concat(f1, 2) a from t1 union select 'x' a from t1; -- CONCAT",
    "target_query": "SELECT concat(f1, toString(2)) AS a FROM t1 UNION ALL SELECT 'x' AS a FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1(f1 varchar(6));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(f1 String) ENGINE = MergeTree ORDER BY f1;"
    ]
  },
  {
    "sql_id": "clickhouse_55_21",
    "database_name": "clickhouse_55_21",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT * FROM t1 WHERE CONCAT(c1,' ',c2) REGEXP 'First.*'; -- CONCAT",
    "target_query": "SELECT * FROM t1 WHERE concat(c1, ' ', c2) REGEXP 'First.*';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (c1 varchar(100), c2 varchar(100));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 String, c2 String) ENGINE = MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_56_2",
    "database_name": "clickhouse_56_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "insert into t1 values (date_add(NULL, INTERVAL 1 DAY)); -- DATE_ADD",
    "target_query": "INSERT INTO t1 VALUES (addDays(NULL, 1));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_ADD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_ADD(datetime_expr, INTERVAL expr unit)",
        "description": "Adds a time interval to a date or datetime value.",
        "examples": [
          "SELECT DATE_ADD('2020-01-01', INTERVAL 10 DAY);",
          "SELECT DATE_ADD('2020-01-01 12:00:00', INTERVAL 3 HOUR);",
          "SELECT DATE_ADD('2020-12-31', INTERVAL 1 MONTH);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "addDays(datetime, n), addHours(datetime, n), ...",
        "description": "Adds a specific time interval to a datetime using functions like addDays or addHours.",
        "examples": [
          "SELECT addDays(toDateTime('2020-01-01'), 10);",
          "SELECT addHours(toDateTime('2020-01-01 12:00:00'), 3);",
          "SELECT addMonths(toDateTime('2020-12-31'), 1);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (d date);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (d Date) ENGINE = MergeTree ORDER BY d;"
    ]
  },
  {
    "sql_id": "clickhouse_56_3",
    "database_name": "clickhouse_56_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "insert into t1 values (date_add('2000-01-04', INTERVAL NULL DAY)); -- DATE_ADD",
    "target_query": "INSERT INTO t1 VALUES (addDays(toDateTime('2000-01-04'), 1));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_ADD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_ADD(datetime_expr, INTERVAL expr unit)",
        "description": "Adds a time interval to a date or datetime value.",
        "examples": [
          "SELECT DATE_ADD('2020-01-01', INTERVAL 10 DAY);",
          "SELECT DATE_ADD('2020-01-01 12:00:00', INTERVAL 3 HOUR);",
          "SELECT DATE_ADD('2020-12-31', INTERVAL 1 MONTH);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "addDays(datetime, n), addHours(datetime, n), ...",
        "description": "Adds a specific time interval to a datetime using functions like addDays or addHours.",
        "examples": [
          "SELECT addDays(toDateTime('2020-01-01'), 10);",
          "SELECT addHours(toDateTime('2020-01-01 12:00:00'), 3);",
          "SELECT addMonths(toDateTime('2020-12-31'), 1);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (d date);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (d Date) ENGINE = MergeTree ORDER BY d;"
    ]
  },
  {
    "sql_id": "clickhouse_56_4",
    "database_name": "clickhouse_56_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "insert into t1 values (date_add(NULL, INTERVAL 1 DAY)); -- DATE_ADD",
    "target_query": "INSERT INTO t1 VALUES (addDays(NULL, 1));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_ADD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_ADD(datetime_expr, INTERVAL expr unit)",
        "description": "Adds a time interval to a date or datetime value.",
        "examples": [
          "SELECT DATE_ADD('2020-01-01', INTERVAL 10 DAY);",
          "SELECT DATE_ADD('2020-01-01 12:00:00', INTERVAL 3 HOUR);",
          "SELECT DATE_ADD('2020-12-31', INTERVAL 1 MONTH);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "addDays(datetime, n), addHours(datetime, n), ...",
        "description": "Adds a specific time interval to a datetime using functions like addDays or addHours.",
        "examples": [
          "SELECT addDays(toDateTime('2020-01-01'), 10);",
          "SELECT addHours(toDateTime('2020-01-01 12:00:00'), 3);",
          "SELECT addMonths(toDateTime('2020-12-31'), 1);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (d date);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (d Date) ENGINE = MergeTree ORDER BY d;"
    ]
  },
  {
    "sql_id": "clickhouse_56_5",
    "database_name": "clickhouse_56_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "insert into t1 values (date_add('2000-01-04', INTERVAL 1 DAY)); -- DATE_ADD",
    "target_query": "INSERT INTO t1 VALUES (addDays(toDateTime('2000-01-04'), 1));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_ADD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_ADD(datetime_expr, INTERVAL expr unit)",
        "description": "Adds a time interval to a date or datetime value.",
        "examples": [
          "SELECT DATE_ADD('2020-01-01', INTERVAL 10 DAY);",
          "SELECT DATE_ADD('2020-01-01 12:00:00', INTERVAL 3 HOUR);",
          "SELECT DATE_ADD('2020-12-31', INTERVAL 1 MONTH);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "addDays(datetime, n), addHours(datetime, n), ...",
        "description": "Adds a specific time interval to a datetime using functions like addDays or addHours.",
        "examples": [
          "SELECT addDays(toDateTime('2020-01-01'), 10);",
          "SELECT addHours(toDateTime('2020-01-01 12:00:00'), 3);",
          "SELECT addMonths(toDateTime('2020-12-31'), 1);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (d date);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (d Date) ENGINE = MergeTree ORDER BY d;"
    ]
  },
  {
    "sql_id": "clickhouse_56_7",
    "database_name": "clickhouse_56_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT DATE(ts) = CURRENT_DATE + INTERVAL '1' DAY AS is_tomorrow, TIME(ts)FROM (SELECT ADDDATE(TIME'00:00:00', INTERVAL 1 DAY) AS ts) AS dt; -- DATE",
    "target_query": "SELECT toDate(ts) = addDays(today(), 1) AS is_tomorrow,toTime(ts) AS time_part FROM (SELECT addDays(toDateTime('1970-01-01 00:00:00'), 1) AS ts) AS dt;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE()",
        "description": "In MySQL, the DATE function extracts the date part from a DATETIME or TIMESTAMP value.",
        "examples": [
          "SELECT DATE('2023-05-01 12:34:56') AS result;",
          "SELECT DATE(NOW()) AS current_date_result;",
          "SELECT DATE(CAST('2023-05-01' AS DATETIME)) AS date_from_datetime;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toDate()",
        "description": "ClickHouse uses the toDate() function to convert a DATETIME or String to a DATE type.",
        "examples": [
          "SELECT toDate('2023-05-01 12:34:56') AS result;",
          "SELECT toDate(now()) AS current_date_result;",
          "SELECT toDate(CAST('2023-05-01' AS String)) AS date_from_datetime;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_57_3",
    "database_name": "clickhouse_57_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select * from t1 where isnull(to_days(mydate)); -- ISNULL, TO_DAYS",
    "target_query": "select * from t1 where isnull(to_days(mydate)); -- ISNULL, TO_DAYS",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ISNULL",
      "TO_DAYS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ISNULL(expr)",
        "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
        "examples": [
          "SELECT ISNULL(NULL);",
          "SELECT ISNULL(5 + NULL);",
          "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
        ]
      },
      {
        "expression": "TO_DAYS(date)",
        "description": "Returns the number of days since 0000-01-01 for a given date.",
        "examples": [
          "SELECT TO_DAYS('2024-05-07');",
          "SELECT TO_DAYS(CURDATE());",
          "SELECT TO_DAYS('1999-12-31 23:59:59');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "expr IS NULL",
        "description": "Checks whether an expression is NULL.",
        "examples": [
          "SELECT NULL IS NULL;",
          "SELECT (number / NULL) IS NULL FROM numbers(1);",
          "SELECT IF(score IS NULL, 'N/A', toString(score)) FROM student_scores;"
        ]
      },
      {
        "expression": "toRelativeDayNum(date) + 719528",
        "description": "Adds offset to the days since 1970-01-01.",
        "examples": [
          "SELECT toRelativeDayNum(toDate('2024-05-07')) + 719528;",
          "SELECT toRelativeDayNum(today()) + 719528;",
          "SELECT toRelativeDayNum(toDate('1999-12-31')) + 719528;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (id int primary key not null, mydate date not null);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id Int32, mydate Date NOT NULL) ENGINE = MergeTree ORDER BY id;"
    ]
  },
  {
    "sql_id": "clickhouse_58_5",
    "database_name": "clickhouse_58_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select * from t1 where a like concat(\"abc\",\"%\"); -- CONCAT",
    "target_query": "SELECT * FROM t1 WHERE a LIKE concat('abc','%');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a varchar(10));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a String) ENGINE = TinyLog;"
    ]
  },
  {
    "sql_id": "clickhouse_59_0",
    "database_name": "clickhouse_59_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL); -- LN",
    "target_query": "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LN"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LN(x)",
        "description": "The LN() function returns the natural logarithm of x. If x is less than or equal to 0, it returns NULL.",
        "examples": [
          "select ln(exp(10));",
          "select exp(ln(sqrt(10)) * 2);",
          "select ln(-1);",
          "select ln(0);",
          "select ln(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LN(x)",
        "description": "In ClickHouse, the LN() function returns the natural logarithm of x. For negative or zero values, it returns NaN (Not a Number).",
        "examples": [
          "select ln(exp(10));",
          "select exp(ln(sqrt(10)) * 2);",
          "select ln(-1);",
          "select ln(0);",
          "select ln(NULL);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_59_1",
    "database_name": "clickhouse_59_1",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select log2(8),log2(15),log2(NULL); -- LOG2",
    "target_query": "select log2(8),log2(15),log2(NULL);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LOG2"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LOG2(number)",
        "description": "Returns the logarithm of a number with base 2. Returns NULL for zero or negative numbers.",
        "examples": [
          "SELECT LOG2(8);",
          "SELECT LOG2(15);",
          "SELECT LOG2(-2);",
          "SELECT LOG2(0);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "log2(number)",
        "description": "Returns the logarithm of a number with base 2. Returns NULL for zero or negative numbers.",
        "examples": [
          "SELECT log2(8);",
          "SELECT log2(15);",
          "SELECT log2(-2);",
          "SELECT log2(0);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_59_2",
    "database_name": "clickhouse_59_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select pow(10,log10(10)),power(2,4); -- POW, POWER",
    "target_query": "select pow(10,log10(10)),pow(2,4);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "POW",
      "POWER"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "POW(3, 3)",
        "description": "POW(x, y) in MySQL is used to calculate x raised to the power of y. It returns the result of x^y.",
        "examples": [
          "SELECT POW(3, 3);",
          "SELECT POW(5, 4);",
          "SELECT POW(x, 2) FROM some_table;"
        ]
      },
      {
        "expression": "SELECT POW(10, 2), POWER(2, 3), POWER(3, 3);",
        "description": "Calculates the power of a number: POW(10, 2) returns 100, POWER(2, 3) returns 8, POWER(3, 3) returns 27.",
        "examples": [
          "SELECT POW(5, 2);",
          "SELECT POWER(3, 4);",
          "SELECT POWER(10, 0);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POW(3, 3)",
        "description": "ClickHouse supports the POW() function to calculate x raised to the power of y.",
        "examples": [
          "SELECT POW(3, 3);",
          "SELECT POW(5, 4);",
          "SELECT POW(x, 2) FROM some_table;"
        ]
      },
      {
        "expression": "SELECT POW(10, 2), POW(2, 3), POW(3, 3);",
        "description": "Calculates the power of a number: POW(10, 2) returns 100, POW(2, 3) returns 8, POW(3, 3) returns 27.",
        "examples": [
          "SELECT POW(5, 2);",
          "SELECT POW(3, 4);",
          "SELECT POW(10, 0);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_59_3",
    "database_name": "clickhouse_59_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select ceil(0.09); -- CEIL",
    "target_query": "select ceil(0.09);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CEIL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CEIL(x)",
        "description": "Returns the smallest integer value not less than x (rounds up).",
        "examples": [
          "SELECT CEIL(1.3);",
          "SELECT CEIL(-2.8);",
          "SELECT CEIL(RAND() * 100);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "ceil(x)",
        "description": "Rounds x upward to the smallest following integer.",
        "examples": [
          "SELECT ceil(1.3);",
          "SELECT ceil(-2.8);",
          "SELECT ceil(rand() % 100 + 0.123);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_59_4",
    "database_name": "clickhouse_59_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select ceil(0.000000000000000009); -- CEIL",
    "target_query": "select ceil(0.000000000000000009);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CEIL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CEIL(x)",
        "description": "Returns the smallest integer value not less than x (rounds up).",
        "examples": [
          "SELECT CEIL(1.3);",
          "SELECT CEIL(-2.8);",
          "SELECT CEIL(RAND() * 100);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "ceil(x)",
        "description": "Rounds x upward to the smallest following integer.",
        "examples": [
          "SELECT ceil(1.3);",
          "SELECT ceil(-2.8);",
          "SELECT ceil(rand() % 100 + 0.123);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_59_7",
    "database_name": "clickhouse_59_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "insert into t1 values ('http://www.foo.com/', now()); -- NOW",
    "target_query": "insert into t1 values ('http://www.foo.com/', now());",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "NOW()",
        "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
        "examples": [
          "SELECT NOW();",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (NOW());"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "now()",
        "description": "ClickHouse uses the now() function to return the current date and time, which is equivalent to MySQL's NOW() function.",
        "examples": [
          "SELECT now();",
          "CREATE TABLE t12 AS SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > now()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (now());"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a varchar(90), ts datetime not null);"
    ],
    "target_related_schemas": [
      "create table t1 (a String, ts DateTime not null)ENGINE=TinyLog;"
    ]
  },
  {
    "sql_id": "clickhouse_59_8",
    "database_name": "clickhouse_59_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select a from t1 where a='http://www.foo.com/' order by abs(timediff(ts, 0)); -- TIMEDIFF",
    "target_query": "select a from t1 where a='http://www.foo.com/' order by abs(dateDiff('second', toDateTime('1970-01-01 00:00:00'), ts));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "dateDiff('second', toDateTime('2023-06-15 10:00:00'), toDateTime('2023-06-15 12:00:00'))",
        "description": "ClickHouse uses the dateDiff function to calculate the difference between two datetime values in various units.",
        "examples": [
          "SELECT dateDiff('second', toDateTime('2023-06-15 12:00:00'), toDateTime('2023-06-15 10:00:00'));",
          "SELECT dateDiff('second', now(), toDateTime('2023-06-15 10:00:00'));",
          "SELECT dateDiff('second', toDateTime('2023-06-15 12:00:00'), toDateTime('2023-06-15 10:00:00'));"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a varchar(90), ts datetime not null);"
    ],
    "target_related_schemas": [
      "create table t1 (a String, ts DateTime not null)ENGINE=TinyLog;"
    ]
  },
  {
    "sql_id": "clickhouse_59_10",
    "database_name": "clickhouse_59_10",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select mod(cast(-2 as unsigned), 3), mod(18446744073709551614, 3), mod(-2, 3); -- MOD",
    "target_query": "select mod(cast(-2 as UInt64), 3), mod(18446744073709551614, 3), mod(-2, 3);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MOD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Returns the remainder of N divided by M. Returns NULL if M = 0.",
        "examples": [
          "SELECT MOD(10, 3);",
          "SELECT 10 % 3;",
          "SELECT MOD(5, 0);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Modulo operation. Returns remainder. Division by zero errors.",
        "examples": [
          "SELECT MOD(11, 5);",
          "SELECT 11 % 5;",
          "SELECT MOD(number, 3) FROM numbers(10);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_59_11",
    "database_name": "clickhouse_59_11",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select mod(5, cast(-2 as unsigned)), mod(5, 18446744073709551614), mod(5, -2); -- MOD",
    "target_query": "select mod(5, cast(-2 as UInt64)), mod(5, 18446744073709551614), mod(5, -2);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MOD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Returns the remainder of N divided by M. Returns NULL if M = 0.",
        "examples": [
          "SELECT MOD(10, 3);",
          "SELECT 10 % 3;",
          "SELECT MOD(5, 0);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Modulo operation. Returns remainder. Division by zero errors.",
        "examples": [
          "SELECT MOD(11, 5);",
          "SELECT 11 % 5;",
          "SELECT MOD(number, 3) FROM numbers(10);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_59_12",
    "database_name": "clickhouse_59_12",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select pow(cast(-2 as unsigned), 5), pow(18446744073709551614, 5), pow(-2, 5); -- POW",
    "target_query": "select pow(cast(-2 as UInt64), 5), pow(18446744073709551614, 5), pow(-2, 5);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "POW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "POW(3, 3)",
        "description": "POW(x, y) in MySQL is used to calculate x raised to the power of y. It returns the result of x^y.",
        "examples": [
          "SELECT POW(3, 3);",
          "SELECT POW(5, 4);",
          "SELECT POW(x, 2) FROM some_table;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POW(3, 3)",
        "description": "ClickHouse supports the POW() function to calculate x raised to the power of y.",
        "examples": [
          "SELECT POW(3, 3);",
          "SELECT POW(5, 4);",
          "SELECT POW(x, 2) FROM some_table;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_59_15",
    "database_name": "clickhouse_59_15",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT DISTINCT (a DIV 254576881) FROM t1; -- DIV",
    "target_query": "SELECT DISTINCT intDiv(toInt64(a), 254576881)FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DIV"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "a DIV b",
        "description": "Performs integer division between two numbers and returns the floor of the quotient.",
        "examples": [
          "SELECT 10 DIV 3;",
          "SELECT 5.8 DIV 2;",
          "SELECT 9 DIV 4 + 1;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "intDiv(a, b)",
        "description": "Returns integer division result by discarding any fractional part.",
        "examples": [
          "SELECT intDiv(10, 3);",
          "SELECT intDiv(6, 2);",
          "SELECT intDiv(9, 4) + 1;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(a LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(a String) ENGINE=TinyLog;"
    ]
  },
  {
    "sql_id": "clickhouse_60_0",
    "database_name": "clickhouse_60_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT ROUND(LEAST(15, -4939092, 0.2704)); -- LEAST, STDDEV",
    "target_query": "SELECT ROUND(least(15, -4939092, 0.2704));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST",
      "STDDEV"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      },
      {
        "expression": "STDDEV(amount)",
        "description": "The STDDEV function calculates the standard deviation of a numeric column in a database. It returns a measure of the amount of variation or dispersion of a set of values.",
        "examples": [
          "SELECT STDDEV(amount) FROM sales;",
          "SELECT STDDEV(amount) OVER (ROWS 2 PRECEDING) FROM sales;",
          "SELECT id, STDDEV(amount) OVER (PARTITION BY region ORDER BY amount) AS region_stddev FROM sales;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the smallest non-null value among arguments. NULLs are ignored unless all arguments are NULL. Use ifNull() when explicit NULL handling is needed.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(toDate('2024-01-01'), toDate('2023-12-31'));",
          "SELECT ifNull(least(NULL, 2), NULL);"
        ]
      },
      {
        "expression": "stddevSamp(amount)",
        "description": "ClickHouse uses the stddevSamp function to calculate the sample standard deviation of a column's values.",
        "examples": [
          "SELECT stddevSamp(amount) FROM sales;",
          "SELECT stddevSamp(amount) OVER (ROWS 2 PRECEDING) FROM sales;",
          "SELECT id, stddevSamp(amount) OVER (PARTITION BY region ORDER BY amount) AS region_stddev FROM sales;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_60_1",
    "database_name": "clickhouse_60_1",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select (1.175494351E-37 div 1.7976931348623157E+308); -- DIV",
    "target_query": "select (1.175494351E-37 / 1.7976931348623157E+308);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DIV"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "a DIV b",
        "description": "Performs integer division between two numbers and returns the floor of the quotient.",
        "examples": [
          "SELECT 10 DIV 3;",
          "SELECT 5.8 DIV 2;",
          "SELECT 9 DIV 4 + 1;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "intDiv(a, b)",
        "description": "Returns integer division result by discarding any fractional part.",
        "examples": [
          "SELECT intDiv(10, 3);",
          "SELECT intDiv(6, 2);",
          "SELECT intDiv(9, 4) + 1;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_60_4",
    "database_name": "clickhouse_60_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO t1 VALUES (ln(1)); -- LN",
    "target_query": "INSERT INTO t1 VALUES (ln(1));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LN"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LN(x)",
        "description": "The LN() function returns the natural logarithm of x. If x is less than or equal to 0, it returns NULL.",
        "examples": [
          "select ln(exp(10));",
          "select exp(ln(sqrt(10)) * 2);",
          "select ln(-1);",
          "select ln(0);",
          "select ln(NULL);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LN(x)",
        "description": "In ClickHouse, the LN() function returns the natural logarithm of x. For negative or zero values, it returns NaN (Not a Number).",
        "examples": [
          "select ln(exp(10));",
          "select exp(ln(sqrt(10)) * 2);",
          "select ln(-1);",
          "select ln(0);",
          "select ln(NULL);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(a DOUBLE);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(a DOUBLE)ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_60_6",
    "database_name": "clickhouse_60_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT floor(ceil(123456789)); -- CEIL",
    "target_query": "SELECT floor(ceil(123456789));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CEIL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CEIL(x)",
        "description": "Returns the smallest integer value not less than x (rounds up).",
        "examples": [
          "SELECT CEIL(1.3);",
          "SELECT CEIL(-2.8);",
          "SELECT CEIL(RAND() * 100);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "ceil(x)",
        "description": "Rounds x upward to the smallest following integer.",
        "examples": [
          "SELECT ceil(1.3);",
          "SELECT ceil(-2.8);",
          "SELECT ceil(rand() % 100 + 0.123);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_60_7",
    "database_name": "clickhouse_60_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select cast(pow(2,63)-1024 as signed) as pp; -- POW",
    "target_query": "select cast(pow(2,63)-1024 as signed) as pp;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "POW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "POW(3, 3)",
        "description": "POW(x, y) in MySQL is used to calculate x raised to the power of y. It returns the result of x^y.",
        "examples": [
          "SELECT POW(3, 3);",
          "SELECT POW(5, 4);",
          "SELECT POW(x, 2) FROM some_table;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POW(3, 3)",
        "description": "ClickHouse supports the POW() function to calculate x raised to the power of y.",
        "examples": [
          "SELECT POW(3, 3);",
          "SELECT POW(5, 4);",
          "SELECT POW(x, 2) FROM some_table;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_60_8",
    "database_name": "clickhouse_60_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select cast(1-pow(2,63) as signed) as qq; -- POW",
    "target_query": "select cast(1-pow(2,63) as signed) as qq;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "POW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "POW(3, 3)",
        "description": "POW(x, y) in MySQL is used to calculate x raised to the power of y. It returns the result of x^y.",
        "examples": [
          "SELECT POW(3, 3);",
          "SELECT POW(5, 4);",
          "SELECT POW(x, 2) FROM some_table;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "POW(3, 3)",
        "description": "ClickHouse supports the POW() function to calculate x raised to the power of y.",
        "examples": [
          "SELECT POW(3, 3);",
          "SELECT POW(5, 4);",
          "SELECT POW(x, 2) FROM some_table;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_60_12",
    "database_name": "clickhouse_60_12",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT * FROM t0 WHERE CAST(COALESCE(t0.c0, -1) AS UNSIGNED); -- COALESCE",
    "target_query": "SELECT * FROM t0 WHERE CAST(coalesce(t0.c0, -1) AS UInt8);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "coalesce(expr1, expr2, ...)",
        "description": "ClickHouse supports COALESCE via SQL-compatible functions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t0(c0 BIGINT UNSIGNED);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0(c0 UInt64)ENGINE=MergeTree ORDER BY c0;"
    ]
  },
  {
    "sql_id": "clickhouse_60_13",
    "database_name": "clickhouse_60_13",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT * FROM t0 WHERE CAST(IFNULL(t0.c0, -1) AS UNSIGNED); -- IFNULL",
    "target_query": "SELECT * FROM t0 WHERE CAST(ifNull(t0.c0, -1) AS UInt8);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "IFNULL"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "IFNULL(expr1, expr2)",
        "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
        "examples": [
          "SELECT IFNULL(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "ifNull(expr1, expr2)",
        "description": "ClickHouse's ifNull is functionally equivalent to MySQL's IFNULL. It returns expr2 if expr1 is NULL; otherwise, it returns expr1.",
        "examples": [
          "SELECT ifNull(NULL, NULL);",
          "CREATE TABLE t13 AS SELECT ifNull(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
          "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = ifNull(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t0(c0 BIGINT UNSIGNED);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0(c0 UInt64)ENGINE=MergeTree ORDER BY c0;"
    ]
  },
  {
    "sql_id": "clickhouse_60_14",
    "database_name": "clickhouse_60_14",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT CAST(COALESCE(t0.c0, -1) AS UNSIGNED) IS TRUE FROM t0; -- COALESCE",
    "target_query": "SELECT CAST(coalesce(t0.c0, -1) AS UInt8) !=0 FROM t0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "coalesce(expr1, expr2, ...)",
        "description": "ClickHouse supports COALESCE via SQL-compatible functions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t0(c0 BIGINT UNSIGNED);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0(c0 UInt64)ENGINE=MergeTree ORDER BY c0;"
    ]
  },
  {
    "sql_id": "clickhouse_60_15",
    "database_name": "clickhouse_60_15",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT CAST(COALESCE(t0.c0, -1) AS UNSIGNED) FROM t0; -- COALESCE",
    "target_query": "SELECT CAST(coalesce(t0.c0, -1) AS UInt8) FROM t0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "COALESCE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
        "description": "Returns the first non-NULL value, or merges table partitions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
          "ALTER TABLE t1 COALESCE PARTITION 2;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "coalesce(expr1, expr2, ...)",
        "description": "ClickHouse supports COALESCE via SQL-compatible functions.",
        "examples": [
          "SELECT COALESCE(a, '') FROM t1;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t0(c0 BIGINT UNSIGNED);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0(c0 UInt64)ENGINE=MergeTree ORDER BY c0;"
    ]
  },
  {
    "sql_id": "clickhouse_61_0",
    "database_name": "clickhouse_61_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select md5('a'), hex(md5('a')); -- MD5, HEX",
    "target_query": "SELECT MD5('a'), HEX(MD5('a'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MD5",
      "HEX"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      },
      {
        "expression": "HEX(N)",
        "description": "Converts the given numeric or string value to a hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      },
      {
        "expression": "HEX(N)",
        "description": "Converts a numeric or string value to its hexadecimal representation.",
        "examples": [
          "SELECT HEX(255);",
          "SELECT HEX('abc');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_61_2",
    "database_name": "clickhouse_61_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "create table t1 as select md5('a') as c1; -- MD5",
    "target_query": "CREATE TABLE t1 engine=TinyLog AS SELECT MD5('a') AS c1 ;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MD5"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 as select md5('a') as c1; -- MD5"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 engine=TinyLog AS SELECT MD5('a') AS c1 ;"
    ]
  },
  {
    "sql_id": "clickhouse_61_4",
    "database_name": "clickhouse_61_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select md5('hello'); -- MD5",
    "target_query": "SELECT MD5('hello');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MD5"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_61_5",
    "database_name": "clickhouse_61_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "explain select md5('hello'); -- MD5",
    "target_query": "EXPLAIN SELECT MD5('hello');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MD5"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_61_6",
    "database_name": "clickhouse_61_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select length(unhex(md5(\"abrakadabra\"))); -- LENGTH, UNHEX, MD5",
    "target_query": "SELECT length(unhex(MD5('abrakadabra')));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LENGTH",
      "UNHEX",
      "MD5"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      },
      {
        "expression": "UNHEX(str)",
        "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT HEX(UNHEX('4D7953514C'));",
          "SELECT UNHEX('48656C6C6F');",
          "SELECT UNHEX(NULL);"
        ]
      },
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      },
      {
        "expression": "unhex(str)",
        "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
        "examples": [
          "SELECT hex(unhex('4D7953514C'));",
          "SELECT unhex('48656C6C6F');",
          "SELECT unhex(NULL);"
        ]
      },
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_61_8",
    "database_name": "clickhouse_61_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "insert into t1 values ( 'test',md5('test')), ('test', md5('test')); -- MD5",
    "target_query": "INSERT INTO t1 VALUES ('test', MD5('test')), ('test', MD5('test'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MD5"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (f1 varchar(4), f2 varchar(64));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (f1 String, f2 String)engine=MergeTree ORDER BY f1;"
    ]
  },
  {
    "sql_id": "clickhouse_61_9",
    "database_name": "clickhouse_61_9",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select * from t1 where f1='test' and (f2= md5(\"test\") or f2= md5(\"Test\")); -- MD5",
    "target_query": "SELECT * FROM t1 WHERE f1 = 'test' AND (f2 = MD5('test') OR f2 = MD5('TEST'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MD5"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (f1 varchar(4), f2 varchar(64));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (f1 String, f2 String)engine=MergeTree ORDER BY f1;"
    ]
  },
  {
    "sql_id": "clickhouse_61_10",
    "database_name": "clickhouse_61_10",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select * from t1 where f1='test' and (f2= md5(\"TEST\") or f2= md5(\"test\")); -- MD5",
    "target_query": "SELECT * FROM t1 WHERE f1 = 'test' AND (f2 = MD5('TEST') OR f2 = MD5('test'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MD5"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MD5()",
        "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
        "examples": [
          "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
          "SELECT MD5('hello') <> MD5('world');",
          "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (f1 varchar(4), f2 varchar(64));"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (f1 String, f2 String)engine=MergeTree ORDER BY f1;"
    ]
  },
  {
    "sql_id": "clickhouse_62_0",
    "database_name": "clickhouse_62_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select inet_ntoa(4294902271),inet_ntoa(511); -- INET_NTOA",
    "target_query": "select inet_ntoa(4294902271),inet_ntoa(511);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "INET_NTOA"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "INET_NTOA(ip)",
        "description": "The INET_NTOA function converts an integer representation of an IPv4 address to a standard dotted-decimal format string.",
        "examples": [
          "SELECT INET_NTOA(3232235776);",
          "SELECT INET_NTOA(16777343);",
          "SELECT INET_NTOA(2886733345);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "INET_NTOA(ip)",
        "description": "ClickHouse supports INET_NTOA just like MySQL and MariaDB, converting an integer IPv4 address to a dotted-decimal string.",
        "examples": [
          "SELECT INET_NTOA(3232235776);",
          "SELECT INET_NTOA(16777343);",
          "SELECT INET_NTOA(2886733345);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_62_4",
    "database_name": "clickhouse_62_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select a from t1 where mid(a+0,6,3) in ( mid(20040106123400,6,3) ); -- MID",
    "target_query": "SELECT a FROM t1 WHERE substring(formatDateTime(a, '%Y%m%d%H%M%S'), 6, 3) = substring(toString(20040106123400), 6, 3);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MID"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MID(str, pos, len)",
        "description": "Extracts a substring from the string `str`, starting at position `pos`, with length `len`.",
        "examples": [
          "SELECT MID('ABCDEFGHIJKL', 5, 3);",
          "SELECT CONCAT(MID('hello_world', 1, 5), MID('hello_world', 7, 5));",
          "SELECT MID('  padded_text  ', 3, 6);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "substring(str, pos, len)",
        "description": "Extracts a substring starting from position `pos`, for `len` characters. Position is 1-based.",
        "examples": [
          "SELECT substring('ABCDEFGHIJKL', 5, 3);",
          "SELECT concat(substring('hello_world', 1, 5), substring('hello_world', 7, 5));",
          "SELECT substring('  padded_text  ', 3, 6);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 ( a timestamp );"
    ],
    "target_related_schemas": [
      "create table t1 ( a timestamp ) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_62_5",
    "database_name": "clickhouse_62_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select a from t1 where mid(a+0,6,3) = ( mid(20040106123400,6,3) ); -- MID",
    "target_query": "select a from t1 where substring(formatDateTime(a, '%Y%m%d%H%M%S'), 6, 3) = ( substring(toString(20040106123400),6,3) );",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MID"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MID(str, pos, len)",
        "description": "Extracts a substring from the string `str`, starting at position `pos`, with length `len`.",
        "examples": [
          "SELECT MID('ABCDEFGHIJKL', 5, 3);",
          "SELECT CONCAT(MID('hello_world', 1, 5), MID('hello_world', 7, 5));",
          "SELECT MID('  padded_text  ', 3, 6);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "substring(str, pos, len)",
        "description": "Extracts a substring starting from position `pos`, for `len` characters. Position is 1-based.",
        "examples": [
          "SELECT substring('ABCDEFGHIJKL', 5, 3);",
          "SELECT concat(substring('hello_world', 1, 5), substring('hello_world', 7, 5));",
          "SELECT substring('  padded_text  ', 3, 6);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 ( a timestamp );"
    ],
    "target_related_schemas": [
      "create table t1 ( a timestamp ) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_62_11",
    "database_name": "clickhouse_62_11",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select min(a) from t1 group by inet_ntoa(a); -- MIN, INET_NTOA",
    "target_query": "select min(a) from t1 group by inet_ntoa(CAST(a AS UInt32));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MIN",
      "INET_NTOA"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      },
      {
        "expression": "INET_NTOA(ip)",
        "description": "The INET_NTOA function converts an integer representation of an IPv4 address to a standard dotted-decimal format string.",
        "examples": [
          "SELECT INET_NTOA(3232235776);",
          "SELECT INET_NTOA(16777343);",
          "SELECT INET_NTOA(2886733345);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MIN()",
        "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
        "examples": [
          "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
          "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
        ]
      },
      {
        "expression": "INET_NTOA(ip)",
        "description": "ClickHouse supports INET_NTOA just like MySQL and MariaDB, converting an integer IPv4 address to a dotted-decimal string.",
        "examples": [
          "SELECT INET_NTOA(3232235776);",
          "SELECT INET_NTOA(16777343);",
          "SELECT INET_NTOA(2886733345);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1 (a int not null);"
    ],
    "target_related_schemas": [
      "create table t1 (a int)ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_62_15",
    "database_name": "clickhouse_62_15",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT DISTINCT LEAST(a, (SELECT b FROM t1 LIMIT 1)) FROM t1 UNION SELECT 1; -- LEAST",
    "target_query": "SELECT DISTINCT least(a, (SELECT CAST(b AS UInt32) FROM t1 LIMIT 1)) FROM t1 UNION DISTINCT SELECT 1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the smallest non-null value among arguments. NULLs are ignored unless all arguments are NULL. Use ifNull() when explicit NULL handling is needed.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(toDate('2024-01-01'), toDate('2023-12-31'));",
          "SELECT ifNull(least(NULL, 2), NULL);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a INT, b LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT, b String)ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_62_16",
    "database_name": "clickhouse_62_16",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT DISTINCT GREATEST(a, (SELECT b FROM t1 LIMIT 1)) FROM t1 UNION SELECT 1; -- GREATEST",
    "target_query": "SELECT DISTINCT GREATEST(a, (SELECT CAST(b AS UInt32) FROM t1 LIMIT 1)) FROM t1 UNION DISTINCT SELECT 1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (a INT, b LONGBLOB);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (a INT, b String)ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_63_0",
    "database_name": "clickhouse_63_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select 1+1,1-1,1+1*2,8/5,8%5,mod(8,5),-(1+1)*-2; -- MOD",
    "target_query": "select 1+1,1-1,1+1*2,8/5,8%5,mod(8,5),-(1+1)*-2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MOD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Returns the remainder of N divided by M. Returns NULL if M = 0.",
        "examples": [
          "SELECT MOD(10, 3);",
          "SELECT 10 % 3;",
          "SELECT MOD(5, 0);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Modulo operation. Returns remainder. Division by zero errors.",
        "examples": [
          "SELECT MOD(11, 5);",
          "SELECT 11 % 5;",
          "SELECT MOD(number, 3) FROM numbers(10);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_63_7",
    "database_name": "clickhouse_63_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select t1.a, t2.a, t2.b, bit_count(t2.b) from t1 left join t2 on t1.a=t2.a; -- BIT_COUNT",
    "target_query": "SELECT t1.a,t2.a,t2.b,bitCount(t2.b) FROM t1 LEFT JOIN t2 ON t1.a=t2.a;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "BIT_COUNT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "BIT_COUNT(N)",
        "description": "Returns the number of bits set to 1 in the binary representation of the given integer.",
        "examples": [
          "SELECT BIT_COUNT(0);",
          "SELECT BIT_COUNT(1);",
          "SELECT BIT_COUNT(15);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "bitCount(N)",
        "description": "Returns the number of set bits (1s) in the binary representation of the integer.",
        "examples": [
          "SELECT bitCount(0);",
          "SELECT bitCount(1);",
          "SELECT bitCount(15);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table t1(a int);",
      "create table t2(a int, b int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(a Int32)ENGINE=MergeTree ORDER BY a;",
      "CREATE TABLE t2(a Int32, b Int32)ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_64_0",
    "database_name": "clickhouse_64_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select date_format(\"1997-12-31 23:59:59.000002\", \"%f\"); -- DATE_FORMAT",
    "target_query": "SELECT formatDateTime(toDateTime('1997-12-31 23:59:59'), '%f');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATE_FORMAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATE_FORMAT(date_expr, format_str)",
        "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
        "examples": [
          "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
          "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
          "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(date_expr, format_str)",
        "description": "Formats a DateTime value using ClickHouse-supported format specifiers. Input must be a DateTime or cast to one explicitly.",
        "examples": [
          "SELECT formatDateTime(toDateTime('2024-05-06 08:30:00'), '%Y/%m/%d');",
          "SELECT formatDateTime(toDateTime('2023-07-14 15:30:00'), '%Y-%m-%d %H:%M:%S');",
          "SELECT formatDateTime(toDateTime('2022-01-01 08:45:30'), '%H:%M:%S on %d/%m/%Y');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_64_1",
    "database_name": "clickhouse_64_1",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select datediff(\"1997-12-31 23:59:59.000001\",\"1997-12-30\"); -- DATEDIFF",
    "target_query": "SELECT dateDiff('day', toDate('1997-12-30'), toDate('1997-12-31 23:59:59'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATEDIFF(date1, date2)",
        "description": "Returns the number of days between two date or datetime expressions (date1 - date2), ignoring time part.",
        "examples": [
          "SELECT DATEDIFF('2025-12-31', '2025-12-01');",
          "SELECT DATEDIFF('2025-01-01', '2024-12-31');",
          "SELECT DATEDIFF(NULL, '2025-01-01');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "dateDiff('day', date2, date1)",
        "description": "Returns the number of days between two dates (date1 - date2). Must explicitly specify 'day' unit.",
        "examples": [
          "SELECT dateDiff('day', toDate('2025-12-01'), toDate('2025-12-31'));",
          "SELECT dateDiff('day', toDate('2024-12-31'), toDate('2025-01-01'));",
          "SELECT dateDiff('day', NULL, toDate('2025-01-01'));"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_64_2",
    "database_name": "clickhouse_64_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select datediff(\"1997-11-30 23:59:59.000001\",null); --  DATEDIFF",
    "target_query": "SELECT dateDiff('day', NULL, toDate('1997-11-30 23:59:59'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DATEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DATEDIFF(date1, date2)",
        "description": "Returns the number of days between two date or datetime expressions (date1 - date2), ignoring time part.",
        "examples": [
          "SELECT DATEDIFF('2025-12-31', '2025-12-01');",
          "SELECT DATEDIFF('2025-01-01', '2024-12-31');",
          "SELECT DATEDIFF(NULL, '2025-01-01');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "dateDiff('day', date2, date1)",
        "description": "Returns the number of days between two dates (date1 - date2). Must explicitly specify 'day' unit.",
        "examples": [
          "SELECT dateDiff('day', toDate('2025-12-01'), toDate('2025-12-31'));",
          "SELECT dateDiff('day', toDate('2024-12-31'), toDate('2025-01-01'));",
          "SELECT dateDiff('day', NULL, toDate('2025-01-01'));"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_64_3",
    "database_name": "clickhouse_64_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select makedate(03,1); -- MAKEDATE",
    "target_query": "SELECT makeDate(3, 1);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKEDATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKEDATE(year, day_of_year)",
        "description": "Returns a date from the given year and day of the year.",
        "examples": [
          "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
          "SELECT MAKEDATE(2025, 100) AS specific_date;",
          "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "makeDate(year, day_of_year)",
        "description": "Returns a date from the given year and day of the year directly using the makeDate function.",
        "examples": [
          "SELECT makeDate(2009, 1) AS first_day_of_year;",
          "SELECT makeDate(2025, 100) AS specific_date;",
          "SELECT makeDate(2020, 366) AS last_day_of_year;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_64_5",
    "database_name": "clickhouse_64_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select makedate(1997,1); -- MAKEDATE",
    "target_query": "SELECT makeDate(1997, 1);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKEDATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKEDATE(year, day_of_year)",
        "description": "Returns a date from the given year and day of the year.",
        "examples": [
          "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
          "SELECT MAKEDATE(2025, 100) AS specific_date;",
          "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "makeDate(year, day_of_year)",
        "description": "Returns a date from the given year and day of the year directly using the makeDate function.",
        "examples": [
          "SELECT makeDate(2009, 1) AS first_day_of_year;",
          "SELECT makeDate(2025, 100) AS specific_date;",
          "SELECT makeDate(2020, 366) AS last_day_of_year;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_64_6",
    "database_name": "clickhouse_64_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select makedate(1997,0); -- MAKEDATE",
    "target_query": "SELECT makeDate(1997, 0);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKEDATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKEDATE(year, day_of_year)",
        "description": "Returns a date from the given year and day of the year.",
        "examples": [
          "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
          "SELECT MAKEDATE(2025, 100) AS specific_date;",
          "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "makeDate(year, day_of_year)",
        "description": "Returns a date from the given year and day of the year directly using the makeDate function.",
        "examples": [
          "SELECT makeDate(2009, 1) AS first_day_of_year;",
          "SELECT makeDate(2025, 100) AS specific_date;",
          "SELECT makeDate(2020, 366) AS last_day_of_year;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_64_7",
    "database_name": "clickhouse_64_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select makedate(9999,365); -- MAKEDATE",
    "target_query": "SELECT makeDate(9999, 365);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKEDATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKEDATE(year, day_of_year)",
        "description": "Returns a date from the given year and day of the year.",
        "examples": [
          "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
          "SELECT MAKEDATE(2025, 100) AS specific_date;",
          "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "makeDate(year, day_of_year)",
        "description": "Returns a date from the given year and day of the year directly using the makeDate function.",
        "examples": [
          "SELECT makeDate(2009, 1) AS first_day_of_year;",
          "SELECT makeDate(2025, 100) AS specific_date;",
          "SELECT makeDate(2020, 366) AS last_day_of_year;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_64_8",
    "database_name": "clickhouse_64_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select makedate(9999,366); -- MAKEDATE",
    "target_query": "SELECT makeDate(9999, 366);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKEDATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKEDATE(year, day_of_year)",
        "description": "Returns a date from the given year and day of the year.",
        "examples": [
          "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
          "SELECT MAKEDATE(2025, 100) AS specific_date;",
          "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "makeDate(year, day_of_year)",
        "description": "Returns a date from the given year and day of the year directly using the makeDate function.",
        "examples": [
          "SELECT makeDate(2009, 1) AS first_day_of_year;",
          "SELECT makeDate(2025, 100) AS specific_date;",
          "SELECT makeDate(2020, 366) AS last_day_of_year;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_64_9",
    "database_name": "clickhouse_64_9",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select makedate(100,1); -- MAKEDATE",
    "target_query": "SELECT makeDate(100, 1);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKEDATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKEDATE(year, day_of_year)",
        "description": "Returns a date from the given year and day of the year.",
        "examples": [
          "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
          "SELECT MAKEDATE(2025, 100) AS specific_date;",
          "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "makeDate(year, day_of_year)",
        "description": "Returns a date from the given year and day of the year directly using the makeDate function.",
        "examples": [
          "SELECT makeDate(2009, 1) AS first_day_of_year;",
          "SELECT makeDate(2025, 100) AS specific_date;",
          "SELECT makeDate(2020, 366) AS last_day_of_year;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_64_10",
    "database_name": "clickhouse_64_10",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select subtime(\"1997-12-31 23:59:59.000001\", \"1 1:1:1.000002\"); -- SUBTIME",
    "target_query": "SELECT subtractSeconds(toDateTime('1997-12-31 23:59:59'), 90061);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "SUBTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SUBTIME(expr1, expr2)",
        "description": "Subtracts a time/datetime interval from the given time or datetime.",
        "examples": [
          "SELECT SUBTIME('12:00:00', '01:30:00');",
          "SELECT SUBTIME('2025-01-01 10:00:00', '00:00:01');",
          "SELECT SUBTIME('05:00:00', '05:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "subtractMinutes or subtractSeconds with toDateTime",
        "description": "Subtracts an integer number of minutes or seconds from a DateTime value using subtractMinutes or subtractSeconds.",
        "examples": [
          "SELECT subtractMinutes(toDateTime('2025-01-01 12:00:00'), 90);",
          "SELECT subtractSeconds(toDateTime('2025-01-01 10:00:00'), 1);",
          "SELECT subtractSeconds(toDateTime('2025-01-01 05:00:00'), 18000);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_64_11",
    "database_name": "clickhouse_64_11",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select subtime(\"1997-12-31 23:59:59.999999\", \"1998-01-01 01:01:01.999999\"); -- SUBTIME",
    "target_query": "SELECT subtractSeconds(toDateTime('1997-12-31 23:59:59'), 90061);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "SUBTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SUBTIME(expr1, expr2)",
        "description": "Subtracts a time/datetime interval from the given time or datetime.",
        "examples": [
          "SELECT SUBTIME('12:00:00', '01:30:00');",
          "SELECT SUBTIME('2025-01-01 10:00:00', '00:00:01');",
          "SELECT SUBTIME('05:00:00', '05:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "subtractMinutes or subtractSeconds with toDateTime",
        "description": "Subtracts an integer number of minutes or seconds from a DateTime value using subtractMinutes or subtractSeconds.",
        "examples": [
          "SELECT subtractMinutes(toDateTime('2025-01-01 12:00:00'), 90);",
          "SELECT subtractSeconds(toDateTime('2025-01-01 10:00:00'), 1);",
          "SELECT subtractSeconds(toDateTime('2025-01-01 05:00:00'), 18000);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_64_12",
    "database_name": "clickhouse_64_12",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select subtime(\"01:00:00.999999\", \"02:00:00.999998\"); -- SUBTIME",
    "target_query": "SELECT subtractSeconds(toDateTime('1970-01-01 01:00:00'), 3601);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "SUBTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SUBTIME(expr1, expr2)",
        "description": "Subtracts a time/datetime interval from the given time or datetime.",
        "examples": [
          "SELECT SUBTIME('12:00:00', '01:30:00');",
          "SELECT SUBTIME('2025-01-01 10:00:00', '00:00:01');",
          "SELECT SUBTIME('05:00:00', '05:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "subtractMinutes or subtractSeconds with toDateTime",
        "description": "Subtracts an integer number of minutes or seconds from a DateTime value using subtractMinutes or subtractSeconds.",
        "examples": [
          "SELECT subtractMinutes(toDateTime('2025-01-01 12:00:00'), 90);",
          "SELECT subtractSeconds(toDateTime('2025-01-01 10:00:00'), 1);",
          "SELECT subtractSeconds(toDateTime('2025-01-01 05:00:00'), 18000);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_64_13",
    "database_name": "clickhouse_64_13",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select subtime(\"02:01:01.999999\", \"01:01:01.999999\"); -- SUBTIME",
    "target_query": "SELECT subtractSeconds(toDateTime('1970-01-01 02:01:01'), 3661);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "SUBTIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SUBTIME(expr1, expr2)",
        "description": "Subtracts a time/datetime interval from the given time or datetime.",
        "examples": [
          "SELECT SUBTIME('12:00:00', '01:30:00');",
          "SELECT SUBTIME('2025-01-01 10:00:00', '00:00:01');",
          "SELECT SUBTIME('05:00:00', '05:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "subtractMinutes or subtractSeconds with toDateTime",
        "description": "Subtracts an integer number of minutes or seconds from a DateTime value using subtractMinutes or subtractSeconds.",
        "examples": [
          "SELECT subtractMinutes(toDateTime('2025-01-01 12:00:00'), 90);",
          "SELECT subtractSeconds(toDateTime('2025-01-01 10:00:00'), 1);",
          "SELECT subtractSeconds(toDateTime('2025-01-01 05:00:00'), 18000);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_64_14",
    "database_name": "clickhouse_64_14",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select timediff(\"1997-01-01 23:59:59.000001\",\"1995-12-31 23:59:59.000002\"); -- TIMEDIFF",
    "target_query": "SELECT dateDiff('second', toDateTime('1995-12-31 23:59:59'), toDateTime('1997-01-01 23:59:59'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "dateDiff('second', toDateTime('2023-06-15 10:00:00'), toDateTime('2023-06-15 12:00:00'))",
        "description": "ClickHouse uses the dateDiff function to calculate the difference between two datetime values in various units.",
        "examples": [
          "SELECT dateDiff('second', toDateTime('2023-06-15 12:00:00'), toDateTime('2023-06-15 10:00:00'));",
          "SELECT dateDiff('second', now(), toDateTime('2023-06-15 10:00:00'));",
          "SELECT dateDiff('second', toDateTime('2023-06-15 12:00:00'), toDateTime('2023-06-15 10:00:00'));"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_64_15",
    "database_name": "clickhouse_64_15",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select timediff(\"1997-12-31 23:59:59.000001\",\"1997-12-30 01:01:01.000002\"); -- TIMEDIFF",
    "target_query": "SELECT dateDiff('second', toDateTime('1997-12-30 01:01:01'), toDateTime('1997-12-31 23:59:59'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "dateDiff('second', toDateTime('2023-06-15 10:00:00'), toDateTime('2023-06-15 12:00:00'))",
        "description": "ClickHouse uses the dateDiff function to calculate the difference between two datetime values in various units.",
        "examples": [
          "SELECT dateDiff('second', toDateTime('2023-06-15 12:00:00'), toDateTime('2023-06-15 10:00:00'));",
          "SELECT dateDiff('second', now(), toDateTime('2023-06-15 10:00:00'));",
          "SELECT dateDiff('second', toDateTime('2023-06-15 12:00:00'), toDateTime('2023-06-15 10:00:00'));"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_64_16",
    "database_name": "clickhouse_64_16",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select timediff(\"1997-12-31 23:59:59.000001\",\"23:59:59.000001\"); -- TIMEDIFF",
    "target_query": "SELECT dateDiff('second', toDateTime('1970-01-01 23:59:59'), toDateTime('1997-12-31 23:59:59'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "dateDiff('second', toDateTime('2023-06-15 10:00:00'), toDateTime('2023-06-15 12:00:00'))",
        "description": "ClickHouse uses the dateDiff function to calculate the difference between two datetime values in various units.",
        "examples": [
          "SELECT dateDiff('second', toDateTime('2023-06-15 12:00:00'), toDateTime('2023-06-15 10:00:00'));",
          "SELECT dateDiff('second', now(), toDateTime('2023-06-15 10:00:00'));",
          "SELECT dateDiff('second', toDateTime('2023-06-15 12:00:00'), toDateTime('2023-06-15 10:00:00'));"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_64_17",
    "database_name": "clickhouse_64_17",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select timediff(\"2000:01:01 00:00:00\", \"2000:01:01 00:00:00.000001\"); -- TIMEDIFF",
    "target_query": "SELECT dateDiff('second', toDateTime('2000-01-01 00:00:00'), toDateTime('2000-01-01 00:00:00'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "dateDiff('second', toDateTime('2023-06-15 10:00:00'), toDateTime('2023-06-15 12:00:00'))",
        "description": "ClickHouse uses the dateDiff function to calculate the difference between two datetime values in various units.",
        "examples": [
          "SELECT dateDiff('second', toDateTime('2023-06-15 12:00:00'), toDateTime('2023-06-15 10:00:00'));",
          "SELECT dateDiff('second', now(), toDateTime('2023-06-15 10:00:00'));",
          "SELECT dateDiff('second', toDateTime('2023-06-15 12:00:00'), toDateTime('2023-06-15 10:00:00'));"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_64_18",
    "database_name": "clickhouse_64_18",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select timediff(\"2005-01-11 15:48:49.999999\", \"2005-01-11 15:48:50\"); --  TIMEDIFF",
    "target_query": "SELECT dateDiff('second', toDateTime('2005-01-11 15:48:50'), toDateTime('2005-01-11 15:48:49'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "dateDiff('second', toDateTime('2023-06-15 10:00:00'), toDateTime('2023-06-15 12:00:00'))",
        "description": "ClickHouse uses the dateDiff function to calculate the difference between two datetime values in various units.",
        "examples": [
          "SELECT dateDiff('second', toDateTime('2023-06-15 12:00:00'), toDateTime('2023-06-15 10:00:00'));",
          "SELECT dateDiff('second', now(), toDateTime('2023-06-15 10:00:00'));",
          "SELECT dateDiff('second', toDateTime('2023-06-15 12:00:00'), toDateTime('2023-06-15 10:00:00'));"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_65_0",
    "database_name": "clickhouse_65_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select maketime(10,11,12); -- MAKETIME",
    "target_query": "SELECT formatDateTime(toDateTime('1970-01-01 10:11:12'), '%H:%i:%s');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKETIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKETIME(hours, minutes, seconds)",
        "description": "Creates a time value from the provided hours, minutes, and seconds.",
        "examples": [
          "SELECT MAKETIME(1, 30, 45);",
          "SELECT MAKETIME(12, 0, 0);",
          "SELECT MAKETIME(23, 59, 59);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(toDateTime('1970-01-01 HH:MM:SS'), '%H:%i:%s')",
        "description": "ClickHouse does not have a direct equivalent to MAKETIME. Therefore, we construct a DateTime using a fixed date (e.g., '1970-01-01') and extract only the time part using `formatDateTime`.",
        "examples": [
          "SELECT formatDateTime(toDateTime('1970-01-01 01:30:45'), '%H:%i:%s');",
          "SELECT formatDateTime(toDateTime('1970-01-01 12:00:00'), '%H:%i:%s');",
          "SELECT formatDateTime(toDateTime('1970-01-01 23:59:59'), '%H:%i:%s');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_65_1",
    "database_name": "clickhouse_65_1",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select maketime(20,11,12); -- MAKETIME",
    "target_query": "SELECT formatDateTime(toDateTime('1970-01-01 20:11:12'), '%H:%i:%s');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKETIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKETIME(hours, minutes, seconds)",
        "description": "Creates a time value from the provided hours, minutes, and seconds.",
        "examples": [
          "SELECT MAKETIME(1, 30, 45);",
          "SELECT MAKETIME(12, 0, 0);",
          "SELECT MAKETIME(23, 59, 59);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(toDateTime('1970-01-01 HH:MM:SS'), '%H:%i:%s')",
        "description": "ClickHouse does not have a direct equivalent to MAKETIME. Therefore, we construct a DateTime using a fixed date (e.g., '1970-01-01') and extract only the time part using `formatDateTime`.",
        "examples": [
          "SELECT formatDateTime(toDateTime('1970-01-01 01:30:45'), '%H:%i:%s');",
          "SELECT formatDateTime(toDateTime('1970-01-01 12:00:00'), '%H:%i:%s');",
          "SELECT formatDateTime(toDateTime('1970-01-01 23:59:59'), '%H:%i:%s');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_65_3",
    "database_name": "clickhouse_65_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select timestamp(\"2001-12-01\", \"01:01:01.999999\"); -- TIMESTAMP",
    "target_query": "SELECT toDateTime('2001-12-01 01:01:01');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
        "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
        "examples": [
          "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toDateTime('2023-06-15 10:30:45')",
        "description": "ClickHouse uses the toDateTime function to convert a date-time string to a DateTime type, without timezone support.",
        "examples": [
          "SELECT toDateTime('2023-06-15 10:30:45');",
          "SELECT toDateTime('2023-06-15 10:30:45');",
          "SELECT toDateTime('2023-06-15 10:30:45') > toDateTime('2023-06-14 10:30:45');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_65_4",
    "database_name": "clickhouse_65_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select timestamp(\"2001-10-01\", \"01:01:01.000001\"); -- TIMESTAMP",
    "target_query": "SELECT toDateTime('2001-13-01 01:01:01');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
        "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
        "examples": [
          "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toDateTime('2023-06-15 10:30:45')",
        "description": "ClickHouse uses the toDateTime function to convert a date-time string to a DateTime type, without timezone support.",
        "examples": [
          "SELECT toDateTime('2023-06-15 10:30:45');",
          "SELECT toDateTime('2023-06-15 10:30:45');",
          "SELECT toDateTime('2023-06-15 10:30:45') > toDateTime('2023-06-14 10:30:45');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_65_5",
    "database_name": "clickhouse_65_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select timestamp(\"2001-12-01\", \"20:01:01\"); -- TIMESTAMP",
    "target_query": "SELECT toDateTime('2001-12-01 20:01:01');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
        "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
        "examples": [
          "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toDateTime('2023-06-15 10:30:45')",
        "description": "ClickHouse uses the toDateTime function to convert a date-time string to a DateTime type, without timezone support.",
        "examples": [
          "SELECT toDateTime('2023-06-15 10:30:45');",
          "SELECT toDateTime('2023-06-15 10:30:45');",
          "SELECT toDateTime('2023-06-15 10:30:45') > toDateTime('2023-06-14 10:30:45');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_65_6",
    "database_name": "clickhouse_65_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select timestamp(\"2001-12-01\"); -- TIMESTAMP",
    "target_query": "SELECT toDateTime('2001-12-01');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMESTAMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
        "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
        "examples": [
          "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
          "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toDateTime('2023-06-15 10:30:45')",
        "description": "ClickHouse uses the toDateTime function to convert a date-time string to a DateTime type, without timezone support.",
        "examples": [
          "SELECT toDateTime('2023-06-15 10:30:45');",
          "SELECT toDateTime('2023-06-15 10:30:45');",
          "SELECT toDateTime('2023-06-15 10:30:45') > toDateTime('2023-06-14 10:30:45');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_65_7",
    "database_name": "clickhouse_65_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select day(\"1997-12-31 23:59:59.000001\"); -- DAY",
    "target_query": "SELECT toDayOfMonth(toDateTime('1997-12-31 23:59:59'));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "DAY"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "DAY(date_expr)",
        "description": "Returns the day of the month (1-31) from a date or datetime expression.",
        "examples": [
          "SELECT DAY('2023-10-15');",
          "SELECT DAY(NOW());",
          "SELECT DAY(CAST('2024-02-29 12:34:56' AS DATE));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "toDayOfMonth(date_expr)",
        "description": "Returns the day of the month from a Date or DateTime expression as UInt8.",
        "examples": [
          "SELECT toDayOfMonth(DATE '2023-10-15');",
          "SELECT toDayOfMonth(now());",
          "SELECT toDayOfMonth(toDateTime('2024-02-29 09:45:00'));"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_65_8",
    "database_name": "clickhouse_65_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select time(\"1997-12-31 23:59:59.000001\"); -- TIME",
    "target_query": "SELECT formatDateTime(toDateTime('1997-12-31 23:59:59'), '%H:%i:%s');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
        "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
        "examples": [
          "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
          "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(datetime_expr, format)",
        "description": "ClickHouse does not have a native TIME type (unlike MySQL), so operations involving just hours, minutes, and seconds must be done on full DateTime values. To extract or format time-only values like 'HH:MM:SS' or 'HH:MM:SS.SSSSSS', you must convert a full DateTime using `formatDateTime`. If only a time string like '14:16:00' is provided, you must first concatenate it with a default date (e.g., '1970-01-01') and then convert it to DateTime using `toDateTime`. \nParameters: datetime_expr (e.g., NOW(), toDateTime('1970-01-01 14:16:00')), format (e.g., '%H:%i:%s', '%H:%i:%s.%f').\nReturns: A string formatted as 'HH:MM:SS' or 'HH:MM:SS.SSSSSS'.",
        "examples": [
          "SELECT formatDateTime(NOW(), '%H:%i:%s'); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT formatDateTime(NOW(), '%H:%i:%s'); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT formatDateTime(toDateTime(concat('1970-01-01 ', '14:16:00')), '%H:%i:%s.%f'); -- Returns '14:16:00.000000' with fractional seconds."
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_65_12",
    "database_name": "clickhouse_65_12",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT TIMEDIFF(t1, t4) As ttt, TIMEDIFF(t2, t3) As qqq,TIMEDIFF(t3, t2) As eee, TIMEDIFF(t2, t4) As rrr from test; -- TIMEDIFF",
    "target_query": "SELECT dateDiff('second', t1, t4) AS ttt, dateDiff('second', t2, t3) AS qqq, dateDiff('second', t3, t2) AS eee, dateDiff('second', t2, t4) AS rrr FROM test;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "dateDiff('second', toDateTime('2023-06-15 10:00:00'), toDateTime('2023-06-15 12:00:00'))",
        "description": "ClickHouse uses the dateDiff function to calculate the difference between two datetime values in various units.",
        "examples": [
          "SELECT dateDiff('second', toDateTime('2023-06-15 12:00:00'), toDateTime('2023-06-15 10:00:00'));",
          "SELECT dateDiff('second', now(), toDateTime('2023-06-15 10:00:00'));",
          "SELECT dateDiff('second', toDateTime('2023-06-15 12:00:00'), toDateTime('2023-06-15 10:00:00'));"
        ]
      }
    ],
    "source_related_schemas": [
      "create table test(t1 datetime, t2 time, t3 time, t4 datetime);"
    ],
    "target_related_schemas": [
      "CREATE TABLE test (t1 DateTime, t2 DateTime, t3 DateTime, t4 DateTime)ENGINE=TinyLog;"
    ]
  },
  {
    "sql_id": "clickhouse_65_13",
    "database_name": "clickhouse_65_13",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select str_to_date(\"2003-01-02 10:11:12.0012\", \"%Y-%m-%d %H:%i:%S.%f\"); -- STR_TO_DATE",
    "target_query": "SELECT parseDateTimeBestEffort('2003-01-02 10:11:12.0012');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STR_TO_DATE"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STR_TO_DATE('09:22', '%H:%i')",
        "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
        "examples": [
          "SELECT STR_TO_DATE('12:45', '%H:%i');",
          "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
          "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "parseDateTimeBestEffort('09:22')",
        "description": "Clickhouse uses parseDateTimeBestEffort to try and automatically parse the string '09:22' into a DateTime type.",
        "examples": [
          "SELECT parseDateTimeBestEffort('12:45');",
          "SELECT toDateTime('2000-01-01');",
          "SELECT parseDateTimeBestEffort('2023-05-06 12:34:56');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_65_14",
    "database_name": "clickhouse_65_14",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select timediff('2008-09-29 20:10:10','2008-09-30 20:10:10'),time('00:00:00'); -- TIMEDIFF, TIME",
    "target_query": "SELECT dateDiff('second', toDateTime('2008-09-29 20:10:10'), toDateTime('2008-09-30 20:10:10')), formatDateTime(toDateTime('1970-01-01 00:00:00'), '%H:%i:%s');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF",
      "TIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      },
      {
        "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
        "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
        "examples": [
          "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
          "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "dateDiff('second', toDateTime('2023-06-15 10:00:00'), toDateTime('2023-06-15 12:00:00'))",
        "description": "ClickHouse uses the dateDiff function to calculate the difference between two datetime values in various units.",
        "examples": [
          "SELECT dateDiff('second', toDateTime('2023-06-15 12:00:00'), toDateTime('2023-06-15 10:00:00'));",
          "SELECT dateDiff('second', now(), toDateTime('2023-06-15 10:00:00'));",
          "SELECT dateDiff('second', toDateTime('2023-06-15 12:00:00'), toDateTime('2023-06-15 10:00:00'));"
        ]
      },
      {
        "expression": "formatDateTime(datetime_expr, format)",
        "description": "ClickHouse does not have a native TIME type (unlike MySQL), so operations involving just hours, minutes, and seconds must be done on full DateTime values. To extract or format time-only values like 'HH:MM:SS' or 'HH:MM:SS.SSSSSS', you must convert a full DateTime using `formatDateTime`. If only a time string like '14:16:00' is provided, you must first concatenate it with a default date (e.g., '1970-01-01') and then convert it to DateTime using `toDateTime`. \nParameters: datetime_expr (e.g., NOW(), toDateTime('1970-01-01 14:16:00')), format (e.g., '%H:%i:%s', '%H:%i:%s.%f').\nReturns: A string formatted as 'HH:MM:SS' or 'HH:MM:SS.SSSSSS'.",
        "examples": [
          "SELECT formatDateTime(NOW(), '%H:%i:%s'); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT formatDateTime(NOW(), '%H:%i:%s'); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT formatDateTime(toDateTime(concat('1970-01-01 ', '14:16:00')), '%H:%i:%s.%f'); -- Returns '14:16:00.000000' with fractional seconds."
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_65_15",
    "database_name": "clickhouse_65_15",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select timediff('2008-09-29 20:10:10','2008-09-30 20:10:10')>time('00:00:00'); -- TIMEDIFF, TIME",
    "target_query": "SELECT dateDiff('second', toDateTime('2008-09-29 20:10:10'), toDateTime('2008-09-30 20:10:10')) > INTERVAL '0 seconds';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF",
      "TIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      },
      {
        "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
        "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
        "examples": [
          "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
          "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "dateDiff('second', toDateTime('2023-06-15 10:00:00'), toDateTime('2023-06-15 12:00:00'))",
        "description": "ClickHouse uses the dateDiff function to calculate the difference between two datetime values in various units.",
        "examples": [
          "SELECT dateDiff('second', toDateTime('2023-06-15 12:00:00'), toDateTime('2023-06-15 10:00:00'));",
          "SELECT dateDiff('second', now(), toDateTime('2023-06-15 10:00:00'));",
          "SELECT dateDiff('second', toDateTime('2023-06-15 12:00:00'), toDateTime('2023-06-15 10:00:00'));"
        ]
      },
      {
        "expression": "formatDateTime(datetime_expr, format)",
        "description": "ClickHouse does not have a native TIME type (unlike MySQL), so operations involving just hours, minutes, and seconds must be done on full DateTime values. To extract or format time-only values like 'HH:MM:SS' or 'HH:MM:SS.SSSSSS', you must convert a full DateTime using `formatDateTime`. If only a time string like '14:16:00' is provided, you must first concatenate it with a default date (e.g., '1970-01-01') and then convert it to DateTime using `toDateTime`. \nParameters: datetime_expr (e.g., NOW(), toDateTime('1970-01-01 14:16:00')), format (e.g., '%H:%i:%s', '%H:%i:%s.%f').\nReturns: A string formatted as 'HH:MM:SS' or 'HH:MM:SS.SSSSSS'.",
        "examples": [
          "SELECT formatDateTime(NOW(), '%H:%i:%s'); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT formatDateTime(NOW(), '%H:%i:%s'); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT formatDateTime(toDateTime(concat('1970-01-01 ', '14:16:00')), '%H:%i:%s.%f'); -- Returns '14:16:00.000000' with fractional seconds."
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_65_16",
    "database_name": "clickhouse_65_16",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select timediff('2008-09-29 20:10:10','2008-09-30 20:10:10')<time('00:00:00'); -- TIMEDIFF, TIME",
    "target_query": "SELECT dateDiff('second', toDateTime('2008-09-29 20:10:10'), toDateTime('2008-09-30 20:10:10')) < INTERVAL '0 seconds';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIMEDIFF",
      "TIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIMEDIFF('12:00:00', '10:00:00')",
        "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
        "examples": [
          "SELECT TIMEDIFF('12:00:00', '10:00:00');",
          "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
          "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
        ]
      },
      {
        "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
        "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
        "examples": [
          "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
          "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "dateDiff('second', toDateTime('2023-06-15 10:00:00'), toDateTime('2023-06-15 12:00:00'))",
        "description": "ClickHouse uses the dateDiff function to calculate the difference between two datetime values in various units.",
        "examples": [
          "SELECT dateDiff('second', toDateTime('2023-06-15 12:00:00'), toDateTime('2023-06-15 10:00:00'));",
          "SELECT dateDiff('second', now(), toDateTime('2023-06-15 10:00:00'));",
          "SELECT dateDiff('second', toDateTime('2023-06-15 12:00:00'), toDateTime('2023-06-15 10:00:00'));"
        ]
      },
      {
        "expression": "formatDateTime(datetime_expr, format)",
        "description": "ClickHouse does not have a native TIME type (unlike MySQL), so operations involving just hours, minutes, and seconds must be done on full DateTime values. To extract or format time-only values like 'HH:MM:SS' or 'HH:MM:SS.SSSSSS', you must convert a full DateTime using `formatDateTime`. If only a time string like '14:16:00' is provided, you must first concatenate it with a default date (e.g., '1970-01-01') and then convert it to DateTime using `toDateTime`. \nParameters: datetime_expr (e.g., NOW(), toDateTime('1970-01-01 14:16:00')), format (e.g., '%H:%i:%s', '%H:%i:%s.%f').\nReturns: A string formatted as 'HH:MM:SS' or 'HH:MM:SS.SSSSSS'.",
        "examples": [
          "SELECT formatDateTime(NOW(), '%H:%i:%s'); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT formatDateTime(NOW(), '%H:%i:%s'); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT formatDateTime(toDateTime(concat('1970-01-01 ', '14:16:00')), '%H:%i:%s.%f'); -- Returns '14:16:00.000000' with fractional seconds."
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_66_1",
    "database_name": "clickhouse_66_1",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT sec_to_time(86399)=TIME('23:59:59'); -- SEC_TO_TIME, TIME",
    "target_query": "SELECT formatDateTime(toDateTime(86399), '%H:%i:%s')=formatDateTime(toDateTime(concat('1970-01-01 ', '23:59:59')), '%H:%i:%s');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "SEC_TO_TIME",
      "TIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SEC_TO_TIME(seconds)",
        "description": "Converts the given number of seconds into a time value in the format HH:MM:SS. Wraps around if seconds exceed 86400.",
        "examples": [
          "SELECT SEC_TO_TIME(3661); -- Returns '01:01:01'",
          "SELECT SEC_TO_TIME(3600); -- Returns '01:00:00'",
          "SELECT SEC_TO_TIME(86400); -- Returns '00:00:00'"
        ]
      },
      {
        "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
        "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
        "examples": [
          "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
          "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(toDateTime(seconds), '%H:%i:%s')",
        "description": "Converts the given number of seconds into a time format using the toDateTime function and the formatDateTime function.",
        "examples": [
          "SELECT formatDateTime(toDateTime(3661), '%H:%i:%s'); -- Returns '01:01:01'",
          "SELECT formatDateTime(toDateTime(3600), '%H:%i:%s'); -- Returns '01:00:00'",
          "SELECT formatDateTime(toDateTime(86400), '%H:%i:%s'); -- Returns '00:00:00'"
        ]
      },
      {
        "expression": "formatDateTime(datetime_expr, format)",
        "description": "ClickHouse does not have a native TIME type (unlike MySQL), so operations involving just hours, minutes, and seconds must be done on full DateTime values. To extract or format time-only values like 'HH:MM:SS' or 'HH:MM:SS.SSSSSS', you must convert a full DateTime using `formatDateTime`. If only a time string like '14:16:00' is provided, you must first concatenate it with a default date (e.g., '1970-01-01') and then convert it to DateTime using `toDateTime`. \nParameters: datetime_expr (e.g., NOW(), toDateTime('1970-01-01 14:16:00')), format (e.g., '%H:%i:%s', '%H:%i:%s.%f').\nReturns: A string formatted as 'HH:MM:SS' or 'HH:MM:SS.SSSSSS'.",
        "examples": [
          "SELECT formatDateTime(NOW(), '%H:%i:%s'); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT formatDateTime(NOW(), '%H:%i:%s'); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT formatDateTime(toDateTime(concat('1970-01-01 ', '14:16:00')), '%H:%i:%s.%f'); -- Returns '14:16:00.000000' with fractional seconds."
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_66_2",
    "database_name": "clickhouse_66_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT sec_to_time(86399)='23:59:59'; -- SEC_TO_TIME",
    "target_query": "SELECT formatDateTime(toDateTime(86399), '%H:%i:%s')='-838:59:59';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "SEC_TO_TIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "SEC_TO_TIME(seconds)",
        "description": "Converts the given number of seconds into a time value in the format HH:MM:SS. Wraps around if seconds exceed 86400.",
        "examples": [
          "SELECT SEC_TO_TIME(3661); -- Returns '01:01:01'",
          "SELECT SEC_TO_TIME(3600); -- Returns '01:00:00'",
          "SELECT SEC_TO_TIME(86400); -- Returns '00:00:00'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(toDateTime(seconds), '%H:%i:%s')",
        "description": "Converts the given number of seconds into a time format using the toDateTime function and the formatDateTime function.",
        "examples": [
          "SELECT formatDateTime(toDateTime(3661), '%H:%i:%s'); -- Returns '01:01:01'",
          "SELECT formatDateTime(toDateTime(3600), '%H:%i:%s'); -- Returns '01:00:00'",
          "SELECT formatDateTime(toDateTime(86400), '%H:%i:%s'); -- Returns '00:00:00'"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_66_3",
    "database_name": "clickhouse_66_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT time(sec_to_time(86399))=TIME('23:59:59'); -- TIME, SEC_TO_TIME",
    "target_query": "SELECT formatDateTime(toDateTime(86399), '%H:%i:%s')=formatDateTime(toDateTime(concat('1970-01-01 ', '23:59:58')), '%H:%i:%s');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TIME",
      "SEC_TO_TIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
        "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
        "examples": [
          "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
          "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
        ]
      },
      {
        "expression": "SEC_TO_TIME(seconds)",
        "description": "Converts the given number of seconds into a time value in the format HH:MM:SS. Wraps around if seconds exceed 86400.",
        "examples": [
          "SELECT SEC_TO_TIME(3661); -- Returns '01:01:01'",
          "SELECT SEC_TO_TIME(3600); -- Returns '01:00:00'",
          "SELECT SEC_TO_TIME(86400); -- Returns '00:00:00'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(datetime_expr, format)",
        "description": "ClickHouse does not have a native TIME type (unlike MySQL), so operations involving just hours, minutes, and seconds must be done on full DateTime values. To extract or format time-only values like 'HH:MM:SS' or 'HH:MM:SS.SSSSSS', you must convert a full DateTime using `formatDateTime`. If only a time string like '14:16:00' is provided, you must first concatenate it with a default date (e.g., '1970-01-01') and then convert it to DateTime using `toDateTime`. \nParameters: datetime_expr (e.g., NOW(), toDateTime('1970-01-01 14:16:00')), format (e.g., '%H:%i:%s', '%H:%i:%s.%f').\nReturns: A string formatted as 'HH:MM:SS' or 'HH:MM:SS.SSSSSS'.",
        "examples": [
          "SELECT formatDateTime(NOW(), '%H:%i:%s'); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT formatDateTime(NOW(), '%H:%i:%s'); -- Returns the current time, formatted as 'HH:MM:SS'.",
          "SELECT formatDateTime(toDateTime(concat('1970-01-01 ', '14:16:00')), '%H:%i:%s.%f'); -- Returns '14:16:00.000000' with fractional seconds."
        ]
      },
      {
        "expression": "formatDateTime(toDateTime(seconds), '%H:%i:%s')",
        "description": "Converts the given number of seconds into a time format using the toDateTime function and the formatDateTime function.",
        "examples": [
          "SELECT formatDateTime(toDateTime(3661), '%H:%i:%s'); -- Returns '01:01:01'",
          "SELECT formatDateTime(toDateTime(3600), '%H:%i:%s'); -- Returns '01:00:00'",
          "SELECT formatDateTime(toDateTime(86400), '%H:%i:%s'); -- Returns '00:00:00'"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_66_4",
    "database_name": "clickhouse_66_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT maketime(1,0,1)='01:00:01'; -- MAKETIME",
    "target_query": "SELECT formatDateTime(toDateTime('1970-01-01 01:00:01'), '%H:%i:%s')='01:00:01';",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKETIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKETIME(hours, minutes, seconds)",
        "description": "Creates a time value from the provided hours, minutes, and seconds.",
        "examples": [
          "SELECT MAKETIME(1, 30, 45);",
          "SELECT MAKETIME(12, 0, 0);",
          "SELECT MAKETIME(23, 59, 59);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(toDateTime('1970-01-01 HH:MM:SS'), '%H:%i:%s')",
        "description": "ClickHouse does not have a direct equivalent to MAKETIME. Therefore, we construct a DateTime using a fixed date (e.g., '1970-01-01') and extract only the time part using `formatDateTime`.",
        "examples": [
          "SELECT formatDateTime(toDateTime('1970-01-01 01:30:45'), '%H:%i:%s');",
          "SELECT formatDateTime(toDateTime('1970-01-01 12:00:00'), '%H:%i:%s');",
          "SELECT formatDateTime(toDateTime('1970-01-01 23:59:59'), '%H:%i:%s');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_66_6",
    "database_name": "clickhouse_66_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT maketime(1,0,1)=CAST('01:00:01' AS TIME); -- MAKETIME",
    "target_query": "SELECT formatDateTime(toDateTime('1970-01-01 01:00:01'), '%H:%i:%s')=CAST('01:00:01' AS String);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MAKETIME"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MAKETIME(hours, minutes, seconds)",
        "description": "Creates a time value from the provided hours, minutes, and seconds.",
        "examples": [
          "SELECT MAKETIME(1, 30, 45);",
          "SELECT MAKETIME(12, 0, 0);",
          "SELECT MAKETIME(23, 59, 59);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "formatDateTime(toDateTime('1970-01-01 HH:MM:SS'), '%H:%i:%s')",
        "description": "ClickHouse does not have a direct equivalent to MAKETIME. Therefore, we construct a DateTime using a fixed date (e.g., '1970-01-01') and extract only the time part using `formatDateTime`.",
        "examples": [
          "SELECT formatDateTime(toDateTime('1970-01-01 01:30:45'), '%H:%i:%s');",
          "SELECT formatDateTime(toDateTime('1970-01-01 12:00:00'), '%H:%i:%s');",
          "SELECT formatDateTime(toDateTime('1970-01-01 23:59:59'), '%H:%i:%s');"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_67_0",
    "database_name": "clickhouse_67_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select elt(2,1),field(NULL,\"a\",\"b\",\"c\"); -- ELT, FIELD",
    "target_query": "SELECT arrayElement([1, 2], 2), indexOf(['a', 'b', 'c'], NULL);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ELT",
      "FIELD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ELT(2, 'apple', 'banana', 'cherry')",
        "description": "Returns the N-th element from the list, where N is the first argument.",
        "examples": [
          "SELECT ELT(2, 'apple', 'banana', 'cherry');  -- Returns 'banana'",
          "SELECT ELT(1, 'red', 'green', 'blue');  -- Returns 'red'",
          "SELECT ELT(3, 'dog', 'cat', 'bird');  -- Returns 'bird'"
        ]
      },
      {
        "expression": "FIELD(val, val1, val2, ..., valN)",
        "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
        "examples": [
          "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "arrayElement(['apple', 'banana', 'cherry'], 2)",
        "description": "Returns the N-th element from the array, where N is the second argument.",
        "examples": [
          "SELECT arrayElement(['apple', 'banana', 'cherry'], 2);  -- Returns 'banana'",
          "SELECT arrayElement(['red', 'green', 'blue'], 1);  -- Returns 'red'",
          "SELECT arrayElement(['dog', 'cat', 'bird'], 3);  -- Returns 'bird'"
        ]
      },
      {
        "expression": "indexOf([val1, val2, ..., valN], val)",
        "description": "Returns the 1-based index of 'val' in the array. Returns 0 if not found. Fully equivalent to FIELD().",
        "examples": [
          "SELECT indexOf(['a', 'b', 'c'], 'c') AS result;",
          "SELECT indexOf(['a', 'b', 'c'], 'x') AS result;",
          "SELECT indexOf(['b', 'b', 'b'], 'b') AS result;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_67_1",
    "database_name": "clickhouse_67_1",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select field(\"b\",\"a\",NULL),field(1,0,NULL)+0,field(1.0,0.0,NULL)+0.0,field(1.0e1,0.0e1,NULL)+0.0e1; -- FIELD",
    "target_query": "SELECT indexOf(['a', NULL], 'b'), indexOf([0, NULL], 1) + 0, indexOf([0.0, NULL], 1.0) + 0.0, indexOf([0.0e1, NULL], 1.0e1) + 0.0e1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FIELD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FIELD(val, val1, val2, ..., valN)",
        "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
        "examples": [
          "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "indexOf([val1, val2, ..., valN], val)",
        "description": "Returns the 1-based index of 'val' in the array. Returns 0 if not found. Fully equivalent to FIELD().",
        "examples": [
          "SELECT indexOf(['a', 'b', 'c'], 'c') AS result;",
          "SELECT indexOf(['a', 'b', 'c'], 'x') AS result;",
          "SELECT indexOf(['b', 'b', 'b'], 'b') AS result;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_67_2",
    "database_name": "clickhouse_67_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select field(NULL,\"a\",NULL),field(NULL,0,NULL)+0,field(NULL,0.0,NULL)+0.0,field(NULL,0.0e1,NULL)+0.0e1; -- FIELD",
    "target_query": "SELECT indexOf(['a', NULL], NULL), indexOf([0, NULL], NULL) + 0, indexOf([0.0, NULL], NULL) + 0.0, indexOf([0.0e1, NULL], NULL) + 0.0e1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "FIELD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "FIELD(val, val1, val2, ..., valN)",
        "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
        "examples": [
          "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
          "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "indexOf([val1, val2, ..., valN], val)",
        "description": "Returns the 1-based index of 'val' in the array. Returns 0 if not found. Fully equivalent to FIELD().",
        "examples": [
          "SELECT indexOf(['a', 'b', 'c'], 'c') AS result;",
          "SELECT indexOf(['a', 'b', 'c'], 'x') AS result;",
          "SELECT indexOf(['b', 'b', 'b'], 'b') AS result;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_67_9",
    "database_name": "clickhouse_67_9",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select one.id, elt(two.val,'one','two') from t1 one, t2 two where two.id=one.id; -- ELT",
    "target_query": "SELECT one.id, arrayElement(['one', 'two'], two.val) FROM t1 AS one, t2 AS two WHERE two.id = one.id;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ELT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ELT(2, 'apple', 'banana', 'cherry')",
        "description": "Returns the N-th element from the list, where N is the first argument.",
        "examples": [
          "SELECT ELT(2, 'apple', 'banana', 'cherry');  -- Returns 'banana'",
          "SELECT ELT(1, 'red', 'green', 'blue');  -- Returns 'red'",
          "SELECT ELT(3, 'dog', 'cat', 'bird');  -- Returns 'bird'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "arrayElement(['apple', 'banana', 'cherry'], 2)",
        "description": "Returns the N-th element from the array, where N is the second argument.",
        "examples": [
          "SELECT arrayElement(['apple', 'banana', 'cherry'], 2);  -- Returns 'banana'",
          "SELECT arrayElement(['red', 'green', 'blue'], 1);  -- Returns 'red'",
          "SELECT arrayElement(['dog', 'cat', 'bird'], 3);  -- Returns 'bird'"
        ]
      }
    ],
    "source_related_schemas": [
      "create  table t1 (id int(10) not null unique);",
      "create  table t2 (id int(10) not null primary key, val int(10) not null);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id Int32 NOT NULL )ENGINE=MergeTree ORDER BY id;",
      "CREATE TABLE t2 (id Int32 NOT NULL , val Int32 NOT NULL)engine=MergeTree ORDER BY id;"
    ]
  },
  {
    "sql_id": "clickhouse_67_10",
    "database_name": "clickhouse_67_10",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select one.id, elt(two.val,'one','two') from t1 one, t2 two where two.id=one.id order by one.id; -- ELT",
    "target_query": "SELECT one.id, arrayElement(['one', 'two'], two.val) FROM t1 AS one, t2 AS two WHERE two.id = one.id ORDER BY one.id;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ELT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ELT(2, 'apple', 'banana', 'cherry')",
        "description": "Returns the N-th element from the list, where N is the first argument.",
        "examples": [
          "SELECT ELT(2, 'apple', 'banana', 'cherry');  -- Returns 'banana'",
          "SELECT ELT(1, 'red', 'green', 'blue');  -- Returns 'red'",
          "SELECT ELT(3, 'dog', 'cat', 'bird');  -- Returns 'bird'"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "arrayElement(['apple', 'banana', 'cherry'], 2)",
        "description": "Returns the N-th element from the array, where N is the second argument.",
        "examples": [
          "SELECT arrayElement(['apple', 'banana', 'cherry'], 2);  -- Returns 'banana'",
          "SELECT arrayElement(['red', 'green', 'blue'], 1);  -- Returns 'red'",
          "SELECT arrayElement(['dog', 'cat', 'bird'], 3);  -- Returns 'bird'"
        ]
      }
    ],
    "source_related_schemas": [
      "create  table t1 (id int(10) not null unique);",
      "create  table t2 (id int(10) not null primary key, val int(10) not null);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (id Int32 NOT NULL )ENGINE=MergeTree ORDER BY id;",
      "CREATE TABLE t2 (id Int32 NOT NULL , val Int32 NOT NULL)engine=MergeTree ORDER BY id;"
    ]
  },
  {
    "sql_id": "clickhouse_68_3",
    "database_name": "clickhouse_68_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT CONCAT('\"',CONCAT_WS('\";\"',title,prio,category,program,bugdesc,created,modified,bugstatus,submitter),'\"') FROM t1; -- CONCAT, CONCAT_WS",
    "target_query": "SELECT concat('\"',concat_ws('\";\"',title,prio,category,program,bugstatus,submitter),'\"') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT",
      "CONCAT_WS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      },
      {
        "expression": "CONCAT_WS(separator, str1, str2, ...)",
        "description": "Concatenates multiple strings with the specified separator. If any argument is NULL, it is ignored.",
        "examples": [
          "SELECT CONCAT_WS(',', 'apple', 'banana', 'cherry');",
          "SELECT CONCAT_WS('-', 'hello', 'world');",
          "SELECT CONCAT_WS(' ', 'this', NULL, 'is', 'a', 'test');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      },
      {
        "expression": "concat_ws(separator, str1, str2, ...)",
        "description": "Concatenates strings using a specified separator, and ignores NULL values.",
        "examples": [
          "SELECT concat_ws(',', 'apple', 'banana', 'cherry');",
          "SELECT concat_ws('-', 'hello', 'world');",
          "SELECT concat_ws(' ', 'this', NULL, 'is', 'a', 'test');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(id int(10) NOT NULL,title varchar(255) default NULL,prio int(10) default NULL,category int(10) default NULL,program int(10) default NULL,bugdesc text,created datetime default NULL,modified timestamp NOT NULL,bugstatus int(10) default NULL,submitter int(10) default NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(id Int32 NOT NULL,title String DEFAULT NULL,prio Int32 DEFAULT NULL,category Int32 DEFAULT NULL,program Int32 DEFAULT NULL,bugdesc String,created DateTime DEFAULT NULL,modified DateTime NOT NULL,bugstatus Int32 DEFAULT NULL,submitter Int32 DEFAULT NULL)ENGINE=MergeTree ORDER BY id;"
    ]
  },
  {
    "sql_id": "clickhouse_68_4",
    "database_name": "clickhouse_68_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT CONCAT('\"',CONCAT_WS('\";\"',title,prio,category,program,bugstatus,submitter),'\"') FROM t1; -- CONCAT, CONCAT_WS",
    "target_query": "SELECT concat('\"',concat_ws('\";\"',title,prio,category,program,bugdesc,created,modified+0,bugstatus,submitter),'\"') FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT",
      "CONCAT_WS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      },
      {
        "expression": "CONCAT_WS(separator, str1, str2, ...)",
        "description": "Concatenates multiple strings with the specified separator. If any argument is NULL, it is ignored.",
        "examples": [
          "SELECT CONCAT_WS(',', 'apple', 'banana', 'cherry');",
          "SELECT CONCAT_WS('-', 'hello', 'world');",
          "SELECT CONCAT_WS(' ', 'this', NULL, 'is', 'a', 'test');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      },
      {
        "expression": "concat_ws(separator, str1, str2, ...)",
        "description": "Concatenates strings using a specified separator, and ignores NULL values.",
        "examples": [
          "SELECT concat_ws(',', 'apple', 'banana', 'cherry');",
          "SELECT concat_ws('-', 'hello', 'world');",
          "SELECT concat_ws(' ', 'this', NULL, 'is', 'a', 'test');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(id int(10) NOT NULL,title varchar(255) default NULL,prio int(10) default NULL,category int(10) default NULL,program int(10) default NULL,bugdesc text,created datetime default NULL,modified timestamp NOT NULL,bugstatus int(10) default NULL,submitter int(10) default NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(id Int32 NOT NULL,title String DEFAULT NULL,prio Int32 DEFAULT NULL,category Int32 DEFAULT NULL,program Int32 DEFAULT NULL,bugdesc String,created DateTime DEFAULT NULL,modified DateTime NOT NULL,bugstatus Int32 DEFAULT NULL,submitter Int32 DEFAULT NULL)ENGINE=MergeTree ORDER BY id;"
    ]
  },
  {
    "sql_id": "clickhouse_68_5",
    "database_name": "clickhouse_68_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT CONCAT_WS('\";\"',title,prio,category,program,bugdesc,created,modified,bugstatus,submitter) FROM t1; -- CONCAT_WS",
    "target_query": "SELECT concat_ws('\";\"',title,prio,category,program,bugdesc,created,modified,bugstatus,submitter) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT_WS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT_WS(separator, str1, str2, ...)",
        "description": "Concatenates multiple strings with the specified separator. If any argument is NULL, it is ignored.",
        "examples": [
          "SELECT CONCAT_WS(',', 'apple', 'banana', 'cherry');",
          "SELECT CONCAT_WS('-', 'hello', 'world');",
          "SELECT CONCAT_WS(' ', 'this', NULL, 'is', 'a', 'test');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat_ws(separator, str1, str2, ...)",
        "description": "Concatenates strings using a specified separator, and ignores NULL values.",
        "examples": [
          "SELECT concat_ws(',', 'apple', 'banana', 'cherry');",
          "SELECT concat_ws('-', 'hello', 'world');",
          "SELECT concat_ws(' ', 'this', NULL, 'is', 'a', 'test');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(id int(10) NOT NULL,title varchar(255) default NULL,prio int(10) default NULL,category int(10) default NULL,program int(10) default NULL,bugdesc text,created datetime default NULL,modified timestamp NOT NULL,bugstatus int(10) default NULL,submitter int(10) default NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(id Int32 NOT NULL,title String DEFAULT NULL,prio Int32 DEFAULT NULL,category Int32 DEFAULT NULL,program Int32 DEFAULT NULL,bugdesc String,created DateTime DEFAULT NULL,modified DateTime NOT NULL,bugstatus Int32 DEFAULT NULL,submitter Int32 DEFAULT NULL)ENGINE=MergeTree ORDER BY id;"
    ]
  },
  {
    "sql_id": "clickhouse_68_10",
    "database_name": "clickhouse_68_10",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT CONCAT(\"</a>\",RPAD(\"\",(55-LENGTH(title)),\".\")) from t1; -- CONCAT, RPAD, LENGTH",
    "target_query": "SELECT concat('</a>', RPAD('', GREATEST(0, 55 - length(title)), '.')) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CONCAT",
      "RPAD",
      "LENGTH"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CONCAT(str1, str2, ..., strN)",
        "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT CONCAT('Hello', ' ', 'World');",
          "SELECT CONCAT('Year: ', 2025);",
          "SELECT CONCAT(name, '_', id) FROM users;"
        ]
      },
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "Pads the string to the right with a specified character.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123, 5, '0');"
        ]
      },
      {
        "expression": "LENGTH(str)",
        "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
        "examples": [
          "SELECT LENGTH('abc');",
          "SELECT LENGTH('你好');",
          "SELECT LENGTH(REPEAT('a', 1000));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "concat(str1, str2, ...)",
        "description": "Concatenates multiple strings into one. NULLs are converted to empty strings, unlike MySQL. Use assumeNotNull() to avoid unexpected NULL behavior.",
        "examples": [
          "SELECT concat('Hello', ' ', 'World');",
          "SELECT concat('Year: ', toString(2025));",
          "SELECT concat(name, '_', toString(id)) FROM users;"
        ]
      },
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "ClickHouse uses the RPAD function for padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(toString(123), 5, '0');"
        ]
      },
      {
        "expression": "length(str)",
        "description": "Returns the byte length of the string. Use lengthUTF8() if character count is needed. 'length()' matches MySQL's LENGTH().",
        "examples": [
          "SELECT length('abc');",
          "SELECT length('你好');",
          "SELECT length(repeat('a', 1000));"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1(title text);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1(title String)ENGINE=MergeTree ORDER BY title;"
    ]
  },
  {
    "sql_id": "clickhouse_69_0",
    "database_name": "clickhouse_69_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select 0=0,1>0,1>=1,1<0,1<=0,1!=0,strcmp(\"abc\",\"abcd\"),strcmp(\"b\",\"a\"),strcmp(\"a\",\"a\") ; -- STRCMP",
    "target_query": "SELECT 0=0, 1>0, 1>=1, 1<0, 1<=0, 1!=0, CASE WHEN 'abc' = 'abcd' THEN 0 WHEN 'abc' < 'abcd' THEN -1 ELSE 1 END, CASE WHEN 'b' = 'a' THEN 0 WHEN 'b' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'a' = 'a' THEN 0 WHEN 'a' < 'a' THEN -1 ELSE 1 END;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "STRCMP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "STRCMP(expr1, expr2)",
        "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
        "examples": [
          "SELECT STRCMP('apple', 'banana');",
          "SELECT STRCMP('grape', 'grape');",
          "SELECT STRCMP('orange', 'apple');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
        "description": "ClickHouse does not have a direct STRCMP function, but the same behavior can be simulated using the CASE statement to compare two strings lexicographically and return 0, -1, or 1 based on the comparison.",
        "examples": [
          "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
          "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_69_4",
    "database_name": "clickhouse_69_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT GREATEST(d,d) FROM t1 WHERE k=2; -- GREATEST",
    "target_query": "SELECT GREATEST(d, d) FROM t1 WHERE k = 2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (d varchar(6), k int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (d String, k Int32)engine=TinyLog"
    ]
  },
  {
    "sql_id": "clickhouse_69_7",
    "database_name": "clickhouse_69_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select (12 mod 1) is null   as 'col'; -- MOD",
    "target_query": "SELECT (12 % 1) IS NULL AS col;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MOD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Returns the remainder of N divided by M. Returns NULL if M = 0.",
        "examples": [
          "SELECT MOD(10, 3);",
          "SELECT 10 % 3;",
          "SELECT MOD(5, 0);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Modulo operation. Returns remainder. Division by zero errors.",
        "examples": [
          "SELECT MOD(11, 5);",
          "SELECT 11 % 5;",
          "SELECT MOD(number, 3) FROM numbers(10);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_69_8",
    "database_name": "clickhouse_69_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select mod(12.0, 1)         as 'col'; -- MOD",
    "target_query": "SELECT 12.0 % 1 AS col;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MOD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Returns the remainder of N divided by M. Returns NULL if M = 0.",
        "examples": [
          "SELECT MOD(10, 3);",
          "SELECT 10 % 3;",
          "SELECT MOD(5, 0);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Modulo operation. Returns remainder. Division by zero errors.",
        "examples": [
          "SELECT MOD(11, 5);",
          "SELECT 11 % 5;",
          "SELECT MOD(number, 3) FROM numbers(10);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_69_9",
    "database_name": "clickhouse_69_9",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "select mod(12, 1.0)         as 'col'; -- MOD",
    "target_query": "SELECT 12 % 0.1 AS col;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "MOD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Returns the remainder of N divided by M. Returns NULL if M = 0.",
        "examples": [
          "SELECT MOD(10, 3);",
          "SELECT 10 % 3;",
          "SELECT MOD(5, 0);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "MOD(N, M) 或 N % M",
        "description": "Modulo operation. Returns remainder. Division by zero errors.",
        "examples": [
          "SELECT MOD(11, 5);",
          "SELECT 11 % 5;",
          "SELECT MOD(number, 3) FROM numbers(10);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_69_10",
    "database_name": "clickhouse_69_10",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT greatest( 123456789 , 234567890 ) as g; -- GREATEST",
    "target_query": "SELECT GREATEST(123456789, 234567890) AS g;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_69_11",
    "database_name": "clickhouse_69_11",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT least   ( 123456789 , 234567890 ) as l; -- LEAST",
    "target_query": "SELECT least(123456789, 234567890) AS l;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the smallest non-null value among arguments. NULLs are ignored unless all arguments are NULL. Use ifNull() when explicit NULL handling is needed.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(toDate('2024-01-01'), toDate('2023-12-31'));",
          "SELECT ifNull(least(NULL, 2), NULL);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_69_12",
    "database_name": "clickhouse_69_12",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT greatest (123456789, -1, 234567890 ) as g; -- GREATEST",
    "target_query": "SELECT GREATEST(123456789, -1, 234567890) AS g;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_69_13",
    "database_name": "clickhouse_69_13",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT least    (123456789, -1, 234567890 ) as l; -- LEAST",
    "target_query": "SELECT least(123456789, -1, 234567890) AS l;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the smallest non-null value among arguments. NULLs are ignored unless all arguments are NULL. Use ifNull() when explicit NULL handling is needed.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(toDate('2024-01-01'), toDate('2023-12-31'));",
          "SELECT ifNull(least(NULL, 2), NULL);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_70_0",
    "database_name": "clickhouse_70_0",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT GREATEST('11', '5', '2'); -- GREATEST",
    "target_query": "SELECT GREATEST('11', '5', '2');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_70_1",
    "database_name": "clickhouse_70_1",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT GREATEST('11', 5, 2); -- GREATEST",
    "target_query": "SELECT GREATEST(toInt32('11'), 5, 2) AS col;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_70_2",
    "database_name": "clickhouse_70_2",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT GREATEST(11, 5, 2); -- GREATEST",
    "target_query": "SELECT GREATEST(11, 5, 2);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_70_3",
    "database_name": "clickhouse_70_3",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT LEAST('11', '5', '2'); -- LEAST",
    "target_query": "SELECT least('11', '5', '2');",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the smallest non-null value among arguments. NULLs are ignored unless all arguments are NULL. Use ifNull() when explicit NULL handling is needed.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(toDate('2024-01-01'), toDate('2023-12-31'));",
          "SELECT ifNull(least(NULL, 2), NULL);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_70_4",
    "database_name": "clickhouse_70_4",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT LEAST('11', 5, 2); -- LEAST",
    "target_query": "SELECT least(toInt32('11'), 5, 2);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the smallest non-null value among arguments. NULLs are ignored unless all arguments are NULL. Use ifNull() when explicit NULL handling is needed.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(toDate('2024-01-01'), toDate('2023-12-31'));",
          "SELECT ifNull(least(NULL, 2), NULL);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_70_5",
    "database_name": "clickhouse_70_5",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT LEAST(11, 5, 2); -- LEAST",
    "target_query": "SELECT least(11, 5, 2);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the smallest non-null value among arguments. NULLs are ignored unless all arguments are NULL. Use ifNull() when explicit NULL handling is needed.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(toDate('2024-01-01'), toDate('2023-12-31'));",
          "SELECT ifNull(least(NULL, 2), NULL);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_70_6",
    "database_name": "clickhouse_70_6",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT GREATEST('11', '5', '2') + 0; -- GREATEST",
    "target_query": "SELECT GREATEST('11', '5', '2')::INTEGER + 0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_70_7",
    "database_name": "clickhouse_70_7",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT GREATEST('11', 5, 2) + 0; -- GREATEST",
    "target_query": "SELECT GREATEST(toInt32('11'), 5, 2) + 0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_70_8",
    "database_name": "clickhouse_70_8",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT GREATEST(11, 5, 2) + 0; -- GREATEST",
    "target_query": "SELECT GREATEST(11, 5, 2) + 0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_70_9",
    "database_name": "clickhouse_70_9",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT GREATEST('11', '5', '2') + 0.00; -- GREATEST",
    "target_query": "SELECT GREATEST('11', '5', '2')::INTEGER + 0.00;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_70_10",
    "database_name": "clickhouse_70_10",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT GREATEST('11', 5, 2) + 0.00; -- GREATEST",
    "target_query": "SELECT GREATEST(toInt32('11'), 5, 2) + 0.00;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_70_11",
    "database_name": "clickhouse_70_11",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT GREATEST(11, 5, 2) + 0.00; -- GREATEST",
    "target_query": "SELECT GREATEST(11, 5, 2) + 0.00;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_70_15",
    "database_name": "clickhouse_70_15",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT greatest(18446744073709551615, NULL)FROM t0017; -- GREATEST",
    "target_query": "SELECT GREATEST(18446744073709551615, NULL) FROM t0017;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t0017 (c0002 bigint(20) NOT NULL);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t0017 (c0002 Int64 NOT NULL)ENGINE=MergeTree ORDER BY c0002;"
    ]
  },
  {
    "sql_id": "clickhouse_70_20",
    "database_name": "clickhouse_70_20",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT * FROM t1 WHERE (GREATEST(c1, c2) = 42) AND (c2 = 1); -- GREATEST",
    "target_query": "SELECT * FROM t1 WHERE (GREATEST(c1, c2) = 42) AND (c2 = 1);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GREATEST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "GREATEST(expr1, expr2, ..., exprN)",
        "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
        "examples": [
          "SELECT GREATEST(3, 7, 2);",
          "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
          "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t1 (c1 INT, c2 INT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t1 (c1 Int32, c2 Int32)ENGINE=MergeTree ORDER BY c1;"
    ]
  },
  {
    "sql_id": "clickhouse_70_27",
    "database_name": "clickhouse_70_27",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT SUM(LEAST(a, b)) FROM t1; -- LEAST",
    "target_query": "SELECT SUM(least(a, b)) FROM t1;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the smallest non-null value among arguments. NULLs are ignored unless all arguments are NULL. Use ifNull() when explicit NULL handling is needed.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(toDate('2024-01-01'), toDate('2023-12-31'));",
          "SELECT ifNull(least(NULL, 2), NULL);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 (a INTEGER, b INTEGER);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (a Int32, b Int32)ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_70_28",
    "database_name": "clickhouse_70_28",
    "source_dialect": "mysql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT SUM(LEAST(a, b)) FROM t2; -- LEAST",
    "target_query": "SELECT SUM(least(a, b)) FROM t2;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "LEAST"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "LEAST(expr1, expr2, ...)",
        "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
        "examples": [
          "SELECT LEAST(5, 10, 3);",
          "SELECT LEAST('2024-01-01', '2023-12-31');",
          "SELECT LEAST(NULL, 2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "least(expr1, expr2, ...)",
        "description": "Returns the smallest non-null value among arguments. NULLs are ignored unless all arguments are NULL. Use ifNull() when explicit NULL handling is needed.",
        "examples": [
          "SELECT least(5, 10, 3);",
          "SELECT least(toDate('2024-01-01'), toDate('2023-12-31'));",
          "SELECT ifNull(least(NULL, 2), NULL);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE t2 (a INTEGER, b INTEGER);"
    ],
    "target_related_schemas": [
      "CREATE TABLE t2 (a Int32, b Int32)ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_1_33",
    "database_name": "clickhouse_1_33",
    "source_dialect": "postgresql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO clstr_tst (a, b, c, d) VALUES (32, 6, 'seis', repeat('xyzzy', 10000)); -- REPEAT",
    "target_query": "INSERT INTO clstr_tst (a, b, c, d) VALUES (32, 6, 'seis', repeat('xyzzy', 10000));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE clstr_tst (a SERIAL PRIMARY KEY,b INT,c TEXT,d TEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE clstr_tst (a UInt32, b Int32, c String, d String) ENGINE = MergeTree() ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_10_2",
    "database_name": "clickhouse_10_2",
    "source_dialect": "postgresql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO tidrangescan SELECT i,repeat('x', 100) FROM generate_series(1,200) AS s(i); -- REPEAT, GENERATE_SERIES",
    "target_query": "INSERT INTO tidrangescan SELECT number + 1 AS id, repeat('x', 100) AS data FROM numbers(200);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT",
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      },
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      },
      {
        "expression": "SELECT ... FROM numbers(n)",
        "description": "Uses the numbers() function to generate integer sequences; transformations can simulate steps.",
        "examples": [
          "SELECT number + 1 AS n FROM numbers(5);",
          "SELECT number * 2 + 3 AS n FROM numbers(4);",
          "SELECT 10 - number * 2 AS n FROM numbers(3);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE tidrangescan(id integer, data text);"
    ],
    "target_related_schemas": [
      "CREATE TABLE tidrangescan (id Int32, data String) ENGINE=MergeTree ORDER BY id;"
    ]
  },
  {
    "sql_id": "clickhouse_11_11",
    "database_name": "clickhouse_11_11",
    "source_dialect": "postgresql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT pg_sleep(0.1); -- PG_SLEEP",
    "target_query": "SELECT sleep(0.1);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "PG_SLEEP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "pg_sleep(seconds)",
        "description": "Delays execution for the specified number of seconds.",
        "examples": [
          "SELECT pg_sleep(1);",
          "SELECT pg_sleep(0.5);",
          "SELECT pg_sleep(2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "sleep(seconds)",
        "description": "Sleeps for the given number of seconds. Useful for testing and debugging.",
        "examples": [
          "SELECT sleep(1);",
          "SELECT sleep(0.5);",
          "SELECT sleep(2);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_11_14",
    "database_name": "clickhouse_11_14",
    "source_dialect": "postgresql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT pg_sleep(0.1); -- PG_SLEEP",
    "target_query": "SELECT sleep(0.1);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "PG_SLEEP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "pg_sleep(seconds)",
        "description": "Delays execution for the specified number of seconds.",
        "examples": [
          "SELECT pg_sleep(1);",
          "SELECT pg_sleep(0.5);",
          "SELECT pg_sleep(2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "sleep(seconds)",
        "description": "Sleeps for the given number of seconds. Useful for testing and debugging.",
        "examples": [
          "SELECT sleep(1);",
          "SELECT sleep(0.5);",
          "SELECT sleep(2);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_11_16",
    "database_name": "clickhouse_11_16",
    "source_dialect": "postgresql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT pg_sleep(0.1); -- PG_SLEEP",
    "target_query": "SELECT sleep(0.1);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "PG_SLEEP"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "pg_sleep(seconds)",
        "description": "Delays execution for the specified number of seconds.",
        "examples": [
          "SELECT pg_sleep(1);",
          "SELECT pg_sleep(0.5);",
          "SELECT pg_sleep(2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "sleep(seconds)",
        "description": "Sleeps for the given number of seconds. Useful for testing and debugging.",
        "examples": [
          "SELECT sleep(1);",
          "SELECT sleep(0.5);",
          "SELECT sleep(2);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_12_0",
    "database_name": "clickhouse_12_0",
    "source_dialect": "postgresql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT generate_series(1, 3); -- GENERATE_SERIES",
    "target_query": "SELECT number + 1 AS n FROM numbers(3);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ... FROM numbers(n)",
        "description": "Uses the numbers() function to generate integer sequences; transformations can simulate steps.",
        "examples": [
          "SELECT number + 1 AS n FROM numbers(5);",
          "SELECT number * 2 + 3 AS n FROM numbers(4);",
          "SELECT 10 - number * 2 AS n FROM numbers(3);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_12_1",
    "database_name": "clickhouse_12_1",
    "source_dialect": "postgresql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT generate_series(1, 3) AS val1, generate_series(3,5) AS val2; -- GENERATE_SERIES",
    "target_query": "SELECT a.number + 1 AS val1, b.number + 3 AS val2 FROM numbers(3) AS a, numbers(3) AS b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ... FROM numbers(n)",
        "description": "Uses the numbers() function to generate integer sequences; transformations can simulate steps.",
        "examples": [
          "SELECT number + 1 AS n FROM numbers(5);",
          "SELECT number * 2 + 3 AS n FROM numbers(4);",
          "SELECT 10 - number * 2 AS n FROM numbers(3);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_12_2",
    "database_name": "clickhouse_12_2",
    "source_dialect": "postgresql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT generate_series(1, 2) AS val1, generate_series(1,4) AS val2; -- GENERATE_SERIES",
    "target_query": "SELECT a.number + 1 AS val1, b.number + 1 AS val2 FROM numbers(2) AS a, numbers(4) AS b;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ... FROM numbers(n)",
        "description": "Uses the numbers() function to generate integer sequences; transformations can simulate steps.",
        "examples": [
          "SELECT number + 1 AS n FROM numbers(5);",
          "SELECT number * 2 + 3 AS n FROM numbers(4);",
          "SELECT 10 - number * 2 AS n FROM numbers(3);"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_2_2",
    "database_name": "clickhouse_2_2",
    "source_dialect": "postgresql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO cmdata VALUES(repeat('1234567890', 1000)); -- REPEAT",
    "target_query": "INSERT INTO cmdata VALUES(repeat('1234567890', 1000));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE cmdata(f1 text);"
    ],
    "target_related_schemas": [
      "CREATE TABLE cmdata(f1 text) ENGINE=MergeTree ORDER BY f1;"
    ]
  },
  {
    "sql_id": "clickhouse_2_6",
    "database_name": "clickhouse_2_6",
    "source_dialect": "postgresql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO cmdata1 VALUES(repeat('1234567890', 1004)); -- REPEAT",
    "target_query": "INSERT INTO cmdata1 VALUES(repeat('1234567890', 1004));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE cmdata1(f1 TEXT);"
    ],
    "target_related_schemas": [
      "CREATE TABLE cmdata1(f1 TEXT) ENGINE=MergeTree ORDER BY f1;"
    ]
  },
  {
    "sql_id": "clickhouse_3_3",
    "database_name": "clickhouse_3_3",
    "source_dialect": "postgresql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO delete_test (id, a, b) VALUES (2, 50, repeat('x', 10000)); -- REPEAT",
    "target_query": "INSERT INTO delete_test (id, a, b) VALUES (2, 50, repeat('x', 10000));",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "REPEAT"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "REPEAT(str, count)",
        "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
        "examples": [
          "SELECT REPEAT('x', 5);",
          "SELECT REPEAT('ab', 3);",
          "SELECT REPEAT('*', 0);",
          "SELECT REPEAT(name, 2) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "repeat(str, count)",
        "description": "Repeats the string 'count' times. NULLs are treated as empty strings unless handled explicitly with assumeNotNull().",
        "examples": [
          "SELECT repeat('x', 5);",
          "SELECT repeat('ab', 3);",
          "SELECT repeat('*', 0);",
          "SELECT repeat(assumeNotNull(name), 2) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE delete_test (id SERIAL PRIMARY KEY,a INT,b text);"
    ],
    "target_related_schemas": [
      "CREATE TABLE delete_test (id Int32 PRIMARY KEY, a Int32, b String) ENGINE=MergeTree() ORDER BY id;"
    ]
  },
  {
    "sql_id": "clickhouse_4_0",
    "database_name": "clickhouse_4_0",
    "source_dialect": "postgresql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT current_timestamp = NOW(); -- NOW",
    "target_query": "SELECT now() = now();",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "NOW"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "CURRENT_TIMESTAMP",
        "description": "In PostgreSQL, CURRENT_TIMESTAMP is used to retrieve the current date and time, equivalent to NOW() in MySQL and MariaDB.",
        "examples": [
          "SELECT CURRENT_TIMESTAMP;",
          "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "now()",
        "description": "ClickHouse uses the now() function to return the current date and time, which is equivalent to MySQL's NOW() function.",
        "examples": [
          "SELECT now();",
          "CREATE TABLE t12 AS SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > now()) ORDER BY 3 DESC;",
          "INSERT INTO t1 VALUES (now());"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_5_0",
    "database_name": "clickhouse_5_0",
    "source_dialect": "postgresql",
    "target_dialect": "clickhouse",
    "source_query": "select current_schemas(false); -- CURRENT_SCHEMAS",
    "target_query": "SELECT currentDatabase();",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "CURRENT_SCHEMAS"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "current_schemas(include_implicit boolean)",
        "description": "Returns a text array of schema names in the current search path. The boolean parameter controls whether implicit schemas such as pg_catalog are included.",
        "examples": [
          "SELECT current_schemas(false);",
          "SELECT current_schemas(true);",
          "SELECT unnest(current_schemas(false));"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "currentDatabase()",
        "description": "Returns the name of the current database for the session, equivalent to PostgreSQL schema name.",
        "examples": [
          "SELECT currentDatabase();"
        ]
      }
    ],
    "source_related_schemas": [],
    "target_related_schemas": []
  },
  {
    "sql_id": "clickhouse_6_2",
    "database_name": "clickhouse_6_2",
    "source_dialect": "postgresql",
    "target_dialect": "clickhouse",
    "source_query": "create table simple1 as select generate_series(1, 200) AS id; -- GENERATE_SERIES",
    "target_query": "CREATE TABLE simple1 ENGINE=MergeTree ORDER BY id AS SELECT number + 1 AS id FROM numbers(200);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ... FROM numbers(n)",
        "description": "Uses the numbers() function to generate integer sequences; transformations can simulate steps.",
        "examples": [
          "SELECT number + 1 AS n FROM numbers(5);",
          "SELECT number * 2 + 3 AS n FROM numbers(4);",
          "SELECT 10 - number * 2 AS n FROM numbers(3);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table simple1 as select generate_series(1, 200) AS id; -- GENERATE_SERIES"
    ],
    "target_related_schemas": [
      "CREATE TABLE simple1 ENGINE=MergeTree ORDER BY id AS SELECT number + 1 AS id FROM numbers(200);"
    ]
  },
  {
    "sql_id": "clickhouse_6_5",
    "database_name": "clickhouse_6_5",
    "source_dialect": "postgresql",
    "target_dialect": "clickhouse",
    "source_query": "create table bigger_than_it_looks as select generate_series(1, 200) as id; -- GENERATE_SERIES",
    "target_query": "CREATE TABLE bigger_than_it_looks ENGINE=MergeTree ORDER BY id AS SELECT number + 1 AS id FROM numbers(200);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ... FROM numbers(n)",
        "description": "Uses the numbers() function to generate integer sequences; transformations can simulate steps.",
        "examples": [
          "SELECT number + 1 AS n FROM numbers(5);",
          "SELECT number * 2 + 3 AS n FROM numbers(4);",
          "SELECT 10 - number * 2 AS n FROM numbers(3);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table bigger_than_it_looks as select generate_series(1, 200) as id; -- GENERATE_SERIES"
    ],
    "target_related_schemas": [
      "CREATE TABLE bigger_than_it_looks ENGINE=MergeTree ORDER BY id AS SELECT number + 1 AS id FROM numbers(200);"
    ]
  },
  {
    "sql_id": "clickhouse_6_10",
    "database_name": "clickhouse_6_10",
    "source_dialect": "postgresql",
    "target_dialect": "clickhouse",
    "source_query": "insert into extremely_skewed select 42 as id, 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'from generate_series(1, 200); -- GENERATE_SERIES",
    "target_query": "INSERT INTO extremely_skewed SELECT 42 AS id, 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' FROM numbers(200);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ... FROM numbers(n)",
        "description": "Uses the numbers() function to generate integer sequences; transformations can simulate steps.",
        "examples": [
          "SELECT number + 1 AS n FROM numbers(5);",
          "SELECT number * 2 + 3 AS n FROM numbers(4);",
          "SELECT 10 - number * 2 AS n FROM numbers(3);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table extremely_skewed (id int, t text);"
    ],
    "target_related_schemas": [
      "CREATE TABLE extremely_skewed (id Int32, t String) ENGINE=MergeTree ORDER BY id;"
    ]
  },
  {
    "sql_id": "clickhouse_6_12",
    "database_name": "clickhouse_6_12",
    "source_dialect": "postgresql",
    "target_dialect": "clickhouse",
    "source_query": "create table wide as select generate_series(1, 2) as id, rpad('', 320000, 'x') as t; -- GENERATE_SERIES, RPAD",
    "target_query": "CREATE TABLE wide ENGINE=MergeTree ORDER BY id AS SELECT number + 1 AS id, RPAD('', 320000, 'x') AS t FROM numbers(2);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GENERATE_SERIES",
      "RPAD"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      },
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "PostgreSQL doesn't have a native RPAD, but can simulate it.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(123::text, 5, '0');"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ... FROM numbers(n)",
        "description": "Uses the numbers() function to generate integer sequences; transformations can simulate steps.",
        "examples": [
          "SELECT number + 1 AS n FROM numbers(5);",
          "SELECT number * 2 + 3 AS n FROM numbers(4);",
          "SELECT 10 - number * 2 AS n FROM numbers(3);"
        ]
      },
      {
        "expression": "RPAD(expression, length, pad_string)",
        "description": "ClickHouse uses the RPAD function for padding.",
        "examples": [
          "SELECT RPAD('hello', 10, ' ');",
          "SELECT RPAD('abc', 6, 'x');",
          "SELECT RPAD(toString(123), 5, '0');"
        ]
      }
    ],
    "source_related_schemas": [
      "create table wide as select generate_series(1, 2) as id, rpad('', 320000, 'x') as t; -- GENERATE_SERIES, RPAD"
    ],
    "target_related_schemas": [
      "CREATE TABLE wide ENGINE=MergeTree ORDER BY id AS SELECT number + 1 AS id, RPAD('', 320000, 'x') AS t FROM numbers(2);"
    ]
  },
  {
    "sql_id": "clickhouse_6_14",
    "database_name": "clickhouse_6_14",
    "source_dialect": "postgresql",
    "target_dialect": "clickhouse",
    "source_query": "create table join_foo as select generate_series(1, 3) as id, 'xxxxx'::text as t; -- GENERATE_SERIES",
    "target_query": "CREATE TABLE join_foo ENGINE=MergeTree ORDER BY id AS SELECT number + 1 AS id, 'xxxxx' AS t FROM numbers(3);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ... FROM numbers(n)",
        "description": "Uses the numbers() function to generate integer sequences; transformations can simulate steps.",
        "examples": [
          "SELECT number + 1 AS n FROM numbers(5);",
          "SELECT number * 2 + 3 AS n FROM numbers(4);",
          "SELECT 10 - number * 2 AS n FROM numbers(3);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table join_foo as select generate_series(1, 3) as id, 'xxxxx'::text as t; -- GENERATE_SERIES"
    ],
    "target_related_schemas": [
      "CREATE TABLE join_foo ENGINE=MergeTree ORDER BY id AS SELECT number + 1 AS id, 'xxxxx' AS t FROM numbers(3);"
    ]
  },
  {
    "sql_id": "clickhouse_6_16",
    "database_name": "clickhouse_6_16",
    "source_dialect": "postgresql",
    "target_dialect": "clickhouse",
    "source_query": "create table join_bar as select generate_series(1, 10000) as id, 'xxxxx'::text as t; -- GENERATE_SERIES",
    "target_query": "CREATE TABLE join_bar ENGINE=MergeTree ORDER BY id AS SELECT number + 1 AS id, 'xxxxx' AS t FROM numbers(10000);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "SELECT ... FROM numbers(n)",
        "description": "Uses the numbers() function to generate integer sequences; transformations can simulate steps.",
        "examples": [
          "SELECT number + 1 AS n FROM numbers(5);",
          "SELECT number * 2 + 3 AS n FROM numbers(4);",
          "SELECT 10 - number * 2 AS n FROM numbers(3);"
        ]
      }
    ],
    "source_related_schemas": [
      "create table join_bar as select generate_series(1, 10000) as id, 'xxxxx'::text as t; -- GENERATE_SERIES"
    ],
    "target_related_schemas": [
      "CREATE TABLE join_bar ENGINE=MergeTree ORDER BY id AS SELECT number + 1 AS id, 'xxxxx' AS t FROM numbers(10000);"
    ]
  },
  {
    "sql_id": "clickhouse_7_2",
    "database_name": "clickhouse_7_2",
    "source_dialect": "postgresql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO pagg_tab SELECT i % 20, i % 30, to_char(i % 12, 'FM0000'), i % 30 FROM generate_series(0, 2999) i; -- TO_CHAR, GENERATE_SERIES",
    "target_query": "INSERT INTO pagg_tab SELECT number % 20 AS a, number % 30 AS b, LPAD(toString(number % 12), 4, '0') AS c, number % 30 AS d FROM numbers(3000);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TO_CHAR",
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "to_char(numeric, 'FM0000')",
        "description": "Formats a number as a zero-padded 4-digit string without leading spaces.",
        "examples": [
          "SELECT to_char(5, 'FM0000');   -- 0005",
          "SELECT to_char(123, 'FM0000'); -- 0123",
          "SELECT to_char(0, 'FM0000');   -- 0000"
        ]
      },
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(toString(value), 4, '0')",
        "description": "Converts number to string and pads with zeros to the left.",
        "examples": [
          "SELECT LPAD(toString(5), 4, '0');",
          "SELECT LPAD(toString(123), 4, '0');",
          "SELECT LPAD(toString(0), 4, '0');"
        ]
      },
      {
        "expression": "SELECT ... FROM numbers(n)",
        "description": "Uses the numbers() function to generate integer sequences; transformations can simulate steps.",
        "examples": [
          "SELECT number + 1 AS n FROM numbers(5);",
          "SELECT number * 2 + 3 AS n FROM numbers(4);",
          "SELECT 10 - number * 2 AS n FROM numbers(3);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE pagg_tab (a int, b int, c text, d int);"
    ],
    "target_related_schemas": [
      "CREATE TABLE pagg_tab (a Int32, b Int32, c String, d Int32) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_7_7",
    "database_name": "clickhouse_7_7",
    "source_dialect": "postgresql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO pagg_tab_ml SELECT i % 30, i % 10, to_char(i % 4, 'FM0000') FROM generate_series(0, 29999) i; -- TO_CHAR",
    "target_query": "INSERT INTO pagg_tab_ml SELECT number % 30 AS a, number % 10 AS b, LPAD(toString(number % 4), 4, '0') AS c FROM numbers(30000);",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TO_CHAR"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "to_char(numeric, 'FM0000')",
        "description": "Formats a number as a zero-padded 4-digit string without leading spaces.",
        "examples": [
          "SELECT to_char(5, 'FM0000');   -- 0005",
          "SELECT to_char(123, 'FM0000'); -- 0123",
          "SELECT to_char(0, 'FM0000');   -- 0000"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(toString(value), 4, '0')",
        "description": "Converts number to string and pads with zeros to the left.",
        "examples": [
          "SELECT LPAD(toString(5), 4, '0');",
          "SELECT LPAD(toString(123), 4, '0');",
          "SELECT LPAD(toString(0), 4, '0');"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE pagg_tab_ml (a int, b int, c text);"
    ],
    "target_related_schemas": [
      "CREATE TABLE pagg_tab_ml (a Int32, b Int32, c String) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_7_9",
    "database_name": "clickhouse_7_9",
    "source_dialect": "postgresql",
    "target_dialect": "clickhouse",
    "source_query": "SELECT a, sum(b), array_agg(distinct c), count(*) FROM pagg_tab_ml GROUP BY a HAVING avg(b) < 3 ORDER BY 1, 2, 3; -- ARRAY_AGG",
    "target_query": "SELECT a, sum(b) AS sum_b, groupUniqArray(c) AS unique_c, count() AS count_all FROM pagg_tab_ml GROUP BY a HAVING avg(b) < 3 ORDER BY a, sum_b, unique_c;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "ARRAY_AGG"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "ARRAY_AGG(expression [DISTINCT])",
        "description": "Aggregate function that returns an array of all input values, optionally removing duplicates if DISTINCT is specified.",
        "examples": [
          "SELECT ARRAY_AGG(DISTINCT x) FROM (VALUES (1), (2), (1), (3)) AS t(x);",
          "SELECT id, ARRAY_AGG(value) FROM my_table GROUP BY id;",
          "SELECT ARRAY_AGG(DISTINCT LOWER(name)) FROM users;"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "groupUniqArray(expression)",
        "description": "Aggregate function that returns an array of unique input values per group. Effectively equivalent to ARRAY_AGG(DISTINCT ...) in PostgreSQL.",
        "examples": [
          "SELECT groupUniqArray(x) FROM (SELECT 1 AS x UNION ALL SELECT 2 UNION ALL SELECT 1 UNION ALL SELECT 3);",
          "SELECT id, groupArray(value) FROM my_table GROUP BY id;",
          "SELECT groupUniqArray(lower(name)) FROM users;"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE pagg_tab_ml (a int, b int, c text);"
    ],
    "target_related_schemas": [
      "CREATE TABLE pagg_tab_ml (a Int32, b Int32, c String) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_8_2",
    "database_name": "clickhouse_8_2",
    "source_dialect": "postgresql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO prt1 SELECT i, i % 25, to_char(i, 'FM0000') FROM generate_series(0, 599) i WHERE i % 2 = 0; -- TO_CHAR, GENERATE_SERIES",
    "target_query": "INSERT INTO prt1 SELECT number AS i, i % 25, LPAD(toString(i), 4, '0') FROM numbers(600) WHERE i % 2 = 0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TO_CHAR",
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "to_char(numeric, 'FM0000')",
        "description": "Formats a number as a zero-padded 4-digit string without leading spaces.",
        "examples": [
          "SELECT to_char(5, 'FM0000');   -- 0005",
          "SELECT to_char(123, 'FM0000'); -- 0123",
          "SELECT to_char(0, 'FM0000');   -- 0000"
        ]
      },
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(toString(value), 4, '0')",
        "description": "Converts number to string and pads with zeros to the left.",
        "examples": [
          "SELECT LPAD(toString(5), 4, '0');",
          "SELECT LPAD(toString(123), 4, '0');",
          "SELECT LPAD(toString(0), 4, '0');"
        ]
      },
      {
        "expression": "SELECT ... FROM numbers(n)",
        "description": "Uses the numbers() function to generate integer sequences; transformations can simulate steps.",
        "examples": [
          "SELECT number + 1 AS n FROM numbers(5);",
          "SELECT number * 2 + 3 AS n FROM numbers(4);",
          "SELECT 10 - number * 2 AS n FROM numbers(3);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE prt1 (a int, b int, c varchar);"
    ],
    "target_related_schemas": [
      "CREATE TABLE prt1 (a Int32, b Int32, c String) ENGINE=MergeTree ORDER BY a;"
    ]
  },
  {
    "sql_id": "clickhouse_8_7",
    "database_name": "clickhouse_8_7",
    "source_dialect": "postgresql",
    "target_dialect": "clickhouse",
    "source_query": "INSERT INTO prt2 SELECT i % 25, i, to_char(i, 'FM0000') FROM generate_series(0, 599) i WHERE i % 3 = 0; -- TO_CHAR, GENERATE_SERIES",
    "target_query": "INSERT INTO prt2 SELECT i % 25, number AS i, LPAD(toString(i), 4, '0') FROM numbers(600) WHERE i % 3 = 0;",
    "semantic_equivalent_type": "exact_equivalence",
    "dialect_tokens": [
      "TO_CHAR",
      "GENERATE_SERIES"
    ],
    "source_dialect_knowledge": [
      {
        "expression": "to_char(numeric, 'FM0000')",
        "description": "Formats a number as a zero-padded 4-digit string without leading spaces.",
        "examples": [
          "SELECT to_char(5, 'FM0000');   -- 0005",
          "SELECT to_char(123, 'FM0000'); -- 0123",
          "SELECT to_char(0, 'FM0000');   -- 0000"
        ]
      },
      {
        "expression": "generate_series(start, stop [, step])",
        "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
        "examples": [
          "SELECT generate_series(1, 5);",
          "SELECT generate_series(3, 9, 2);",
          "SELECT generate_series(10, 6, -2);"
        ]
      }
    ],
    "target_dialect_knowledge": [
      {
        "expression": "LPAD(toString(value), 4, '0')",
        "description": "Converts number to string and pads with zeros to the left.",
        "examples": [
          "SELECT LPAD(toString(5), 4, '0');",
          "SELECT LPAD(toString(123), 4, '0');",
          "SELECT LPAD(toString(0), 4, '0');"
        ]
      },
      {
        "expression": "SELECT ... FROM numbers(n)",
        "description": "Uses the numbers() function to generate integer sequences; transformations can simulate steps.",
        "examples": [
          "SELECT number + 1 AS n FROM numbers(5);",
          "SELECT number * 2 + 3 AS n FROM numbers(4);",
          "SELECT 10 - number * 2 AS n FROM numbers(3);"
        ]
      }
    ],
    "source_related_schemas": [
      "CREATE TABLE prt2 (a int, b int, c varchar);"
    ],
    "target_related_schemas": [
      "CREATE TABLE prt2 (a Int32, b Int32, c String) ENGINE=MergeTree ORDER BY a;"
    ]
  }
]